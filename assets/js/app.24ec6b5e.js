(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],c=e[2],u=0,p=[];u<s.length;u++)o=s[u],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&p.push(i[o][0]),i[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(d&&d(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==i[l]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={1:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"4615a819",3:"c7255874",4:"8844c7c6",5:"d85ca603",6:"b5c87a76",7:"b762b15a",8:"ce6b453e",9:"cee9094a",10:"5712a6b9",11:"64978825",12:"4672093d",13:"514c624f",14:"684f545e",15:"443e1f82",16:"554bf912",17:"10770306",18:"47c8e9dc",19:"9ccbab29",20:"cfe64352",21:"08ded76b",22:"30a8a7ba",23:"e55cce19",24:"a971b8ae",25:"b0b75d76",26:"3b3ea698",27:"5c60f91f",28:"2bbf1597",29:"7741fccf",30:"86f2fd07",31:"5a96a257",32:"f8ecda14",33:"50ec8315",34:"1c62808e",35:"21acae61",36:"744eb2f7",37:"077678f2",38:"d2c19552",39:"d873f04b",40:"a9c0394e",41:"bd1b72f7",42:"8c5ba50f",43:"1c2fbec0",44:"2601ff73",45:"be6d6650",46:"43c49e4e",47:"915bfbea",48:"2eab3613",49:"80f28ebf",50:"7807e666",51:"1d274389",52:"509cdcc1",53:"aecfe03c",54:"efdf89ed",55:"6f8ddb85",56:"58b793ba",57:"3d08056f",58:"00820ba6",59:"4d4be159",60:"6089e8d9",61:"2f20e8a2",62:"03592460",63:"77002dd4",64:"21682768",65:"2864a239",66:"f56322cc",67:"74b17996",68:"aa956418",69:"6d03b9dd",70:"969e7814",71:"be209940",72:"ba2e6d02",73:"9fd124c3",74:"249922dd",75:"ceed0d6c",76:"72fa47b7",77:"0fc014e1",78:"53fae55d",79:"7ada76cb",80:"dc2a63b1",81:"390ff175",82:"2c89c39d",83:"63771f20",84:"97605ff9",85:"6be666e3",86:"b7199cc0",87:"259402b4",88:"c6187e8f",89:"cbb01039",90:"45499693",91:"5e71600c",92:"39993963",93:"90e9d9cd",94:"6c746767",95:"51e19fea",96:"787f754e",97:"6ad67df0",98:"7fb9a2ea",99:"81da5e8b",100:"2b9c7044",101:"2e83b5ef",102:"18a17638"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var d=l;a.push([102,0]),t()}([function(n,e,t){var r=t(55),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===i}:function(n){return"function"==typeof n}},function(n,e,t){var r=t(27),i=Function.prototype,a=i.call,o=r&&i.bind.bind(a,a);n.exports=r?o:function(n){return function(){return a.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||this||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";function r(n,e,t,r,i,a,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):i&&(l=s?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(69),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){var r=t(1),i=t(32),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e,t){var r=t(0),i=t(55),a=i.all;n.exports=i.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===a}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(163),i=t(166);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return f})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(24);const r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",i=s(n);return a.test(i)?n:i+".html"+t}function p(n,e){const t=n.hash,i=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(i&&t!==i)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:i,themeConfig:a}=t,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return v(n);const s=o.sidebar||a.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?v(n):r?r.map(n=>function n(e,t,r,i=1){if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function v(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function f(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function _(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return _(e)-_(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(15),i=t(148),a=t(149),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,e,t){var r=t(5),i=t(16),a=t(35);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(7).Symbol;n.exports=r},function(n,e,t){var r=t(5),i=t(64),a=t(98),o=t(25),s=t(54),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=d(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(1),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){var r=t(153),i=t(154),a=t(155),o=t(156),s=t(157);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(175);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(45);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),d=r.speed,u=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,d,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,o=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),d=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&p(i),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=u(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n,e,t){"use strict";var r=t(26),i=t(32),a=t(33),o=t(127),s=t(129);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=i(this),t=a(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){var r=t(9),i=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw a(i(n)+" is not an object")}},function(n,e,t){var r=t(2),i=t(51).f,a=t(14),o=t(110),s=t(37),l=t(65),c=t(123);n.exports=function(n,e){var t,d,u,p,m,h=n.target,v=n.global,g=n.stat;if(t=v?r:g?r[h]||s(h,{}):(r[h]||{}).prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=i(t,d))&&m.value:t[d],!c(v?d:h+(g?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&a(p,"sham",!0),o(t,d,p,n)}}},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(47),i=t(52);n.exports=function(n){return r(i(n))}},function(n,e,t){var r=t(2),i=t(0),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(0),i=t(108),a=TypeError;n.exports=function(n){if(r(n))return n;throw a(i(n)+" is not a function")}},function(n,e,t){var r=t(2),i=t(61),a=t(8),o=t(63),s=t(59),l=t(58),c=r.Symbol,d=i("wks"),u=l?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return a(d,n)||(d[n]=s&&a(c,n)?c[n]:u("Symbol."+n)),d[n]}},function(n,e,t){var r=t(52),i=Object;n.exports=function(n){return i(r(n))}},function(n,e,t){var r=t(121);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(27),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(2),i=t(37),a=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(2),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(147),i=t(12),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(7),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(167),i=t(174),a=t(176),o=t(177),s=t(178);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(6),i=t(45),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(13),i=t(12);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),i=t(3),a=t(17),o=Object,s=r("".split);n.exports=i((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?s(n,""):o(n)}:o},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function v(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=i.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,o,s,l,c=0,d=!1,g=!1,f=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=i;return r=i=void 0,c=e,o=n.apply(a,t)}function _(n){return c=n,s=setTimeout(x,e),d?b(n):o}function y(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function x(){var n=m();if(y(n))return T(n);s=setTimeout(x,function(n){var t=e-(n-l);return g?p(t,a-(n-c)):t}(n))}function T(n){return s=void 0,f&&r?b(n):(r=i=void 0,o)}function k(){var n=m(),t=y(n);if(r=arguments,i=this,l=n,t){if(void 0===s)return _(l);if(g)return s=setTimeout(x,e),b(l)}return void 0===s&&(s=setTimeout(x,e)),o}return e=v(e)||0,h(t)&&(d=!!t.leading,a=(g="maxWait"in t)?u(v(t.maxWait)||0,e):a,f="trailing"in t?!!t.trailing:f),k.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=i=s=void 0},k.flush=function(){return void 0===s?o:T(m())},k}},function(n,e,t){var r=t(5),i=t(34),a=t(104),o=t(35),s=t(28),l=t(54),c=t(8),d=t(64),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=s(n),e=l(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return o(!i(a.f,n,e),n[e])}},function(n,e,t){var r=t(53),i=TypeError;n.exports=function(n){if(r(n))throw i("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(105),i=t(56);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(29),i=t(0),a=t(57),o=t(58),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return i(e)&&a(e.prototype,s(n))}},function(n,e,t){var r=t(1);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(59);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(60),i=t(3),a=t(2).String;n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!a(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,i,a=t(2),o=t(106),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,d=c&&c.v8;d&&(i=(r=d.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){var r=t(62),i=t(36);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.30.2",mode:r?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(1),i=0,a=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,e,t){var r=t(5),i=t(3),a=t(97);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(8),i=t(116),a=t(51),o=t(16);n.exports=function(n,e,t){for(var s=i(e),l=o.f,c=a.f,d=0;d<s.length;d++){var u=s[d];r(n,u)||t&&r(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var r=t(120);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(133),i=t(25),a=t(134);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return i(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(18),i=t(158),a=t(159),o=t(160),s=t(161),l=t(162);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(13),i=t(40);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(179),i=t(12);n.exports=function n(e,t,a,o,s){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,o,n,s))}},function(n,e,t){var r=t(76),i=t(182),a=t(77);n.exports=function(n,e,t,o,s,l){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,v=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<d;){var f=n[h],b=e[h];if(o)var _=c?o(b,f,h,e,n,l):o(f,b,h,n,e,l);if(void 0!==_){if(_)continue;v=!1;break}if(g){if(!i(e,(function(n,e){if(!a(g,e)&&(f===n||s(f,n,t,o,l)))return g.push(e)}))){v=!1;break}}else if(f!==b&&!s(f,b,t,o,l)){v=!1;break}}return l.delete(n),l.delete(e),v}},function(n,e,t){var r=t(41),i=t(180),a=t(181);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(192),i=t(198),a=t(82);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(7),i=t(194),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||i;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(195),i=t(196),a=t(197),o=a&&a.isTypedArray,s=o?i(o):r;n.exports=s},function(n,e,t){var r=t(72),i=t(43);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(7),"Set");n.exports=r},function(n,e,t){var r=t(40);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(87),i=t(22);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(6),i=t(44),a=t(209),o=t(212);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(145),i=t(150),a=t(221),o=t(229),s=t(238),l=t(101),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=r.exec(t);if(!i)return t;var a="",o=0,s=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(a+=t.substring(s,o)),s=o+1,a+=e}return s!==o?a+t.substring(s,o):a}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(242),t(4)),a=Object(i.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(243),t(4)),a=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(2),i=t(9),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){var r=t(5),i=t(3);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(61),i=t(63),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){var r=t(1),i=t(8),a=t(28),o=t(118).indexOf,s=t(48),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,d=[];for(t in r)!i(s,t)&&i(r,t)&&l(d,t);for(;e.length>c;)i(r,t=e[c++])&&(~o(d,t)||l(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(248)},function(n,e,t){"use strict";var r=t(26),i=t(124).left,a=t(125),o=t(60);r({target:"Array",proto:!0,forced:!t(126)&&o>79&&o<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(34),i=t(9),a=t(56),o=t(107),s=t(109),l=t(31),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!i(n)||a(n))return n;var t,l=o(n,d);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!i(t)||a(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var r=t(30),i=t(53);n.exports=function(n,e){var t=n[e];return i(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(34),i=t(0),a=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&i(t=n.toString)&&!a(s=r(t,n)))return s;if(i(t=n.valueOf)&&!a(s=r(t,n)))return s;if("string"!==e&&i(t=n.toString)&&!a(s=r(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),i=t(16),a=t(111),o=t(37);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&a(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(1),i=t(3),a=t(0),o=t(8),s=t(5),l=t(112).CONFIGURABLE,c=t(113),d=t(114),u=d.enforce,p=d.get,m=String,h=Object.defineProperty,v=r("".slice),g=r("".replace),f=r([].join),b=s&&!i((function(){return 8!==h((function(){}),"length",{value:8}).length})),_=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===v(m(e),0,7)&&(e="["+g(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&o(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return o(r,"source")||(r.source=f(_,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return a(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){var r=t(5),i=t(8),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=i(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(1),i=t(0),a=t(36),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e,t){var r,i,a,o=t(115),s=t(2),l=t(9),c=t(14),d=t(8),u=t(36),p=t(99),m=t(48),h=s.TypeError,v=s.WeakMap;if(o||u.state){var g=u.state||(u.state=new v);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw h("Object already initialized");return e.facade=n,g.set(n,e),e},i=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var f=p("state");m[f]=!0,r=function(n,e){if(d(n,f))throw h("Object already initialized");return e.facade=n,c(n,f,e),e},i=function(n){return d(n,f)?n[f]:{}},a=function(n){return d(n,f)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=i(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(2),i=t(0),a=r.WeakMap;n.exports=i(a)&&/native code/.test(String(a))},function(n,e,t){var r=t(29),i=t(1),a=t(117),o=t(122),s=t(25),l=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(100),i=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){var r=t(28),i=t(119),a=t(33),o=function(n){return function(e,t,o){var s,l=r(e),c=a(l),d=i(o,c);if(n&&t!=t){for(;c>d;)if((s=l[d++])!=s)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(66),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(66),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(3),i=t(0),a=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==d||t!=c&&(i(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",d=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(30),i=t(32),a=t(47),o=t(33),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var d=i(e),u=a(d),p=o(d),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(c=t(c,u[m],m,d));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(17);n.exports="undefined"!=typeof process&&"process"==r(process)},function(n,e,t){"use strict";var r=t(5),i=t(128),a=TypeError,o=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(i(n)&&!o(n,"length").writable)throw a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(17);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(26),i=t(2),a=t(131),o=t(132),s=i.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(27),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(29),i=t(8),a=t(14),o=t(57),s=t(67),l=t(65),c=t(135),d=t(136),u=t(137),p=t(141),m=t(142),h=t(5),v=t(62);n.exports=function(n,e,t,g){var f=g?2:1,b=n.split("."),_=b[b.length-1],y=r.apply(null,b);if(y){var x=y.prototype;if(!v&&i(x,"cause")&&delete x.cause,!t)return y;var T=r("Error"),k=e((function(n,e){var t=u(g?e:n,void 0),r=g?new y(n):new y;return void 0!==t&&a(r,"message",t),m(r,k,r.stack,2),this&&o(x,this)&&d(r,this,k),arguments.length>f&&p(r,arguments[f]),r}));if(k.prototype=x,"Error"!==_?s?s(k,T):l(k,T,{name:!0}):h&&"stackTraceLimit"in y&&(c(k,y,"stackTraceLimit"),c(k,y,"prepareStackTrace")),l(k,y),!v)try{x.name!==_&&a(x,"name",_),x.constructor=k}catch(n){}return k}}},function(n,e,t){var r=t(1),i=t(30);n.exports=function(n,e,t){try{return r(i(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var r=t(0),i=String,a=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw a("Can't set "+i(n)+" as a prototype")}},function(n,e,t){var r=t(16).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),i=t(9),a=t(67);n.exports=function(n,e,t){var o,s;return a&&r(o=e.constructor)&&o!==t&&i(s=o.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){var r=t(138);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(139),i=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var r=t(140),i=t(0),a=t(17),o=t(31)("toStringTag"),s=Object,l="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?a(e):"Object"==(r=a(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(31)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),i=t(14);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var r=t(14),i=t(143),a=t(144),o=Error.captureStackTrace;n.exports=function(n,e,t,s){a&&(o?o(n,e):r(n,"stack",i(t,s)))}},function(n,e,t){var r=t(1),i=Error,a=r("".replace),o=String(i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var r=t(3),i=t(35);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(68),i=t(146);n.exports=function n(e,t,a,o,s){var l=-1,c=e.length;for(a||(a=i),s||(s=[]);++l<c;){var d=e[l];t>0&&a(d)?t>1?n(d,t-1,a,o,s):r(s,d):o||(s[s.length]=d)}return s}},function(n,e,t){var r=t(15),i=t(38),a=t(6),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(13),i=t(12);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(15),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(e?n[s]=t:delete n[s]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(151),i=t(207),a=t(46),o=t(6),s=t(218);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(152),i=t(206),a=t(85);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(70),i=t(74);n.exports=function(n,e,t,a){var o=t.length,s=o,l=!a;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var d=(c=t[o])[0],u=n[d],p=c[1];if(l&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new r;if(a)var h=a(u,p,d,n,e,m);if(!(void 0===h?i(p,u,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(19),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(19);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(19);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(19);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(18);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(18),i=t(39),a=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(72),i=t(164),a=t(40),o=t(73),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?p:s).test(o(n))}},function(n,e,t){var r,i=t(165),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(7)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(168),i=t(18),a=t(39);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(169),i=t(170),a=t(171),o=t(172),s=t(173);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(20);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(20),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(20),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(21);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(21);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(70),i=t(75),a=t(183),o=t(186),s=t(202),l=t(6),c=t(79),d=t(81),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,v){var g=l(n),f=l(e),b=g?"[object Array]":s(n),_=f?"[object Array]":s(e),y=(b="[object Arguments]"==b?u:b)==u,x=(_="[object Arguments]"==_?u:_)==u,T=b==_;if(T&&c(n)){if(!c(e))return!1;g=!0,y=!1}if(T&&!y)return v||(v=new r),g||d(n)?i(n,e,t,m,h,v):a(n,e,b,t,m,h,v);if(!(1&t)){var k=y&&p.call(n,"__wrapped__"),w=x&&p.call(e,"__wrapped__");if(k||w){var E=k?n.value():n,I=w?e.value():e;return v||(v=new r),h(E,I,t,m,v)}}return!!T&&(v||(v=new r),o(n,e,t,m,h,v))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(15),i=t(184),a=t(71),o=t(75),s=t(185),l=t(42),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&r;if(m||(m=l),n.size!=e.size&&!h)return!1;var v=p.get(n);if(v)return v==e;r|=2,p.set(n,e);var g=o(m(n),m(e),r,c,u,p);return p.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(7).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(187),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,s){var l=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!l)return!1;for(var u=d;u--;){var p=c[u];if(!(l?p in e:i.call(e,p)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var v=!0;s.set(n,e),s.set(e,n);for(var g=l;++u<d;){var f=n[p=c[u]],b=e[p];if(a)var _=l?a(b,f,p,e,n,s):a(f,b,p,n,e,s);if(!(void 0===_?f===b||o(f,b,t,a,s):_)){v=!1;break}g||(g="constructor"==p)}if(v&&!g){var y=n.constructor,x=e.constructor;y==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof x&&x instanceof x||(v=!1)}return s.delete(n),s.delete(e),v}},function(n,e,t){var r=t(188),i=t(189),a=t(78);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(68),i=t(6);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(190),i=t(191),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return a.call(n,e)})))}:i;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var o=n[t];e(o,t,n)&&(a[i++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(193),i=t(38),a=t(6),o=t(79),s=t(80),l=t(81),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),d=!t&&i(n),u=!t&&!d&&o(n),p=!t&&!d&&!u&&l(n),m=t||d||u||p,h=m?r(n.length,String):[],v=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||u&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,v))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(13),i=t(43),a=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(69),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(49)(n))},function(n,e,t){var r=t(199),i=t(200),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(201)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(203),i=t(39),a=t(204),o=t(83),s=t(205),l=t(13),c=t(73),d=c(r),u=c(i),p=c(a),m=c(o),h=c(s),v=l;(r&&"[object DataView]"!=v(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=v(new i)||a&&"[object Promise]"!=v(a.resolve())||o&&"[object Set]"!=v(new o)||s&&"[object WeakMap]"!=v(new s))&&(v=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=v},function(n,e,t){var r=t(10)(t(7),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(7),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(7),"WeakMap");n.exports=r},function(n,e,t){var r=t(84),i=t(78);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,r(o)]}return e}},function(n,e,t){var r=t(74),i=t(208),a=t(215),o=t(44),s=t(84),l=t(85),c=t(22);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?a(t,n):r(e,o,3)}}},function(n,e,t){var r=t(86);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(210),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(211);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(41);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return t.cache=a.set(i,o)||a,o};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(213);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(15),i=t(214),a=t(6),o=t(45),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(216),i=t(217);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(87),i=t(38),a=t(6),o=t(80),s=t(43),l=t(22);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,u=!1;++c<d;){var p=l(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&s(d)&&o(p,d)&&(a(n)||i(n))}},function(n,e,t){var r=t(219),i=t(220),a=t(44),o=t(22);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(86);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(46),i=t(222),a=t(224);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(223),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,s=i(a.length-e,0),l=Array(s);++o<s;)l[o]=a[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=a[o];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(225),i=t(228)(r);n.exports=i},function(n,e,t){var r=t(226),i=t(227),a=t(46),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(76),i=t(230),a=t(235),o=t(77),s=t(236),l=t(42);n.exports=function(n,e,t){var c=-1,d=i,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=a;else if(u>=200){var v=e?null:s(n);if(v)return l(v);p=!1,d=o,h=new r}else h=e?[]:m;n:for(;++c<u;){var g=n[c],f=e?e(g):g;if(g=t||0!==g?g:0,p&&f==f){for(var b=h.length;b--;)if(h[b]===f)continue n;e&&h.push(f),m.push(g)}else d(h,f,t)||(h!==m&&h.push(f),m.push(g))}return m}},function(n,e,t){var r=t(231);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(232),i=t(233),a=t(234);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(83),i=t(237),a=t(42),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(82),i=t(12);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),i=Array.isArray;function a(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function v(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function f(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var _=b("key,ref,slot,slot-scope,is");function y(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var x=Object.prototype.hasOwnProperty;function T(n,e){return x.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var w=/-(\w)/g,E=k((function(n){return n.replace(w,(function(n,e){return e?e.toUpperCase():""}))})),I=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),C=/\B([A-Z])/g,A=k((function(n){return n.replace(C,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function S(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function P(n,e){for(var t in e)n[t]=e[t];return n}function R(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function j(n,e,t){}var q=function(n,e,t){return!1},L=function(n){return n};function O(n,e){if(n===e)return!0;var t=d(n),r=d(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function N(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function B(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var M=["component","directive","filter"],U=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],V={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:q,isReservedAttr:q,isUnknownElement:q,getTagNamespace:j,parsePlatformTagName:L,mustUseProp:q,async:!0,_lifecycleHooks:U},F=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function $(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(F.source,".$_\\d]"));var W="__proto__"in{},Q="undefined"!=typeof window,J=Q&&window.navigator.userAgent.toLowerCase(),Y=J&&/msie|trident/.test(J),K=J&&J.indexOf("msie 9.0")>0,X=J&&J.indexOf("edge/")>0;J&&J.indexOf("android");var Z=J&&/iphone|ipad|ipod|ios/.test(J);J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J);var nn,en=J&&J.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(Q)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(Js){}var on=function(){return void 0===nn&&(nn=!Q&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=Q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,r,i,a,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function vn(n){return new mn(void 0,void 0,void 0,String(n))}function gn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var fn=0,bn=[],_n=function(){function n(){this._pending=!1,this.id=fn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();_n.target=null;var yn=[];function xn(n){yn.push(n),_n.target=n}function Tn(){yn.pop(),_n.target=yn[yn.length-1]}var kn=Array.prototype,wn=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];$(wn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var i,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var En=Object.getOwnPropertyNames(wn),In={},Cn=!0;function An(n){Cn=n}var zn={notify:j,depend:j,addSub:j,removeSub:j},Sn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?zn:new _n,this.vmCount=0,$(n,"__ob__",this),i(n)){if(!t)if(W)n.__proto__=wn;else for(var r=0,a=En.length;r<a;r++){$(n,s=En[r],wn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(r=0;r<o.length;r++){var s;Rn(n,s=o[r],In,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&T(n,"__ob__")&&n.__ob__ instanceof Sn?n.__ob__:!Cn||!t&&on()||!i(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Bn(n)||n instanceof mn?void 0:new Sn(n,e,t)}function Rn(n,e,t,r,a,o){var s=new _n,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,d=l&&l.set;c&&!d||t!==In&&2!==arguments.length||(t=n[e]);var u=!a&&Pn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return _n.target&&(s.depend(),u&&(u.dep.depend(),i(e)&&Ln(e))),Bn(e)&&!a?e.value:e},set:function(e){var r=c?c.call(n):t;if(B(r,e)){if(d)d.call(n,e);else{if(c)return;if(!a&&Bn(r)&&!Bn(e))return void(r.value=e);t=e}u=!a&&Pn(e,!1,o),s.notify()}}}),s}}function jn(n,e,t){if(!Dn(n)){var r=n.__ob__;return i(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(Rn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function qn(n,e){if(i(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||T(n,e)&&(delete n[e],t&&t.dep.notify())}}function Ln(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Ln(e)}function On(n){return Nn(n,!0),$(n,"__v_isShallow",!0),n}function Nn(n,e){if(!Dn(n)){Pn(n,e,on());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Bn(n){return!(!n||!0!==n.__v_isRef)}function Mn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Bn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Bn(r)&&!Bn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var Vn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Un,!n&&Un&&(this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Fn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Hn=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function $n(n,e){function t(){var n=t.fns;if(!i(n))return Ce(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)Ce(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Gn(n,e,t,r,i,o){var l,c,d,u;for(l in n)c=n[l],d=e[l],u=Hn(l),a(c)||(a(d)?(a(c.fns)&&(c=n[l]=$n(c,o)),s(u.once)&&(c=n[l]=i(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)a(n[l])&&r((u=Hn(l)).name,e[l],u.capture)}function Wn(n,e,t){var r;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),y(r.fns,l)}a(i)?r=$n([l]):o(i.fns)&&s(i.merged)?(r=i).fns.push(l):r=$n([i,l]),r.merged=!0,n[e]=r}function Qn(n,e,t,r,i){if(o(e)){if(T(e,t))return n[t]=e[t],i||delete e[t],!0;if(T(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function Jn(n){return l(n)?[vn(n)]:i(n)?function n(e,t){var r,c,d,u,p=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(d=p.length-1,u=p[d],i(c)?c.length>0&&(Yn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Yn(u)&&(p[d]=vn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Yn(u)?p[d]=vn(u.text+c):""!==c&&p.push(vn(c)):Yn(c)&&Yn(u)?p[d]=vn(u.text+c.text):(s(e._isVList)&&o(c.tag)&&a(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),p.push(c)));return p}(n):void 0}function Yn(n){return o(n)&&o(n.text)&&function(n){return!1===n}(n.isComment)}function Kn(n,e){var t,r,a,s,l=null;if(i(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)s=a[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Xn(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=P(P({},r),t)),i=a(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function Zn(n){return St(this.$options,"filters",n,!0)||L}function ne(n,e){return i(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,r,i){var a=V.keyCodes[e]||t;return i&&r&&!V.keyCodes[e]?ne(i,r):a?ne(a,n):r?A(r)!==e:void 0===n}function te(n,e,t,r,a){if(t)if(d(t)){i(t)&&(t=R(t));var o=void 0,s=function(i){if("class"===i||"style"===i||_(i))o=n;else{var s=n.attrs&&n.attrs.type;o=r||V.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=E(i),c=A(i);l in o||c in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var l in t)s(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ae(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ie(n,e,t){return ae(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ae(n,e,t){if(i(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&oe(n[r],"".concat(e,"_").concat(r),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(p(e)){var t=n.on=n.on?P({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function le(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];i(o)?le(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=ie,n._n=f,n._s=g,n._l=Kn,n._t=Xn,n._q=O,n._i=N,n._m=re,n._f=Zn,n._k=ee,n._b=te,n._v=vn,n._e=hn,n._u=le,n._g=se,n._d=ce,n._p=de}function pe(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ve(n,e,t,i){var a,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&i&&i!==r&&l===i.$key&&!o&&!i.$hasNormal)return i;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=ge(n,t,c,e[c]))}else a={};for(var d in t)d in a||(a[d]=fe(t,d));return e&&Object.isExtensible(e)&&(e._normalized=a),$(a,"$stable",s),$(a,"$key",l),$(a,"$hasNormal",o),a}function ge(n,e,t,r){var a=function(){var e=un;pn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!i(t)?[t]:Jn(t))&&t[0];return pn(e),t&&(!a||1===t.length&&a.isComment&&!he(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function fe(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};$(e,"_v_attr_proxy",!0),_e(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||_e(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:z(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Mn(n,e,t)}))}}}function _e(n,e,t,r,i){var a=!1;for(var o in e)o in n?e[o]!==t[o]&&(a=!0):(a=!0,ye(n,o,r,i));for(var o in n)o in e||(a=!0,delete n[o]);return a}function ye(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Te=null;function ke(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function we(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||he(t)))return t}}function Ee(n,e,t,r,u,p){return(i(t)||l(t))&&(u=r,r=t,t=void 0),s(p)&&(u=2),function(n,e,t,r,l){if(o(t)&&o(t.__ob__))return hn();o(t)&&o(t.is)&&(e=t.is);if(!e)return hn();0;i(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Jn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||V.getTagNamespace(e),u=V.isReservedTag(e)?new mn(V.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(m=St(n.$options,"components",e))?new mn(e,t,r,void 0,void 0,n):yt(m,t,n,r,e)}else u=yt(e,t,n,r);return i(u)?u:o(u)?(o(p)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];o(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(u,p),o(t)&&function(n){d(n.style)&&Ve(n.style);d(n.class)&&Ve(n.class)}(t),u):hn()}(n,e,t,r,u)}function Ie(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){Ae(n,r,"errorCaptured hook")}}Ae(n,e,t)}finally{Tn()}}function Ce(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&v(a)&&!a._handled&&(a.catch((function(n){return Ie(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){Ie(n,r,i)}return a}function Ae(n,e,t){if(V.errorHandler)try{return V.errorHandler.call(null,n,e,t)}catch(e){e!==n&&ze(e,null,"config.errorHandler")}ze(n,e,t)}function ze(n,e,t){if(!Q||"undefined"==typeof console)throw n;console.error(n)}var Se,Pe=!1,Re=[],je=!1;function qe(){je=!1;var n=Re.slice(0);Re.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Le=Promise.resolve();Se=function(){Le.then(qe),Z&&setTimeout(j)},Pe=!0}else if(Y||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Se="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(qe)}:function(){setTimeout(qe,0)};else{var Oe=1,Ne=new MutationObserver(qe),De=document.createTextNode(String(Oe));Ne.observe(De,{characterData:!0}),Se=function(){Oe=(Oe+1)%2,De.data=String(Oe)},Pe=!0}function Be(n,e){var t;if(Re.push((function(){if(n)try{n.call(e)}catch(n){Ie(n,e,"nextTick")}else t&&t(e)})),je||(je=!0,Se()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Me(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var r=n.$options;r[e]=It(r[e],t)}(t,n,e)}}Me("beforeMount"),Me("mounted"),Me("beforeUpdate"),Me("updated"),Me("beforeDestroy"),Me("destroyed"),Me("activated"),Me("deactivated"),Me("serverPrefetch"),Me("renderTracked"),Me("renderTriggered"),Me("errorCaptured");var Ue=new cn;function Ve(n){return function n(e,t){var r,a,o=i(e);if(!o&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(r=e.length;r--;)n(e[r],t);else if(Bn(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,Ue),Ue.clear(),n}var Fe,He=0,$e=function(){function n(n,e,t,r,i){var a,o;a=this,void 0===(o=Un&&!Un._vm?Un:n?n._scope:void 0)&&(o=Un),o&&o.active&&o.effects.push(a),(this.vm=n)&&i&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++He,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=j)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ie(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ve(n),Tn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ce(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ge(n,e){Fe.$on(n,e)}function We(n,e){Fe.$off(n,e)}function Qe(n,e){var t=Fe;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Je(n,e,t){Fe=n,Gn(e,t||{},Ge,We,Qe,n),Fe=void 0}var Ye=null;function Ke(n){var e=Ye;return Ye=n,function(){Ye=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ze(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ze(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,r){void 0===r&&(r=!0),xn();var i=un;r&&pn(n);var a=n.$options[e],o="".concat(e," hook");if(a)for(var s=0,l=a.length;s<l;s++)Ce(a[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),r&&pn(i),Tn()}var et=[],tt=[],rt={},it=!1,at=!1,ot=0;var st=0,lt=Date.now;if(Q&&!Y){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(st=lt(),at=!0,et.sort(dt),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();ot=et.length=tt.length=0,rt={},it=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ze(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&V.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==rt[e]&&(n!==_n.target||!n.noRecurse)){if(rt[e]=!0,at){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);it||(it=!0,Be(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){var o=n[a].from;if(o in e._provided)t[a]=e._provided[o];else if("default"in n[a]){var s=n[a].default;t[a]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,a,o){var l,c=this,d=o.options;T(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var u=s(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=mt(d.inject,a),this.slots=function(){return c.$slots||ve(a,n.scopedSlots,c.$slots=pe(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ve(a,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=ve(a,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,r){var o=Ee(l,n,e,t,r,p);return o&&!i(o)&&(o.fnScopeId=d._scopeId,o.fnContext=a),o}:this._c=function(n,e,t,r){return Ee(l,n,e,t,r,p)}}function vt(n,e,t,r,i){var a=gn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function gt(n,e){for(var t in e)n[E(t)]=e[t]}function ft(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,a){var o=i.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=a;var u=i.data.attrs||r;n._attrsProxy&&_e(n._attrsProxy,u,d.data&&d.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||r;var p=n.$options._parentListeners;if(n._listenersProxy&&_e(n._listenersProxy,t,p||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Je(n,t,p),e&&n.$options.props){An(!1);for(var m=n._props,h=n.$options._propKeys||[],v=0;v<h.length;v++){var g=h[v],f=n.$options.props;m[g]=Pt(g,f,e,n)}An(!0),n.$options.propsData=e}c&&(n.$slots=pe(a,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Ze(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Xe(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},_t=Object.keys(bt);function yt(n,e,t,l,c){if(!a(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Te;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=D((function(t){n.resolved=ke(t,e),i?r.length=0:u(!0)})),m=D((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(v(h)?a(n.resolved)&&h.then(p,m):v(h.component)&&(h.component.then(p,m),o(h.error)&&(n.errorComp=ke(h.error,e)),o(h.loading)&&(n.loadingComp=ke(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),o(h.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&m(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,r,i){var a=hn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(p,e,t,l,c);e=e||{},$t(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],l=e.model.callback;o(s)?(i(s)?-1===s.indexOf(l):s!==l)&&(a[r]=[l].concat(s)):a[r]=l}(n.options,e);var m=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in r){var d=A(c);Qn(i,l,c,d,!0)||Qn(i,s,c,d,!1)}return i}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var l=n.options,c={},d=l.props;if(o(d))for(var u in d)c[u]=Pt(u,d,e||r);else o(t.attrs)&&gt(c,t.attrs),o(t.props)&&gt(c,t.props);var p=new ht(t,c,s,a,n),m=l.render.call(null,p._c,p);if(m instanceof mn)return vt(m,t,p.parent,l,p);if(i(m)){for(var h=Jn(m)||[],v=new Array(h.length),g=0;g<h.length;g++)v[g]=vt(h[g],t,p.parent,l,p);return v}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<_t.length;t++){var r=_t[t],i=e[r],a=bt[r];i===a||i&&i._merged||(e[r]=i?xt(a,i):a)}}(e);var f=ft(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(f?"-".concat(f):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function xt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var Tt=j,kt=V.optionMergeStrategies;function wt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,i,a,o=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(r=o[s])&&(i=n[r],a=e[r],t&&T(n,r)?i!==a&&p(i)&&p(a)&&wt(i,a):jn(n,r,a));return n}function Et(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return r?wt(r,i):i}:e?n?function(){return wt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function It(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ct(n,e,t,r){var i=Object.create(n||null);return e?P(i,e):i}kt.data=function(n,e,t){return t?Et(n,e,t):e&&"function"!=typeof e?n:Et(n,e)},U.forEach((function(n){kt[n]=It})),M.forEach((function(n){kt[n+"s"]=Ct})),kt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in P(a,n),e){var s=a[o],l=e[o];s&&!i(s)&&(s=[s]),a[o]=s?s.concat(l):i(l)?l:[l]}return a},kt.props=kt.methods=kt.inject=kt.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return P(i,n),e&&P(i,e),i},kt.provide=function(n,e){return n?function(){var t=Object.create(null);return wt(t,c(n)?n.call(this):n),e&&wt(t,c(e)?e.call(this):e,!1),t}:e};var At=function(n,e){return void 0===e?n:e};function zt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(i(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[E(a)]={type:null});else if(p(t))for(var s in t)a=t[s],o[E(s)]=p(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(i(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(p(t))for(var o in t){var s=t[o];r[o]=p(s)?P({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=zt(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=zt(n,e.mixins[r],t);var o,s={};for(o in n)l(o);for(o in e)T(n,o)||l(o);function l(r){var i=kt[r]||At;s[r]=i(n[r],e[r],t,r)}return s}function St(n,e,t,r){if("string"==typeof t){var i=n[e];if(T(i,t))return i[t];var a=E(t);if(T(i,a))return i[a];var o=I(a);return T(i,o)?i[o]:i[t]||i[a]||i[o]}}function Pt(n,e,t,r){var i=e[n],a=!T(t,n),o=t[n],s=Lt(Boolean,i.type);if(s>-1)if(a&&!T(i,"default"))o=!1;else if(""===o||o===A(n)){var l=Lt(String,i.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!T(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==jt(e.type)?r.call(n):r}(r,i,n);var d=Cn;An(!0),Pn(o),An(d)}return o}var Rt=/^\s*function (\w+)/;function jt(n){var e=n&&n.toString().match(Rt);return e?e[1]:""}function qt(n,e){return jt(n)===jt(e)}function Lt(n,e){if(!i(e))return qt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(qt(e[t],n))return t;return-1}var Ot={enumerable:!0,configurable:!0,get:j,set:j};function Nt(n,e,t){Ot.get=function(){return this[e][t]},Ot.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ot)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=On({}),i=n.$options._propKeys=[];n.$parent&&An(!1);var a=function(a){i.push(a);var o=Pt(a,e,t,n);Rn(r,a,o),a in n||Nt(n,"_props",a)};for(var o in e)a(o);An(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=be(n);pn(n),xn();var i=Ce(t,null,[n._props||On({}),r],n,"setup");if(Tn(),pn(),c(i))e.render=i;else if(d(i))if(n._setupState=i,i.__sfc){var a=n._setupProxy={};for(var o in i)"__sfc"!==o&&Mn(a,i,o)}else for(var o in i)H(o)||Mn(n,i,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?j:z(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return Ie(n,e,"data()"),{}}finally{Tn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&T(r,a)||H(a)||Nt(n,"_data",a)}var o=Pn(e);o&&o.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var i in e){var a=e[i],o=c(a)?a:a.get;0,r||(t[i]=new $e(n,o||j,j,Bt)),i in n||Mt(n,i,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(i(r))for(var a=0;a<r.length;a++)Ft(n,t,r[a]);else Ft(n,t,r)}}(n,e.watch)}var Bt={lazy:!0};function Mt(n,e,t){var r=!on();c(t)?(Ot.get=r?Ut(e):Vt(t),Ot.set=j):(Ot.get=t.get?r&&!1!==t.cache?Ut(e):Vt(t.get):j,Ot.set=t.set||j),Object.defineProperty(n,e,Ot)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),_n.target&&e.depend(),e.value}}function Vt(n){return function(){return n.call(this,this)}}function Ft(n,e,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Ht=0;function $t(n){var e=n.options;if(n.super){var t=$t(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&P(n.extendOptions,r),(e=n.options=zt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Gt(n){this._init(n)}function Wt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=ft(n)||ft(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=zt(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Nt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Mt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,M.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=P({},o.options),i[r]=o,o}}function Qt(n){return n&&(ft(n.Ctor.options)||n.tag)}function Jt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Yt(n,e){var t=n.cache,r=n.keys,i=n._vnode;for(var a in t){var o=t[a];if(o){var s=o.name;s&&!e(s)&&Kt(t,a,r,i)}}}function Kt(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,y(t,e)}Gt.prototype._init=function(n){var e=this;e._uid=Ht++,e._isVue=!0,e.__v_skip=!0,e._scope=new Vn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=zt($t(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Je(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=pe(e._renderChildren,i),n.$scopedSlots=t?ve(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,i){return Ee(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return Ee(n,e,t,r,i,!0)};var a=t&&t.data;Rn(n,"$attrs",a&&a.attrs||r,null,!0),Rn(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){Rn(n,t,e[t])})),An(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var r=Fn(n),i=dn?Reflect.ownKeys(t):Object.keys(t),a=0;a<i.length;a++){var o=i[a];Object.defineProperty(r,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=jn,n.prototype.$delete=qn,n.prototype.$watch=function(n,e,t){if(p(e))return Ft(this,n,e,t);(t=t||{}).user=!0;var r=new $e(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');xn(),Ce(e,this,[r.value],this,i),Tn()}return function(){r.teardown()}}}(Gt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(i(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?S(t):t;for(var r=S(arguments,1),i='event handler for "'.concat(n,'"'),a=0,o=t.length;a<o;a++)Ce(t[a],e,r,e,i)}return e}}(Gt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=Ke(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Gt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Be(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=ve(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{pn(e),Te=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Ie(t,e,"render"),n=e._vnode}finally{Te=null,pn()}return i(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=a,n}}(Gt);var Xt=[String,RegExp,Array],Zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Xt,exclude:Xt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,o=t.componentOptions;n[r]={name:Qt(o),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Kt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Kt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Yt(n,(function(n){return Jt(e,n)}))})),this.$watch("exclude",(function(e){Yt(n,(function(n){return!Jt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=we(n),t=e&&e.componentOptions;if(t){var r=Qt(t),i=this.include,a=this.exclude;if(i&&(!r||!Jt(i,r))||a&&r&&Jt(a,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,y(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return V}};Object.defineProperty(n,"config",e),n.util={warn:Tt,extend:P,mergeOptions:zt,defineReactive:Rn},n.set=jn,n.delete=qn,n.nextTick=Be,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),M.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=S(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=zt(this.options,n),this}}(n),Wt(n),function(n){M.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Gt),Object.defineProperty(Gt.prototype,"$isServer",{get:on}),Object.defineProperty(Gt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Gt,"FunctionalRenderContext",{value:ht}),Gt.version="2.7.14";var nr=b("style,class"),er=b("input,textarea,option,select,progress"),tr=b("contenteditable,draggable,spellcheck"),rr=b("events,caret,typing,plaintext-only"),ir=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ar="http://www.w3.org/1999/xlink",or=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sr=function(n){return or(n)?n.slice(6,n.length):""},lr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(o(n)||o(e))return ur(n,pr(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:ur(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function ur(n,e){return n?e?n+" "+e:n:e||""}function pr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)o(e=pr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),vr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),gr=function(n){return hr(n)||vr(n)};var fr=Object.create(null);var br=b("text,number,password,search,email,tel,url");var _r=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yr={create:function(n,e){xr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xr(n,!0),xr(e))},destroy:function(n){xr(n,!0)}};function xr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,a=n.componentInstance||n.elm,s=e?null:a,l=e?void 0:a;if(c(t))Ce(t,r,[s],r,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Bn(t),m=r.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?i(h)&&y(h,a):i(h)?h.includes(a)||h.push(a):u?(m[t]=[a],Tr(r,t,m[t])):t.value=[a]}else if(u){if(e&&m[t]!==a)return;m[t]=l,Tr(r,t,s)}else if(p){if(e&&t.value!==a)return;t.value=s}else 0}}}function Tr(n,e,t){var r=n._setupState;r&&T(r,e)&&(Bn(r[e])?r[e].value=t:r[e]=t)}var kr=new mn("",{},[]),wr=["create","activate","update","remove","destroy"];function Er(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===i||br(r)&&br(i)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Ir(n,e,t){var r,i,a={};for(r=e;r<=t;++r)o(i=n[r].key)&&(a[i]=r);return a}var Cr={create:Ar,update:Ar,destroy:function(n){Ar(n,kr)}};function Ar(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===kr,o=e===kr,s=Sr(n.data.directives,n.context),l=Sr(e.data.directives,e.context),c=[],d=[];for(t in l)r=s[t],i=l[t],r?(i.oldValue=r.value,i.oldArg=r.arg,Rr(i,"update",e,n),i.def&&i.def.componentUpdated&&d.push(i)):(Rr(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Rr(c[t],"inserted",e,n)};a?Wn(e,"insert",u):u()}d.length&&Wn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Rr(d[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||Rr(s[t],"unbind",n,n,o)}(n,e)}var zr=Object.create(null);function Sr(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=zr),i[Pr(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||St(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||St(e.$options,"directives",r.name)}return i}function Pr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Rr(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){Ie(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var jr=[yr,Cr];function qr(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(r in(o(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.attrs=P({},d)),d)i=d[r],c[r]!==i&&Lr(l,r,i,e.data.pre);for(r in(Y||X)&&d.value!==c.value&&Lr(l,"value",d.value),c)a(d[r])&&(or(r)?l.removeAttributeNS(ar,sr(r)):tr(r)||l.removeAttribute(r))}}function Lr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Or(n,e,t):ir(e)?lr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):tr(e)?n.setAttribute(e,function(n,e){return lr(e)||"false"===e?"false":"contenteditable"===n&&rr(e)?e:"true"}(e,t)):or(e)?lr(t)?n.removeAttributeNS(ar,sr(e)):n.setAttributeNS(ar,e,t):Or(n,e,t)}function Or(n,e,t){if(lr(t))n.removeAttribute(e);else{if(Y&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Nr={create:qr,update:qr};function Dr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var s=cr(e),l=t._transitionClasses;o(l)&&(s=ur(s,pr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Br,Mr={create:Dr,update:Dr};function Ur(n,e,t){var r=Br;return function i(){var a=e.apply(null,arguments);null!==a&&Hr(n,i,t,r)}}var Vr=Pe&&!(en&&Number(en[1])<=53);function Fr(n,e,t,r){if(Vr){var i=st,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Br.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Hr(n,e,t,r){(r||Br).removeEventListener(n,e._wrapper||e,t)}function $r(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Br=e.elm||n.elm,function(n){if(o(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Gn(t,r,Fr,Hr,Ur,e.context),Br=void 0}}var Gr,Wr={create:$r,update:$r,destroy:function(n){return $r(n,kr)}};function Qr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=P({},c)),l)t in c||(i[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var d=a(r)?"":String(r);Jr(i,d)&&(i.value=d)}else if("innerHTML"===t&&vr(i.tagName)&&a(i.innerHTML)){(Gr=Gr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Gr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;u.firstChild;)i.appendChild(u.firstChild)}else if(r!==l[t])try{i[t]=r}catch(n){}}}}function Jr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return f(t)!==f(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Yr={create:Qr,update:Qr},Kr=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Xr(n){var e=Zr(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Zr(n){return Array.isArray(n)?R(n):"string"==typeof n?Kr(n):n}var ni,ei=/^--/,ti=/\s*!important$/,ri=function(n,e,t){if(ei.test(e))n.style.setProperty(e,t);else if(ti.test(t))n.style.setProperty(A(e),t.replace(ti,""),"important");else{var r=ai(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},ii=["Webkit","Moz","ms"],ai=k((function(n){if(ni=ni||document.createElement("div").style,"filter"!==(n=E(n))&&n in ni)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ii.length;t++){var r=ii[t]+e;if(r in ni)return r}}));function oi(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,s,l=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},u=c||d,p=Zr(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?P({},p):p;var m=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Xr(i.data))&&P(r,t);(t=Xr(n.data))&&P(r,t);for(var a=n;a=a.parent;)a.data&&(t=Xr(a.data))&&P(r,t);return r}(e,!0);for(s in u)a(m[s])&&ri(l,s,"");for(s in m)(i=m[s])!==u[s]&&ri(l,s,null==i?"":i)}}var si={create:oi,update:oi},li=/\s+/;function ci(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(li).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function di(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(li).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ui(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,pi(n.name||"v")),P(e,n),e}return"string"==typeof n?pi(n):void 0}}var pi=k((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mi=Q&&!K,hi="transition",vi="transitionend",gi="animation",fi="animationend";mi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hi="WebkitTransition",vi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gi="WebkitAnimation",fi="webkitAnimationEnd"));var bi=Q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function _i(n){bi((function(){bi(n)}))}function yi(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ci(n,e))}function xi(n,e){n._transitionClasses&&y(n._transitionClasses,e),di(n,e)}function Ti(n,e,t){var r=wi(n,e),i=r.type,a=r.timeout,o=r.propCount;if(!i)return t();var s="transition"===i?vi:fi,l=0,c=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),a+1),n.addEventListener(s,d)}var ki=/\b(transform|all)(,|$)/;function wi(n,e){var t,r=window.getComputedStyle(n),i=(r[hi+"Delay"]||"").split(", "),a=(r[hi+"Duration"]||"").split(", "),o=Ei(i,a),s=(r[gi+"Delay"]||"").split(", "),l=(r[gi+"Duration"]||"").split(", "),c=Ei(s,l),d=0,u=0;return"transition"===e?o>0&&(t="transition",d=o,u=a.length):"animation"===e?c>0&&(t="animation",d=c,u=l.length):u=(t=(d=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&ki.test(r[hi+"Property"])}}function Ei(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ii(e)+Ii(n[t])})))}function Ii(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ci(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ui(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,l=r.enterClass,u=r.enterToClass,p=r.enterActiveClass,m=r.appearClass,h=r.appearToClass,v=r.appearActiveClass,g=r.beforeEnter,b=r.enter,_=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,T=r.appear,k=r.afterAppear,w=r.appearCancelled,E=r.duration,I=Ye,C=Ye.$vnode;C&&C.parent;)I=C.context,C=C.parent;var A=!I._isMounted||!n.isRootInsert;if(!A||T||""===T){var z=A&&m?m:l,S=A&&v?v:p,P=A&&h?h:u,R=A&&x||g,j=A&&c(T)?T:b,q=A&&k||_,L=A&&w||y,O=f(d(E)?E.enter:E);0;var N=!1!==i&&!K,B=Si(j),M=t._enterCb=D((function(){N&&(xi(t,P),xi(t,S)),M.cancelled?(N&&xi(t,z),L&&L(t)):q&&q(t),t._enterCb=null}));n.data.show||Wn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),j&&j(t,M)})),R&&R(t),N&&(yi(t,z),yi(t,S),_i((function(){xi(t,z),M.cancelled||(yi(t,P),B||(zi(O)?setTimeout(M,O):Ti(t,s,M)))}))),n.data.show&&(e&&e(),j&&j(t,M)),N||B||M()}}}function Ai(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ui(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,u=r.leaveActiveClass,p=r.beforeLeave,m=r.leave,h=r.afterLeave,v=r.leaveCancelled,g=r.delayLeave,b=r.duration,_=!1!==i&&!K,y=Si(m),x=f(d(b)?b.leave:b);0;var T=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),_&&(xi(t,c),xi(t,u)),T.cancelled?(_&&xi(t,l),v&&v(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(k):k()}function k(){T.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),_&&(yi(t,l),yi(t,u),_i((function(){xi(t,l),T.cancelled||(yi(t,c),y||(zi(x)?setTimeout(T,x):Ti(t,s,T)))}))),m&&m(t,T),_||y||T())}}function zi(n){return"number"==typeof n&&!isNaN(n)}function Si(n){if(a(n))return!1;var e=n.fns;return o(e)?Si(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Pi(n,e){!0!==e.data.show&&Ci(e)}var Ri=function(n){var e,t,r={},c=n.modules,d=n.nodeOps;for(e=0;e<wr.length;++e)for(r[wr[e]]=[],t=0;t<c.length;++t)o(c[t][wr[e]])&&r[wr[e]].push(c[t][wr[e]]);function u(n){var e=d.parentNode(n);o(e)&&d.removeChild(e,n)}function p(n,e,t,i,a,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=gn(n)),n.isRootInsert=!a,!function(n,e,t,i){var a=n.data;if(o(a)){var l=o(n.componentInstance)&&a.keepAlive;if(o(a=a.hook)&&o(a=a.init)&&a(n,!1),o(n.componentInstance))return m(n,e),h(t,n.elm,i),s(l)&&function(n,e,t,i){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(a=s.data)&&o(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](kr,s);e.push(s);break}h(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,p=n.children,g=n.tag;o(g)?(n.elm=n.ns?d.createElementNS(n.ns,g):d.createElement(g,n),_(n),v(n,p,e),o(u)&&f(n,e),h(t,n.elm,i)):s(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,i)):(n.elm=d.createTextNode(n.text),h(t,n.elm,i))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(f(n,e),_(n)):(xr(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function v(n,e,t){if(i(e)){0;for(var r=0;r<e.length;++r)p(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function f(n,t){for(var i=0;i<r.create.length;++i)r.create[i](kr,n);o(e=n.data.hook)&&(o(e.create)&&e.create(kr,n),o(e.insert)&&t.push(n))}function _(n){var e;if(o(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;o(e=Ye)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function y(n,e,t,r,i,a){for(;r<=i;++r)p(t[r],a,n,e,!1,t,r)}function x(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function T(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(k(r),x(r)):u(r.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,i=r.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else u(n.elm)}function w(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(o(a)&&Er(n,a))return i}}function E(n,e,t,i,l,c){if(n!==e){o(e.elm)&&o(i)&&(e=i[l]=gn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;o(h)&&o(m=h.hook)&&o(m=m.prepatch)&&m(n,e);var v=n.children,f=e.children;if(o(h)&&g(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);o(m=h.hook)&&o(m=m.update)&&m(n,e)}a(e.text)?o(v)&&o(f)?v!==f&&function(n,e,t,r,i){var s,l,c,u=0,m=0,h=e.length-1,v=e[0],g=e[h],f=t.length-1,b=t[0],_=t[f],x=!i;for(0;u<=h&&m<=f;)a(v)?v=e[++u]:a(g)?g=e[--h]:Er(v,b)?(E(v,b,r,t,m),v=e[++u],b=t[++m]):Er(g,_)?(E(g,_,r,t,f),g=e[--h],_=t[--f]):Er(v,_)?(E(v,_,r,t,f),x&&d.insertBefore(n,v.elm,d.nextSibling(g.elm)),v=e[++u],_=t[--f]):Er(g,b)?(E(g,b,r,t,m),x&&d.insertBefore(n,g.elm,v.elm),g=e[--h],b=t[++m]):(a(s)&&(s=Ir(e,u,h)),a(l=o(b.key)?s[b.key]:w(b,e,u,h))?p(b,r,n,v.elm,!1,t,m):Er(c=e[l],b)?(E(c,b,r,t,m),e[l]=void 0,x&&d.insertBefore(n,c.elm,v.elm)):p(b,r,n,v.elm,!1,t,m),b=t[++m]);u>h?y(n,a(t[f+1])?null:t[f+1].elm,t,m,f,r):m>f&&T(e,u,h)}(u,v,f,t,c):o(f)?(o(n.text)&&d.setTextContent(u,""),y(u,null,f,0,f.length-1,t)):o(v)?T(v,0,v.length-1):o(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),o(h)&&o(m=h.hook)&&o(m=m.postpatch)&&m(n,e)}}}function I(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var C=b("attrs,class,staticClass,staticStyle,key");function A(n,e,t,r){var i,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(i=l.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return m(e,t),!0;if(o(a)){if(o(c))if(n.hasChildNodes())if(o(i=l)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!A(u,c[p],t,r)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else v(e,c,t);if(o(l)){var h=!1;for(var g in l)if(!C(g)){h=!0,f(e,t);break}!h&&l.class&&Ve(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var l,c=!1,u=[];if(a(n))c=!0,p(e,u);else{var m=o(n.nodeType);if(!m&&Er(n,e))E(n,e,u,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,u))return I(e,u,!0),n;l=n,n=new mn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,v=d.parentNode(h);if(p(e,u,h._leaveCb?null:v,d.nextSibling(h)),o(e.parent))for(var f=e.parent,b=g(e);f;){for(var _=0;_<r.destroy.length;++_)r.destroy[_](f);if(f.elm=e.elm,b){for(var y=0;y<r.create.length;++y)r.create[y](kr,f);var k=f.data.hook.insert;if(k.merged)for(var w=1;w<k.fns.length;w++)k.fns[w]()}else xr(f);f=f.parent}o(v)?T([n],0,0):o(n.tag)&&x(n)}}return I(e,u,c),e.elm}o(n)&&x(n)}}({nodeOps:_r,modules:[Nr,Mr,Wr,Yr,si,Q?{create:Pi,activate:Pi,remove:function(n,e){!0!==n.data.show?Ai(n,e):e()}}:{}].concat(jr)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Mi(n,"input")}));var ji={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Wn(t,"postpatch",(function(){ji.componentUpdated(n,e,t)})):qi(n,e,t.context),n._vOptions=[].map.call(n.options,Ni)):("textarea"===t.tag||br(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Di),n.addEventListener("compositionend",Bi),n.addEventListener("change",Bi),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){qi(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,Ni);if(i.some((function(n,e){return!O(n,r[e])})))(n.multiple?e.value.some((function(n){return Oi(n,i)})):e.value!==e.oldValue&&Oi(e.value,i))&&Mi(n,"change")}}};function qi(n,e,t){Li(n,e,t),(Y||X)&&setTimeout((function(){Li(n,e,t)}),0)}function Li(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],i)a=N(r,Ni(o))>-1,o.selected!==a&&(o.selected=a);else if(O(Ni(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function Oi(n,e){return e.every((function(e){return!O(e,n)}))}function Ni(n){return"_value"in n?n._value:n.value}function Di(n){n.target.composing=!0}function Bi(n){n.target.composing&&(n.target.composing=!1,Mi(n.target,"input"))}function Mi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ui(n){return!n.componentInstance||n.data&&n.data.transition?n:Ui(n.componentInstance._vnode)}var Vi={model:ji,show:{bind:function(n,e,t){var r=e.value,i=(t=Ui(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,Ci(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Ui(t)).data&&t.data.transition?(t.data.show=!0,r?Ci(t,(function(){n.style.display=n.__vOriginalDisplay})):Ai(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},Fi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Hi(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Hi(we(e.children)):n}function $i(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var r in i)e[E(r)]=i[r];return e}function Gi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Wi=function(n){return n.tag||he(n)},Qi=function(n){return"show"===n.name},Ji={name:"transition",props:Fi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Wi)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=Hi(i);if(!a)return i;if(this._leaving)return Gi(n,i);var o="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?o+"comment":o+a.tag:l(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var s=(a.data||(a.data={})).transition=$i(this),c=this._vnode,d=Hi(c);if(a.data.directives&&a.data.directives.some(Qi)&&(a.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,d)&&!he(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=P({},s);if("out-in"===r)return this._leaving=!0,Wn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Gi(n,i);if("in-out"===r){if(he(a))return c;var p,m=function(){p()};Wn(s,"afterEnter",m),Wn(s,"enterCancelled",m),Wn(u,"delayLeave",(function(n){p=n}))}}return i}}},Yi=P({tag:String,moveClass:String},Fi);function Ki(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Xi(n){n.data.newPos=n.elm.getBoundingClientRect()}function Zi(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),a.transitionDuration="0s"}}delete Yi.mode;var na={Transition:Ji,TransitionGroup:{props:Yi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=Ke(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=$i(this),s=0;s<i.length;s++){if((d=i[s]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))a.push(d),t[d.key]=d,(d.data||(d.data={})).transition=o;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var d;(d=r[s]).data.transition=o,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ki),n.forEach(Xi),n.forEach(Zi),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;yi(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(vi,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(vi,n),t._moveCb=null,xi(t,e))})}})))},methods:{hasMove:function(n,e){if(!mi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){di(t,n)})),ci(t,e),t.style.display="none",this.$el.appendChild(t);var r=wi(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ea(n,e){for(var t in e)n[t]=e[t];return n}Gt.config.mustUseProp=function(n,e,t){return"value"===t&&er(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Gt.config.isReservedTag=gr,Gt.config.isReservedAttr=nr,Gt.config.getTagNamespace=function(n){return vr(n)?"svg":"math"===n?"math":void 0},Gt.config.isUnknownElement=function(n){if(!Q)return!0;if(gr(n))return!1;if(n=n.toLowerCase(),null!=fr[n])return fr[n];var e=document.createElement(n);return n.indexOf("-")>-1?fr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:fr[n]=/HTMLUnknownElement/.test(e.toString())},P(Gt.options.directives,Vi),P(Gt.options.components,na),Gt.prototype.__patch__=Q?Ri:j,Gt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new $e(n,r,j,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var a=0;a<i.length;a++)i[a].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&Q?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Q&&setTimeout((function(){V.devtools&&sn&&sn.emit("init",Gt)}),0);var ta=/[!'()*]/g,ra=function(n){return"%"+n.charCodeAt(0).toString(16)},ia=/%2C/g,aa=function(n){return encodeURIComponent(n).replace(ta,ra).replace(ia,",")};function oa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var sa=function(n){return null==n||"object"==typeof n?n:String(n)};function la(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=oa(t.shift()),i=t.length>0?oa(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function ca(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return aa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(aa(e)):r.push(aa(e)+"="+aa(n)))})),r.join("&")}return aa(e)+"="+aa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var da=/\/?$/;function ua(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=pa(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:va(e,i),matched:n?ha(n):[]};return t&&(o.redirectedFrom=va(t,i)),Object.freeze(o)}function pa(n){if(Array.isArray(n))return n.map(pa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=pa(n[t]);return e}return n}var ma=ua(null,{path:"/"});function ha(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function va(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||ca)(r)+i}function ga(n,e,t){return e===ma?n===e:!!e&&(n.path&&e.path?n.path.replace(da,"")===e.path.replace(da,"")&&(t||n.hash===e.hash&&fa(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&fa(n.query,e.query)&&fa(n.params,e.params))))}function fa(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?fa(a,o):String(a)===String(o)}))}function ba(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var _a={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,a=e.data;a.routerView=!0;for(var o=i.$createElement,s=t.name,l=i.$route,c=i._routerViewCache||(i._routerViewCache={}),d=0,u=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&d++,p.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(a.routerViewDepth=d,u){var m=c[s],h=m&&m.component;return h?(m.configProps&&ya(h,a,m.route,m.configProps),o(h,a,r)):o()}var v=l.matched[d],g=v&&v.components[s];if(!v||!g)return c[s]=null,o();c[s]={component:g},a.registerRouteInstance=function(n,e){var t=v.instances[s];(e&&t!==n||!e&&t===n)&&(v.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){v.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==v.instances[s]&&(v.instances[s]=n.componentInstance),ba(l)};var f=v.props&&v.props[s];return f&&(ea(c[s],{route:l,configProps:f}),ya(g,a,l,f)),o(g,a,r)}};function ya(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=ea({},i);var a=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function xa(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function Ta(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ka=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},wa=Da,Ea=Sa,Ia=function(n,e){return Ra(Sa(n,e),e)},Ca=Ra,Aa=Na,za=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Sa(n,e){for(var t,r=[],i=0,a=0,o="",s=e&&e.delimiter||"/";null!=(t=za.exec(n));){var l=t[0],c=t[1],d=t.index;if(o+=n.slice(a,d),a=d+l.length,c)o+=c[1];else{var u=n[a],p=t[2],m=t[3],h=t[4],v=t[5],g=t[6],f=t[7];o&&(r.push(o),o="");var b=null!=p&&null!=u&&u!==p,_="+"===g||"*"===g,y="?"===g||"*"===g,x=t[2]||s,T=h||v;r.push({name:m||i++,prefix:p||"",delimiter:x,optional:y,repeat:_,partial:b,asterisk:!!f,pattern:T?qa(T):f?".*":"[^"+ja(x)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function Pa(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Ra(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Oa(e)));return function(e,r){for(var i="",a=e||{},o=(r||{}).pretty?Pa:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,d=a[l.name];if(null==d){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ka(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=o(d[u]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(d),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function ja(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function qa(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function La(n,e){return n.keys=e,n}function Oa(n){return n&&n.sensitive?"":"i"}function Na(n,e,t){ka(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=ja(s);else{var l=ja(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=ja(t.delimiter||"/"),u=a.slice(-d.length)===d;return r||(a=(u?a.slice(0,-d.length):a)+"(?:"+d+"(?=$))?"),a+=i?"$":r&&u?"":"(?="+d+"|$)",La(new RegExp("^"+a,Oa(t)),e)}function Da(n,e,t){return ka(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return La(n,e)}(n,e):ka(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(Da(n[i],e,t).source);return La(new RegExp("(?:"+r.join("|")+")",Oa(t)),e)}(n,e,t):function(n,e,t){return Na(Sa(n,t),e,t)}(n,e,t)}wa.parse=Ea,wa.compile=Ia,wa.tokensToFunction=Ca,wa.tokensToRegExp=Aa;var Ba=Object.create(null);function Ma(n,e,t){e=e||{};try{var r=Ba[n]||(Ba[n]=wa.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ua(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=ea({},n)).params;return a&&"object"==typeof a&&(i.params=ea({},a)),i}if(!i.path&&i.params&&e){(i=ea({},i))._normalized=!0;var o=ea(ea({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;i.path=Ma(s,o,e.path)}else 0;return i}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",d=l.path?xa(l.path,c,t||i.append):c,u=function(n,e,t){void 0===e&&(e={});var r,i=t||la;try{r=i(n||"")}catch(n){r={}}for(var a in e){var o=e[a];r[a]=Array.isArray(o)?o.map(sa):sa(o)}return r}(l.query,i.query,r&&r.options.parseQuery),p=i.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Va,Fa=function(){},Ha={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),a=i.location,o=i.route,s=i.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,v=o.redirectedFrom?ua(null,Ua(o.redirectedFrom),null,t):o;l[h]=ga(r,v,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(da,"/").indexOf(e.path.replace(da,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,v);var g=l[h]?this.ariaCurrentValue:null,f=function(n){$a(n)&&(e.replace?t.replace(a,Fa):t.push(a,Fa))},b={click:$a};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=f})):b[this.event]=f;var _={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:f,isActive:l[m],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)_.on=b,_.attrs={href:s,"aria-current":g};else{var x=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var T=x.data=ea({},x.data);for(var k in T.on=T.on||{},T.on){var w=T.on[k];k in b&&(T.on[k]=Array.isArray(w)?w:[w])}for(var E in b)E in T.on?T.on[E].push(b[E]):T.on[E]=f;var I=x.data.attrs=ea({},x.data.attrs);I.href=s,I["aria-current"]=g}else _.on=b}return n(this.tag,_,this.$slots.default)}};function $a(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ga="undefined"!=typeof window;function Wa(n,e,t,r,i){var a=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,o){var s=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Ta(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var u={path:d,regex:Qa(d,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?Ta(o+"/"+i.path):void 0;n(e,t,r,i,u,a)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:i.children};n(e,t,r,h,a,u.path||"/")}l&&(r[l]||(r[l]=u))}(a,o,s,n,i)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:o,nameMap:s}}function Qa(n,e){return wa(n,[],e)}function Ja(n,e){var t=Wa(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function o(n,t,o){var s=Ua(n,t,!1,e),c=s.name;if(c){var d=a[c];if(!d)return l(null,s);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&u.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Ma(d.path,s.params),l(d,s,o)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var h=r[m],v=i[h];if(Ya(v.regex,s.path,s.params))return l(v,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,i="function"==typeof r?r(ua(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var s=i,c=s.name,d=s.path,u=t.query,p=t.hash,m=t.params;if(u=s.hasOwnProperty("query")?s.query:u,p=s.hasOwnProperty("hash")?s.hash:p,m=s.hasOwnProperty("params")?s.params:m,c){a[c];return o({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return xa(n,e.parent?e.parent.path:"/",!0)}(d,n);return o({_normalized:!0,path:Ma(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:Ma(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):ua(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Wa([e||n],r,i,a,t),t&&t.alias.length&&Wa(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Wa(n,r,i,a)}}}function Ya(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[i]?oa(r[i]):r[i])}return!0}var Ka=Ga&&window.performance&&window.performance.now?window.performance:Date;function Xa(){return Ka.now().toFixed(3)}var Za=Xa();function no(){return Za}function eo(n){return Za=n}var to=Object.create(null);function ro(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ea({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function io(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=no();if(n)return to[n]}(),o=i.call(n,e,t,r?a:null);o&&("function"==typeof o.then?o.then((function(n){po(n,a)})).catch((function(n){0})):po(o,a))}))}}function ao(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){ao(),n.state&&n.state.key&&eo(n.state.key)}function so(n){return co(n.x)||co(n.y)}function lo(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var uo=/^#\d/;function po(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=uo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:co((t=a).x)?t.x:0,y:co(t.y)?t.y:0})}else so(n)&&(e=lo(n))}else r&&so(n)&&(e=lo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var mo,ho=Ga&&((-1===(mo=window.navigator.userAgent).indexOf("Android 2.")&&-1===mo.indexOf("Android 4.0")||-1===mo.indexOf("Mobile Safari")||-1!==mo.indexOf("Chrome")||-1!==mo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function vo(n,e){ao();var t=window.history;try{if(e){var r=ea({},t.state);r.key=no(),t.replaceState(r,"",n)}else t.pushState({key:eo(Xa())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function go(n){vo(n,!0)}var fo={redirected:2,aborted:4,cancelled:8,duplicated:16};function bo(n,e){return yo(n,e,fo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return xo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function _o(n,e){return yo(n,e,fo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function yo(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var xo=["params","query","hash"];function To(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ko(n,e){return To(n)&&n._isRouter&&(null==e||n.type===e)}function wo(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}function Eo(n){return function(e,t,r){var i=!1,a=0,o=null;Io(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var l,c=zo((function(e){var i;((i=e).__esModule||Ao&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Va.extend(e),t.components[s]=e,--a<=0&&r()})),d=zo((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=To(n)?n:new Error(e),r(o))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),i||r()}}function Io(n,e){return Co(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Co(n){return Array.prototype.concat.apply([],n)}var Ao="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function zo(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var So=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ga){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ma,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Po(n,e,t,r){var i=Io(n,(function(n,r,i,a){var o=function(n,e){"function"!=typeof n&&(n=Va.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,i,a)})):t(o,r,i,a)}));return Co(r?i.reverse():i)}function Ro(n,e){if(e)return function(){return n.apply(e,arguments)}}So.prototype.listen=function(n){this.cb=n},So.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},So.prototype.onError=function(n){this.errorCbs.push(n)},So.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(ko(n,fo.redirected)&&a===ma||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},So.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,o,s=function(n){!ko(n)&&To(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(ga(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&io(this.router,i,n,!1),s(((o=yo(a=i,n,fo.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var d=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return Po(n,"beforeRouteLeave",Ro,!0)}(p),this.router.beforeHooks,function(n){return Po(n,"beforeRouteUpdate",Ro)}(u),m.map((function(n){return n.beforeEnter})),Eo(m)),v=function(e,t){if(r.pending!==n)return s(_o(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return yo(n,e,fo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):To(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bo(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};wo(h,v,(function(){wo(function(n){return Po(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),v,(function(){if(r.pending!==n)return s(_o(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){ba(n)}))}))}))},So.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},So.prototype.setupListeners=function(){},So.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ma,this.pending=null};var jo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=qo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=ho&&t;r&&this.listeners.push(ro());var i=function(){var t=n.current,i=qo(n.base);n.current===ma&&i===n._startLocation||n.transitionTo(i,(function(n){r&&io(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){vo(Ta(r.base+n.fullPath)),io(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){go(Ta(r.base+n.fullPath)),io(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(qo(this.base)!==this.current.fullPath){var e=Ta(this.base+this.current.fullPath);n?vo(e):go(e)}},e.prototype.getCurrentLocation=function(){return qo(this.base)},e}(So);function qo(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(Ta(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Lo=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=qo(n);if(!/^\/#/.test(e))return window.location.replace(Ta(n+"/#"+e)),!0}(this.base)||Oo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ho&&e;t&&this.listeners.push(ro());var r=function(){var e=n.current;Oo()&&n.transitionTo(No(),(function(r){t&&io(n.router,r,e,!0),ho||Mo(r.fullPath)}))},i=ho?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Bo(n.fullPath),io(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Mo(n.fullPath),io(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;No()!==e&&(n?Bo(e):Mo(e))},e.prototype.getCurrentLocation=function(){return No()},e}(So);function Oo(){var n=No();return"/"===n.charAt(0)||(Mo("/"+n),!1)}function No(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Do(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Bo(n){ho?vo(Do(n)):window.location.hash=n}function Mo(n){ho?go(Do(n)):window.location.replace(Do(n))}var Uo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ko(n,fo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(So),Vo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ja(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ho&&!1!==n.fallback,this.fallback&&(e="hash"),Ga||(e="abstract"),this.mode=e,e){case"history":this.history=new jo(this,n.base);break;case"hash":this.history=new Lo(this,n.base,this.fallback);break;case"abstract":this.history=new Uo(this,n.base);break;default:0}},Fo={currentRoute:{configurable:!0}};Vo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Fo.currentRoute.get=function(){return this.history&&this.history.current},Vo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof jo||t instanceof Lo){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;ho&&i&&"fullPath"in n&&io(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Vo.prototype.beforeEach=function(n){return $o(this.beforeHooks,n)},Vo.prototype.beforeResolve=function(n){return $o(this.resolveHooks,n)},Vo.prototype.afterEach=function(n){return $o(this.afterHooks,n)},Vo.prototype.onReady=function(n,e){this.history.onReady(n,e)},Vo.prototype.onError=function(n){this.history.onError(n)},Vo.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Vo.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Vo.prototype.go=function(n){this.history.go(n)},Vo.prototype.back=function(){this.go(-1)},Vo.prototype.forward=function(){this.go(1)},Vo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Vo.prototype.resolve=function(n,e,t){var r=Ua(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?Ta(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},Vo.prototype.getRoutes=function(){return this.matcher.getRoutes()},Vo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ma&&this.history.transitionTo(this.history.getCurrentLocation())},Vo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ma&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Vo.prototype,Fo);var Ho=Vo;function $o(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Vo.install=function n(e){if(!n.installed||Va!==e){n.installed=!0,Va=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",_a),e.component("RouterLink",Ha);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Vo.version="3.6.5",Vo.isNavigationFailure=ko,Vo.NavigationFailureType=fo,Vo.START_LOCATION=ma,Ga&&window.Vue&&window.Vue.use(Vo);t(103);t(24),t(130);var Go={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,329)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,328))},Wo={"v-4c87a166":()=>t.e(5).then(t.bind(null,330)),"v-e9680046":()=>t.e(6).then(t.bind(null,331)),"v-7eb5beb0":()=>t.e(7).then(t.bind(null,332)),"v-3d949f6d":()=>t.e(8).then(t.bind(null,333)),"v-4b19516d":()=>t.e(9).then(t.bind(null,334)),"v-30f3c798":()=>t.e(10).then(t.bind(null,335)),"v-bf39c196":()=>t.e(11).then(t.bind(null,336)),"v-3448b2e6":()=>t.e(12).then(t.bind(null,337)),"v-175c66c1":()=>t.e(13).then(t.bind(null,338)),"v-07650679":()=>t.e(14).then(t.bind(null,339)),"v-dbcac10c":()=>t.e(15).then(t.bind(null,340)),"v-4a2741a2":()=>t.e(16).then(t.bind(null,341)),"v-164b59d5":()=>t.e(17).then(t.bind(null,342)),"v-5c088d6b":()=>t.e(18).then(t.bind(null,343)),"v-afd5090a":()=>t.e(19).then(t.bind(null,344)),"v-2f55ed6a":()=>t.e(20).then(t.bind(null,345)),"v-0ae8e482":()=>t.e(21).then(t.bind(null,346)),"v-4d99aed0":()=>t.e(22).then(t.bind(null,347)),"v-53af30f2":()=>t.e(23).then(t.bind(null,348)),"v-55759766":()=>t.e(24).then(t.bind(null,349)),"v-f0cc61b6":()=>t.e(25).then(t.bind(null,350)),"v-13ee8c1e":()=>t.e(26).then(t.bind(null,351)),"v-65a3fd54":()=>t.e(27).then(t.bind(null,352)),"v-966b0b0c":()=>t.e(28).then(t.bind(null,353)),"v-7784b32c":()=>t.e(30).then(t.bind(null,354)),"v-2a6914c8":()=>t.e(29).then(t.bind(null,355)),"v-1c42788c":()=>t.e(31).then(t.bind(null,356)),"v-be55bf68":()=>t.e(32).then(t.bind(null,357)),"v-34eff995":()=>t.e(33).then(t.bind(null,358)),"v-a3b400f8":()=>t.e(34).then(t.bind(null,359)),"v-53d48847":()=>t.e(35).then(t.bind(null,360)),"v-33f65e3e":()=>t.e(36).then(t.bind(null,361)),"v-789efd9e":()=>t.e(37).then(t.bind(null,362)),"v-75f7300c":()=>t.e(38).then(t.bind(null,363)),"v-7c46b244":()=>t.e(39).then(t.bind(null,364)),"v-39fe2a71":()=>t.e(40).then(t.bind(null,365)),"v-1d0967af":()=>t.e(41).then(t.bind(null,366)),"v-10241104":()=>t.e(42).then(t.bind(null,367)),"v-4624b883":()=>t.e(43).then(t.bind(null,368)),"v-1ad60d6d":()=>t.e(44).then(t.bind(null,369)),"v-54a29711":()=>t.e(45).then(t.bind(null,370)),"v-4eb718aa":()=>t.e(46).then(t.bind(null,371)),"v-8c26678c":()=>t.e(47).then(t.bind(null,372)),"v-c8298182":()=>t.e(48).then(t.bind(null,373)),"v-f015cfe8":()=>t.e(49).then(t.bind(null,374)),"v-1b717988":()=>t.e(50).then(t.bind(null,375)),"v-58b77b9c":()=>t.e(51).then(t.bind(null,376)),"v-9bf9313e":()=>t.e(52).then(t.bind(null,377)),"v-9aa3c6f6":()=>t.e(53).then(t.bind(null,378)),"v-d65ef770":()=>t.e(54).then(t.bind(null,379)),"v-54831b1a":()=>t.e(55).then(t.bind(null,380)),"v-43aa51a6":()=>t.e(56).then(t.bind(null,381)),"v-60c6683a":()=>t.e(57).then(t.bind(null,382)),"v-3aa2523b":()=>t.e(58).then(t.bind(null,383)),"v-b47686b4":()=>t.e(59).then(t.bind(null,384)),"v-372f1e78":()=>t.e(60).then(t.bind(null,385)),"v-66f71cf5":()=>t.e(61).then(t.bind(null,386)),"v-46b4dd50":()=>t.e(62).then(t.bind(null,387)),"v-5b5f2600":()=>t.e(63).then(t.bind(null,388)),"v-0853ad4b":()=>t.e(64).then(t.bind(null,389)),"v-1e8d5707":()=>t.e(65).then(t.bind(null,390)),"v-ac1d6b14":()=>t.e(66).then(t.bind(null,391)),"v-410564b4":()=>t.e(67).then(t.bind(null,392)),"v-27236994":()=>t.e(68).then(t.bind(null,393)),"v-5242031b":()=>t.e(70).then(t.bind(null,394)),"v-aab2f91e":()=>t.e(71).then(t.bind(null,395)),"v-a0b324d4":()=>t.e(72).then(t.bind(null,396)),"v-202a2426":()=>t.e(73).then(t.bind(null,397)),"v-1c9fad02":()=>t.e(74).then(t.bind(null,398)),"v-32cb5a16":()=>t.e(75).then(t.bind(null,399)),"v-20d2ed7d":()=>t.e(77).then(t.bind(null,400)),"v-52f9c0bc":()=>t.e(76).then(t.bind(null,401)),"v-36e58cd3":()=>t.e(78).then(t.bind(null,402)),"v-3e1c391d":()=>t.e(80).then(t.bind(null,403)),"v-9234eeec":()=>t.e(81).then(t.bind(null,404)),"v-12c5a2d2":()=>t.e(79).then(t.bind(null,405)),"v-aa36d4ca":()=>t.e(82).then(t.bind(null,406)),"v-c14a0baa":()=>t.e(69).then(t.bind(null,407)),"v-5b96df4b":()=>t.e(84).then(t.bind(null,408)),"v-7a055f2b":()=>t.e(83).then(t.bind(null,409)),"v-ce0f9c12":()=>t.e(86).then(t.bind(null,410)),"v-314cb88d":()=>t.e(87).then(t.bind(null,411)),"v-8fdd4394":()=>t.e(88).then(t.bind(null,412)),"v-184e2a44":()=>t.e(89).then(t.bind(null,413)),"v-2e8d2abf":()=>t.e(85).then(t.bind(null,414)),"v-d11e1d16":()=>t.e(90).then(t.bind(null,415)),"v-c8b112f4":()=>t.e(91).then(t.bind(null,416)),"v-1e3da8ea":()=>t.e(93).then(t.bind(null,417)),"v-8189a45c":()=>t.e(94).then(t.bind(null,418)),"v-5d79f192":()=>t.e(92).then(t.bind(null,419)),"v-711839c2":()=>t.e(95).then(t.bind(null,420)),"v-71e9447e":()=>t.e(96).then(t.bind(null,421)),"v-cc44b1e0":()=>t.e(97).then(t.bind(null,422)),"v-3616f8cb":()=>t.e(98).then(t.bind(null,423)),"v-265da4ce":()=>t.e(99).then(t.bind(null,424)),"v-34e1c1e0":()=>t.e(100).then(t.bind(null,425)),"v-0fc0ddc2":()=>t.e(102).then(t.bind(null,426)),"v-7db92364":()=>t.e(101).then(t.bind(null,427))};function Qo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Jo=/-(\w)/g,Yo=Qo(n=>n.replace(Jo,(n,e)=>e?e.toUpperCase():"")),Ko=/\B([A-Z])/g,Xo=Qo(n=>n.replace(Ko,"-$1").toLowerCase()),Zo=Qo(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Zo(Yo(e))):n(Zo(e))||n(Xo(e))}const es=Object.assign({},Go,Wo),ts=n=>es[n],rs=n=>Wo[n],is=n=>Go[n],as=n=>Gt.component(n);function os(n){return ns(rs,n)}function ss(n){return ns(is,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(as,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Gt.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(92),ms=t.n(ps),hs=t(93),vs=t.n(hs),gs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${vs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=_s(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],n,this.siteMeta,ys)},updateCanonicalLink(){fs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){_s(null,this.currentMetaTags),fs()}};function fs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function _s(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ys(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var xs=t(50),Ts={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(xs)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],o=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(i===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ks=t(23),ws=t.n(ks),Es={mounted(){ws.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Gt.component(n.name)||ws.a.start(),t()}),this.$router.afterEach(()=>{ws.a.done(),this.isSidebarOpen=!1})}};t(239),t(240);class Is{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Cs={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="点击复制",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Is).show({text:"复制成功",duration:300}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},As=(t(241),Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n}),zs=function(n){return"IMG"===n.tagName},Ss=function(n){return n&&1===n.nodeType},Ps=function(n){return".svg"===(n.currentSrc||n.src).substr(-4).toLowerCase()},Rs=function(n){try{return Array.isArray(n)?n.filter(zs):function(n){return NodeList.prototype.isPrototypeOf(n)}(n)?[].slice.call(n).filter(zs):Ss(n)?[n].filter(zs):"string"==typeof n?[].slice.call(document.querySelectorAll(n)).filter(zs):[]}catch(n){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},js=function(n){var e=document.createElement("div");return e.classList.add("medium-zoom-overlay"),e.style.background=n,e},qs=function(n){var e=n.getBoundingClientRect(),t=e.top,r=e.left,i=e.width,a=e.height,o=n.cloneNode(),s=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,l=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return o.removeAttribute("id"),o.style.position="absolute",o.style.top=t+s+"px",o.style.left=r+l+"px",o.style.width=i+"px",o.style.height=a+"px",o.style.transform="",o},Ls=function(n,e){var t=As({bubbles:!1,cancelable:!1,detail:void 0},e);if("function"==typeof window.CustomEvent)return new CustomEvent(n,t);var r=document.createEvent("CustomEvent");return r.initCustomEvent(n,t.bubbles,t.cancelable,t.detail),r};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var Os=function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=window.Promise||function(n){function e(){}n(e,e)},i=function(n){var e=n.target;e!==E?-1!==_.indexOf(e)&&v({target:e}):h()},a=function(){if(!x&&w.original){var n=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(T-n)>k.scrollOffset&&setTimeout(h,150)}},o=function(n){var e=n.key||n.keyCode;"Escape"!==e&&"Esc"!==e&&27!==e||h()},s=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n;if(n.background&&(E.style.background=n.background),n.container&&n.container instanceof Object&&(e.container=As({},k.container,n.container)),n.template){var t=Ss(n.template)?n.template:document.querySelector(n.template);e.template=t}return k=As({},k,e),_.forEach((function(n){n.dispatchEvent(Ls("medium-zoom:update",{detail:{zoom:I}}))})),I},l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(As({},k,e))},c=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];var r=e.reduce((function(n,e){return[].concat(n,Rs(e))}),[]);return r.filter((function(n){return-1===_.indexOf(n)})).forEach((function(n){_.push(n),n.classList.add("medium-zoom-image")})),y.forEach((function(n){var e=n.type,t=n.listener,i=n.options;r.forEach((function(n){n.addEventListener(e,t,i)}))})),I},d=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];w.zoomed&&h();var r=e.length>0?e.reduce((function(n,e){return[].concat(n,Rs(e))}),[]):_;return r.forEach((function(n){n.classList.remove("medium-zoom-image"),n.dispatchEvent(Ls("medium-zoom:detach",{detail:{zoom:I}}))})),_=_.filter((function(n){return-1===r.indexOf(n)})),I},u=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return _.forEach((function(r){r.addEventListener("medium-zoom:"+n,e,t)})),y.push({type:"medium-zoom:"+n,listener:e,options:t}),I},p=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return _.forEach((function(r){r.removeEventListener("medium-zoom:"+n,e,t)})),y=y.filter((function(t){return!(t.type==="medium-zoom:"+n&&t.listener.toString()===e.toString())})),I},m=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target,t=function(){var n={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},e=void 0,t=void 0;if(k.container)if(k.container instanceof Object)e=(n=As({},n,k.container)).width-n.left-n.right-2*k.margin,t=n.height-n.top-n.bottom-2*k.margin;else{var r=(Ss(k.container)?k.container:document.querySelector(k.container)).getBoundingClientRect(),i=r.width,a=r.height,o=r.left,s=r.top;n=As({},n,{width:i,height:a,left:o,top:s})}e=e||n.width-2*k.margin,t=t||n.height-2*k.margin;var l=w.zoomedHd||w.original,c=Ps(l)?e:l.naturalWidth||e,d=Ps(l)?t:l.naturalHeight||t,u=l.getBoundingClientRect(),p=u.top,m=u.left,h=u.width,v=u.height,g=Math.min(Math.max(h,c),e)/h,f=Math.min(Math.max(v,d),t)/v,b=Math.min(g,f),_="scale("+b+") translate3d("+((e-h)/2-m+k.margin+n.left)/b+"px, "+((t-v)/2-p+k.margin+n.top)/b+"px, 0)";w.zoomed.style.transform=_,w.zoomedHd&&(w.zoomedHd.style.transform=_)};return new r((function(n){if(e&&-1===_.indexOf(e))n(I);else{if(w.zoomed)n(I);else{if(e)w.original=e;else{if(!(_.length>0))return void n(I);var r=_;w.original=r[0]}if(w.original.dispatchEvent(Ls("medium-zoom:open",{detail:{zoom:I}})),T=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,x=!0,w.zoomed=qs(w.original),document.body.appendChild(E),k.template){var i=Ss(k.template)?k.template:document.querySelector(k.template);w.template=document.createElement("div"),w.template.appendChild(i.content.cloneNode(!0)),document.body.appendChild(w.template)}if(w.original.parentElement&&"PICTURE"===w.original.parentElement.tagName&&w.original.currentSrc&&(w.zoomed.src=w.original.currentSrc),document.body.appendChild(w.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),w.original.classList.add("medium-zoom-image--hidden"),w.zoomed.classList.add("medium-zoom-image--opened"),w.zoomed.addEventListener("click",h),w.zoomed.addEventListener("transitionend",(function e(){x=!1,w.zoomed.removeEventListener("transitionend",e),w.original.dispatchEvent(Ls("medium-zoom:opened",{detail:{zoom:I}})),n(I)})),w.original.getAttribute("data-zoom-src")){w.zoomedHd=w.zoomed.cloneNode(),w.zoomedHd.removeAttribute("srcset"),w.zoomedHd.removeAttribute("sizes"),w.zoomedHd.removeAttribute("loading"),w.zoomedHd.src=w.zoomed.getAttribute("data-zoom-src"),w.zoomedHd.onerror=function(){clearInterval(a),console.warn("Unable to reach the zoom image target "+w.zoomedHd.src),w.zoomedHd=null,t()};var a=setInterval((function(){w.zoomedHd.complete&&(clearInterval(a),w.zoomedHd.classList.add("medium-zoom-image--opened"),w.zoomedHd.addEventListener("click",h),document.body.appendChild(w.zoomedHd),t())}),10)}else if(w.original.hasAttribute("srcset")){w.zoomedHd=w.zoomed.cloneNode(),w.zoomedHd.removeAttribute("sizes"),w.zoomedHd.removeAttribute("loading");var o=w.zoomedHd.addEventListener("load",(function(){w.zoomedHd.removeEventListener("load",o),w.zoomedHd.classList.add("medium-zoom-image--opened"),w.zoomedHd.addEventListener("click",h),document.body.appendChild(w.zoomedHd),t()}))}else t()}}}))},h=function(){return new r((function(n){if(!x&&w.original){x=!0,document.body.classList.remove("medium-zoom--opened"),w.zoomed.style.transform="",w.zoomedHd&&(w.zoomedHd.style.transform=""),w.template&&(w.template.style.transition="opacity 150ms",w.template.style.opacity=0),w.original.dispatchEvent(Ls("medium-zoom:close",{detail:{zoom:I}})),w.zoomed.addEventListener("transitionend",(function e(){w.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(w.zoomed),w.zoomedHd&&document.body.removeChild(w.zoomedHd),document.body.removeChild(E),w.zoomed.classList.remove("medium-zoom-image--opened"),w.template&&document.body.removeChild(w.template),x=!1,w.zoomed.removeEventListener("transitionend",e),w.original.dispatchEvent(Ls("medium-zoom:closed",{detail:{zoom:I}})),w.original=null,w.zoomed=null,w.zoomedHd=null,w.template=null,n(I)}))}else n(I)}))},v=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target;return w.original?h():m({target:e})},g=function(){return k},f=function(){return _},b=function(){return w.original},_=[],y=[],x=!1,T=0,k=t,w={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?k=e:(e||"string"==typeof e)&&c(e),k=As({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},k);var E=js(k.background);document.addEventListener("click",i),document.addEventListener("keyup",o),document.addEventListener("scroll",a),window.addEventListener("resize",h);var I={open:m,close:h,toggle:v,update:s,clone:l,attach:c,detach:d,on:u,off:p,getOptions:g,getImages:f,getZoomedImage:b};return I},Ns=[gs,Ts,Es,Cs,{data:()=>({zoom:null}),mounted(){this.updateZoom()},updated(){this.updateZoom()},methods:{updateZoom(){setTimeout(()=>{this.zoom&&this.zoom.detach(),this.zoom=Os(".theme-default-content :not(a) > img",void 0)},1e3)}}}],Ds={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Gt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Bs=t(4),Ms=Object(Bs.a)(Ds,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(Ms,"mixins",Ns);const Us=[{name:"v-4c87a166",path:"/pages/7e99d5/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-4c87a166").then(t)}},{path:"/pages/7e99d5/index.html",redirect:"/pages/7e99d5/"},{path:"/00.知识整理/00.网站内容.html",redirect:"/pages/7e99d5/"},{name:"v-e9680046",path:"/pages/c5bdd8/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-e9680046").then(t)}},{path:"/pages/c5bdd8/index.html",redirect:"/pages/c5bdd8/"},{path:"/01.CPP语言/01.Cpp之旅/01.第1章 基础.html",redirect:"/pages/c5bdd8/"},{name:"v-7eb5beb0",path:"/pages/88a7db/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-7eb5beb0").then(t)}},{path:"/pages/88a7db/index.html",redirect:"/pages/88a7db/"},{path:"/01.CPP语言/01.Cpp之旅/02.第2章 用户自定义类型.html",redirect:"/pages/88a7db/"},{name:"v-3d949f6d",path:"/pages/61ffe6/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-3d949f6d").then(t)}},{path:"/pages/61ffe6/index.html",redirect:"/pages/61ffe6/"},{path:"/01.CPP语言/01.Cpp之旅/03.第3章 模块化.html",redirect:"/pages/61ffe6/"},{name:"v-4b19516d",path:"/pages/2dfe3d/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-4b19516d").then(t)}},{path:"/pages/2dfe3d/index.html",redirect:"/pages/2dfe3d/"},{path:"/01.CPP语言/01.Cpp之旅/04.第4章 错误处理.html",redirect:"/pages/2dfe3d/"},{name:"v-30f3c798",path:"/pages/1cb324/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-30f3c798").then(t)}},{path:"/pages/1cb324/index.html",redirect:"/pages/1cb324/"},{path:"/01.CPP语言/01.Cpp之旅/05.第5章 类.html",redirect:"/pages/1cb324/"},{name:"v-bf39c196",path:"/pages/fae683/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-bf39c196").then(t)}},{path:"/pages/fae683/index.html",redirect:"/pages/fae683/"},{path:"/01.CPP语言/01.Cpp之旅/07.第6章 基本操作.html",redirect:"/pages/fae683/"},{name:"v-3448b2e6",path:"/pages/2cdace/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-3448b2e6").then(t)}},{path:"/pages/2cdace/index.html",redirect:"/pages/2cdace/"},{path:"/01.CPP语言/01.Cpp之旅/08.第7章 模板.html",redirect:"/pages/2cdace/"},{name:"v-175c66c1",path:"/pages/619376/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-175c66c1").then(t)}},{path:"/pages/619376/index.html",redirect:"/pages/619376/"},{path:"/01.CPP语言/01.Cpp之旅/09.第8章 概念和泛型编程.html",redirect:"/pages/619376/"},{name:"v-07650679",path:"/pages/48ac45/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-07650679").then(t)}},{path:"/pages/48ac45/index.html",redirect:"/pages/48ac45/"},{path:"/01.CPP语言/01.Cpp之旅/10.第9章 标准库.html",redirect:"/pages/48ac45/"},{name:"v-dbcac10c",path:"/pages/279e62/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-dbcac10c").then(t)}},{path:"/pages/279e62/index.html",redirect:"/pages/279e62/"},{path:"/01.CPP语言/20.Cpp专栏/01.第2章 变量和基本类型.html",redirect:"/pages/279e62/"},{name:"v-4a2741a2",path:"/pages/518856/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-4a2741a2").then(t)}},{path:"/pages/518856/index.html",redirect:"/pages/518856/"},{path:"/01.CPP语言/20.Cpp专栏/02.Cpp11新标准.html",redirect:"/pages/518856/"},{name:"v-164b59d5",path:"/pages/2f7f31/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-164b59d5").then(t)}},{path:"/pages/2f7f31/index.html",redirect:"/pages/2f7f31/"},{path:"/01.CPP语言/20.Cpp专栏/03.探索C++14新特性：更强大、更高效的编程.html",redirect:"/pages/2f7f31/"},{name:"v-5c088d6b",path:"/pages/801755/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-5c088d6b").then(t)}},{path:"/pages/801755/index.html",redirect:"/pages/801755/"},{path:"/01.CPP语言/30.Effetcive_CPP/01.条款1-4 让自己习惯C++.html",redirect:"/pages/801755/"},{name:"v-afd5090a",path:"/pages/4fc2cb/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-afd5090a").then(t)}},{path:"/pages/4fc2cb/index.html",redirect:"/pages/4fc2cb/"},{path:"/01.CPP语言/30.Effetcive_CPP/02.条款5- 12 构造析构赋值运算.html",redirect:"/pages/4fc2cb/"},{name:"v-2f55ed6a",path:"/pages/ec62b4/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-2f55ed6a").then(t)}},{path:"/pages/ec62b4/index.html",redirect:"/pages/ec62b4/"},{path:"/01.CPP语言/30.Effetcive_CPP/03.条款26-31 实现.html",redirect:"/pages/ec62b4/"},{name:"v-0ae8e482",path:"/pages/b4a7fb/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-0ae8e482").then(t)}},{path:"/pages/b4a7fb/index.html",redirect:"/pages/b4a7fb/"},{path:"/01.CPP语言/30.Effetcive_CPP/04.条款32-40 继承与面向对象设计.html",redirect:"/pages/b4a7fb/"},{name:"v-4d99aed0",path:"/pages/799b40/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-4d99aed0").then(t)}},{path:"/pages/799b40/index.html",redirect:"/pages/799b40/"},{path:"/01.CPP语言/30.Effetcive_CPP/05.条款41-48 模板和泛型编程.html",redirect:"/pages/799b40/"},{name:"v-53af30f2",path:"/pages/6b2468/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-53af30f2").then(t)}},{path:"/pages/6b2468/index.html",redirect:"/pages/6b2468/"},{path:"/01.CPP语言/40.muduo网络库/01.第4章 C++多线程系统编程精要.html",redirect:"/pages/6b2468/"},{name:"v-55759766",path:"/pages/5f8c9f/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-55759766").then(t)}},{path:"/pages/5f8c9f/index.html",redirect:"/pages/5f8c9f/"},{path:"/01.CPP语言/50.Unix环境高级编程/11.第11章 线程同步.html",redirect:"/pages/5f8c9f/"},{name:"v-f0cc61b6",path:"/pages/3f1d21/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-f0cc61b6").then(t)}},{path:"/pages/3f1d21/index.html",redirect:"/pages/3f1d21/"},{path:"/01.CPP语言/60.Cpp提高编程/01.函数模板.html",redirect:"/pages/3f1d21/"},{name:"v-13ee8c1e",path:"/pages/db4e3c/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-13ee8c1e").then(t)}},{path:"/pages/db4e3c/index.html",redirect:"/pages/db4e3c/"},{path:"/01.CPP语言/60.Cpp提高编程/02.类模板.html",redirect:"/pages/db4e3c/"},{name:"v-65a3fd54",path:"/pages/a7c324/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-65a3fd54").then(t)}},{path:"/pages/a7c324/index.html",redirect:"/pages/a7c324/"},{path:"/01.CPP语言/60.Cpp提高编程/03.初识STL.html",redirect:"/pages/a7c324/"},{name:"v-966b0b0c",path:"/pages/4906d0/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-966b0b0c").then(t)}},{path:"/pages/4906d0/index.html",redirect:"/pages/4906d0/"},{path:"/01.CPP语言/60.Cpp提高编程/04.string 容器.html",redirect:"/pages/4906d0/"},{name:"v-7784b32c",path:"/pages/2a1016/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-7784b32c").then(t)}},{path:"/pages/2a1016/index.html",redirect:"/pages/2a1016/"},{path:"/01.CPP语言/60.Cpp提高编程/06.deque 容器.html",redirect:"/pages/2a1016/"},{name:"v-2a6914c8",path:"/pages/13697a/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-2a6914c8").then(t)}},{path:"/pages/13697a/index.html",redirect:"/pages/13697a/"},{path:"/01.CPP语言/60.Cpp提高编程/05.vector 容器.html",redirect:"/pages/13697a/"},{name:"v-1c42788c",path:"/pages/29568d/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-1c42788c").then(t)}},{path:"/pages/29568d/index.html",redirect:"/pages/29568d/"},{path:"/01.CPP语言/60.Cpp提高编程/07.stack 容器.html",redirect:"/pages/29568d/"},{name:"v-be55bf68",path:"/pages/95225a/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-be55bf68").then(t)}},{path:"/pages/95225a/index.html",redirect:"/pages/95225a/"},{path:"/01.CPP语言/60.Cpp提高编程/08.queue 容器.html",redirect:"/pages/95225a/"},{name:"v-34eff995",path:"/pages/7b1cb2/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-34eff995").then(t)}},{path:"/pages/7b1cb2/index.html",redirect:"/pages/7b1cb2/"},{path:"/02.计算机基础/01.网络/01.网络核心知识总结.html",redirect:"/pages/7b1cb2/"},{name:"v-a3b400f8",path:"/pages/0728af/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-a3b400f8").then(t)}},{path:"/pages/0728af/index.html",redirect:"/pages/0728af/"},{path:"/02.计算机基础/01.网络/02.TCP 三次握手和四次挥手.html",redirect:"/pages/0728af/"},{name:"v-53d48847",path:"/pages/8d5654/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-53d48847").then(t)}},{path:"/pages/8d5654/index.html",redirect:"/pages/8d5654/"},{path:"/02.计算机基础/01.网络/03.TCP 传输可靠性问题.html",redirect:"/pages/8d5654/"},{name:"v-33f65e3e",path:"/pages/11e44b/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-33f65e3e").then(t)}},{path:"/pages/11e44b/index.html",redirect:"/pages/11e44b/"},{path:"/02.计算机基础/01.网络/04.常见状态码总结.html",redirect:"/pages/11e44b/"},{name:"v-789efd9e",path:"/pages/92d82c/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-789efd9e").then(t)}},{path:"/pages/92d82c/index.html",redirect:"/pages/92d82c/"},{path:"/02.计算机基础/01.网络/10.《计算机网络》谢希仁.html",redirect:"/pages/92d82c/"},{name:"v-75f7300c",path:"/pages/6048a8/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-75f7300c").then(t)}},{path:"/pages/6048a8/index.html",redirect:"/pages/6048a8/"},{path:"/02.计算机基础/02.操作系统/01.硬件结构.html",redirect:"/pages/6048a8/"},{name:"v-7c46b244",path:"/pages/3b34ba/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-7c46b244").then(t)}},{path:"/pages/3b34ba/index.html",redirect:"/pages/3b34ba/"},{path:"/02.计算机基础/03.数据结构/01.数据结构基础小结.html",redirect:"/pages/3b34ba/"},{name:"v-39fe2a71",path:"/pages/2dcfa1/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-39fe2a71").then(t)}},{path:"/pages/2dcfa1/index.html",redirect:"/pages/2dcfa1/"},{path:"/02.计算机基础/04.算法/1. 两数之和.html",redirect:"/pages/2dcfa1/"},{name:"v-1d0967af",path:"/pages/3ec756/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-1d0967af").then(t)}},{path:"/pages/3ec756/index.html",redirect:"/pages/3ec756/"},{path:"/02.计算机基础/04.算法/101. 对称二叉树.html",redirect:"/pages/3ec756/"},{name:"v-10241104",path:"/pages/cfaacb/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-10241104").then(t)}},{path:"/pages/cfaacb/index.html",redirect:"/pages/cfaacb/"},{path:"/02.计算机基础/04.算法/104. 二叉树的最大深度.html",redirect:"/pages/cfaacb/"},{name:"v-4624b883",path:"/pages/5b2b9b/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-4624b883").then(t)}},{path:"/pages/5b2b9b/index.html",redirect:"/pages/5b2b9b/"},{path:"/02.计算机基础/04.算法/120. LCR寻找文件副本.html",redirect:"/pages/5b2b9b/"},{name:"v-1ad60d6d",path:"/pages/4e735a/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-1ad60d6d").then(t)}},{path:"/pages/4e735a/index.html",redirect:"/pages/4e735a/"},{path:"/02.计算机基础/04.算法/121. 买卖股票的最佳时机.html",redirect:"/pages/4e735a/"},{name:"v-54a29711",path:"/pages/61a107/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-54a29711").then(t)}},{path:"/pages/61a107/index.html",redirect:"/pages/61a107/"},{path:"/02.计算机基础/04.算法/125. LCR图书整理 II.html",redirect:"/pages/61a107/"},{name:"v-4eb718aa",path:"/pages/d2368e/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-4eb718aa").then(t)}},{path:"/pages/d2368e/index.html",redirect:"/pages/d2368e/"},{path:"/02.计算机基础/04.算法/136. 只出现一次的数字.html",redirect:"/pages/d2368e/"},{name:"v-8c26678c",path:"/pages/d52abe/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-8c26678c").then(t)}},{path:"/pages/d52abe/index.html",redirect:"/pages/d52abe/"},{path:"/02.计算机基础/04.算法/14. 最长公共前缀.html",redirect:"/pages/d52abe/"},{name:"v-c8298182",path:"/pages/4806d9/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-c8298182").then(t)}},{path:"/pages/4806d9/index.html",redirect:"/pages/4806d9/"},{path:"/02.计算机基础/04.算法/140. LCR 训练计划 II.html",redirect:"/pages/4806d9/"},{name:"v-f015cfe8",path:"/pages/6ac024/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-f015cfe8").then(t)}},{path:"/pages/6ac024/index.html",redirect:"/pages/6ac024/"},{path:"/02.计算机基础/04.算法/141. 环形链表.html",redirect:"/pages/6ac024/"},{name:"v-1b717988",path:"/pages/7c062a/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-1b717988").then(t)}},{path:"/pages/7c062a/index.html",redirect:"/pages/7c062a/"},{path:"/02.计算机基础/04.算法/206. 反转链表.html",redirect:"/pages/7c062a/"},{name:"v-58b77b9c",path:"/pages/28ad9f/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-58b77b9c").then(t)}},{path:"/pages/28ad9f/index.html",redirect:"/pages/28ad9f/"},{path:"/02.计算机基础/04.算法/226. 翻转二叉树.html",redirect:"/pages/28ad9f/"},{name:"v-9bf9313e",path:"/pages/29ee33/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-9bf9313e").then(t)}},{path:"/pages/29ee33/index.html",redirect:"/pages/29ee33/"},{path:"/02.计算机基础/04.算法/234. 回文链表.html",redirect:"/pages/29ee33/"},{name:"v-9aa3c6f6",path:"/pages/4c0819/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-9aa3c6f6").then(t)}},{path:"/pages/4c0819/index.html",redirect:"/pages/4c0819/"},{path:"/02.计算机基础/04.算法/26. 删除有序数组中的重复项.html",redirect:"/pages/4c0819/"},{name:"v-d65ef770",path:"/pages/e85eda/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-d65ef770").then(t)}},{path:"/pages/e85eda/index.html",redirect:"/pages/e85eda/"},{path:"/02.计算机基础/04.算法/283. 移动零.html",redirect:"/pages/e85eda/"},{name:"v-54831b1a",path:"/pages/5d801b/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-54831b1a").then(t)}},{path:"/pages/5d801b/index.html",redirect:"/pages/5d801b/"},{path:"/02.计算机基础/04.算法/409. 最长回文串.html",redirect:"/pages/5d801b/"},{name:"v-43aa51a6",path:"/pages/55ec77/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-43aa51a6").then(t)}},{path:"/pages/55ec77/index.html",redirect:"/pages/55ec77/"},{path:"/02.计算机基础/04.算法/461. 汉明距离.html",redirect:"/pages/55ec77/"},{name:"v-60c6683a",path:"/pages/edd6da/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-60c6683a").then(t)}},{path:"/pages/edd6da/index.html",redirect:"/pages/edd6da/"},{path:"/02.计算机基础/04.算法/53. 最大子数组和.html",redirect:"/pages/edd6da/"},{name:"v-3aa2523b",path:"/pages/299c79/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-3aa2523b").then(t)}},{path:"/pages/299c79/index.html",redirect:"/pages/299c79/"},{path:"/02.计算机基础/04.算法/538. 把二叉搜索树转换为累加树.html",redirect:"/pages/299c79/"},{name:"v-b47686b4",path:"/pages/6354db/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-b47686b4").then(t)}},{path:"/pages/6354db/index.html",redirect:"/pages/6354db/"},{path:"/02.计算机基础/04.算法/581. 最短无序连续子数组.html",redirect:"/pages/6354db/"},{name:"v-372f1e78",path:"/pages/2998a0/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-372f1e78").then(t)}},{path:"/pages/2998a0/index.html",redirect:"/pages/2998a0/"},{path:"/02.计算机基础/04.算法/617. 合并二叉树.html",redirect:"/pages/2998a0/"},{name:"v-66f71cf5",path:"/pages/480e04/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-66f71cf5").then(t)}},{path:"/pages/480e04/index.html",redirect:"/pages/480e04/"},{path:"/02.计算机基础/04.算法/69. x 的平方根.html",redirect:"/pages/480e04/"},{name:"v-46b4dd50",path:"/pages/6b01fc/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-46b4dd50").then(t)}},{path:"/pages/6b01fc/index.html",redirect:"/pages/6b01fc/"},{path:"/02.计算机基础/04.算法/70. 爬楼梯.html",redirect:"/pages/6b01fc/"},{name:"v-5b5f2600",path:"/pages/173765/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-5b5f2600").then(t)}},{path:"/pages/173765/index.html",redirect:"/pages/173765/"},{path:"/02.计算机基础/04.算法/704. 二分查找.html",redirect:"/pages/173765/"},{name:"v-0853ad4b",path:"/pages/d178f3/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-0853ad4b").then(t)}},{path:"/pages/d178f3/index.html",redirect:"/pages/d178f3/"},{path:"/02.计算机基础/04.算法/876. 链表的中间结点.html",redirect:"/pages/d178f3/"},{name:"v-1e8d5707",path:"/pages/67ccea/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-1e8d5707").then(t)}},{path:"/pages/67ccea/index.html",redirect:"/pages/67ccea/"},{path:"/02.计算机基础/04.算法/977. 有序数组的平方.html",redirect:"/pages/67ccea/"},{name:"v-ac1d6b14",path:"/pages/33a1c0/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-ac1d6b14").then(t)}},{path:"/pages/33a1c0/index.html",redirect:"/pages/33a1c0/"},{path:"/02.计算机基础/04.算法/997. 找到小镇的法官.html",redirect:"/pages/33a1c0/"},{name:"v-410564b4",path:"/pages/412fe7/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-410564b4").then(t)}},{path:"/pages/412fe7/index.html",redirect:"/pages/412fe7/"},{path:"/02.计算机基础/05.Linux/01.Linux基础小结.html",redirect:"/pages/412fe7/"},{name:"v-27236994",path:"/pages/efa3f2/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-27236994").then(t)}},{path:"/pages/efa3f2/index.html",redirect:"/pages/efa3f2/"},{path:"/03.数据库/01.基础/01.数据库基础知识小结.html",redirect:"/pages/efa3f2/"},{name:"v-5242031b",path:"/pages/126a5a/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-5242031b").then(t)}},{path:"/pages/126a5a/index.html",redirect:"/pages/126a5a/"},{path:"/03.数据库/01.基础/03.字符集详解.html",redirect:"/pages/126a5a/"},{name:"v-aab2f91e",path:"/pages/ed0fa0/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-aab2f91e").then(t)}},{path:"/pages/ed0fa0/index.html",redirect:"/pages/ed0fa0/"},{path:"/03.数据库/01.基础/04.SQL/01.SQL语法基础小结.html",redirect:"/pages/ed0fa0/"},{name:"v-a0b324d4",path:"/pages/def622/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-a0b324d4").then(t)}},{path:"/pages/def622/index.html",redirect:"/pages/def622/"},{path:"/03.数据库/01.基础/04.SQL/02.SQL必知必会题解.html",redirect:"/pages/def622/"},{name:"v-202a2426",path:"/pages/ccc445/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-202a2426").then(t)}},{path:"/pages/ccc445/index.html",redirect:"/pages/ccc445/"},{path:"/03.数据库/02.Mysql/01.MySQL基础小结.html",redirect:"/pages/ccc445/"},{name:"v-1c9fad02",path:"/pages/0b5aee/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-1c9fad02").then(t)}},{path:"/pages/0b5aee/index.html",redirect:"/pages/0b5aee/"},{path:"/03.数据库/02.Mysql/02.索引篇.html",redirect:"/pages/0b5aee/"},{name:"v-32cb5a16",path:"/pages/db8ded/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-32cb5a16").then(t)}},{path:"/pages/db8ded/index.html",redirect:"/pages/db8ded/"},{path:"/03.数据库/02.Mysql/10.思维导图.html",redirect:"/pages/db8ded/"},{name:"v-20d2ed7d",path:"/pages/163cf9/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-20d2ed7d").then(t)}},{path:"/pages/163cf9/index.html",redirect:"/pages/163cf9/"},{path:"/03.数据库/03.Redis/02.Redis小记.html",redirect:"/pages/163cf9/"},{name:"v-52f9c0bc",path:"/pages/54616e/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-52f9c0bc").then(t)}},{path:"/pages/54616e/index.html",redirect:"/pages/54616e/"},{path:"/03.数据库/03.Redis/01.Redis总结.html",redirect:"/pages/54616e/"},{name:"v-36e58cd3",path:"/pages/793d0a/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-36e58cd3").then(t)}},{path:"/pages/793d0a/index.html",redirect:"/pages/793d0a/"},{path:"/05.系统设计/03.权限校验/01.JWT基础小结.html",redirect:"/pages/793d0a/"},{name:"v-3e1c391d",path:"/pages/0863fc/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-3e1c391d").then(t)}},{path:"/pages/0863fc/index.html",redirect:"/pages/0863fc/"},{path:"/05.系统设计/04.设计模式/02.设计模式 13 问.html",redirect:"/pages/0863fc/"},{name:"v-9234eeec",path:"/pages/71f6ae/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-9234eeec").then(t)}},{path:"/pages/71f6ae/index.html",redirect:"/pages/71f6ae/"},{path:"/07.开发日常/02.Git知识总结.html",redirect:"/pages/71f6ae/"},{name:"v-12c5a2d2",path:"/pages/73ddd7/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-12c5a2d2").then(t)}},{path:"/pages/73ddd7/index.html",redirect:"/pages/73ddd7/"},{path:"/05.系统设计/04.设计模式/01.常见设计模式总结.html",redirect:"/pages/73ddd7/"},{name:"v-aa36d4ca",path:"/pages/777b8a/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-aa36d4ca").then(t)}},{path:"/pages/777b8a/index.html",redirect:"/pages/777b8a/"},{path:"/07.开发日常/03.nvm使用小结.html",redirect:"/pages/777b8a/"},{name:"v-c14a0baa",path:"/pages/54fc03/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-c14a0baa").then(t)}},{path:"/pages/54fc03/index.html",redirect:"/pages/54fc03/"},{path:"/03.数据库/01.基础/02.NoSQL基础知识小结.html",redirect:"/pages/54fc03/"},{name:"v-5b96df4b",path:"/pages/ee770e/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-5b96df4b").then(t)}},{path:"/pages/ee770e/index.html",redirect:"/pages/ee770e/"},{path:"/07.开发日常/05.虚拟机固定ip地址.html",redirect:"/pages/ee770e/"},{name:"v-7a055f2b",path:"/pages/e472d1/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-7a055f2b").then(t)}},{path:"/pages/e472d1/index.html",redirect:"/pages/e472d1/"},{path:"/07.开发日常/04.随笔（持续更新）.html",redirect:"/pages/e472d1/"},{name:"v-ce0f9c12",path:"/pages/0d525d/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-ce0f9c12").then(t)}},{path:"/pages/0d525d/index.html",redirect:"/pages/0d525d/"},{path:"/07.开发日常/07.KylinV10 将项目上传至 Github.html",redirect:"/pages/0d525d/"},{name:"v-314cb88d",path:"/pages/ef40f0/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-314cb88d").then(t)}},{path:"/pages/ef40f0/index.html",redirect:"/pages/ef40f0/"},{path:"/07.开发日常/08.KylinV10 安装 MySQL 教程（可防踩雷）.html",redirect:"/pages/ef40f0/"},{name:"v-8fdd4394",path:"/pages/f8640c/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-8fdd4394").then(t)}},{path:"/pages/f8640c/index.html",redirect:"/pages/f8640c/"},{path:"/07.开发日常/09.个人博客代码推送教程.html",redirect:"/pages/f8640c/"},{name:"v-184e2a44",path:"/pages/67c5c8/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-184e2a44").then(t)}},{path:"/pages/67c5c8/index.html",redirect:"/pages/67c5c8/"},{path:"/08.项目笔记/10.存储介质消除工具/01.项目笔记.html",redirect:"/pages/67c5c8/"},{name:"v-2e8d2abf",path:"/pages/411aa4/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-2e8d2abf").then(t)}},{path:"/pages/411aa4/index.html",redirect:"/pages/411aa4/"},{path:"/07.开发日常/06.VScode 插件 CodeGeex 使用教程.html",redirect:"/pages/411aa4/"},{name:"v-d11e1d16",path:"/pages/08dfe9/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-d11e1d16").then(t)}},{path:"/pages/08dfe9/index.html",redirect:"/pages/08dfe9/"},{path:"/08.项目笔记/30.ip_file_hook/01.项目解读.html",redirect:"/pages/08dfe9/"},{name:"v-c8b112f4",path:"/pages/00e0b6/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-c8b112f4").then(t)}},{path:"/pages/00e0b6/index.html",redirect:"/pages/00e0b6/"},{path:"/08.项目笔记/30.ip_file_hook/02.项目bug汇总.html",redirect:"/pages/00e0b6/"},{name:"v-1e3da8ea",path:"/pages/51542d/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-1e3da8ea").then(t)}},{path:"/pages/51542d/index.html",redirect:"/pages/51542d/"},{path:"/09.前端学习/03.js学习.html",redirect:"/pages/51542d/"},{name:"v-8189a45c",path:"/pages/803f9d/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-8189a45c").then(t)}},{path:"/pages/803f9d/index.html",redirect:"/pages/803f9d/"},{path:"/09.前端学习/06.Vue3入门.html",redirect:"/pages/803f9d/"},{name:"v-5d79f192",path:"/pages/99897f/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-5d79f192").then(t)}},{path:"/pages/99897f/index.html",redirect:"/pages/99897f/"},{path:"/09.前端学习/01.HTML与CSS.html",redirect:"/pages/99897f/"},{name:"v-711839c2",path:"/pages/ca4cfb/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-711839c2").then(t)}},{path:"/pages/ca4cfb/index.html",redirect:"/pages/ca4cfb/"},{path:"/09.前端学习/08.Vue3进阶.html",redirect:"/pages/ca4cfb/"},{name:"v-71e9447e",path:"/pages/50e8d3/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-71e9447e").then(t)}},{path:"/pages/50e8d3/index.html",redirect:"/pages/50e8d3/"},{path:"/09.前端学习/10.黑马Vue3.html",redirect:"/pages/50e8d3/"},{name:"v-cc44b1e0",path:"/pages/d69946/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-cc44b1e0").then(t)}},{path:"/pages/d69946/index.html",redirect:"/pages/d69946/"},{path:"/15.面经/01.虎牙C++技术面经.html",redirect:"/pages/d69946/"},{name:"v-3616f8cb",path:"/pages/29251d/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-3616f8cb").then(t)}},{path:"/pages/29251d/index.html",redirect:"/pages/29251d/"},{path:"/15.面经/02.金山一面复习.html",redirect:"/pages/29251d/"},{name:"v-265da4ce",path:"/pages/fa256e/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-265da4ce").then(t)}},{path:"/pages/fa256e/index.html",redirect:"/pages/fa256e/"},{path:"/20.碎片文章/01.博客搭建.html",redirect:"/pages/fa256e/"},{name:"v-34e1c1e0",path:"/pages/335531/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-34e1c1e0").then(t)}},{path:"/pages/335531/index.html",redirect:"/pages/335531/"},{path:"/20.碎片文章/02.网站收藏箱.html",redirect:"/pages/335531/"},{name:"v-0fc0ddc2",path:"/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-0fc0ddc2").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-7db92364",path:"/pages/94109b/",component:Ms,beforeEnter:(n,e,t)=>{ds("Layout","v-7db92364").then(t)}},{path:"/pages/94109b/index.html",redirect:"/pages/94109b/"},{path:"/20.碎片文章/03.断墨寻径摘录.html",redirect:"/pages/94109b/"},{path:"*",component:Ms}],Vs={title:"ShuangChenYue",description:"满招损，谦受益",base:"/",headTags:[["link",{rel:"icon",href:"https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/logo/白云.38zbldnhh180.jpg"}],["meta",{name:"keywords",content:"专注于Cpp语言的旅行者"}],["meta",{name:"description",content:"Cpp旅行者"}]],pages:[{title:"网站内容",frontmatter:{title:"网站内容",date:"2023-05-10T04:38:02.000Z",permalink:"/pages/7e99d5/"},regularPath:"/00.%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/00.%E7%BD%91%E7%AB%99%E5%86%85%E5%AE%B9.html",relativePath:"00.知识整理/00.网站内容.md",key:"v-4c87a166",path:"/pages/7e99d5/",headers:[{level:2,title:"一、网站内容",slug:"一、网站内容",normalizedTitle:"一、网站内容",charIndex:2}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.015,time:899.9999999999999,words:3},headersStr:"一、网站内容",content:"# 一、网站内容\n\n这是静态博客的模板内容，自己进行更改",normalizedContent:"# 一、网站内容\n\n这是静态博客的模板内容，自己进行更改",charsets:{cjk:!0}},{title:"第1章 基础",frontmatter:{title:"第1章 基础",date:"2023-11-24T15:54:40.000Z",permalink:"/pages/c5bdd8/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/01.%E7%AC%AC1%E7%AB%A0%20%E5%9F%BA%E7%A1%80.html",relativePath:"01.CPP语言/01.Cpp之旅/01.第1章 基础.md",key:"v-e9680046",path:"/pages/c5bdd8/",headers:[{level:2,title:"1.1 程序",slug:"_1-1-程序",normalizedTitle:"1.1 程序",charIndex:32},{level:2,title:"1.2 新东西",slug:"_1-2-新东西",normalizedTitle:"1.2 新东西",charIndex:256},{level:2,title:"1.3 函数",slug:"_1-3-函数",normalizedTitle:"1.3 函数",charIndex:555},{level:2,title:"1.4 类型、变量、运算",slug:"_1-4-类型、变量、运算",normalizedTitle:"1.4 类型、变量、运算",charIndex:771},{level:3,title:"1.4.1 运算",slug:"_1-4-1-运算",normalizedTitle:"1.4.1 运算",charIndex:1017},{level:3,title:"1.4.2 初始化",slug:"_1-4-2-初始化",normalizedTitle:"1.4.2 初始化",charIndex:1134},{level:2,title:"1.5 作用域和生命周期",slug:"_1-5-作用域和生命周期",normalizedTitle:"1.5 作用域和生命周期",charIndex:1774},{level:2,title:"1.6 常量",slug:"_1-6-常量",normalizedTitle:"1.6 常量",charIndex:2448},{level:2,title:"1.7 指针、数组、引用",slug:"_1-7-指针、数组、引用",normalizedTitle:"1.7 指针、数组、引用",charIndex:3306},{level:3,title:"1.7.1 空指针",slug:"_1-7-1-空指针",normalizedTitle:"1.7.1 空指针",charIndex:3689},{level:2,title:"1.8 建议",slug:"_1-8-建议",normalizedTitle:"1.8 建议",charIndex:4329}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.13,time:127800,words:426},headersStr:"1.1 程序 1.2 新东西 1.3 函数 1.4 类型、变量、运算 1.4.1 运算 1.4.2 初始化 1.5 作用域和生命周期 1.6 常量 1.7 指针、数组、引用 1.7.1 空指针 1.8 建议",content:'# Cpp之旅（学习笔记）第1章\n\n\n# 第1章 基础\n\n\n# 1.1 程序\n\nCpp是一门编译型语言。源代码必须交由编译器处理生成可执行文件，然后由链接器组装成可执行程序。\n\n一个可执行文件通常是为一个特定的硬件与操作系统组合而制定的，换句话说，它在安卓设备与Windows个人电脑之间是不可移植的，因此，可移植性指的是源代码的可移植性，即源代码可以在多种系统中编译成功，然后运行。\n\n最小的Cpp程序：\n\nint main(){}\n\n\n1\n\n\n定义一个main函数，不接受任何参数，也不做任何事情。\n\n\n# 1.2 新东西\n\n//旧版本\n#include <iostream>\nint main() {\n\tstd::cout << "Hello, World!\\n";\n}\n\n\n1\n2\n3\n4\n5\n\n\n//Cpp20版本\nimport std;\nint main() {\n    std::cout << "Hello, World!\\n";\n}\n\n\n1\n2\n3\n4\n5\n\n\nimport std;指示编译器去声明标准库变量的存在。如果没有这个声明，std::cout << "Hello, World!\\n";将没有意义。但是指令import将所有标准库放进一个单独的std模块还没有成为标准。\n\n\n# 1.3 函数\n\ndouble get(const vector<double>& vec, int index);\n//函数类型是：\ndouble(const vector<double>&,int)\n\n\n1\n2\n3\n\n\n对于成员函数来说，类的名称也是函数类型的一部分：\n\nchar& String::operator[](int index);\n//函数类型是：\nchar& String::(int)\n\n\n1\n2\n3\n\n\n\n# 1.4 类型、变量、运算\n\n * 前缀0b表示二进制整数字面量，如：0b10101010\n * 前缀0x表示十六进制整数字面量，如：0xBAD12CE3\n * 前缀0表示八进制字面量，如：0334\n\n可以引入单引号（’）作为数字分隔符提升长字面量的可读性\n\n> 例如：Π的值大约是：3.14159 ‘ 26535 ’ 89793 ‘ 23846 ’ 26433 ‘ 83279 ’ 50288\n> \n> 用十六进制表示就是：0x3.243F ’ 6A88 ‘ 85A3 ’ 08D3\n\n\n# 1.4.1 运算\n\n * 部分操作符的计算顺序是从左向右的：\n   \n   x.y、x->y、x(y)、x[y]、x<<y、x>>y、x&&y、x||y\n\n * 但赋值符号的计算顺序是从右往左的：\n   \n   x += y\n\n\n# 1.4.2 初始化\n\n * 使用=或者{}初始化\n\ndouble d1 = 2.3;\ndouble d2 {2.3};//等价于double d2 = {2.3}\n\n\n1\n2\n\n * 使用=的形式是C语言传统的方式，如果拿不定主意，就是用更通用的{}列表形式。可以避免隐式类型转换导致的信息丢失\n\nint i1 = 7.8;//i1变成了7（你可能感到意外）\nint i2 {7.8};//错误：floating-point to integer conversion\n\n\n1\n2\n\n * 当使用=而不是{}的时候，会进行从double到int及从int到char这样的窄化类型转换。\n\n如果变量的类型可以从初始化符号中推导出来，就无需显示指定类型\n\nauto b = true; \t//bool类型\nauto ch = \'x\';\t//char类型\nauto i = 123;\t//int类型\nauto d = 1.2;\t//double类型\n...\n\n\n1\n2\n3\n4\n5\n\n\n使用auto声明变量时，作者倾向于使用=符号，因为没有类型转换的风险。当然，偏好使用{}也无伤大雅。\n\n当没有明显的需要显示地指定类型时，一般使用 auto 。\n\n理由如下：\n\n 1. 该定义的作用域较大，我们希望代码的读者清楚地知道其类型。\n 2. 初始化表达式的类型（对读者来说）不是显而易见的。\n 3. 我们希望明确规定某个变量的范围和精度（如：希望使用double而非float）。\n\n\n# 1.5 作用域和生命周期\n\n * **局部作用域：**在函数或匿名函数中定义的名字叫局部名字，作用域从声明它的地方开始，直到声明语句所在的块结尾。语句块的边界由一对{}决定。函数参数的名字也属于局部名字。\n * **类作用域：**定义在类的内部，不在任何函数、匿名函数、enum class中，可被叫做成员名字（或类成员名字）。作用域从它括起声明的左花括号 { 开始，到对应的右花括号 } 结束。\n * 命名空间作用域：在命名空间内部，并且不再任何函数、匿名函数、enum class中，则把这个名字叫做命名空间成员名字。作用域从声明它的地方开始，到命名空间结束为止。\n\n某些对象也可以没有名字，比如：临时对象或者用new创建的对象：\n\nvector<int> vec;\t\t\t\t\t//vec是全局名字（全局整数动态数组）\nvoid fct(int arg) {\t\t\t\t\t//fct是全局名字（全局函数）arg是局部名字（局部整数参数）\n    string motto {"Who dares wins"};//motto是局部名字\n    auto p = new Record{"Hume"};\t//p指向无名Record对象（由new创建）\n    //...\n}\nstruct Record {\n  \tstring name;\t\t\t\t\t//name是Record的成员名字（字符串成员）\n    //...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n一个new创建的对象可以持续“生存”，知道用delete将其销毁。\n\n\n# 1.6 常量\n\nCpp支持两种不变性：\n\n * const：“我承诺不修改这个值”，主要用来说明接口，可以用指针或者引用的方式传入函数参数而不用担心被改变。编译器负责强制执行const承诺。const声明的值可以在运行时被计算。\n * constexpr：“请在编译时计算出它的值”，主要用于声明常量，作用是把数据置于只读内存区域（更小概率被破坏），以及提高性能。constexpr的值必须由编译器计算。\n\n例如：\n\nconstexpr int dmv = 17;\t\t\t\t//dmv是一个命名常量\nint var = 17;\t\t\t\t\t\t//var不是常量\nconst double sqv = sqrt(var);\t\t//sqv是一个命名常量，可能在运行时计算\ndouble sum(const vector<double>&);\t//sum不会修改它的参数\nvector<double> v {1.2, 3.4, 4.5};\t//v不是常量\nconst double s1 = sum(v);\t\t\t//可行：sum(v)在运行时计算\nconstexpr double s2 = sum(v);\t\t//错误：sum(v)不是一个常量表达式\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为了使函数可在常量表达式中使用，这个函数必须被定义为constexpr 或consteval，这样才能在编译期表达式中被计算。\n\n例如：\n\nconstexpr double square(double x){return x*x};\nconstexpr double max1 = 1.4*square(17);\t//可行：1.4*square(17)是常量表达式\nconstexpr double max2 = 1.4*square(var);//错误：var不是常量，所以square(var)不是常量\nconst double max3 = 1.4*square(var);\t//可行：允许在运行时计算\n\n\n1\n2\n3\n4\n\n\n\n# 1.7 指针、数组、引用\n\n * 数组：同类型元素的连续分配序列。\n * 指针：可存放指定类型的对象的地址。\n\n在声明中，[ ]意味着对应类型的数组，*意味着指向对应类型的指针。\n\nchar v[6];\t\t//6个字符组成的数组\nchar *p = &v[3];//p指向v的第4个元素\nchar x = *p;\t//*p代表p指向的对象\n\n\n1\n2\n3\n\n * 前置一元操作符*表示取内容，前置一元操作符&表示取地址，后置一元操作符&表示指向前者的引用。\n * 引用在初始化后就不能再指向其他的对象了。\n * 当用于什么语句时，操作符&、*、[ ]被称为声明操作符。\n\nT* p\t//T*：p是一个指向T的指针\nT& r\t//T&：r是一个指向T的引用\nT f(A)  //T f(A)：f是一个函数，接受A类型的参数，返回T类型的结果\n\n\n1\n2\n3\n\n\n\n# 1.7.1 空指针\n\n当确实没有对象可指向，我们希望表达出一种“没有对象可用”的含义时，可令指针取值为nullptr。所有指针类型共享同一个nullptr。\n\n在使用指针前检查它是否为空，是明智的行为：\n\nint count_x(const char* p, char x){\n    //计算x在p[]中出现的次数\n    //假定p指向一个以零结尾的字符数组（或者指向空）\n    if(p == nullptr)\n        return 0;\n    int count = 0;\n    for(; *p != 0; ++p)\n        if(*p == x)\n            ++count;\n    return count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 假定输入的char*是一个C风格字符串，也就是说，改指针指向一个以零结尾的char数组。字符串字面量中的字符是不可变的。\n * 所以为了以count_x("Hello!")，这样的格式接收字符串字面量作为参数，因此把第一个参数声明为const char*。\n * 在旧式代码中，常常用0或者NULL代替nullptr，但是，使用nullptr可以消除整数（0或者NULL）与指针（nullptr）之间存在的潜在歧义。\n * 指针可以为空，但引用不能，引用必须指向有效的对象（编译器也假定如此）。当然，有些奇淫巧计可以打破这个规则，但请不要这么左。\n\n\n# 1.8 建议\n\n 1.  使用#include 或者 import引入库，可以简化编程。\n 2.  函数重载的适用情况是，几个函数的任务相同而处理的参数类型不同；\n 3.  如果一个函数可能需要在编译时求值，那么将它声明为constexpr；\n 4.  如果一个函数必须在编译时求值，那么将它声明为consteval；\n 5.  如果一个函数不允许有副作用，那么就将它声明为constexpr或consteval；\n 6.  在声明语句中制定了类型名称（而非使用auto）时，优先使用{}初始化语法；\n 7.  使用auto可避免重复输入类型名称；\n 8.  在if语句的条件中声明变量时，优先采用隐式检验而不是与0或nullptr进行比较；\n 9.  优先使用范围for语句而非使用显示循环变量的传统for语句；\n 10. 只对位运算使用unsigned；\n 11. 使用nullptr而非0或NULL；',normalizedContent:'# cpp之旅（学习笔记）第1章\n\n\n# 第1章 基础\n\n\n# 1.1 程序\n\ncpp是一门编译型语言。源代码必须交由编译器处理生成可执行文件，然后由链接器组装成可执行程序。\n\n一个可执行文件通常是为一个特定的硬件与操作系统组合而制定的，换句话说，它在安卓设备与windows个人电脑之间是不可移植的，因此，可移植性指的是源代码的可移植性，即源代码可以在多种系统中编译成功，然后运行。\n\n最小的cpp程序：\n\nint main(){}\n\n\n1\n\n\n定义一个main函数，不接受任何参数，也不做任何事情。\n\n\n# 1.2 新东西\n\n//旧版本\n#include <iostream>\nint main() {\n\tstd::cout << "hello, world!\\n";\n}\n\n\n1\n2\n3\n4\n5\n\n\n//cpp20版本\nimport std;\nint main() {\n    std::cout << "hello, world!\\n";\n}\n\n\n1\n2\n3\n4\n5\n\n\nimport std;指示编译器去声明标准库变量的存在。如果没有这个声明，std::cout << "hello, world!\\n";将没有意义。但是指令import将所有标准库放进一个单独的std模块还没有成为标准。\n\n\n# 1.3 函数\n\ndouble get(const vector<double>& vec, int index);\n//函数类型是：\ndouble(const vector<double>&,int)\n\n\n1\n2\n3\n\n\n对于成员函数来说，类的名称也是函数类型的一部分：\n\nchar& string::operator[](int index);\n//函数类型是：\nchar& string::(int)\n\n\n1\n2\n3\n\n\n\n# 1.4 类型、变量、运算\n\n * 前缀0b表示二进制整数字面量，如：0b10101010\n * 前缀0x表示十六进制整数字面量，如：0xbad12ce3\n * 前缀0表示八进制字面量，如：0334\n\n可以引入单引号（’）作为数字分隔符提升长字面量的可读性\n\n> 例如：π的值大约是：3.14159 ‘ 26535 ’ 89793 ‘ 23846 ’ 26433 ‘ 83279 ’ 50288\n> \n> 用十六进制表示就是：0x3.243f ’ 6a88 ‘ 85a3 ’ 08d3\n\n\n# 1.4.1 运算\n\n * 部分操作符的计算顺序是从左向右的：\n   \n   x.y、x->y、x(y)、x[y]、x<<y、x>>y、x&&y、x||y\n\n * 但赋值符号的计算顺序是从右往左的：\n   \n   x += y\n\n\n# 1.4.2 初始化\n\n * 使用=或者{}初始化\n\ndouble d1 = 2.3;\ndouble d2 {2.3};//等价于double d2 = {2.3}\n\n\n1\n2\n\n * 使用=的形式是c语言传统的方式，如果拿不定主意，就是用更通用的{}列表形式。可以避免隐式类型转换导致的信息丢失\n\nint i1 = 7.8;//i1变成了7（你可能感到意外）\nint i2 {7.8};//错误：floating-point to integer conversion\n\n\n1\n2\n\n * 当使用=而不是{}的时候，会进行从double到int及从int到char这样的窄化类型转换。\n\n如果变量的类型可以从初始化符号中推导出来，就无需显示指定类型\n\nauto b = true; \t//bool类型\nauto ch = \'x\';\t//char类型\nauto i = 123;\t//int类型\nauto d = 1.2;\t//double类型\n...\n\n\n1\n2\n3\n4\n5\n\n\n使用auto声明变量时，作者倾向于使用=符号，因为没有类型转换的风险。当然，偏好使用{}也无伤大雅。\n\n当没有明显的需要显示地指定类型时，一般使用 auto 。\n\n理由如下：\n\n 1. 该定义的作用域较大，我们希望代码的读者清楚地知道其类型。\n 2. 初始化表达式的类型（对读者来说）不是显而易见的。\n 3. 我们希望明确规定某个变量的范围和精度（如：希望使用double而非float）。\n\n\n# 1.5 作用域和生命周期\n\n * **局部作用域：**在函数或匿名函数中定义的名字叫局部名字，作用域从声明它的地方开始，直到声明语句所在的块结尾。语句块的边界由一对{}决定。函数参数的名字也属于局部名字。\n * **类作用域：**定义在类的内部，不在任何函数、匿名函数、enum class中，可被叫做成员名字（或类成员名字）。作用域从它括起声明的左花括号 { 开始，到对应的右花括号 } 结束。\n * 命名空间作用域：在命名空间内部，并且不再任何函数、匿名函数、enum class中，则把这个名字叫做命名空间成员名字。作用域从声明它的地方开始，到命名空间结束为止。\n\n某些对象也可以没有名字，比如：临时对象或者用new创建的对象：\n\nvector<int> vec;\t\t\t\t\t//vec是全局名字（全局整数动态数组）\nvoid fct(int arg) {\t\t\t\t\t//fct是全局名字（全局函数）arg是局部名字（局部整数参数）\n    string motto {"who dares wins"};//motto是局部名字\n    auto p = new record{"hume"};\t//p指向无名record对象（由new创建）\n    //...\n}\nstruct record {\n  \tstring name;\t\t\t\t\t//name是record的成员名字（字符串成员）\n    //...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n一个new创建的对象可以持续“生存”，知道用delete将其销毁。\n\n\n# 1.6 常量\n\ncpp支持两种不变性：\n\n * const：“我承诺不修改这个值”，主要用来说明接口，可以用指针或者引用的方式传入函数参数而不用担心被改变。编译器负责强制执行const承诺。const声明的值可以在运行时被计算。\n * constexpr：“请在编译时计算出它的值”，主要用于声明常量，作用是把数据置于只读内存区域（更小概率被破坏），以及提高性能。constexpr的值必须由编译器计算。\n\n例如：\n\nconstexpr int dmv = 17;\t\t\t\t//dmv是一个命名常量\nint var = 17;\t\t\t\t\t\t//var不是常量\nconst double sqv = sqrt(var);\t\t//sqv是一个命名常量，可能在运行时计算\ndouble sum(const vector<double>&);\t//sum不会修改它的参数\nvector<double> v {1.2, 3.4, 4.5};\t//v不是常量\nconst double s1 = sum(v);\t\t\t//可行：sum(v)在运行时计算\nconstexpr double s2 = sum(v);\t\t//错误：sum(v)不是一个常量表达式\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为了使函数可在常量表达式中使用，这个函数必须被定义为constexpr 或consteval，这样才能在编译期表达式中被计算。\n\n例如：\n\nconstexpr double square(double x){return x*x};\nconstexpr double max1 = 1.4*square(17);\t//可行：1.4*square(17)是常量表达式\nconstexpr double max2 = 1.4*square(var);//错误：var不是常量，所以square(var)不是常量\nconst double max3 = 1.4*square(var);\t//可行：允许在运行时计算\n\n\n1\n2\n3\n4\n\n\n\n# 1.7 指针、数组、引用\n\n * 数组：同类型元素的连续分配序列。\n * 指针：可存放指定类型的对象的地址。\n\n在声明中，[ ]意味着对应类型的数组，*意味着指向对应类型的指针。\n\nchar v[6];\t\t//6个字符组成的数组\nchar *p = &v[3];//p指向v的第4个元素\nchar x = *p;\t//*p代表p指向的对象\n\n\n1\n2\n3\n\n * 前置一元操作符*表示取内容，前置一元操作符&表示取地址，后置一元操作符&表示指向前者的引用。\n * 引用在初始化后就不能再指向其他的对象了。\n * 当用于什么语句时，操作符&、*、[ ]被称为声明操作符。\n\nt* p\t//t*：p是一个指向t的指针\nt& r\t//t&：r是一个指向t的引用\nt f(a)  //t f(a)：f是一个函数，接受a类型的参数，返回t类型的结果\n\n\n1\n2\n3\n\n\n\n# 1.7.1 空指针\n\n当确实没有对象可指向，我们希望表达出一种“没有对象可用”的含义时，可令指针取值为nullptr。所有指针类型共享同一个nullptr。\n\n在使用指针前检查它是否为空，是明智的行为：\n\nint count_x(const char* p, char x){\n    //计算x在p[]中出现的次数\n    //假定p指向一个以零结尾的字符数组（或者指向空）\n    if(p == nullptr)\n        return 0;\n    int count = 0;\n    for(; *p != 0; ++p)\n        if(*p == x)\n            ++count;\n    return count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 假定输入的char*是一个c风格字符串，也就是说，改指针指向一个以零结尾的char数组。字符串字面量中的字符是不可变的。\n * 所以为了以count_x("hello!")，这样的格式接收字符串字面量作为参数，因此把第一个参数声明为const char*。\n * 在旧式代码中，常常用0或者null代替nullptr，但是，使用nullptr可以消除整数（0或者null）与指针（nullptr）之间存在的潜在歧义。\n * 指针可以为空，但引用不能，引用必须指向有效的对象（编译器也假定如此）。当然，有些奇淫巧计可以打破这个规则，但请不要这么左。\n\n\n# 1.8 建议\n\n 1.  使用#include 或者 import引入库，可以简化编程。\n 2.  函数重载的适用情况是，几个函数的任务相同而处理的参数类型不同；\n 3.  如果一个函数可能需要在编译时求值，那么将它声明为constexpr；\n 4.  如果一个函数必须在编译时求值，那么将它声明为consteval；\n 5.  如果一个函数不允许有副作用，那么就将它声明为constexpr或consteval；\n 6.  在声明语句中制定了类型名称（而非使用auto）时，优先使用{}初始化语法；\n 7.  使用auto可避免重复输入类型名称；\n 8.  在if语句的条件中声明变量时，优先采用隐式检验而不是与0或nullptr进行比较；\n 9.  优先使用范围for语句而非使用显示循环变量的传统for语句；\n 10. 只对位运算使用unsigned；\n 11. 使用nullptr而非0或null；',charsets:{cjk:!0}},{title:"第2章 用户自定义类型",frontmatter:{title:"第2章 用户自定义类型",date:"2023-11-24T15:54:44.000Z",permalink:"/pages/88a7db/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/02.%E7%AC%AC2%E7%AB%A0%20%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B.html",relativePath:"01.CPP语言/01.Cpp之旅/02.第2章 用户自定义类型.md",key:"v-7eb5beb0",path:"/pages/88a7db/",headers:[{level:2,title:"2.1 引言",slug:"_2-1-引言",normalizedTitle:"2.1 引言",charIndex:18},{level:2,title:"2.2 结构",slug:"_2-2-结构",normalizedTitle:"2.2 结构",charIndex:147},{level:2,title:"2.3 类",slug:"_2-3-类",normalizedTitle:"2.3 类",charIndex:1204},{level:2,title:"2.4 枚举",slug:"_2-4-枚举",normalizedTitle:"2.4 枚举",charIndex:2509},{level:2,title:"2.5 联合",slug:"_2-5-联合",normalizedTitle:"2.5 联合",charIndex:3557},{level:2,title:"2.6 建议",slug:"_2-6-建议",normalizedTitle:"2.6 建议",charIndex:4934}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.425,time:145500,words:485},headersStr:"2.1 引言 2.2 结构 2.3 类 2.4 枚举 2.5 联合 2.6 建议",content:"# 第2章 用户自定义类型\n\n\n# 2.1 引言\n\n * 用基本类型、const修饰符和声明操作符构造出来的类型，称为内置类型。\n * Cpp抽象机制的目的：令程序员能够设计并实现他们自己的数据类型。\n * 利用Cpp的抽象机制从其他类型构造出来的类型称为用户自定义类型，即类和枚举。\n\n\n# 2.2 结构\n\n构建新类型的第一步通常是：把所需元素组织成一种数据结构。\n\n一个struct的例子如下：\n\nstruct Vector{\n    double* elem;\t//指向元素的指针\n    int sz;\t\t\t//元素的数量\n};\n//可通过下述方式定义：\nVector v;\n\n\n1\n2\n3\n4\n5\n6\n\n\n然而，它本身并无太大用处，因为v的elem指针并不指向任何实际内容。为了变得有用，需令v指向某些元素。\n\n例如：\n\nvoid vector_init(Vector& v,int s){\t//初始化Vector类型\n    v.elem = new double[s]; \t\t//分配数组空间，包含s个double类型的值\n    v.sz = s;\t\t\t\t\t\t\n}\n\n\n1\n2\n3\n4\n\n\nnew操作符从名为自由存储（也叫动态内存或者堆）的区域中分配内存。分配在自由存储中的对象作用域与创建时所处的作用域无关，它会一直存活，直到调用delete操作符销毁它为止。\n\nVector的一个简单应用如下：\n\ndouble read_and_sum(int s) {\t//从cin读入s个整数，然后返回它们的和；假定s为正\n    Vector v;\n    vector_init(v,s);\n    for(int i = 0; i != s; ++i)\n    \tcin >> v.elem[i];\t\t//读入元素\n    double sum = 0;\n    for(int i = 0; i != s; ++i)\n        sum += v.elem[i];\t\t//计算元素的和\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n标准库类型使用小写名称，所以自定义的类型的名称通常使用首字母大写（例如：Vector和String），以示区别。\n\n不要试图重新发明vector和string这样的标准库组件；直接使用现成的更明智。\n\n访问struct成员有两种方式，通过名字或者引用来访问时用 . （点），通过指针访问时用 -> 。\n\n例如：\n\nvoid f(Vector v, Vector& rv, Vector* pv) {\n    int i1 = v.sz;\t\t//通过名字访问\n    int i2 = rv.sz;\t\t//通过引用访问\n    int i3 = pv->sz;\t//通过指针访问\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.3 类\n\n把类型的接口（所有代码都可使用的部分）与其实现（可访问外部不可访问的数据）分离开来。在Cpp中，实现上述目的的语言机制被称为类。\n\n类的public成员定义了该类的接口，private成员则只能通过接口访问。public和private成员声明允许以任意顺序出现在类声明中，但是按惯例通常将public声明放在private前面，除非需要特别强调private成员的实现。\n\n例如：\n\nclass Vector {\npublic:\n    Vector(int s) : elem{new double[s]}, sz{s} { }\t//构造一个Vector\n    double& operator[] (int i) { return elem[i];}\t//通过下标访问元素\n    int size() {return sz;}\nprivate:\n    double* elem;\t//指向元素的指针\n    int sz;\t\t\t//元素的数量\n};\n//定义一个Vector类型的变量\nVector v(6);\t//拥有6个元素的Vector\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n * 总的来说，Vector对象是一个“句柄”，它包含指向元素的指针（elem）及元素的数量（sz）。\n\n * 在这里，我们只能通过Vector的接口访问其表示形式（成员elem和sz）。Vector接口由其public成员构成，包括Vector()、operator和size()。\n\n所以之前的read_and_sum()示例可简化为：\n\ndouble read_and_sum(int s) {\n    Vector v(s);\t\t\t\t//创建一个包含s个元素的动态数组\n    for(int i = 0; i != s; ++i)\n        cin >> v.elem[i];\t\t//读入元素\n    double sum = 0;\n    for(int i = 0; i != s; ++i)\n        sum += v.elem[i];\t\t//计算元素的和\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 与所属类同名的成员函数被称为构造函数，即它是用来构造类的对象的。与普通函数不同，构造函数在初始化类的对象时一定会被调用。因此定义一个构造函数可以消除类变量未初始化造成的问题。\n\n * Vector(int s) : elem{new double[s]}, sz{s} { }\n\n * 该构造函数使用成员初始值列表来初始化Vector的成员：\n\n * 这条语句的含义是：首先从自由存储分配能容纳s个double类型的元素的空间，用指向这个空间的指针初始化elem，然后将sz初始化为s。\n\n==我们常用的两个关键字struct和class没有本质区别，唯一的不同之处在于，struct的成员默认是public的。例如，我们也可以为struct定义构造函数和其他成员函数，这一点与class完全一致。==\n\n\n# 2.4 枚举\n\nenum class Color( red, blue, green);\nenum class Traffic_light { green, yellow, red };\nColor col = Color::red;\nTraffic_light light = Traffic_light::red;\n\n\n1\n2\n3\n4\n\n * 注意：枚举值（例如：red）的作用域在它们的 enum class 内，因此它们可以在不同的 enum class 中重复使用而不会混淆。\n * 例如：Color::red 是Color的red值；与Traffic_light::red完全不同。\n * enum后面的class表示这个枚举类型是强类型，并且具备独立作用域。\n\n不同的enum class 是不同的类型，这有助于防止对常量的误用。比如：不能混用Traffic_light类与Color类的枚举值\n\nColor x1 = red;\t\t\t\t\t//错误：哪个red?\nColor y2 = Traffic_light::red;\t//错误：这个red不属于Color类型\nColor z3 = Color::red;\t\t\t//可行\nauto x4 = Color::red;\t\t\t//可行：Color::red是Color类型\n//类似的，也无法隐式地混用Color与整数类型的值\nint i = Color::red;\t//错误：Color::red不是int类型\nColor c = 2;\t\t//初始化错误：2不是Color类型\n//允许显示地指定从int类型进行转换：\nColor x = Color{5};\t//可行，但烦琐\nColor y {6};\t\t//可行\n//类似地，可以显示地将enum值转换到其实际存储类型：\nint x = int(Color::red);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果不想显式指定枚举地名称，并且希望枚举值的类型直接是int（而不需要显式类型转换），可以去掉enum class中的class字样，得到一个“普通的”enum。普通的enum中枚举值进入与enum自身同级的作用域，并且可以被隐式转换为整数数值。例如：\n\nenum Color {red, green, blue};\nint col = green;\n\n\n1\n2\n\n\n此处col的值为1。默认情况下，枚举值的整数数值从0开始，逐个加1。\n\n\n# 2.5 联合\n\nunion是一种特殊的struct，它的所有成员都被分配在同一块内存区域中，因此，union实际占用的空间就是它最大的成员所占的空间。\n\n显然，同一时刻，union中只能保存一个成员的值。\n\n * 例如：考虑实现一个符号表的表项，它保存着一个名字和一个值，这个值要么是Node*，要么是int类型，程序可能如下：\n\nenum class Type {ptr,num};//Type 可以是ptr或者num\nstruct Entry {\n    string name;\n    Type t;\n    Node* p;\t//如果t == Type::ptr,使用p\n    int i;\t\t//如果t == Type::num,使用i\n};\nvoid f(Entry* pe) {\n    if(pe->t == Type::num)\n        cout << pe->i;\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 成员p和i从来不会同时被使用，所以空间浪费。使用union可以解决该问题，例如，把两者都定义为union的成员：\n\nunion Value {\n    Node* p;\n    int i;\n};\n\n\n1\n2\n3\n4\n\n\n * 对于相同的Value对象而言，现在Value::p和Value::i将被放在相同的内存地址。\n\n * 因为Cpp语言本身不负责跟踪union实际存储的值的类型，所以需要程序员手动维护如下代码：\n\nenum class Type {ptr,num};//Type 可以是ptr或者num\nstruct Entry {\n    string name;\n    Type t;\n    Value v;\t\t//如果t == Type::ptr,使用v.p;如果t == Type::num,使用v.i\n};\nvoid f(Entry* pe) {\n    if(pe->t == Type::num)\n        cout << pe->i;\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n * 时刻维护类型字段（也叫标记，此处为t）与union中实际类型的对应关系并不容易。\n\n * 也可以使用标准库类型variant，从而消除大多数需要直接使用union的情形。variant保存给定的类型列表集合中的一个值。\n\n例如，variant<Node* t,int>可以保存Node*或者int类型的值。\n\nenum class Type {ptr,num};//Type 可以是ptr或者num\nstruct Entry {\n    string name;\n    variant<Node* ,int> v;\n};\nvoid f(Entry* pe) {\n    if(holds_alternative<int>(pe->v))\t//*pe是否保存了int类型？\n        cout << get<int>(pe->v);\t\t//获取这个int\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在很多使用场景中，variant都比union更简单、更安全。\n\n\n# 2.6 建议\n\n 1. 当内置类型过于底层时，优先使用定义良好的用户自定义类型；\n 2. 将有关联的数据组织为结构（struct或class）；\n 3. 用class表达接口与实现的区别；\n 4. 一个struct就是一个成员默认的public的class；\n 5. 优先使用enum class而不是“普通”enum，以避免很多麻烦；\n 6. 避免使用“裸”union；将其与类型字段一起封装到一个类中；\n 7. 优先使用std::variant，而不是“裸”union;",normalizedContent:"# 第2章 用户自定义类型\n\n\n# 2.1 引言\n\n * 用基本类型、const修饰符和声明操作符构造出来的类型，称为内置类型。\n * cpp抽象机制的目的：令程序员能够设计并实现他们自己的数据类型。\n * 利用cpp的抽象机制从其他类型构造出来的类型称为用户自定义类型，即类和枚举。\n\n\n# 2.2 结构\n\n构建新类型的第一步通常是：把所需元素组织成一种数据结构。\n\n一个struct的例子如下：\n\nstruct vector{\n    double* elem;\t//指向元素的指针\n    int sz;\t\t\t//元素的数量\n};\n//可通过下述方式定义：\nvector v;\n\n\n1\n2\n3\n4\n5\n6\n\n\n然而，它本身并无太大用处，因为v的elem指针并不指向任何实际内容。为了变得有用，需令v指向某些元素。\n\n例如：\n\nvoid vector_init(vector& v,int s){\t//初始化vector类型\n    v.elem = new double[s]; \t\t//分配数组空间，包含s个double类型的值\n    v.sz = s;\t\t\t\t\t\t\n}\n\n\n1\n2\n3\n4\n\n\nnew操作符从名为自由存储（也叫动态内存或者堆）的区域中分配内存。分配在自由存储中的对象作用域与创建时所处的作用域无关，它会一直存活，直到调用delete操作符销毁它为止。\n\nvector的一个简单应用如下：\n\ndouble read_and_sum(int s) {\t//从cin读入s个整数，然后返回它们的和；假定s为正\n    vector v;\n    vector_init(v,s);\n    for(int i = 0; i != s; ++i)\n    \tcin >> v.elem[i];\t\t//读入元素\n    double sum = 0;\n    for(int i = 0; i != s; ++i)\n        sum += v.elem[i];\t\t//计算元素的和\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n标准库类型使用小写名称，所以自定义的类型的名称通常使用首字母大写（例如：vector和string），以示区别。\n\n不要试图重新发明vector和string这样的标准库组件；直接使用现成的更明智。\n\n访问struct成员有两种方式，通过名字或者引用来访问时用 . （点），通过指针访问时用 -> 。\n\n例如：\n\nvoid f(vector v, vector& rv, vector* pv) {\n    int i1 = v.sz;\t\t//通过名字访问\n    int i2 = rv.sz;\t\t//通过引用访问\n    int i3 = pv->sz;\t//通过指针访问\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.3 类\n\n把类型的接口（所有代码都可使用的部分）与其实现（可访问外部不可访问的数据）分离开来。在cpp中，实现上述目的的语言机制被称为类。\n\n类的public成员定义了该类的接口，private成员则只能通过接口访问。public和private成员声明允许以任意顺序出现在类声明中，但是按惯例通常将public声明放在private前面，除非需要特别强调private成员的实现。\n\n例如：\n\nclass vector {\npublic:\n    vector(int s) : elem{new double[s]}, sz{s} { }\t//构造一个vector\n    double& operator[] (int i) { return elem[i];}\t//通过下标访问元素\n    int size() {return sz;}\nprivate:\n    double* elem;\t//指向元素的指针\n    int sz;\t\t\t//元素的数量\n};\n//定义一个vector类型的变量\nvector v(6);\t//拥有6个元素的vector\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n * 总的来说，vector对象是一个“句柄”，它包含指向元素的指针（elem）及元素的数量（sz）。\n\n * 在这里，我们只能通过vector的接口访问其表示形式（成员elem和sz）。vector接口由其public成员构成，包括vector()、operator和size()。\n\n所以之前的read_and_sum()示例可简化为：\n\ndouble read_and_sum(int s) {\n    vector v(s);\t\t\t\t//创建一个包含s个元素的动态数组\n    for(int i = 0; i != s; ++i)\n        cin >> v.elem[i];\t\t//读入元素\n    double sum = 0;\n    for(int i = 0; i != s; ++i)\n        sum += v.elem[i];\t\t//计算元素的和\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 与所属类同名的成员函数被称为构造函数，即它是用来构造类的对象的。与普通函数不同，构造函数在初始化类的对象时一定会被调用。因此定义一个构造函数可以消除类变量未初始化造成的问题。\n\n * vector(int s) : elem{new double[s]}, sz{s} { }\n\n * 该构造函数使用成员初始值列表来初始化vector的成员：\n\n * 这条语句的含义是：首先从自由存储分配能容纳s个double类型的元素的空间，用指向这个空间的指针初始化elem，然后将sz初始化为s。\n\n==我们常用的两个关键字struct和class没有本质区别，唯一的不同之处在于，struct的成员默认是public的。例如，我们也可以为struct定义构造函数和其他成员函数，这一点与class完全一致。==\n\n\n# 2.4 枚举\n\nenum class color( red, blue, green);\nenum class traffic_light { green, yellow, red };\ncolor col = color::red;\ntraffic_light light = traffic_light::red;\n\n\n1\n2\n3\n4\n\n * 注意：枚举值（例如：red）的作用域在它们的 enum class 内，因此它们可以在不同的 enum class 中重复使用而不会混淆。\n * 例如：color::red 是color的red值；与traffic_light::red完全不同。\n * enum后面的class表示这个枚举类型是强类型，并且具备独立作用域。\n\n不同的enum class 是不同的类型，这有助于防止对常量的误用。比如：不能混用traffic_light类与color类的枚举值\n\ncolor x1 = red;\t\t\t\t\t//错误：哪个red?\ncolor y2 = traffic_light::red;\t//错误：这个red不属于color类型\ncolor z3 = color::red;\t\t\t//可行\nauto x4 = color::red;\t\t\t//可行：color::red是color类型\n//类似的，也无法隐式地混用color与整数类型的值\nint i = color::red;\t//错误：color::red不是int类型\ncolor c = 2;\t\t//初始化错误：2不是color类型\n//允许显示地指定从int类型进行转换：\ncolor x = color{5};\t//可行，但烦琐\ncolor y {6};\t\t//可行\n//类似地，可以显示地将enum值转换到其实际存储类型：\nint x = int(color::red);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果不想显式指定枚举地名称，并且希望枚举值的类型直接是int（而不需要显式类型转换），可以去掉enum class中的class字样，得到一个“普通的”enum。普通的enum中枚举值进入与enum自身同级的作用域，并且可以被隐式转换为整数数值。例如：\n\nenum color {red, green, blue};\nint col = green;\n\n\n1\n2\n\n\n此处col的值为1。默认情况下，枚举值的整数数值从0开始，逐个加1。\n\n\n# 2.5 联合\n\nunion是一种特殊的struct，它的所有成员都被分配在同一块内存区域中，因此，union实际占用的空间就是它最大的成员所占的空间。\n\n显然，同一时刻，union中只能保存一个成员的值。\n\n * 例如：考虑实现一个符号表的表项，它保存着一个名字和一个值，这个值要么是node*，要么是int类型，程序可能如下：\n\nenum class type {ptr,num};//type 可以是ptr或者num\nstruct entry {\n    string name;\n    type t;\n    node* p;\t//如果t == type::ptr,使用p\n    int i;\t\t//如果t == type::num,使用i\n};\nvoid f(entry* pe) {\n    if(pe->t == type::num)\n        cout << pe->i;\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 成员p和i从来不会同时被使用，所以空间浪费。使用union可以解决该问题，例如，把两者都定义为union的成员：\n\nunion value {\n    node* p;\n    int i;\n};\n\n\n1\n2\n3\n4\n\n\n * 对于相同的value对象而言，现在value::p和value::i将被放在相同的内存地址。\n\n * 因为cpp语言本身不负责跟踪union实际存储的值的类型，所以需要程序员手动维护如下代码：\n\nenum class type {ptr,num};//type 可以是ptr或者num\nstruct entry {\n    string name;\n    type t;\n    value v;\t\t//如果t == type::ptr,使用v.p;如果t == type::num,使用v.i\n};\nvoid f(entry* pe) {\n    if(pe->t == type::num)\n        cout << pe->i;\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n * 时刻维护类型字段（也叫标记，此处为t）与union中实际类型的对应关系并不容易。\n\n * 也可以使用标准库类型variant，从而消除大多数需要直接使用union的情形。variant保存给定的类型列表集合中的一个值。\n\n例如，variant<node* t,int>可以保存node*或者int类型的值。\n\nenum class type {ptr,num};//type 可以是ptr或者num\nstruct entry {\n    string name;\n    variant<node* ,int> v;\n};\nvoid f(entry* pe) {\n    if(holds_alternative<int>(pe->v))\t//*pe是否保存了int类型？\n        cout << get<int>(pe->v);\t\t//获取这个int\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在很多使用场景中，variant都比union更简单、更安全。\n\n\n# 2.6 建议\n\n 1. 当内置类型过于底层时，优先使用定义良好的用户自定义类型；\n 2. 将有关联的数据组织为结构（struct或class）；\n 3. 用class表达接口与实现的区别；\n 4. 一个struct就是一个成员默认的public的class；\n 5. 优先使用enum class而不是“普通”enum，以避免很多麻烦；\n 6. 避免使用“裸”union；将其与类型字段一起封装到一个类中；\n 7. 优先使用std::variant，而不是“裸”union;",charsets:{cjk:!0}},{title:"第3章 模块化",frontmatter:{title:"第3章 模块化",date:"2023-11-24T15:54:47.000Z",permalink:"/pages/61ffe6/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/03.%E7%AC%AC3%E7%AB%A0%20%E6%A8%A1%E5%9D%97%E5%8C%96.html",relativePath:"01.CPP语言/01.Cpp之旅/03.第3章 模块化.md",key:"v-3d949f6d",path:"/pages/61ffe6/",headers:[{level:2,title:"3.1 分离编译",slug:"_3-1-分离编译",normalizedTitle:"3.1 分离编译",charIndex:25},{level:2,title:"3.2 模块",slug:"_3-2-模块",normalizedTitle:"3.2 模块",charIndex:755},{level:2,title:"3.3 模块与头文件两种方法的区别",slug:"_3-3-模块与头文件两种方法的区别",normalizedTitle:"3.3 模块与头文件两种方法的区别",charIndex:1887},{level:2,title:"3.4 命名空间",slug:"_3-4-命名空间",normalizedTitle:"3.4 命名空间",charIndex:2954},{level:2,title:"3.5 函数参数与返回值",slug:"_3-5-函数参数与返回值",normalizedTitle:"3.5 函数参数与返回值",charIndex:3402},{level:3,title:"3.5.1 结构化绑定",slug:"_3-5-1-结构化绑定",normalizedTitle:"3.5.1 结构化绑定",charIndex:3539},{level:2,title:"3.6 建议",slug:"_3-6-建议",normalizedTitle:"3.6 建议",charIndex:4093}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.905,time:114300,words:381},headersStr:"3.1 分离编译 3.2 模块 3.3 模块与头文件两种方法的区别 3.4 命名空间 3.5 函数参数与返回值 3.5.1 结构化绑定 3.6 建议",content:'# Cpp之旅（学习笔记）第3章 模块化\n\n\n# 3.1 分离编译\n\nCpp支持一种名为分离编译的概念，用户代码只能看见所用类型和函数的声明。\n\n有两种方法可以实现它：\n\n * 头文件：将声明放进一个名为头文件的独立文件，然后将头文件以文本方式#include到代码中你需要声明的地方。\n * 模块：定义module文件，独立地编译它们，然后在需要时import它们。在import对应module时，只有其中显示export的声明是可见的。\n\n优点：\n\n * 可以尽可能地减少编译时间，并且强制要求程序中逻辑独立地部分分离开来（从而尽可能降低发生错误地概率）。\n\n> 模块技术是在Cpp20中出现地新特性，其提供了实质性地优势，对改善代码组织与编译耗时都有好处。\n\n> 一个单独编译的.cpp文件（包含它#include的.h文件）被称作一个翻译单元。\n\n使用#include及头文件实现模块化是一种传统方法，它具有明显地缺点：\n\n * 编译时间： 如果你在101个翻译单元中#include header.h，这个header.h的头文件将被编译器处理101次。\n * 依赖顺序： 如果你在header2.h之前#include header1.h，在header1.h中的定义与宏可能会影响header2.h中代码的含义，反之亦然。\n * 不协调： 如果你在一个文件中定义一个实体，比如类型或者函数，然后在另一个文件中定义一个稍微不同的版本，则可能导致崩溃或者难以觉察的错误。\n * 传染性： 所有表达头文件中某一个声明所需的代码，都必须出现在头文件中。这会导致代码膨胀，因为头文件为了完成声明需要#include其他头文件，这会导致头文件的用户需要（有意或者无意地）依赖头文件包含地实现细节。\n\n\n# 3.2 模块\n\nCpp20中出现了语言级的方式来直接实现模块化。\n\nexport module Vector;\t\t\t//定义一个module，名为Vector\nexport class Vector {\npublic:\n    Vector(int s);\n    double& operator[](int i);\n    int size();\nprivate:\n    double* elem;\t\t\t\t//elem指向一个数组，该数组包含sz个double类型的元素\n    int sz;\n};\nVector::Vector(int s) : elem{new double[s], sz{s}} {}//初始化元素\ndouble& Vector::operator[](int i){\n    return elem[i];\n}\nint Vector::size() {\n    return sz;\n}\nexport bool operator==(const Vector& v1,const Vector& v2) {\n    if(v1.size() != v2.size())\n        return false;\n    for(int i = 0; i < v1.size(); ++i)\n        if(v1[i] != v2[i])\n            return false;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上诉代码定义了一个 module，名为 Vector，这个模块导出了 Vector 类及所有成员函数，还有成员函数的操作符 ==。\n\n要使用上述 module，只要在需要用到它的地方 import 就可以了。\n\n例如：\n\n//user.cpp\nimport Vector;\t\t\t\t\t\t\t//获得Vector的相关接口\n#include <cmath>\t\t\t\t\t\t//获得标准库的数学函数接口，包含sqrt()\ndouble sqrt_sum(Vector& v){\n    double sum = 0;\n    for(int i = 0; i != v.size(); ++i)\n        sum +=std::sqrt(v[i]);\t\t\t//平方根之和\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n#inclue <cmath>也可以改为import cmath;这里仅仅是为了演示新旧方式的混合。\n\n\n# 3.3 模块与头文件两种方法的区别\n\n头文件与模块的区别不仅仅是在语法上：\n\n * 模块只被编译一次，不会在每个用到它的翻译单元那里都被重新编译。\n * 两个模块 import 的顺序不影响其含义。\n * 如果你在模块内部 import 或者 #include 其他内容，模块的使用者不会隐式地获得那些模块地访问权：这意味着 import 没有传染性。\n * 模块在维护性与编译时间方面地改进非常显著。\n\n例如：作者测试过使用 `import std;` 的 "Hello，world!" 程序\n它的编译速度比使用 `#include<iostream>` 的版本 快10倍 \n这还是在 std 模块因包含了整个标准库足足有 <iostream> 10 倍大小的前提下实现的。\n\n\n1\n2\n3\n\n\n提升的原理：\n\n * 模块只导出接口，但头文件需要传递所有直接的或者间接的信息给编译器。\n\n不幸的是，module std还没有进入Cpp20。 附录A介绍了如何获得一份 module std 的方法，这里不详细展开。\n\n示例：\n\n当定义一个模块时，不需要将实现与声明分开写成两个文件，如果想改进你的源代码，可以这么做：\n\nexport module Vector;\t\t//定义 module，名叫 Vector\nexport class Vector {\n    //...\n};\nexport bool operator==(const Vector& v1, const Vector& v2){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n编译器负责把（用 export 指定的）模块的接口从实现细节中分离出来，因此，Vector 接口由编译器生成，不需要由用户指定。\n\n使用module时，不需要为了在接口文件内隐藏实现细节而将代码变得复杂；因为模块只导出显示export的声明。\n\n考虑如下代码：\n\nexport module vector_printer;\nimport std;\nexport\ntemplate<typename T>\nvoid print(std::vector<T>& v)\t//这是唯一能被用户看见的函数\n{\n    cout << "{\\n";\n    for(const T& val : v)\n        std::cout << " " << val << \'\\n\';\n    cout << \'}\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.4 命名空间\n\n * Cpp还提供了一种名为命名空间的机制，一方面表达某些声明是属于一个整体的，另一方面表面它们的名字不会与其他命名空间中的名字冲突。\n * 要想访问其他命名空间中的某个名字，最简单的方法是在这个名字前加上命名空间的名字作为限定（例如，std::cout和My_code::main）。\n * ”真正的main()“定义在全局命名空间中，换句话说，它不属于任何自定义的命名空间、类或者函数。\n * 如果觉得反复使用命名空间限定显得冗长及干扰了可读性，可以使用using声明将命名空间中的名字放进当前作用域。\n\nvoid my_code(vector<int>& x,vector<int>& y) {\n    using std::swap; //将标准库的swap放进本地作用域\n    //...\n    swap(x,y);\t\t //std::swap()\n    other::swap(x,y);//某个其他的swap()\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.5 函数参数与返回值\n\n默认情况使用复制（传值），如果希望直接指向调用者环境中的对象，我们使用引用（传引用）的方式。\n\n从性能方面考虑，我们通常对小数据传值、对大数据传引用。这里的小意味着”复制开销很低“。通常而言，”尺寸在两到三个指针以内“是一个不错的标准。\n\n\n# 3.5.1 结构化绑定\n\n一个函数只能返回一个值，但这个值可以是拥有很多成员的类对象。这往往是函数体面地返回多个值地方法。\n\n例如：\n\nstruct Entry {\n    string name;\n    int value;\n};\nEntry read_entry(istream& is)//简单地读函数\n{\n    string s;\n    int i;\n    is >> s >> i;\n    return {s,i};\n}\nauto e = read_entry(cin);\ncout << "{" << e.name << "," << e.value << "}\\n";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在这里，{s,i}被用于构造Entry类型地返回值。类似地，我们也可以将Entry的成员”解包"为局部变量：\n\nauto [n,v] = read_entry(is);\ncout << "{" << n << " , " << v << " }\\n";\n\n\n1\n2\n\n\n这里的auto[n,v]声明了两个变量n和v，它们的类型来自对read_entry()返回类型的推导。\n\n这种把类对象成员的名称赋予局部变量名称的机制叫作结构化绑定。\n\n\n# 3.6 建议\n\n区分声明（用作接口）和定义（用作实现）；\n\n优先选择module而非头文件（在支持module的地方）；\n\n使用头文件描述接口、强调逻辑结构；\n\n在头文件中应避免定义非内联函数；\n\n不要在头文件中使用using指令；\n\n采用传值方式传递“小”值，采用传引用方式传递“大”值；\n\n优先选择传const引用方式而非传普通引用方式；\n\n不要过度使用返回类型推断；\n\n不要过度使用结构化绑定；使用命名的返回类型通常可以使代码更为清晰。',normalizedContent:'# cpp之旅（学习笔记）第3章 模块化\n\n\n# 3.1 分离编译\n\ncpp支持一种名为分离编译的概念，用户代码只能看见所用类型和函数的声明。\n\n有两种方法可以实现它：\n\n * 头文件：将声明放进一个名为头文件的独立文件，然后将头文件以文本方式#include到代码中你需要声明的地方。\n * 模块：定义module文件，独立地编译它们，然后在需要时import它们。在import对应module时，只有其中显示export的声明是可见的。\n\n优点：\n\n * 可以尽可能地减少编译时间，并且强制要求程序中逻辑独立地部分分离开来（从而尽可能降低发生错误地概率）。\n\n> 模块技术是在cpp20中出现地新特性，其提供了实质性地优势，对改善代码组织与编译耗时都有好处。\n\n> 一个单独编译的.cpp文件（包含它#include的.h文件）被称作一个翻译单元。\n\n使用#include及头文件实现模块化是一种传统方法，它具有明显地缺点：\n\n * 编译时间： 如果你在101个翻译单元中#include header.h，这个header.h的头文件将被编译器处理101次。\n * 依赖顺序： 如果你在header2.h之前#include header1.h，在header1.h中的定义与宏可能会影响header2.h中代码的含义，反之亦然。\n * 不协调： 如果你在一个文件中定义一个实体，比如类型或者函数，然后在另一个文件中定义一个稍微不同的版本，则可能导致崩溃或者难以觉察的错误。\n * 传染性： 所有表达头文件中某一个声明所需的代码，都必须出现在头文件中。这会导致代码膨胀，因为头文件为了完成声明需要#include其他头文件，这会导致头文件的用户需要（有意或者无意地）依赖头文件包含地实现细节。\n\n\n# 3.2 模块\n\ncpp20中出现了语言级的方式来直接实现模块化。\n\nexport module vector;\t\t\t//定义一个module，名为vector\nexport class vector {\npublic:\n    vector(int s);\n    double& operator[](int i);\n    int size();\nprivate:\n    double* elem;\t\t\t\t//elem指向一个数组，该数组包含sz个double类型的元素\n    int sz;\n};\nvector::vector(int s) : elem{new double[s], sz{s}} {}//初始化元素\ndouble& vector::operator[](int i){\n    return elem[i];\n}\nint vector::size() {\n    return sz;\n}\nexport bool operator==(const vector& v1,const vector& v2) {\n    if(v1.size() != v2.size())\n        return false;\n    for(int i = 0; i < v1.size(); ++i)\n        if(v1[i] != v2[i])\n            return false;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上诉代码定义了一个 module，名为 vector，这个模块导出了 vector 类及所有成员函数，还有成员函数的操作符 ==。\n\n要使用上述 module，只要在需要用到它的地方 import 就可以了。\n\n例如：\n\n//user.cpp\nimport vector;\t\t\t\t\t\t\t//获得vector的相关接口\n#include <cmath>\t\t\t\t\t\t//获得标准库的数学函数接口，包含sqrt()\ndouble sqrt_sum(vector& v){\n    double sum = 0;\n    for(int i = 0; i != v.size(); ++i)\n        sum +=std::sqrt(v[i]);\t\t\t//平方根之和\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n#inclue <cmath>也可以改为import cmath;这里仅仅是为了演示新旧方式的混合。\n\n\n# 3.3 模块与头文件两种方法的区别\n\n头文件与模块的区别不仅仅是在语法上：\n\n * 模块只被编译一次，不会在每个用到它的翻译单元那里都被重新编译。\n * 两个模块 import 的顺序不影响其含义。\n * 如果你在模块内部 import 或者 #include 其他内容，模块的使用者不会隐式地获得那些模块地访问权：这意味着 import 没有传染性。\n * 模块在维护性与编译时间方面地改进非常显著。\n\n例如：作者测试过使用 `import std;` 的 "hello，world!" 程序\n它的编译速度比使用 `#include<iostream>` 的版本 快10倍 \n这还是在 std 模块因包含了整个标准库足足有 <iostream> 10 倍大小的前提下实现的。\n\n\n1\n2\n3\n\n\n提升的原理：\n\n * 模块只导出接口，但头文件需要传递所有直接的或者间接的信息给编译器。\n\n不幸的是，module std还没有进入cpp20。 附录a介绍了如何获得一份 module std 的方法，这里不详细展开。\n\n示例：\n\n当定义一个模块时，不需要将实现与声明分开写成两个文件，如果想改进你的源代码，可以这么做：\n\nexport module vector;\t\t//定义 module，名叫 vector\nexport class vector {\n    //...\n};\nexport bool operator==(const vector& v1, const vector& v2){\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n编译器负责把（用 export 指定的）模块的接口从实现细节中分离出来，因此，vector 接口由编译器生成，不需要由用户指定。\n\n使用module时，不需要为了在接口文件内隐藏实现细节而将代码变得复杂；因为模块只导出显示export的声明。\n\n考虑如下代码：\n\nexport module vector_printer;\nimport std;\nexport\ntemplate<typename t>\nvoid print(std::vector<t>& v)\t//这是唯一能被用户看见的函数\n{\n    cout << "{\\n";\n    for(const t& val : v)\n        std::cout << " " << val << \'\\n\';\n    cout << \'}\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.4 命名空间\n\n * cpp还提供了一种名为命名空间的机制，一方面表达某些声明是属于一个整体的，另一方面表面它们的名字不会与其他命名空间中的名字冲突。\n * 要想访问其他命名空间中的某个名字，最简单的方法是在这个名字前加上命名空间的名字作为限定（例如，std::cout和my_code::main）。\n * ”真正的main()“定义在全局命名空间中，换句话说，它不属于任何自定义的命名空间、类或者函数。\n * 如果觉得反复使用命名空间限定显得冗长及干扰了可读性，可以使用using声明将命名空间中的名字放进当前作用域。\n\nvoid my_code(vector<int>& x,vector<int>& y) {\n    using std::swap; //将标准库的swap放进本地作用域\n    //...\n    swap(x,y);\t\t //std::swap()\n    other::swap(x,y);//某个其他的swap()\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.5 函数参数与返回值\n\n默认情况使用复制（传值），如果希望直接指向调用者环境中的对象，我们使用引用（传引用）的方式。\n\n从性能方面考虑，我们通常对小数据传值、对大数据传引用。这里的小意味着”复制开销很低“。通常而言，”尺寸在两到三个指针以内“是一个不错的标准。\n\n\n# 3.5.1 结构化绑定\n\n一个函数只能返回一个值，但这个值可以是拥有很多成员的类对象。这往往是函数体面地返回多个值地方法。\n\n例如：\n\nstruct entry {\n    string name;\n    int value;\n};\nentry read_entry(istream& is)//简单地读函数\n{\n    string s;\n    int i;\n    is >> s >> i;\n    return {s,i};\n}\nauto e = read_entry(cin);\ncout << "{" << e.name << "," << e.value << "}\\n";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在这里，{s,i}被用于构造entry类型地返回值。类似地，我们也可以将entry的成员”解包"为局部变量：\n\nauto [n,v] = read_entry(is);\ncout << "{" << n << " , " << v << " }\\n";\n\n\n1\n2\n\n\n这里的auto[n,v]声明了两个变量n和v，它们的类型来自对read_entry()返回类型的推导。\n\n这种把类对象成员的名称赋予局部变量名称的机制叫作结构化绑定。\n\n\n# 3.6 建议\n\n区分声明（用作接口）和定义（用作实现）；\n\n优先选择module而非头文件（在支持module的地方）；\n\n使用头文件描述接口、强调逻辑结构；\n\n在头文件中应避免定义非内联函数；\n\n不要在头文件中使用using指令；\n\n采用传值方式传递“小”值，采用传引用方式传递“大”值；\n\n优先选择传const引用方式而非传普通引用方式；\n\n不要过度使用返回类型推断；\n\n不要过度使用结构化绑定；使用命名的返回类型通常可以使代码更为清晰。',charsets:{cjk:!0}},{title:"第4章 错误处理",frontmatter:{title:"第4章 错误处理",date:"2023-11-24T15:54:51.000Z",permalink:"/pages/2dfe3d/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/04.%E7%AC%AC4%E7%AB%A0%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",relativePath:"01.CPP语言/01.Cpp之旅/04.第4章 错误处理.md",key:"v-4b19516d",path:"/pages/2dfe3d/",headers:[{level:2,title:"4.1 异常",slug:"_4-1-异常",normalizedTitle:"4.1 异常",charIndex:26},{level:2,title:"4.2 断言机制",slug:"_4-2-断言机制",normalizedTitle:"4.2 断言机制",charIndex:1204},{level:3,title:"4.2.1 assert",slug:"_4-2-1-assert",normalizedTitle:"4.2.1 assert",charIndex:1217},{level:3,title:"4.2.2 static_assert",slug:"_4-2-2-static-assert",normalizedTitle:"4.2.2 static_assert",charIndex:1447},{level:3,title:"4.2.3  noexcept",slug:"_4-2-3-noexcept",normalizedTitle:"4.2.3  noexcept",charIndex:null},{level:2,title:"4.3 建议",slug:"_4-3-建议",normalizedTitle:"4.3 建议",charIndex:2445}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.07,time:64200,words:214},headersStr:"4.1 异常 4.2 断言机制 4.2.1 assert 4.2.2 static_assert 4.2.3  noexcept 4.3 建议",content:'# Cpp之旅（学习笔记）第4章 错误处理\n\n\n# 4.1 异常\n\n当我们试图越界访问Vector动态数组时，应该发生什么？\n\n假定可从下标越界的访问错误中恢复，那么Vector类的解决方案是实现者检测所有的越界访问并且告知用户。然后用户执行合适的操作。\n\n例如：Vector::operator可以检测所有越界访问并且抛出out_of_range异常：\n\ndouble& Vector::operator[](int i) {\n    if(!(0 < i && i < size()))\n        throw out_of_range{"Vector::operator[]"};\n    return elem[i];\n}\n\n\n1\n2\n3\n4\n5\n\n * throw指令创建了一个 out_of_range 类型的异常，并将异常的控制权转移给直接或者间接调用 Vector::operator[]() 函数的用户。\n * 要做到这点，编译器的实现需要回溯函数的调用栈并且找到调用者的上下文。\n * 这意味着异常处理机制将退出当前作用域并且把上下文回溯到对该异常感兴趣的调用者，在这个过程中可能会调用析构函数。\n\nvoid f(Vector& v)\n{\n    //...\n    try{\t\t\t\t\t\t\t//在这个区块抛出的out_of_range异常，使用下方处理器处理\n        compute1(v);\t\t\t\t//可能会试图访问v的结束以外的范围\n        Vector v2 = compute2(v);\t//可能会试图访问v的结束以外的范围\n        compute3(v2);\t\t\t\t//可能会试图访问v2的结束以外的范围\n    }\n    catch(const out_of_range& err){//哎呀，发生了out_of_range错误\n        //处理这个错误\n        cerr << err.what() << \'\\n\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 将想要捕获异常的代码放进一个try代码块。此处的catch语句用来处理类型为 out_of_range 的异常。\n * out_of_range 类型在标准库<stdexcept>中定义，事实上也已经被一些容器访问类标准库函数使用。\n * 这里使用引用来捕获异常以避免对异常变量的复制，同时使用 what() 函数打印输出被 throw 抛出的错误信息。\n\n异常处理机制可以是错误处理更简单、更系统化，同时提升可读性。\n\n让异常处理变得简单与系统化的主流技术（名为资源获取即初始化，RAII）。\n\nRAII的基本思想：让构造函数负责获取类需要的资源，同时让析构函数负责释放资源，这样就可让资源释放可靠地自动进行。\n\n\n# 4.2 断言机制\n\n\n# 4.2.1 assert\n\n标准库提供了一个调试宏，assert()，它可以在运行时断言必须满足的条件。\n\n例如：\n\nvoid f(const char* p) {\n    assert(p != nullptr);//p不可以是nullptr\n    // ...\n}\n\n\n1\n2\n3\n4\n\n\n如果assert()的条件不满足，在调试模式下，程序终止，在非调试模式下，assert()不被检查。这个功能简单粗暴而且不够灵活，当然也比什么都不做要强。\n\n\n# 4.2.2 static_assert\n\n异常用于报告在运行时发现的错误。但只要有可能，我们倾向于尽量让错误可以在编译时被发现。\n\nstatic_assert(4 <= sizeof(int), "integers are too small");//检查整数大小\n\n\n1\n\n\n如果4 <= sizeof(int)不满足（意思是：如果系统中的int类型不具备至少4字节长度）。则会输出integers are too small。我们把这种语句叫做断言。\n\n静态断言机制可以使用任何表达式：\n\nconstexpr double C = 299792.458;\t\t\t\t\t// km/s\nvoid f(double speed) {\n    constexpr double local_max = 160.0/(60*60);\t\t// 160km/h = 160.0/(60*60)km/s\n    static_assert(speed < C, "can\'t go that fast");\t// 错误：speed必须是常量\n    static_assert(local_max < C, "can\'t go that fast");// 可行\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 一般来说，如果A不为真，那么static_assert(A,S)打印输出S作为编译错误信息。\n * 如果你不需要某个特定的信息，可以忽略S参数，编译器会生成默认信息：static_assert(4 <= sizeof(int));//使用默认信息\n * 典型的默认信息通常由static_assert调用代码的位置加上断言内容的字符表述谓词构成。\n * 静态断言的一大重要用途是在泛型编程中对类型参数进行断言。\n\n\n# 4.2.3 noexcept\n\n如果一个函数绝不应当抛出异常，那么可以将它声明为noexcept。\n\nvoid user(int sz) noexcept\n{\n    Vector v(sz);\n    iota(&v[0],&v[sz],1);//将v填充为1，2，3，4...\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果所有的意图与设计都失败，user()函数依然抛出异常，系统会立即调用std::terminate中止这个程序。\n\n\n# 4.3 建议\n\n 1. 打开文件失败或到达迭代结束是预期事件而不是异常；\n 2. 在错误需要通过多层函数调用向上渗透时，抛出异常；\n 3. 如果不确定是使用异常还是错误代码，首选异常；\n 4. 优先使用RAII，而不是直接用try代码块；\n 5. 能在编译时检查的问题尽量在编译时检查；\n 6. 使用断言机制对故障进行单点控制；\n 7. Concepts是编译时的断言，因此经常用在断言中；\n 8. 如果你的函数不允许抛出异常，那么把它声明为noexcept；\n 9. 除非经过全面考虑，否则不要使用noexcept；',normalizedContent:'# cpp之旅（学习笔记）第4章 错误处理\n\n\n# 4.1 异常\n\n当我们试图越界访问vector动态数组时，应该发生什么？\n\n假定可从下标越界的访问错误中恢复，那么vector类的解决方案是实现者检测所有的越界访问并且告知用户。然后用户执行合适的操作。\n\n例如：vector::operator可以检测所有越界访问并且抛出out_of_range异常：\n\ndouble& vector::operator[](int i) {\n    if(!(0 < i && i < size()))\n        throw out_of_range{"vector::operator[]"};\n    return elem[i];\n}\n\n\n1\n2\n3\n4\n5\n\n * throw指令创建了一个 out_of_range 类型的异常，并将异常的控制权转移给直接或者间接调用 vector::operator[]() 函数的用户。\n * 要做到这点，编译器的实现需要回溯函数的调用栈并且找到调用者的上下文。\n * 这意味着异常处理机制将退出当前作用域并且把上下文回溯到对该异常感兴趣的调用者，在这个过程中可能会调用析构函数。\n\nvoid f(vector& v)\n{\n    //...\n    try{\t\t\t\t\t\t\t//在这个区块抛出的out_of_range异常，使用下方处理器处理\n        compute1(v);\t\t\t\t//可能会试图访问v的结束以外的范围\n        vector v2 = compute2(v);\t//可能会试图访问v的结束以外的范围\n        compute3(v2);\t\t\t\t//可能会试图访问v2的结束以外的范围\n    }\n    catch(const out_of_range& err){//哎呀，发生了out_of_range错误\n        //处理这个错误\n        cerr << err.what() << \'\\n\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 将想要捕获异常的代码放进一个try代码块。此处的catch语句用来处理类型为 out_of_range 的异常。\n * out_of_range 类型在标准库<stdexcept>中定义，事实上也已经被一些容器访问类标准库函数使用。\n * 这里使用引用来捕获异常以避免对异常变量的复制，同时使用 what() 函数打印输出被 throw 抛出的错误信息。\n\n异常处理机制可以是错误处理更简单、更系统化，同时提升可读性。\n\n让异常处理变得简单与系统化的主流技术（名为资源获取即初始化，raii）。\n\nraii的基本思想：让构造函数负责获取类需要的资源，同时让析构函数负责释放资源，这样就可让资源释放可靠地自动进行。\n\n\n# 4.2 断言机制\n\n\n# 4.2.1 assert\n\n标准库提供了一个调试宏，assert()，它可以在运行时断言必须满足的条件。\n\n例如：\n\nvoid f(const char* p) {\n    assert(p != nullptr);//p不可以是nullptr\n    // ...\n}\n\n\n1\n2\n3\n4\n\n\n如果assert()的条件不满足，在调试模式下，程序终止，在非调试模式下，assert()不被检查。这个功能简单粗暴而且不够灵活，当然也比什么都不做要强。\n\n\n# 4.2.2 static_assert\n\n异常用于报告在运行时发现的错误。但只要有可能，我们倾向于尽量让错误可以在编译时被发现。\n\nstatic_assert(4 <= sizeof(int), "integers are too small");//检查整数大小\n\n\n1\n\n\n如果4 <= sizeof(int)不满足（意思是：如果系统中的int类型不具备至少4字节长度）。则会输出integers are too small。我们把这种语句叫做断言。\n\n静态断言机制可以使用任何表达式：\n\nconstexpr double c = 299792.458;\t\t\t\t\t// km/s\nvoid f(double speed) {\n    constexpr double local_max = 160.0/(60*60);\t\t// 160km/h = 160.0/(60*60)km/s\n    static_assert(speed < c, "can\'t go that fast");\t// 错误：speed必须是常量\n    static_assert(local_max < c, "can\'t go that fast");// 可行\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 一般来说，如果a不为真，那么static_assert(a,s)打印输出s作为编译错误信息。\n * 如果你不需要某个特定的信息，可以忽略s参数，编译器会生成默认信息：static_assert(4 <= sizeof(int));//使用默认信息\n * 典型的默认信息通常由static_assert调用代码的位置加上断言内容的字符表述谓词构成。\n * 静态断言的一大重要用途是在泛型编程中对类型参数进行断言。\n\n\n# 4.2.3 noexcept\n\n如果一个函数绝不应当抛出异常，那么可以将它声明为noexcept。\n\nvoid user(int sz) noexcept\n{\n    vector v(sz);\n    iota(&v[0],&v[sz],1);//将v填充为1，2，3，4...\n    //...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果所有的意图与设计都失败，user()函数依然抛出异常，系统会立即调用std::terminate中止这个程序。\n\n\n# 4.3 建议\n\n 1. 打开文件失败或到达迭代结束是预期事件而不是异常；\n 2. 在错误需要通过多层函数调用向上渗透时，抛出异常；\n 3. 如果不确定是使用异常还是错误代码，首选异常；\n 4. 优先使用raii，而不是直接用try代码块；\n 5. 能在编译时检查的问题尽量在编译时检查；\n 6. 使用断言机制对故障进行单点控制；\n 7. concepts是编译时的断言，因此经常用在断言中；\n 8. 如果你的函数不允许抛出异常，那么把它声明为noexcept；\n 9. 除非经过全面考虑，否则不要使用noexcept；',charsets:{cjk:!0}},{title:"第5章 类",frontmatter:{title:"第5章 类",date:"2023-11-24T15:54:58.000Z",permalink:"/pages/1cb324/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/05.%E7%AC%AC5%E7%AB%A0%20%E7%B1%BB.html",relativePath:"01.CPP语言/01.Cpp之旅/05.第5章 类.md",key:"v-30f3c798",path:"/pages/1cb324/",headers:[{level:2,title:"5.1 类的概述",slug:"_5-1-类的概述",normalizedTitle:"5.1 类的概述",charIndex:23},{level:2,title:"5.2 具体类型",slug:"_5-2-具体类型",normalizedTitle:"5.2 具体类型",charIndex:145},{level:2,title:"5.3 容器",slug:"_5-3-容器",normalizedTitle:"5.3 容器",charIndex:365},{level:3,title:"5.3.1 容器的初始化",slug:"_5-3-1-容器的初始化",normalizedTitle:"5.3.1 容器的初始化",charIndex:1144},{level:2,title:"5.4 抽象类型",slug:"_5-4-抽象类型",normalizedTitle:"5.4 抽象类型",charIndex:1719},{level:2,title:"5.5 虚函数",slug:"_5-5-虚函数",normalizedTitle:"5.5 虚函数",charIndex:3208},{level:2,title:"5.6 类层次结构",slug:"_5-6-类层次结构",normalizedTitle:"5.6 类层次结构",charIndex:3300},{level:3,title:"5.6.1 类层次结构的益处",slug:"_5-6-1-类层次结构的益处",normalizedTitle:"5.6.1 类层次结构的益处",charIndex:3419},{level:3,title:"5.6.2 避免资源泄露",slug:"_5-6-2-避免资源泄露",normalizedTitle:"5.6.2 避免资源泄露",charIndex:3654},{level:2,title:"5.7 建议",slug:"_5-7-建议",normalizedTitle:"5.7 建议",charIndex:4216}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.59,time:95400,words:318},headersStr:"5.1 类的概述 5.2 具体类型 5.3 容器 5.3.1 容器的初始化 5.4 抽象类型 5.5 虚函数 5.6 类层次结构 5.6.1 类层次结构的益处 5.6.2 避免资源泄露 5.7 建议",content:"# Cpp之旅（学习笔记）第5章 类\n\n\n# 5.1 类的概述\n\nCpp最核心的语言特性就是类。\n\n类（class）是一种用户自定义的类型，用于在程序代码中表示某种实体。\n\n接下来，我们优先考虑对三种重要的类的基本支持：\n\n * 具体类。\n * 抽象类。\n * 类层次结构中的类。\n\n\n# 5.2 具体类型\n\n具体类的基本思想是它们的行为“就像内置类型一样”。\n\n> 例如：如数类型和无穷精度整数与内置的int非常像，当然它们有自己的语义和操作集合。\n\n具体类型的典型定义特征是：它的成员变量是其定义的一部分。\n\n它允许我们：\n\n * 把具体类型的对象置于栈、静态分配的内存或者其他对象中。\n * 直接引用对象（而非仅通过指针或引用）。\n * 创建对象后立即进行完整的初始化（比如使用构造函数）。\n * 拷贝与移动对象。\n\n\n# 5.3 容器\n\n容器是指一个包含若干元素的对象，因为Vector的对象都是容器，所以我们称Vector是一种容器类型。\n\nVector作为一种容器具有许多优点，但是存在一个致命的缺陷：它使用new分配元素，但从来没有释放这些元素。因此我们迫切需要一种机制以确保构造函数分配的内存一定会被销毁，这种机制就叫作析构函数：\n\nclass Vector {\npublic:\n    Vector(int s):elem{new double[s],sz{s}}{\t//构造函数：获取资源\n        for(int i = 0; i != s; ++i)\t\t\t\t//初始化元素\n            elem[i] = 0;\n    }\n    ~Vector(){delete[] elem;}\t\t\t\t\t//析构函数：释放资源\n    double& operator[](int i);\n    int size() const;\nprivate:\n    double* elem;\t\t\t\t\t\t\t\t//elem是指向有sz个double类型的元素的数组\n    int sz;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n析构函数的命名规则是在一个求补操作符~后面跟上类的名字，从含义上来说，它是构造函数的补充。\n\nVector的构造函数使用new操作符从自由存储（也称为堆或动态存储）分配一些内存空间，析构函数则使用delete[]操作符释放该空间以达到清理资源的目的。单独的delete释放一个独立对象，delete[]则释放一个数组。\n\n在构造函数中获取资源，然后在构造函数中释放它们，这种技术称为资源获取即初始化，又叫RAII。这种技术使得我们可避免“裸new操作”和“裸delete操作”，避免资源泄露。\n\n\n# 5.3.1 容器的初始化\n\n一种笨方法：先用若干元素创建一个Vector，然后再依次为这些元素赋值。显然这不够优雅。\n\n下面这两种更为简洁：\n\n * 初始值列表构造函数：使用元素列表进行初始化。\n * push_back()：在序列的末尾添加一个新元素。\n\nclass Vector{\npublic:\n    Vector();\t\t\t\t\t\t\t\t//默认初始化为空，意味着没有元素\n    Vector(std::initializer_list<double>);\t//使用double类型的值列表进行初始化\n    //...\n    void push_back(double);\t\t\t\t\t//在末尾添加一个元素，容器的长度加1\n    //...\n};\n//其中push_back()可用于添加任意数量的元素。\nVector read(istream& is)\n{\n    Vector v;\n    for(double d; is >> d; )\t//将浮点值读入d\n        v.push_back(d);\t\t\t//把d加到v中\n    return v;\n}\n//这里循环负责执行输入操作，终止条件是到达文件末尾或者遇到格式错误。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 5.4 抽象类型\n\nVector之所以被称为具体类型，是因为它们的实现属于定义的一部分。\n\n而，抽象类型把使用者与类的实现细节完全隔离开来。为此，我们将接口与实现解耦，并且放弃来的纯局部变量。因为我们对抽象类型的的实现一无所知，所以必须从自由存储为对象分配空间，然后通过引用或指针访问对象。\n\n首先，为Container类设计接口，Container类可以看成比Vector更抽象的一个版本：\n\nclass Container{\npublic:\n    virtual double& operator[](int) = 0;\t//纯虚函数\n    virtual int size() const = 0;\t\t\t//const成员函数\n    virtual ~Container(){}\t\t\t\t\t//析构函数\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面这个类是一个纯粹的接口。==关键字virtual的意思是“可能在随后的派生类中被重新定义”。==我们把这种关键字virtual声明的函数称为虚函数。===0说明该函数是纯虚函数，意味着“Container的派生类必须定义这个函数”。==\n\n因此：我们不能单纯定义一个Container的对象。\n\nContainer c;\t\t\t\t\t\t\t//错误，不可定义抽象类的对象\nContainer* p = new Vector_container(10);//可行，Container是Vector_container的接口\n\n\n1\n2\n\n\nContainer只是作为接口出现，它的派生类负责具体实现operator和size()函数。含有纯虚函数的类被称为抽象类。\n\nContainer的用法如下：\n\nvoid use(Container& c)\n{\n    const int sz = c.size();\n    for(int i = 0; i != sz; ++i)\n        cout << c[i] << '\\n';\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意：use()是如何在完全忽视实现细节的情况下使用Container接口的。它使用了size()和[]，却根本不知道是哪个类型做到的。\n\n我们把一个常用来为其他类型提供接口的类型为多态类型。\n\n作为一个抽象类，Container中没有构造函数，毕竟它不需要初始化数据。\n\n为了获得一个有用的容器，必须实现抽象类Container接口所需的函数，为此，可以使用具体类Vector：\n\nclass Vector_container : public Container {\npublic:\n    Vector_container(int s) : v(s) {}\n    ~Vector_container(){}\n    double& operator[](int i) override {return v[i];}\n    int size() const override {return v.size();}\nprivate:\n    Vector v;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 这里的：public可读作“派生自”或“是......的子类型”。\n * 派生类从它的基类继承成员，所以我们通常把基类和派生类的这种关联关系叫做继承。\n * 此处显示声明了override以描述程序员的意图。使用override指令是可选的。显示指定override在大型的类层次结构中特别有用，否则我们很难知道谁试图覆盖谁。\n\n\n# 5.5 虚函数\n\n编译器将虚函数的名字转换成函数指针表中对应的索引值，这张表就是所谓的虚函数表，或简称为vtbl。\n\n每个含有虚函数的类都有它直接的vtbl，用于辨识虚函数。\n\n\n# 5.6 类层次结构\n\nContainer是一个非常简单的类层次结构的例子，所谓类层次结构是指通过派生类（如public）创建的一组在框架中有序排列的类。\n\n比如：消防车是卡车的一种，卡车是车辆的一种；笑脸是一种圆，圆是一种形状。\n\n\n# 5.6.1 类层次结构的益处\n\n主要体现在以下两个方面：\n\n * 接口继承：派生类的对象可以被用在任何需要基类对象的地方。也就是说，基类看起来像是派生类的接口。\n * 实现继承：基类负责提供可以简化派生类实现的函数或数据。\n\n具体类，尤其是表现形式不复杂的类，具有非常类似于内置类型的行为：我们将其定义为局部变量，通过它们的名字进行访问或随意拷贝。\n\n类层次结构中的类则与之有所区别：我们倾向于通过new在自由存储中为其分配空间，然后=通过指针或引用访问它们。\n\n\n# 5.6.2 避免资源泄露\n\n当我们获取了资源并且没有释放它们的时候，通常用泄露这个词来描述。因为资源泄露导致系统无法访问相关资源，所以必须尽量避免。否则，资源泄露导致的资源耗尽，最终将导致系统卡顿或者崩溃。\n\n函数返回一个指向自由存储中的对象的指针是非常危险的：不应当用“旧式裸指针”来表达所有权。\n\nvoid user(int x)\n{\n    Shape* p = new Circle(Point{0,0},10);\n    //...\n    if(x < 0) throw Bad_x{};//潜在的泄露\n    if(x == 0) return;\t\t//潜在的泄露\n    //...\n    delete p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n除非x是正数，否则这都会造成泄露。将new的返回值赋值给“裸指针”是自找麻烦。\n\n上述问题的简单解决办法就是使用标准库unique_ptr替代\"裸指针\"\n\nclass Smiley : public Circle {\n    //...\nprivate:\n    vector<unique_ptr<Shape>> eyes;//通常是两只眼睛\n    unique_ptr<Shape> mouth;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.7 建议\n\n 1. 具体类是最简单的类，在适用的情况下，与复杂类或者普通数据结构相比，请优先选择使用具体类；\n 2. 如果成员函数不会改变对象的状态，则把它声明成const；\n 3. 如果类的构造函数获取了资源，那么类需要使用析构函数释放这些资源；\n 4. 避免“裸new”和“裸delete”操作；\n 5. 抽象类通常不需要构造函数；\n 6. 含有虚函数的类应该同时包含一个虚析构函数；\n 7. 在规模较大的类层次结构中使用override显式地指明函数覆盖；\n 8. 为了防止忘记用delete销毁 用new创建地对象，建议使用unique_ptr或者shared_ptr；",normalizedContent:"# cpp之旅（学习笔记）第5章 类\n\n\n# 5.1 类的概述\n\ncpp最核心的语言特性就是类。\n\n类（class）是一种用户自定义的类型，用于在程序代码中表示某种实体。\n\n接下来，我们优先考虑对三种重要的类的基本支持：\n\n * 具体类。\n * 抽象类。\n * 类层次结构中的类。\n\n\n# 5.2 具体类型\n\n具体类的基本思想是它们的行为“就像内置类型一样”。\n\n> 例如：如数类型和无穷精度整数与内置的int非常像，当然它们有自己的语义和操作集合。\n\n具体类型的典型定义特征是：它的成员变量是其定义的一部分。\n\n它允许我们：\n\n * 把具体类型的对象置于栈、静态分配的内存或者其他对象中。\n * 直接引用对象（而非仅通过指针或引用）。\n * 创建对象后立即进行完整的初始化（比如使用构造函数）。\n * 拷贝与移动对象。\n\n\n# 5.3 容器\n\n容器是指一个包含若干元素的对象，因为vector的对象都是容器，所以我们称vector是一种容器类型。\n\nvector作为一种容器具有许多优点，但是存在一个致命的缺陷：它使用new分配元素，但从来没有释放这些元素。因此我们迫切需要一种机制以确保构造函数分配的内存一定会被销毁，这种机制就叫作析构函数：\n\nclass vector {\npublic:\n    vector(int s):elem{new double[s],sz{s}}{\t//构造函数：获取资源\n        for(int i = 0; i != s; ++i)\t\t\t\t//初始化元素\n            elem[i] = 0;\n    }\n    ~vector(){delete[] elem;}\t\t\t\t\t//析构函数：释放资源\n    double& operator[](int i);\n    int size() const;\nprivate:\n    double* elem;\t\t\t\t\t\t\t\t//elem是指向有sz个double类型的元素的数组\n    int sz;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n析构函数的命名规则是在一个求补操作符~后面跟上类的名字，从含义上来说，它是构造函数的补充。\n\nvector的构造函数使用new操作符从自由存储（也称为堆或动态存储）分配一些内存空间，析构函数则使用delete[]操作符释放该空间以达到清理资源的目的。单独的delete释放一个独立对象，delete[]则释放一个数组。\n\n在构造函数中获取资源，然后在构造函数中释放它们，这种技术称为资源获取即初始化，又叫raii。这种技术使得我们可避免“裸new操作”和“裸delete操作”，避免资源泄露。\n\n\n# 5.3.1 容器的初始化\n\n一种笨方法：先用若干元素创建一个vector，然后再依次为这些元素赋值。显然这不够优雅。\n\n下面这两种更为简洁：\n\n * 初始值列表构造函数：使用元素列表进行初始化。\n * push_back()：在序列的末尾添加一个新元素。\n\nclass vector{\npublic:\n    vector();\t\t\t\t\t\t\t\t//默认初始化为空，意味着没有元素\n    vector(std::initializer_list<double>);\t//使用double类型的值列表进行初始化\n    //...\n    void push_back(double);\t\t\t\t\t//在末尾添加一个元素，容器的长度加1\n    //...\n};\n//其中push_back()可用于添加任意数量的元素。\nvector read(istream& is)\n{\n    vector v;\n    for(double d; is >> d; )\t//将浮点值读入d\n        v.push_back(d);\t\t\t//把d加到v中\n    return v;\n}\n//这里循环负责执行输入操作，终止条件是到达文件末尾或者遇到格式错误。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 5.4 抽象类型\n\nvector之所以被称为具体类型，是因为它们的实现属于定义的一部分。\n\n而，抽象类型把使用者与类的实现细节完全隔离开来。为此，我们将接口与实现解耦，并且放弃来的纯局部变量。因为我们对抽象类型的的实现一无所知，所以必须从自由存储为对象分配空间，然后通过引用或指针访问对象。\n\n首先，为container类设计接口，container类可以看成比vector更抽象的一个版本：\n\nclass container{\npublic:\n    virtual double& operator[](int) = 0;\t//纯虚函数\n    virtual int size() const = 0;\t\t\t//const成员函数\n    virtual ~container(){}\t\t\t\t\t//析构函数\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面这个类是一个纯粹的接口。==关键字virtual的意思是“可能在随后的派生类中被重新定义”。==我们把这种关键字virtual声明的函数称为虚函数。===0说明该函数是纯虚函数，意味着“container的派生类必须定义这个函数”。==\n\n因此：我们不能单纯定义一个container的对象。\n\ncontainer c;\t\t\t\t\t\t\t//错误，不可定义抽象类的对象\ncontainer* p = new vector_container(10);//可行，container是vector_container的接口\n\n\n1\n2\n\n\ncontainer只是作为接口出现，它的派生类负责具体实现operator和size()函数。含有纯虚函数的类被称为抽象类。\n\ncontainer的用法如下：\n\nvoid use(container& c)\n{\n    const int sz = c.size();\n    for(int i = 0; i != sz; ++i)\n        cout << c[i] << '\\n';\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n注意：use()是如何在完全忽视实现细节的情况下使用container接口的。它使用了size()和[]，却根本不知道是哪个类型做到的。\n\n我们把一个常用来为其他类型提供接口的类型为多态类型。\n\n作为一个抽象类，container中没有构造函数，毕竟它不需要初始化数据。\n\n为了获得一个有用的容器，必须实现抽象类container接口所需的函数，为此，可以使用具体类vector：\n\nclass vector_container : public container {\npublic:\n    vector_container(int s) : v(s) {}\n    ~vector_container(){}\n    double& operator[](int i) override {return v[i];}\n    int size() const override {return v.size();}\nprivate:\n    vector v;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 这里的：public可读作“派生自”或“是......的子类型”。\n * 派生类从它的基类继承成员，所以我们通常把基类和派生类的这种关联关系叫做继承。\n * 此处显示声明了override以描述程序员的意图。使用override指令是可选的。显示指定override在大型的类层次结构中特别有用，否则我们很难知道谁试图覆盖谁。\n\n\n# 5.5 虚函数\n\n编译器将虚函数的名字转换成函数指针表中对应的索引值，这张表就是所谓的虚函数表，或简称为vtbl。\n\n每个含有虚函数的类都有它直接的vtbl，用于辨识虚函数。\n\n\n# 5.6 类层次结构\n\ncontainer是一个非常简单的类层次结构的例子，所谓类层次结构是指通过派生类（如public）创建的一组在框架中有序排列的类。\n\n比如：消防车是卡车的一种，卡车是车辆的一种；笑脸是一种圆，圆是一种形状。\n\n\n# 5.6.1 类层次结构的益处\n\n主要体现在以下两个方面：\n\n * 接口继承：派生类的对象可以被用在任何需要基类对象的地方。也就是说，基类看起来像是派生类的接口。\n * 实现继承：基类负责提供可以简化派生类实现的函数或数据。\n\n具体类，尤其是表现形式不复杂的类，具有非常类似于内置类型的行为：我们将其定义为局部变量，通过它们的名字进行访问或随意拷贝。\n\n类层次结构中的类则与之有所区别：我们倾向于通过new在自由存储中为其分配空间，然后=通过指针或引用访问它们。\n\n\n# 5.6.2 避免资源泄露\n\n当我们获取了资源并且没有释放它们的时候，通常用泄露这个词来描述。因为资源泄露导致系统无法访问相关资源，所以必须尽量避免。否则，资源泄露导致的资源耗尽，最终将导致系统卡顿或者崩溃。\n\n函数返回一个指向自由存储中的对象的指针是非常危险的：不应当用“旧式裸指针”来表达所有权。\n\nvoid user(int x)\n{\n    shape* p = new circle(point{0,0},10);\n    //...\n    if(x < 0) throw bad_x{};//潜在的泄露\n    if(x == 0) return;\t\t//潜在的泄露\n    //...\n    delete p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n除非x是正数，否则这都会造成泄露。将new的返回值赋值给“裸指针”是自找麻烦。\n\n上述问题的简单解决办法就是使用标准库unique_ptr替代\"裸指针\"\n\nclass smiley : public circle {\n    //...\nprivate:\n    vector<unique_ptr<shape>> eyes;//通常是两只眼睛\n    unique_ptr<shape> mouth;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.7 建议\n\n 1. 具体类是最简单的类，在适用的情况下，与复杂类或者普通数据结构相比，请优先选择使用具体类；\n 2. 如果成员函数不会改变对象的状态，则把它声明成const；\n 3. 如果类的构造函数获取了资源，那么类需要使用析构函数释放这些资源；\n 4. 避免“裸new”和“裸delete”操作；\n 5. 抽象类通常不需要构造函数；\n 6. 含有虚函数的类应该同时包含一个虚析构函数；\n 7. 在规模较大的类层次结构中使用override显式地指明函数覆盖；\n 8. 为了防止忘记用delete销毁 用new创建地对象，建议使用unique_ptr或者shared_ptr；",charsets:{cjk:!0}},{title:"第6章 基本操作",frontmatter:{title:"第6章 基本操作",date:"2023-11-24T15:54:58.000Z",permalink:"/pages/fae683/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/07.%E7%AC%AC6%E7%AB%A0%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html",relativePath:"01.CPP语言/01.Cpp之旅/07.第6章 基本操作.md",key:"v-bf39c196",path:"/pages/fae683/",headers:[{level:2,title:"6.1 基本操作",slug:"_6-1-基本操作",normalizedTitle:"6.1 基本操作",charIndex:26},{level:3,title:"6.1.2 转换",slug:"_6-1-2-转换",normalizedTitle:"6.1.2 转换",charIndex:1015},{level:3,title:"6.1.3 成员初始值设定项",slug:"_6-1-3-成员初始值设定项",normalizedTitle:"6.1.3 成员初始值设定项",charIndex:2126},{level:2,title:"6.2 拷贝和移动",slug:"_6-2-拷贝和移动",normalizedTitle:"6.2 拷贝和移动",charIndex:2536},{level:3,title:"6.2.1 拷贝容器",slug:"_6-2-1-拷贝容器",normalizedTitle:"6.2.1 拷贝容器",charIndex:2617},{level:3,title:"6.2.2 移动容器",slug:"_6-2-2-移动容器",normalizedTitle:"6.2.2 移动容器",charIndex:3977},{level:2,title:"6.3 资源管理",slug:"_6-3-资源管理",normalizedTitle:"6.3 资源管理",charIndex:4720},{level:2,title:"6.4 建议",slug:"_6-4-建议",normalizedTitle:"6.4 建议",charIndex:5015}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.495,time:149700.00000000003,words:499},headersStr:"6.1 基本操作 6.1.2 转换 6.1.3 成员初始值设定项 6.2 拷贝和移动 6.2.1 拷贝容器 6.2.2 移动容器 6.3 资源管理 6.4 建议",content:'# Cpp之旅（学习笔记）第6章 基本操作\n\n\n# 6.1 基本操作\n\nclass X{\npublic:\n    X(Sometype);\t\t\t// "普通的构造函数": 创建一个对象\n    X();\t\t\t\t\t// 默认构造函数\n    X(const X&);\t\t\t// 拷贝构造函数\n    X(X&&);\t\t\t\t\t// 移动构造函数\n    X& operator=(const X&);\t// 拷贝赋值操作符：清空目标对象并拷贝\n    X& operator=(X&&);\t\t// 移动赋值操作符：清空目标对象并移动\n    ~X();\t\t\t\t\t// 析构函数：清理资源\n    //...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在下面5种情况下，对象会被移动或拷贝：\n\n * 赋值给其他对象。\n * 作为对象初始化。\n * 作为函数的实参。\n * 作为函数的返回值。\n * 作为异常。\n\n如果希望显示地使用函数的默认实现：在函数后面加上 =default\n\nclass Y{\npublic:\n    Y(Sometype);\n    Y(const Y&) = default;\t// 我确实需要默认的拷贝构造函数\n    Y(Y&&) = default;\t\t// 也确实需要默认的移动构造函数\n};\n\n\n1\n2\n3\n4\n5\n6\n\n * 一旦显示地指定了某些函数地默认形式，编译器就不会再为函数生成其他默认定义了。\n * 当类中含有指针成员时，最好显示地指定拷贝操作和移动操作。如果不这样做，当编译器生成地默认函数试图delete指针对象时，系统将发生错误。\n\n如果不想生成目标操作函数：在函数后面加上=delete\n\nclass Shape {\npublic:\n    Shape(const Shape&) =delete;\t\t// 禁止拷贝\n    Shape& operator=(const Shape&) =delete;\n    //...\n};\nvoid copy(Shape& s1, const Shape& s2)\n{\n    s1 = s2;\t\t\t\t\t\t\t// 错误：Shape禁止拷贝\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 试图使用=delete的函数会在编译时报错；=delete可以用于禁用任意函数，并非仅仅用于禁用基础成员函数。\n\n\n# 6.1.2 转换\n\n接受单个参数的构造函数同时定义了从参数类型到类类型的转换。\n\n例如：complex提供了一个接受double类型的参数的构造函数：\n\nclass complex {\n    double re,im;\t\t// 成员变量：两个双精度浮点数\npublic:\n    complex(double r,double i):re{r},im{i}{}\t// 用两个标量构建该复数\n    complex(double r):re{r},im{0}{}\t\t\t\t// 用一个标量构建该复数\n    complex():re{0},im{0}{}\t\t\t\t\t\t// 默认的复数是：{0，0}\n    //...\n};\ncomplex z1 = 3.14;\t// z1变成 {3.14，0.0}\ncomplex z2 = z1*2;\t// z2变成 z1*{2.0,0} == {6.28,0.0}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 这种转换有时似乎合情理，有时则不然。\n\n例如：Vector提供了一个接受int类型的参数构造函数：\n\nclass Vector{\nprivate:\n    double* elem;\n    int sz;\npublic:\n    Vector(int s):elem{new double[s]},sz{s}\n    {\n        for(int i = 0; i != s; ++i)\n            elem[i] = 0;\n    }\n    ~Vector(){delete[] elem;}\n    // ...\n};\nVector v1 = 7;\t\t// 可行：v1有7个元素\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 通常情况下，该语句的执行结果并非如我们的预期，标准库vector禁止这种int到vector的转换。\n\n解决该问题的办法是只允许显示进行类型转换：\n\nclass Vector{\npublic:\n    explicit Vector(int s);\t// 不能隐式地将int转化为Vector\n    // ...\n};\nVector v1(7);\t\t// 可行：v1有7个元素\nVector v2 = 7;\t\t// 错误：不能隐式地将int转化为Vector\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 关于类型转换地问题，complex只是一小部分，大多数类型地情况与Vector类似。\n\n所以除非你有充分地理由，否则最好把接受单个参数的构造函数声明成explicit的。\n\n\n# 6.1.3 成员初始值设定项\n\n定义类的数据成员时，可以提供默认的初始值，称其为默认成员初始值设定项。\n\n如下：修订版本的complex\n\nclass complex {\n    double re = 0;\n    double im = 0;\t// 表示两个默认值为0.0的double类型的成员\npublic: \n    complex(double r, double i) : re{r}, im{i} {}\t// 从两个标量{r,i}构造complex\n    complex(double r) : re{r} {}\t\t\t\t\t// 从一个标量{r,0}构造complex\n    complex() {}\t\t\t\t\t\t\t\t\t// 默认值为{0，0}的complex\n    // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对于所有构造函数没有提供初始值的成员，默认初始值都会起作用。\n\n\n# 6.2 拷贝和移动\n\n默认情况下，我们可以拷贝对象，不论是用户自定义类型的对象还是内置类型的对象。\n\n拷贝的默认含义是逐成员地复制，即依次复制每个成员。\n\n\n# 6.2.1 拷贝容器\n\n当一个类被作为资源句柄时，换句话说，当这个类负责通过指针访问一个对象时，采用默认的逐成员复制方式通常意味着会产生灾难性的错误。\n\n逐成员复制的方式会违反资源句柄的约束条件。\n\n例如：默认拷贝将产生Vector的一份拷贝，而这个拷贝所指向的元素与原来的元素是同一个：\n\nvoid bad_copy(Vector v1)\n{\n    Vector v2 = v1;\t// 将v1的表层拷贝到v2\n    v1[0] = 2;\t\t// v2[0]也变成了2\n    v2[1] = 3;\t\t// v1[1]也变成了3\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n假设v1包含4个元素，则结果如下图所示：\n\n\n\n类对象的拷贝操作可以通过两个成员来定义：拷贝函数与拷贝赋值操作符：\n\nclass Vector {\npublic:\n    Vector(int s);\n    ~Vector() { delete[] elem; }\n    \n    Vector(const Vector& a);\t\t\t\t// 拷贝构造函数\n    Vector& operator=(const Vector& a);\t\t// 拷贝赋值操作符\n    \n    double& operator[](int i);\n    const double& operator[](int i) const;\n    \n    int size() const;\nprivate:\n    double* elem;\n    int sz;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n对Vector来说，拷贝构造函数的正确定义应该首先为指定数量的元素分配空间，然后把元素复制到空间中。这样复制完成后，每个Vector就拥有自己的元素拷贝了：\n\nVector::Vector(const Vector& a) : elem {new double[a.sz]}, sz{a.sz}\t//拷贝构造函数，分配元素所需要的空间\n{\n    for(int i = 0; i != sz; ++i)\n        elem[i] = a.elem[i];\n}\n\n\n1\n2\n3\n4\n5\n\n\n在这个示例中，v2=v1的结果现在可以表示成：\n\n\n\n除了拷贝构造函数，我们还需要一个拷贝赋值操作符：\n\nVector& Vector::operator=(const Vector& a) \t// 拷贝赋值操作\n{\n    double* p = new double[a.sz];\n    for(int i = 0; i != a.sz; ++i)\n        p[i] = a.elem[i];\n    delete[] elem;\t\t\t\t\t\t\t// 删除旧元素\n    elem = p;\n    sz = a.sz;\n    return *this;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n其中，名字this被预定义在成员函数中，它指向调用该成员函数的那个对象。\n\n元素拷贝发生在旧元素被删除之前，所以如果在拷贝的过程中抛出异常，Vector的旧值可得以保留。\n\n\n# 6.2.2 移动容器\n\n对于大容量的容器，拷贝过程有可能消耗巨大。\n\n当给函数传递对象时，可通过使用引用类型来减少拷贝对象的代价，但是无法返回局部对象的引用（函数的调用者都没机会和返回结果碰面，局部对象就被销毁了）。\n\n我们相比于拷贝一个Vector对象，更希望移动它。\n\nclass Vector {\n    // ...\n    Vector(const Vector& a);\t\t\t// 拷贝构造函数（复制构造）\n    Vector& operator=(const Vector& a);\t// 拷贝赋值操作符（复制赋值）\n    \n    Vector(Vector&& a);\t\t\t\t\t// 移动构造函数\n    Vector& operator=(Vector&& a);\t\t// 移动赋值操作符\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n基于上述定义，编译器将选择移动构造函数来执行从函数中移出返回值的任务。\n\n定义Vector移动构造函数的过程非常简单：\n\nVector::Vector(Vector&& a) : elem {a.elem}, sz{a.sz}\n{\n    a.elem = nullptr;\t//现在a中没有任何元素\n    a.sz = 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n符号&&的意思是”右值引用“，右值的含义与左值正好相反。\n\n左值的大致含义是 ”能出现在赋值操作符左侧的内容“，因此右值大致上就是无法为其赋值的值，比如函数调用返回的一个整数就是右值。进一步地，右值引用地含义就是引用了一个别人无法赋值地内容，所以我们可以安全地”窃取“它的值。\n\n移动构造函数不接受const实参：毕竟移动构造函数最终要删除它实参中的值。\n\n\n# 6.3 资源管理\n\n通过定义构造函数、拷贝操作、移动操作和析构函数，程序员就能对受控资源（比如容器中元素）的生命周期进行完全控制。\n\n内存也不是唯一的一种资源。资源是指任何在使用前需要获取与（显示或隐式）释放的东西，除了内存，还有锁、套接字、文件句柄和线程句柄等非内存资源。\n\n在Cpp标准库中，RAII无处不在：例如，内存（string、vector、map、unordered_map等）、文件（ifstream、ofstream等）、线程（thread）、锁（lock_guard、unique_lock等）和通用对象（通过unique_ptr和shared_ptr访问）。\n\n\n# 6.4 建议\n\n 1.  尽量让对象的构造、拷贝（复制）、移动和销毁、在掌控之中；\n 2.  同时定义所有的基本操作，或者什么都不定义；\n 3.  如果默认的构造函数、赋值操作符和析构函数符合要求、那么让编译器负责生成它们；\n 4.  如果类含有指针成员，考虑这个类是否需要用户自定义或者删除析构函数、拷贝函数及移动函数；\n 5.  默认情况下，把单参数的构造函数声明成explicit的；\n 6.  如果默认拷贝函数不适合当前类型，则重新定义或禁止拷贝函数；\n 7.  用传值的方式返回容器（依赖拷贝消除和移动以提高效率）；\n 8.  避免显示使用std::copy()；\n 9.  对于容量较大的操作数，使用const引用作为参数类型；\n 10. 使用RAII管理所有资源——内存和非内存资源；',normalizedContent:'# cpp之旅（学习笔记）第6章 基本操作\n\n\n# 6.1 基本操作\n\nclass x{\npublic:\n    x(sometype);\t\t\t// "普通的构造函数": 创建一个对象\n    x();\t\t\t\t\t// 默认构造函数\n    x(const x&);\t\t\t// 拷贝构造函数\n    x(x&&);\t\t\t\t\t// 移动构造函数\n    x& operator=(const x&);\t// 拷贝赋值操作符：清空目标对象并拷贝\n    x& operator=(x&&);\t\t// 移动赋值操作符：清空目标对象并移动\n    ~x();\t\t\t\t\t// 析构函数：清理资源\n    //...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在下面5种情况下，对象会被移动或拷贝：\n\n * 赋值给其他对象。\n * 作为对象初始化。\n * 作为函数的实参。\n * 作为函数的返回值。\n * 作为异常。\n\n如果希望显示地使用函数的默认实现：在函数后面加上 =default\n\nclass y{\npublic:\n    y(sometype);\n    y(const y&) = default;\t// 我确实需要默认的拷贝构造函数\n    y(y&&) = default;\t\t// 也确实需要默认的移动构造函数\n};\n\n\n1\n2\n3\n4\n5\n6\n\n * 一旦显示地指定了某些函数地默认形式，编译器就不会再为函数生成其他默认定义了。\n * 当类中含有指针成员时，最好显示地指定拷贝操作和移动操作。如果不这样做，当编译器生成地默认函数试图delete指针对象时，系统将发生错误。\n\n如果不想生成目标操作函数：在函数后面加上=delete\n\nclass shape {\npublic:\n    shape(const shape&) =delete;\t\t// 禁止拷贝\n    shape& operator=(const shape&) =delete;\n    //...\n};\nvoid copy(shape& s1, const shape& s2)\n{\n    s1 = s2;\t\t\t\t\t\t\t// 错误：shape禁止拷贝\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 试图使用=delete的函数会在编译时报错；=delete可以用于禁用任意函数，并非仅仅用于禁用基础成员函数。\n\n\n# 6.1.2 转换\n\n接受单个参数的构造函数同时定义了从参数类型到类类型的转换。\n\n例如：complex提供了一个接受double类型的参数的构造函数：\n\nclass complex {\n    double re,im;\t\t// 成员变量：两个双精度浮点数\npublic:\n    complex(double r,double i):re{r},im{i}{}\t// 用两个标量构建该复数\n    complex(double r):re{r},im{0}{}\t\t\t\t// 用一个标量构建该复数\n    complex():re{0},im{0}{}\t\t\t\t\t\t// 默认的复数是：{0，0}\n    //...\n};\ncomplex z1 = 3.14;\t// z1变成 {3.14，0.0}\ncomplex z2 = z1*2;\t// z2变成 z1*{2.0,0} == {6.28,0.0}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 这种转换有时似乎合情理，有时则不然。\n\n例如：vector提供了一个接受int类型的参数构造函数：\n\nclass vector{\nprivate:\n    double* elem;\n    int sz;\npublic:\n    vector(int s):elem{new double[s]},sz{s}\n    {\n        for(int i = 0; i != s; ++i)\n            elem[i] = 0;\n    }\n    ~vector(){delete[] elem;}\n    // ...\n};\nvector v1 = 7;\t\t// 可行：v1有7个元素\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 通常情况下，该语句的执行结果并非如我们的预期，标准库vector禁止这种int到vector的转换。\n\n解决该问题的办法是只允许显示进行类型转换：\n\nclass vector{\npublic:\n    explicit vector(int s);\t// 不能隐式地将int转化为vector\n    // ...\n};\nvector v1(7);\t\t// 可行：v1有7个元素\nvector v2 = 7;\t\t// 错误：不能隐式地将int转化为vector\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 关于类型转换地问题，complex只是一小部分，大多数类型地情况与vector类似。\n\n所以除非你有充分地理由，否则最好把接受单个参数的构造函数声明成explicit的。\n\n\n# 6.1.3 成员初始值设定项\n\n定义类的数据成员时，可以提供默认的初始值，称其为默认成员初始值设定项。\n\n如下：修订版本的complex\n\nclass complex {\n    double re = 0;\n    double im = 0;\t// 表示两个默认值为0.0的double类型的成员\npublic: \n    complex(double r, double i) : re{r}, im{i} {}\t// 从两个标量{r,i}构造complex\n    complex(double r) : re{r} {}\t\t\t\t\t// 从一个标量{r,0}构造complex\n    complex() {}\t\t\t\t\t\t\t\t\t// 默认值为{0，0}的complex\n    // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对于所有构造函数没有提供初始值的成员，默认初始值都会起作用。\n\n\n# 6.2 拷贝和移动\n\n默认情况下，我们可以拷贝对象，不论是用户自定义类型的对象还是内置类型的对象。\n\n拷贝的默认含义是逐成员地复制，即依次复制每个成员。\n\n\n# 6.2.1 拷贝容器\n\n当一个类被作为资源句柄时，换句话说，当这个类负责通过指针访问一个对象时，采用默认的逐成员复制方式通常意味着会产生灾难性的错误。\n\n逐成员复制的方式会违反资源句柄的约束条件。\n\n例如：默认拷贝将产生vector的一份拷贝，而这个拷贝所指向的元素与原来的元素是同一个：\n\nvoid bad_copy(vector v1)\n{\n    vector v2 = v1;\t// 将v1的表层拷贝到v2\n    v1[0] = 2;\t\t// v2[0]也变成了2\n    v2[1] = 3;\t\t// v1[1]也变成了3\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n假设v1包含4个元素，则结果如下图所示：\n\n\n\n类对象的拷贝操作可以通过两个成员来定义：拷贝函数与拷贝赋值操作符：\n\nclass vector {\npublic:\n    vector(int s);\n    ~vector() { delete[] elem; }\n    \n    vector(const vector& a);\t\t\t\t// 拷贝构造函数\n    vector& operator=(const vector& a);\t\t// 拷贝赋值操作符\n    \n    double& operator[](int i);\n    const double& operator[](int i) const;\n    \n    int size() const;\nprivate:\n    double* elem;\n    int sz;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n对vector来说，拷贝构造函数的正确定义应该首先为指定数量的元素分配空间，然后把元素复制到空间中。这样复制完成后，每个vector就拥有自己的元素拷贝了：\n\nvector::vector(const vector& a) : elem {new double[a.sz]}, sz{a.sz}\t//拷贝构造函数，分配元素所需要的空间\n{\n    for(int i = 0; i != sz; ++i)\n        elem[i] = a.elem[i];\n}\n\n\n1\n2\n3\n4\n5\n\n\n在这个示例中，v2=v1的结果现在可以表示成：\n\n\n\n除了拷贝构造函数，我们还需要一个拷贝赋值操作符：\n\nvector& vector::operator=(const vector& a) \t// 拷贝赋值操作\n{\n    double* p = new double[a.sz];\n    for(int i = 0; i != a.sz; ++i)\n        p[i] = a.elem[i];\n    delete[] elem;\t\t\t\t\t\t\t// 删除旧元素\n    elem = p;\n    sz = a.sz;\n    return *this;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n其中，名字this被预定义在成员函数中，它指向调用该成员函数的那个对象。\n\n元素拷贝发生在旧元素被删除之前，所以如果在拷贝的过程中抛出异常，vector的旧值可得以保留。\n\n\n# 6.2.2 移动容器\n\n对于大容量的容器，拷贝过程有可能消耗巨大。\n\n当给函数传递对象时，可通过使用引用类型来减少拷贝对象的代价，但是无法返回局部对象的引用（函数的调用者都没机会和返回结果碰面，局部对象就被销毁了）。\n\n我们相比于拷贝一个vector对象，更希望移动它。\n\nclass vector {\n    // ...\n    vector(const vector& a);\t\t\t// 拷贝构造函数（复制构造）\n    vector& operator=(const vector& a);\t// 拷贝赋值操作符（复制赋值）\n    \n    vector(vector&& a);\t\t\t\t\t// 移动构造函数\n    vector& operator=(vector&& a);\t\t// 移动赋值操作符\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n基于上述定义，编译器将选择移动构造函数来执行从函数中移出返回值的任务。\n\n定义vector移动构造函数的过程非常简单：\n\nvector::vector(vector&& a) : elem {a.elem}, sz{a.sz}\n{\n    a.elem = nullptr;\t//现在a中没有任何元素\n    a.sz = 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n符号&&的意思是”右值引用“，右值的含义与左值正好相反。\n\n左值的大致含义是 ”能出现在赋值操作符左侧的内容“，因此右值大致上就是无法为其赋值的值，比如函数调用返回的一个整数就是右值。进一步地，右值引用地含义就是引用了一个别人无法赋值地内容，所以我们可以安全地”窃取“它的值。\n\n移动构造函数不接受const实参：毕竟移动构造函数最终要删除它实参中的值。\n\n\n# 6.3 资源管理\n\n通过定义构造函数、拷贝操作、移动操作和析构函数，程序员就能对受控资源（比如容器中元素）的生命周期进行完全控制。\n\n内存也不是唯一的一种资源。资源是指任何在使用前需要获取与（显示或隐式）释放的东西，除了内存，还有锁、套接字、文件句柄和线程句柄等非内存资源。\n\n在cpp标准库中，raii无处不在：例如，内存（string、vector、map、unordered_map等）、文件（ifstream、ofstream等）、线程（thread）、锁（lock_guard、unique_lock等）和通用对象（通过unique_ptr和shared_ptr访问）。\n\n\n# 6.4 建议\n\n 1.  尽量让对象的构造、拷贝（复制）、移动和销毁、在掌控之中；\n 2.  同时定义所有的基本操作，或者什么都不定义；\n 3.  如果默认的构造函数、赋值操作符和析构函数符合要求、那么让编译器负责生成它们；\n 4.  如果类含有指针成员，考虑这个类是否需要用户自定义或者删除析构函数、拷贝函数及移动函数；\n 5.  默认情况下，把单参数的构造函数声明成explicit的；\n 6.  如果默认拷贝函数不适合当前类型，则重新定义或禁止拷贝函数；\n 7.  用传值的方式返回容器（依赖拷贝消除和移动以提高效率）；\n 8.  避免显示使用std::copy()；\n 9.  对于容量较大的操作数，使用const引用作为参数类型；\n 10. 使用raii管理所有资源——内存和非内存资源；',charsets:{cjk:!0}},{title:"第7章 模板",frontmatter:{title:"第7章 模板",date:"2023-11-24T15:54:58.000Z",permalink:"/pages/2cdace/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/08.%E7%AC%AC7%E7%AB%A0%20%E6%A8%A1%E6%9D%BF.html",relativePath:"01.CPP语言/01.Cpp之旅/08.第7章 模板.md",key:"v-3448b2e6",path:"/pages/2cdace/",headers:[{level:2,title:"7.1 参数化类型",slug:"_7-1-参数化类型",normalizedTitle:"7.1 参数化类型",charIndex:56},{level:2,title:"7.2 受限模板参数",slug:"_7-2-受限模板参数",normalizedTitle:"7.2 受限模板参数",charIndex:1372},{level:3,title:"7.2.1 模板参数值",slug:"_7-2-1-模板参数值",normalizedTitle:"7.2.1 模板参数值",charIndex:1652},{level:3,title:"7.2.2 模板参数推导",slug:"_7-2-2-模板参数推导",normalizedTitle:"7.2.2 模板参数推导",charIndex:2254},{level:2,title:"7.3 参数化操作",slug:"_7-3-参数化操作",normalizedTitle:"7.3 参数化操作",charIndex:2718},{level:3,title:"7.4 函数对象",slug:"_7-4-函数对象",normalizedTitle:"7.4 函数对象",charIndex:2905},{level:2,title:"7.5 匿名函数表达式(lambda)",slug:"_7-5-匿名函数表达式-lambda",normalizedTitle:"7.5 匿名函数表达式(lambda)",charIndex:3211},{level:2,title:"7.6 作用域终结函数",slug:"_7-6-作用域终结函数",normalizedTitle:"7.6 作用域终结函数",charIndex:3507},{level:2,title:"7.7 模板机制",slug:"_7-7-模板机制",normalizedTitle:"7.7 模板机制",charIndex:4114},{level:2,title:"7.8 建议",slug:"_7-8-建议",normalizedTitle:"7.8 建议",charIndex:4215}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.165,time:129900,words:433},headersStr:"7.1 参数化类型 7.2 受限模板参数 7.2.1 模板参数值 7.2.2 模板参数推导 7.3 参数化操作 7.4 函数对象 7.5 匿名函数表达式(lambda) 7.6 作用域终结函数 7.7 模板机制 7.8 建议",content:'# Cpp之旅（学习笔记）第7章 模板\n\n模板是一个类或者一个函数，我们用一组类型或值对其进行参数化。\n\n\n# 7.1 参数化类型\n\ntemplate <typename T>\nclass Vector {\nprivate:\n    T* elem;\n    int sz;\npublic:\n    explicit Vector(int s);\n    ~Vector(){ delete[] elem;}\n    T& operator[](int i);\t\t\t\t//对于非常量的Vector\n    const T& operator[](int i) const; \t//对于常量Vector\n    int size() const {return sz;}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n前缀template <typename T>指明T是该声明的形参。在引出类型参数时，使用class和使用typename是等价的，在旧式代码中经常出现将template <class T>作为前缀。\n\n成员函数的定义方式与之类似：\n\ntemplate<typename T>\nVector<T>::Vector(int s)\n{\n    if(s < 0)\n        throw length_error{"Vector constructor: negative size"};\n    elem = new T[s];\n    sz = s;\n}\ntemplate<typename T>\nconst T& Vector<T>::operator[](int i) const\n{\n    if(i < 0 || size() <= i)\n        throw out_of_range{"Vector::operator[]"};\n    return elem[i];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n可以用如下方式声明动态数组Vector：\n\nVector<char> vc(200);\t\t// 200个字符组成的动态数组\nVector<string> vs(17);\t\t// 17个字符串组成的动态数组\nVector<list<int>> vli(45);\t// 45个整数链表组成的动态数组\n\n\n1\n2\n3\n\n\n为了让Vector支持范围for循环，需要为之定义适当的begin()和end()函数：\n\ntemplate<typename T>\nT* begin(Vector<T>& x)\n{\n    return &x[0];\t\t\t// 指向第一个元素，或者指向末尾元素后面的一个位置\n}\ntemplate<typename T>\nT* end(Vector<T>& x)\n{\n    return &x[0]+x.size();\t// 指向末尾元素后面的一个位置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 模板是一种编译时的机制，因此与“手工编码”相比，它并不会产生任何额外的运行时开销。\n * 模板加上一系列模板参数被统称为实例化或者特例化。在编译过程中进行实例化时，每个实例都会生成一份代码。\n\n\n# 7.2 受限模板参数\n\nVector的模板参数仅仅是一个typename还不够，还需要指定Element满足特定需求才能成为其元素：\n\ntemplate<Element T>\nclass Vector {\nprivate:\n    T* elem;\n    int sz;\n    // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里，template<Element T>Element是一个谓词，用于检查T是否满足Vector需要的特性。\n\n这种谓词叫做概念。在模板参数中指定一个概念，这叫作受限模板参数，拥有这种参数的模板叫作受限模板。\n\n\n# 7.2.1 模板参数值\n\n除了类型参数以外，模板还支持值作为参数。\n\ntemplate<typename T, int N>\nstruct Buffer{\n    constexpr int size() {return N;}\n    T elem[N];\n    // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n值参数在很多环境中都有用。例如：Buffer允许我们创建任意尺寸的缓冲区而不需要使用动态内存分配：\n\nBuffer<char,1024> glob;\t\t// 静态分配的全局char缓冲区\nvoid fct()\n{\n    Buffer<int,10> buf;\t\t// 栈上分配的本地int缓冲区\n    // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是，字符串字面量不可以作为模板值参数。但我们可以使用存放字符的数组来表示字符串：\n\ntemplate<char* s>\nvoid outs()\n{ \n    cout << s; \n}\n\nchar arr[] = "Werid workaround";\nvoid use()\n{\n    outs <"straightforward use">();\t\t// 到目前为止，这样不可行\n    outs<arr>();\t\t\t\t\t\t// 诡异的间接解决方案\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 7.2.2 模板参数推导\n\n指定模板参数类型显得有些冗长，考虑使用标准库模板pair：\n\npair<int,double> p = {1, 5.2};\n// 等价于\npair p = {1, 5.2};\n\n\n1\n2\n3\n\n\n可以使用s后缀把字符串变成一个正确的string\n\ntemplate<typename T>\nclass Vector {\npublic:\n    Vector(int);\n    Vector(initializer_list<T>);\t\t// 初始化列表构造函数\n    // ...\n};\n\nVector<string> vs {"Hello", "World"};\t// 可行：Vector<string>\nVector vs1 {"Hello"s, "World"s};\t\t// 可行：推导为Vector<string>\nVector vs2 {"Hello"s, "World"};\t\t\t// 错误：初始化列表中的数据类型不一致\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7.3 参数化操作\n\n模板还被广泛用于参数化标准库中的类型与算法。\n\n要想表达将操作用类型或者值来参数化，有三种方法：\n\n * 模板函数。\n * 函数对象：对象可以携带数据，并且以函数的形式调用。\n * 匿名函数表达式：函数对象的简略记法。\n\n==模板函数可以是成员函数，但不能是virtual函数。编译器不可能知道模板的所有实例，所以不可能像函数一样被调用。==\n\n\n# 7.4 函数对象\n\n一种特别有用的模板叫作函数对象（有时也被称为仿函数），它可以用来定义对象，该对象可以像函数一样被调用。\n\ntemplate<typename T>\nclass Less_than{\n    const T val;\npublic:\n    Less_than(const T& v):val(v){}\n    bool operator()(const T& x) const {return x < val;}\t//函数调用操作符\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n名叫operator()的函数实现了应用操作符()，这个操作符又可被称作“函数调用操作符”“调用操作符”。\n\n\n# 7.5 匿名函数表达式(lambda)\n\n匿名函数表达式（lambda）\n\n[&](int a){ return a < x; }\n\n\n1\n\n\n[&]是匿名函数的捕获列表，它指定了函数体内所有局部变量可以以引用的形式被访问。\n\n * 只捕获x这一个变量，使用[&x]；\n * 生成x的一份拷贝，使用[x]；\n * 什么都不捕获，使用[]；\n * 以引用的方式捕获所有局部变量，使用[&]；\n * 以值的方式捕获所有局部变量，使用[=]；\n * 如果成员函数中定义匿名函数，使用[this]来捕获当前对象；\n * 如果成员函数中定义匿名函数，可以使用[*this]捕获当前对象的拷贝。\n\n\n# 7.6 作用域终结函数\n\n析构函数提供了一种通用的方案，用于在作用域结束时隐式清除所有使用过的对象RAII，但如果需要进行的清理涉及多个对象，或者涉及不含析构函数的对象，可以定义一个finally()函数，它在作用域结束时执行：\n\nvoid old_style(int n)\n{\n    void *p = malloc(n* sizeof(int));\n    auto act = finally([&]{free(p);});\t// 作用域结束时调用该匿名函数\n}\n\n\n1\n2\n3\n4\n5\n\n\n实现finally()函数的方法：\n\ntemplate<class F>\n[[nodiscard]] auto finally(F f)\n{\n    return Final_action{f};\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里使用了[[nodiscard]]属性修饰，确保用户不会忘记保存所生成的返回值Final_action，因为正常完成功能必须保存它。\n\n用来提供析构函数的类Final_action可以写成下面这样：\n\ntemplate<class F>\nstruct Final_action{\n    explicit Final_action(F f):act(f){}\n    ~Final_action(){act();}\n    F act;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.7 模板机制\n\n * 依赖类型的值：参数模板\n * 类型与模板的别名：别名模板\n * 编译时选择机制：if constexpr\n * 编译时查询值与表达式属性的机制：requires表达式\n\n\n# 7.8 建议\n\n 1.  用模板来表达那些可以用于多种参数类型的算法；\n 2.  用模板实现容器；\n 3.  用模板提升代码的抽象层次；\n 4.  让构造函数或函数模板推断出类模板实参类型；\n 5.  把函数对象作为算法的参数；\n 6.  如果简单的函数对象只在某处使用一次，不妨使用匿名函数；\n 7.  不能把虚函数成员定义成模板成员函数；\n 8.  使用finally()为不带析构函数且需要“清理操作”的类型提供RAII；\n 9.  利用模板别名来简化符号并隐藏实现细节；\n 10. 使用if constexpr条件编译提供替代实现，不会存在运行时开销；',normalizedContent:'# cpp之旅（学习笔记）第7章 模板\n\n模板是一个类或者一个函数，我们用一组类型或值对其进行参数化。\n\n\n# 7.1 参数化类型\n\ntemplate <typename t>\nclass vector {\nprivate:\n    t* elem;\n    int sz;\npublic:\n    explicit vector(int s);\n    ~vector(){ delete[] elem;}\n    t& operator[](int i);\t\t\t\t//对于非常量的vector\n    const t& operator[](int i) const; \t//对于常量vector\n    int size() const {return sz;}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n前缀template <typename t>指明t是该声明的形参。在引出类型参数时，使用class和使用typename是等价的，在旧式代码中经常出现将template <class t>作为前缀。\n\n成员函数的定义方式与之类似：\n\ntemplate<typename t>\nvector<t>::vector(int s)\n{\n    if(s < 0)\n        throw length_error{"vector constructor: negative size"};\n    elem = new t[s];\n    sz = s;\n}\ntemplate<typename t>\nconst t& vector<t>::operator[](int i) const\n{\n    if(i < 0 || size() <= i)\n        throw out_of_range{"vector::operator[]"};\n    return elem[i];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n可以用如下方式声明动态数组vector：\n\nvector<char> vc(200);\t\t// 200个字符组成的动态数组\nvector<string> vs(17);\t\t// 17个字符串组成的动态数组\nvector<list<int>> vli(45);\t// 45个整数链表组成的动态数组\n\n\n1\n2\n3\n\n\n为了让vector支持范围for循环，需要为之定义适当的begin()和end()函数：\n\ntemplate<typename t>\nt* begin(vector<t>& x)\n{\n    return &x[0];\t\t\t// 指向第一个元素，或者指向末尾元素后面的一个位置\n}\ntemplate<typename t>\nt* end(vector<t>& x)\n{\n    return &x[0]+x.size();\t// 指向末尾元素后面的一个位置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 模板是一种编译时的机制，因此与“手工编码”相比，它并不会产生任何额外的运行时开销。\n * 模板加上一系列模板参数被统称为实例化或者特例化。在编译过程中进行实例化时，每个实例都会生成一份代码。\n\n\n# 7.2 受限模板参数\n\nvector的模板参数仅仅是一个typename还不够，还需要指定element满足特定需求才能成为其元素：\n\ntemplate<element t>\nclass vector {\nprivate:\n    t* elem;\n    int sz;\n    // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里，template<element t>element是一个谓词，用于检查t是否满足vector需要的特性。\n\n这种谓词叫做概念。在模板参数中指定一个概念，这叫作受限模板参数，拥有这种参数的模板叫作受限模板。\n\n\n# 7.2.1 模板参数值\n\n除了类型参数以外，模板还支持值作为参数。\n\ntemplate<typename t, int n>\nstruct buffer{\n    constexpr int size() {return n;}\n    t elem[n];\n    // ...\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n值参数在很多环境中都有用。例如：buffer允许我们创建任意尺寸的缓冲区而不需要使用动态内存分配：\n\nbuffer<char,1024> glob;\t\t// 静态分配的全局char缓冲区\nvoid fct()\n{\n    buffer<int,10> buf;\t\t// 栈上分配的本地int缓冲区\n    // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是，字符串字面量不可以作为模板值参数。但我们可以使用存放字符的数组来表示字符串：\n\ntemplate<char* s>\nvoid outs()\n{ \n    cout << s; \n}\n\nchar arr[] = "werid workaround";\nvoid use()\n{\n    outs <"straightforward use">();\t\t// 到目前为止，这样不可行\n    outs<arr>();\t\t\t\t\t\t// 诡异的间接解决方案\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 7.2.2 模板参数推导\n\n指定模板参数类型显得有些冗长，考虑使用标准库模板pair：\n\npair<int,double> p = {1, 5.2};\n// 等价于\npair p = {1, 5.2};\n\n\n1\n2\n3\n\n\n可以使用s后缀把字符串变成一个正确的string\n\ntemplate<typename t>\nclass vector {\npublic:\n    vector(int);\n    vector(initializer_list<t>);\t\t// 初始化列表构造函数\n    // ...\n};\n\nvector<string> vs {"hello", "world"};\t// 可行：vector<string>\nvector vs1 {"hello"s, "world"s};\t\t// 可行：推导为vector<string>\nvector vs2 {"hello"s, "world"};\t\t\t// 错误：初始化列表中的数据类型不一致\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7.3 参数化操作\n\n模板还被广泛用于参数化标准库中的类型与算法。\n\n要想表达将操作用类型或者值来参数化，有三种方法：\n\n * 模板函数。\n * 函数对象：对象可以携带数据，并且以函数的形式调用。\n * 匿名函数表达式：函数对象的简略记法。\n\n==模板函数可以是成员函数，但不能是virtual函数。编译器不可能知道模板的所有实例，所以不可能像函数一样被调用。==\n\n\n# 7.4 函数对象\n\n一种特别有用的模板叫作函数对象（有时也被称为仿函数），它可以用来定义对象，该对象可以像函数一样被调用。\n\ntemplate<typename t>\nclass less_than{\n    const t val;\npublic:\n    less_than(const t& v):val(v){}\n    bool operator()(const t& x) const {return x < val;}\t//函数调用操作符\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n名叫operator()的函数实现了应用操作符()，这个操作符又可被称作“函数调用操作符”“调用操作符”。\n\n\n# 7.5 匿名函数表达式(lambda)\n\n匿名函数表达式（lambda）\n\n[&](int a){ return a < x; }\n\n\n1\n\n\n[&]是匿名函数的捕获列表，它指定了函数体内所有局部变量可以以引用的形式被访问。\n\n * 只捕获x这一个变量，使用[&x]；\n * 生成x的一份拷贝，使用[x]；\n * 什么都不捕获，使用[]；\n * 以引用的方式捕获所有局部变量，使用[&]；\n * 以值的方式捕获所有局部变量，使用[=]；\n * 如果成员函数中定义匿名函数，使用[this]来捕获当前对象；\n * 如果成员函数中定义匿名函数，可以使用[*this]捕获当前对象的拷贝。\n\n\n# 7.6 作用域终结函数\n\n析构函数提供了一种通用的方案，用于在作用域结束时隐式清除所有使用过的对象raii，但如果需要进行的清理涉及多个对象，或者涉及不含析构函数的对象，可以定义一个finally()函数，它在作用域结束时执行：\n\nvoid old_style(int n)\n{\n    void *p = malloc(n* sizeof(int));\n    auto act = finally([&]{free(p);});\t// 作用域结束时调用该匿名函数\n}\n\n\n1\n2\n3\n4\n5\n\n\n实现finally()函数的方法：\n\ntemplate<class f>\n[[nodiscard]] auto finally(f f)\n{\n    return final_action{f};\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里使用了[[nodiscard]]属性修饰，确保用户不会忘记保存所生成的返回值final_action，因为正常完成功能必须保存它。\n\n用来提供析构函数的类final_action可以写成下面这样：\n\ntemplate<class f>\nstruct final_action{\n    explicit final_action(f f):act(f){}\n    ~final_action(){act();}\n    f act;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 7.7 模板机制\n\n * 依赖类型的值：参数模板\n * 类型与模板的别名：别名模板\n * 编译时选择机制：if constexpr\n * 编译时查询值与表达式属性的机制：requires表达式\n\n\n# 7.8 建议\n\n 1.  用模板来表达那些可以用于多种参数类型的算法；\n 2.  用模板实现容器；\n 3.  用模板提升代码的抽象层次；\n 4.  让构造函数或函数模板推断出类模板实参类型；\n 5.  把函数对象作为算法的参数；\n 6.  如果简单的函数对象只在某处使用一次，不妨使用匿名函数；\n 7.  不能把虚函数成员定义成模板成员函数；\n 8.  使用finally()为不带析构函数且需要“清理操作”的类型提供raii；\n 9.  利用模板别名来简化符号并隐藏实现细节；\n 10. 使用if constexpr条件编译提供替代实现，不会存在运行时开销；',charsets:{cjk:!0}},{title:"第8章 概念和泛型编程",frontmatter:{title:"第8章 概念和泛型编程",date:"2023-11-24T15:54:58.000Z",permalink:"/pages/619376/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/09.%E7%AC%AC8%E7%AB%A0%20%E6%A6%82%E5%BF%B5%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B.html",relativePath:"01.CPP语言/01.Cpp之旅/09.第8章 概念和泛型编程.md",key:"v-175c66c1",path:"/pages/619376/",headers:[{level:2,title:"8.1 引言",slug:"_8-1-引言",normalizedTitle:"8.1 引言",charIndex:29},{level:2,title:"8.2 概念",slug:"_8-2-概念",normalizedTitle:"8.2 概念",charIndex:276},{level:3,title:"8.2.1 概念的运用",slug:"_8-2-1-概念的运用",normalizedTitle:"8.2.1 概念的运用",charIndex:707},{level:3,title:"8.2.2 基于概念的重载",slug:"_8-2-2-基于概念的重载",normalizedTitle:"8.2.2 基于概念的重载",charIndex:2585},{level:2,title:"8.3 泛型编程",slug:"_8-3-泛型编程",normalizedTitle:"8.3 泛型编程",charIndex:3510},{level:2,title:"8.4 可变参数模板",slug:"_8-4-可变参数模板",normalizedTitle:"8.4 可变参数模板",charIndex:3638},{level:3,title:"8.4.1 折叠表达式",slug:"_8-4-1-折叠表达式",normalizedTitle:"8.4.1 折叠表达式",charIndex:4966},{level:3,title:"8.4.2 完美转发参数",slug:"_8-4-2-完美转发参数",normalizedTitle:"8.4.2 完美转发参数",charIndex:5749},{level:2,title:"8.5 建议",slug:"_8-5-建议",normalizedTitle:"8.5 建议",charIndex:5805}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.465,time:147899.99999999997,words:493},headersStr:"8.1 引言 8.2 概念 8.2.1 概念的运用 8.2.2 基于概念的重载 8.3 泛型编程 8.4 可变参数模板 8.4.1 折叠表达式 8.4.2 完美转发参数 8.5 建议",content:"# Cpp之旅（学习笔记）第8章 概念和泛型编程\n\n\n# 8.1 引言\n\n模板第一个最常用的应用是泛型编程，泛型编程主要关注通用算法的设计、实现和使用。\n\n这里“通用”的含义是该算法能支持多种数据类型，只要类型符合算法对参数的要求即可。\n\n模板提供了以下功能：\n\n * 在不丢失信息的情况下将类型（以及值和模板）作为参数传递的能力。这意味着表达的内容具有很大的灵活性以及具有内联的绝佳机会。\n * 有机会在实例化时将来自不同上下文的信息捏合在一起，这意味着有进行针对性优化的可能。\n * 把值作为模板参数传递的能力，也就是在编译时计算的能力。\n\n\n# 8.2 概念\n\ntemplate<typename Seq, typename Value>\nValue sum(Seq s, Value v) {\n    for(const auto& x : s)\n        v+=x;\n    return v;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个sum函数需要保证\n\n * 它的第一个模板参数是某种元素序列，Seq，它支持begin()和end()，从而允许范围for语句正常工作。\n * 第二个参数是某种形式的数字，Value，支持+=，因此元素可以被累加。\n\n这种需求叫作概念。\n\n> 满足作为序列要求的大致有：标准库vector、list、map\n> \n> 满足作为算术类型的大致有：int、double、Matrix（所有合理定义的矩阵都支持算术运算）。\n> \n> 从以下两个维度看，sum属于通用算法：\n> \n>  * 数据结构的类型（序列存储方式）维度；\n>  * 数据元素的类型维度。\n\n\n# 8.2.1 概念的运用\n\n大多数模板参数必须符合特定需求才能被正常编译和运行。也就是说，绝大多数模板都应当是受限模板。\n\n类型名称指示符typename是限定程度最低的，他仅仅要求该参数是一个类型。\n\ntemplate<Sequence Seq, Number Num>\nNum sum(Seq s, Num v){\n    for(const auto& x : s)\n        v+=x;\n    return v;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 这里的sum定义了Sequence和Number这两个概念的实际含义，编译器就可从sum的接口中直接识别出无效的实例化调用而无需等到编译或者运行时才能报告错误。\n\n----------------------------------------\n\n以下这些巴拉巴拉一大堆也不知道讲的什么，做个标记，以后再看\n\n> 先看看GPT的解释：\n> \n> 强调了使用概念来对模板参数进行约束的重要性，以提高代码的清晰度和安全性。通过使用概念，可以在编译期间发现一些错误，而不是等到运行时才暴露问题。\n> \n> 在Cpp中，requires 子句是用于指定模板参数的一组要求（constraints）的关键字。它用于在模板定义中对模板参数进行约束，以确保只有符合指定条件的类型或值才能被接受。\n> \n> 在模板中，requires 子句通常用于 requires 关键字之后，用于指定一组布尔表达式，这些表达式描述了模板参数必须满足的条件。如果这些条件不满足，编译器将拒绝对该模板的实例化，并在编译时生成错误消息。\n> \n> 例如，在上面提到的代码中，requires Arithmetic<range_value_t<Seq>, Num> 表达了对于类型 range_value_t<Seq> 和 Num，必须满足 Arithmetic 概念。这样的约束有助于确保在模板函数中对这些类型进行算术运算时是安全和合法的。\n> \n> requires 子句的使用使得模板的错误能够更早地在编译期间被发现，提高了代码的可读性和安全性。在概念引入之前，开发者通常通过模板的SFINAE（Substitution Failure Is Not An Error）机制来实现类似的效果，但概念提供了更为直观和清晰的方式来表达对模板参数的要求。\n\n但是，sum接口的技术规格不太完整：应该允许将整个Sequence的元素累加到Number。\n\ntemplate<Sequence Seq, Number Num>\n\trequires Arithmetic<range_value_t<Seq>,Num>\nNum sum(Seq s, Num s);\n\n\n1\n2\n3\n\n * 序列的range_value_t是序列中的元素类型；它来自标准库中range的类型名称。\n * Arithmetic<X,Y>则是一个概念，它表明X与Y可以进行算术运算。这样可避免vector<string>或vector<int>的sum()这样的操作。同时也可以正常支持vector<int>与vector<complex<double>>这样的参数。\n * 在这个例子中，我们只需要+=操作符。但不需要限制的那么死，或许某一天我们需要用+和=两个操作符来替代+=操作符，就会庆幸使用了更通用的概念（Arithmetic），而不是单纯限制为“有用+=操作符”。\n\nrequires Arithmetic<range_value_t<Seq>,Num>被称作requirements子句。其中记法template<Sequence Seq>就是比requires Sequence<Seq>更简单的写法。\n\n复杂点则等价于：\n\ntemplate<Sequence Seq, Number Num>\n\trequires Arithmetic<Seq> && Number<Num> && Arithmetic<range_value_t<Seq>,Num>\nNum sum(Seq s, Num s);\n\n\n1\n2\n3\n\n\n同时，写成如下简写形式也具有等价的效果：\n\ntemplate<<Sequence Seq, Arithmetic<range_value_t<Seq>> Num>\nNum sum(Seq s, Num n);\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 8.2.2 基于概念的重载\n\n一旦我们正确地指定了模板地接口，就可以根据它们地属性进行重载，如同函数一样。\n\n例如：标准库advance()函数向前移动迭代器，简化版本如下：\n\ntemplate<forward_iterator Iter>\nvoid advance(Iter p, int n) {\t// 将p向前移动n个元素\n    while(n--)\n        ++p;\t\t\t\t\t// 前向迭代器拥有 ++ 操作符，但没有+或者+=操作符\n}\n\ntemplate<random_access_iterator Iter>\nvoid advance(Iter p, int n) {\t// 将p向前移动n个元素\n    p += n;\t\t\t\t\t\t// 随机访问迭代器拥有 += 操作符\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n编译器会选择满足最严格参数需求的版本。list只提供了向前迭代器，vector提供了随机访问迭代器。\n\n因此：\n\nvoid user(vector<int>::iterator vip, list<string>::iterator lsp)\n{\n    advance(vip,10);\t// 使用快速版本的advance()\n    advance(lsp,10);\t// 使用慢速版本的advance()\n}\n\n\n1\n2\n3\n4\n5\n\n\n如同其他的重载，这是编译时机制，没有任何开销；\n\n如果编译器无法找到最佳选择，会报二义性错误。\n\n考虑具有一个参数并且提供多个版本的模板函数：\n\n * 如果参数不能匹配特定概念，那么那个版本不会被选择。\n * 如果参数可以匹配概念并且存在唯一匹配，那么选择那个版本。\n * 如果参数可以同时匹配两个版本的概念，但其中一个概念比另外一个更严格（其中一个概念时另外一个概念的完整子集），那么选择更严格的那一个。\n * 如果参数匹配两个概念，并且无法判断两个概念谁更严格，那么会报二义性错误。\n\n选择某个特定版本的模板，必须满足这些条件：\n\n * 匹配所有参数，并且\n * 至少有一个参数与其他版本的匹配度均等，并且\n * 至少有一个参数是最佳匹配。\n\n\n# 8.3 泛型编程\n\nCpp直接支持的泛型编程形式围绕着这样的思想：从具体、高效的算法中抽象出来，从而获得可以与不同数据表示相结合的泛型算法，以生成各种有用的软件。\n\n表示基本操作和数据结构的抽象被称为概念。\n\n...较为复杂先不管，以后有能力再看\n\n\n# 8.4 可变参数模板\n\n定义模板时可以令其接受任意数量、任意类型的实参，这样的模板被称为可变参数模板。\n\n假设我们需要实现一个简单的函数，输出任意可以被 << 操作符输出的数据：\n\nvoid user() {\n    print(\"first: \", 1, 2.2, \"hello\\n\"s);\t\t\t\t\t\t// 输出first: 1 2.2 hello\n    printf(\"\\nsecond: \", 0.2, 'c', \"yuck!\"s, 0, 1, 2, '\\n');\t// 输出second: 0.2 c yuck! 0 1 2\n}\n\n\n1\n2\n3\n4\n\n\n传统方法是：实现一个可变参数模板，将第一个参数剥离出来，然后用递归调用的办法处理所有剩下的参数：\n\ntemplate<typename T>\nconcept Printable = requires(T t) { std::cout << t; }\t// 只有一个操作\nvoid print()\n{\n    // 处理无参数的情况：什么都不做\n}\ntemplate<Printable T, Printable... Tail>\nvoid print()\n{\n    cout << head << ' ';\t\t// 首先对head进行操作\n    print(tail...);\t\t\t\t// 然后操作tail\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 这里加了省略号的Printable...表示Tail包含多个类型的序列。\n * 而Tail...则表示tail本身是这个序列的值。参数声明后面加了省略号...，这叫作参数包。\n * 这里的tail是由函数参数组成的参数包，其元素类型对应的是Tail模板参数包中指定的类型。\n * 使用这样的机制，print()可以接受任意数量、任意类型的参数。\n\n每次调用print()都把参数分成头元素以及其他（尾）元素。对头元素调用了打印命令，然后对其他元素调用print()。最终，tail变为空，所以我们一定需要一个无参数的版本来处理空参数的情况。如果不需要处理无参数的情况，可以通过编译时if来消除这种情况。\n\ntemplate<Printable T, Printable... Tail>\nvoid print(T head, Tail... tail)\n{\n    cout << head << ' ';\n    if constexpr(sizeof...(tail) > 0)\n        print(tail...);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里使用编译时if而不是运行时if，可以避免生成对空参数print()函数的调用。这也就无须定义空参数版本的print()。\n\n可变参数模板的强大之处在于，它们可以接受任意参数。缺点包括：\n\n * 递归实现需要一些技巧，容易出错。\n * 很可能需要一个精心设计的模板程序，才能方便地对接口地类型进行有效检查。\n * 类型检查代码是临时地，而不是被标准定义地。\n * 递归实现在编译时地开销可能非常昂贵，也会占用大量地编译器内存。\n\n\n# 8.4.1 折叠表达式\n\ntemplate<Number... T>\nint sum(T... v)\n{\n    return (v + ... + 0);\t// 将v中所有元素与0累和\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里，(v + ... + 0)表示把v中的所有元素加起来，从0开始。首先做加法的元素是最右边的那个（也就是索引最大的那个）：（v[0]+(v[1]+(v[2]+(v[3]+(v[4]+0))))。从右边开始的叫作右折叠。\n\n这个sum()函数可以接受任意数量、任意类型的参数：\n\nint x = sum(1,2,3,4,5);\t\t// x变成15\nint y = sum('a', 2.4, x);\t// y变成114（2.4被取整，‘a'的值是97\n\n\n1\n2\n\n\n反之，左折叠：\n\ntemplate<Number... T>\nint sum(T... v)\n{\n    return (0 + ... + v);\t// 将v中所有元素与0累和\n}\n\n\n1\n2\n3\n4\n5\n\n\n(((((0+v[0])+v[1])+v[2])+v[3])+v[4])\n\n除此之外，折叠表达式不仅限于算术操作。\n\ntemplate<Printable ...T>\nvoid print(T&&... args)\n{\n    (std::cout << ... << args) << '\\n';\t\t// 打印输出所有参数\n}\n// (((((std::cout << \"Hello!\"s) << ' ') << \"World \") << 2017) << '\\n');\nprint(\"Hello!\"s,' ',\"World \",2017);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n出现2017，是因为fold()的特性实在Cpp2017标准中被添加的。\n\n\n# 8.4.2 完美转发参数\n\n使用可变参数模板时，保证参数在通过接口传递的过程中完全不变，有时非常有用。\n\n\n# 8.5 建议\n\n。。。",normalizedContent:"# cpp之旅（学习笔记）第8章 概念和泛型编程\n\n\n# 8.1 引言\n\n模板第一个最常用的应用是泛型编程，泛型编程主要关注通用算法的设计、实现和使用。\n\n这里“通用”的含义是该算法能支持多种数据类型，只要类型符合算法对参数的要求即可。\n\n模板提供了以下功能：\n\n * 在不丢失信息的情况下将类型（以及值和模板）作为参数传递的能力。这意味着表达的内容具有很大的灵活性以及具有内联的绝佳机会。\n * 有机会在实例化时将来自不同上下文的信息捏合在一起，这意味着有进行针对性优化的可能。\n * 把值作为模板参数传递的能力，也就是在编译时计算的能力。\n\n\n# 8.2 概念\n\ntemplate<typename seq, typename value>\nvalue sum(seq s, value v) {\n    for(const auto& x : s)\n        v+=x;\n    return v;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个sum函数需要保证\n\n * 它的第一个模板参数是某种元素序列，seq，它支持begin()和end()，从而允许范围for语句正常工作。\n * 第二个参数是某种形式的数字，value，支持+=，因此元素可以被累加。\n\n这种需求叫作概念。\n\n> 满足作为序列要求的大致有：标准库vector、list、map\n> \n> 满足作为算术类型的大致有：int、double、matrix（所有合理定义的矩阵都支持算术运算）。\n> \n> 从以下两个维度看，sum属于通用算法：\n> \n>  * 数据结构的类型（序列存储方式）维度；\n>  * 数据元素的类型维度。\n\n\n# 8.2.1 概念的运用\n\n大多数模板参数必须符合特定需求才能被正常编译和运行。也就是说，绝大多数模板都应当是受限模板。\n\n类型名称指示符typename是限定程度最低的，他仅仅要求该参数是一个类型。\n\ntemplate<sequence seq, number num>\nnum sum(seq s, num v){\n    for(const auto& x : s)\n        v+=x;\n    return v;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 这里的sum定义了sequence和number这两个概念的实际含义，编译器就可从sum的接口中直接识别出无效的实例化调用而无需等到编译或者运行时才能报告错误。\n\n----------------------------------------\n\n以下这些巴拉巴拉一大堆也不知道讲的什么，做个标记，以后再看\n\n> 先看看gpt的解释：\n> \n> 强调了使用概念来对模板参数进行约束的重要性，以提高代码的清晰度和安全性。通过使用概念，可以在编译期间发现一些错误，而不是等到运行时才暴露问题。\n> \n> 在cpp中，requires 子句是用于指定模板参数的一组要求（constraints）的关键字。它用于在模板定义中对模板参数进行约束，以确保只有符合指定条件的类型或值才能被接受。\n> \n> 在模板中，requires 子句通常用于 requires 关键字之后，用于指定一组布尔表达式，这些表达式描述了模板参数必须满足的条件。如果这些条件不满足，编译器将拒绝对该模板的实例化，并在编译时生成错误消息。\n> \n> 例如，在上面提到的代码中，requires arithmetic<range_value_t<seq>, num> 表达了对于类型 range_value_t<seq> 和 num，必须满足 arithmetic 概念。这样的约束有助于确保在模板函数中对这些类型进行算术运算时是安全和合法的。\n> \n> requires 子句的使用使得模板的错误能够更早地在编译期间被发现，提高了代码的可读性和安全性。在概念引入之前，开发者通常通过模板的sfinae（substitution failure is not an error）机制来实现类似的效果，但概念提供了更为直观和清晰的方式来表达对模板参数的要求。\n\n但是，sum接口的技术规格不太完整：应该允许将整个sequence的元素累加到number。\n\ntemplate<sequence seq, number num>\n\trequires arithmetic<range_value_t<seq>,num>\nnum sum(seq s, num s);\n\n\n1\n2\n3\n\n * 序列的range_value_t是序列中的元素类型；它来自标准库中range的类型名称。\n * arithmetic<x,y>则是一个概念，它表明x与y可以进行算术运算。这样可避免vector<string>或vector<int>的sum()这样的操作。同时也可以正常支持vector<int>与vector<complex<double>>这样的参数。\n * 在这个例子中，我们只需要+=操作符。但不需要限制的那么死，或许某一天我们需要用+和=两个操作符来替代+=操作符，就会庆幸使用了更通用的概念（arithmetic），而不是单纯限制为“有用+=操作符”。\n\nrequires arithmetic<range_value_t<seq>,num>被称作requirements子句。其中记法template<sequence seq>就是比requires sequence<seq>更简单的写法。\n\n复杂点则等价于：\n\ntemplate<sequence seq, number num>\n\trequires arithmetic<seq> && number<num> && arithmetic<range_value_t<seq>,num>\nnum sum(seq s, num s);\n\n\n1\n2\n3\n\n\n同时，写成如下简写形式也具有等价的效果：\n\ntemplate<<sequence seq, arithmetic<range_value_t<seq>> num>\nnum sum(seq s, num n);\n\n\n1\n2\n\n\n----------------------------------------\n\n\n# 8.2.2 基于概念的重载\n\n一旦我们正确地指定了模板地接口，就可以根据它们地属性进行重载，如同函数一样。\n\n例如：标准库advance()函数向前移动迭代器，简化版本如下：\n\ntemplate<forward_iterator iter>\nvoid advance(iter p, int n) {\t// 将p向前移动n个元素\n    while(n--)\n        ++p;\t\t\t\t\t// 前向迭代器拥有 ++ 操作符，但没有+或者+=操作符\n}\n\ntemplate<random_access_iterator iter>\nvoid advance(iter p, int n) {\t// 将p向前移动n个元素\n    p += n;\t\t\t\t\t\t// 随机访问迭代器拥有 += 操作符\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n编译器会选择满足最严格参数需求的版本。list只提供了向前迭代器，vector提供了随机访问迭代器。\n\n因此：\n\nvoid user(vector<int>::iterator vip, list<string>::iterator lsp)\n{\n    advance(vip,10);\t// 使用快速版本的advance()\n    advance(lsp,10);\t// 使用慢速版本的advance()\n}\n\n\n1\n2\n3\n4\n5\n\n\n如同其他的重载，这是编译时机制，没有任何开销；\n\n如果编译器无法找到最佳选择，会报二义性错误。\n\n考虑具有一个参数并且提供多个版本的模板函数：\n\n * 如果参数不能匹配特定概念，那么那个版本不会被选择。\n * 如果参数可以匹配概念并且存在唯一匹配，那么选择那个版本。\n * 如果参数可以同时匹配两个版本的概念，但其中一个概念比另外一个更严格（其中一个概念时另外一个概念的完整子集），那么选择更严格的那一个。\n * 如果参数匹配两个概念，并且无法判断两个概念谁更严格，那么会报二义性错误。\n\n选择某个特定版本的模板，必须满足这些条件：\n\n * 匹配所有参数，并且\n * 至少有一个参数与其他版本的匹配度均等，并且\n * 至少有一个参数是最佳匹配。\n\n\n# 8.3 泛型编程\n\ncpp直接支持的泛型编程形式围绕着这样的思想：从具体、高效的算法中抽象出来，从而获得可以与不同数据表示相结合的泛型算法，以生成各种有用的软件。\n\n表示基本操作和数据结构的抽象被称为概念。\n\n...较为复杂先不管，以后有能力再看\n\n\n# 8.4 可变参数模板\n\n定义模板时可以令其接受任意数量、任意类型的实参，这样的模板被称为可变参数模板。\n\n假设我们需要实现一个简单的函数，输出任意可以被 << 操作符输出的数据：\n\nvoid user() {\n    print(\"first: \", 1, 2.2, \"hello\\n\"s);\t\t\t\t\t\t// 输出first: 1 2.2 hello\n    printf(\"\\nsecond: \", 0.2, 'c', \"yuck!\"s, 0, 1, 2, '\\n');\t// 输出second: 0.2 c yuck! 0 1 2\n}\n\n\n1\n2\n3\n4\n\n\n传统方法是：实现一个可变参数模板，将第一个参数剥离出来，然后用递归调用的办法处理所有剩下的参数：\n\ntemplate<typename t>\nconcept printable = requires(t t) { std::cout << t; }\t// 只有一个操作\nvoid print()\n{\n    // 处理无参数的情况：什么都不做\n}\ntemplate<printable t, printable... tail>\nvoid print()\n{\n    cout << head << ' ';\t\t// 首先对head进行操作\n    print(tail...);\t\t\t\t// 然后操作tail\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 这里加了省略号的printable...表示tail包含多个类型的序列。\n * 而tail...则表示tail本身是这个序列的值。参数声明后面加了省略号...，这叫作参数包。\n * 这里的tail是由函数参数组成的参数包，其元素类型对应的是tail模板参数包中指定的类型。\n * 使用这样的机制，print()可以接受任意数量、任意类型的参数。\n\n每次调用print()都把参数分成头元素以及其他（尾）元素。对头元素调用了打印命令，然后对其他元素调用print()。最终，tail变为空，所以我们一定需要一个无参数的版本来处理空参数的情况。如果不需要处理无参数的情况，可以通过编译时if来消除这种情况。\n\ntemplate<printable t, printable... tail>\nvoid print(t head, tail... tail)\n{\n    cout << head << ' ';\n    if constexpr(sizeof...(tail) > 0)\n        print(tail...);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里使用编译时if而不是运行时if，可以避免生成对空参数print()函数的调用。这也就无须定义空参数版本的print()。\n\n可变参数模板的强大之处在于，它们可以接受任意参数。缺点包括：\n\n * 递归实现需要一些技巧，容易出错。\n * 很可能需要一个精心设计的模板程序，才能方便地对接口地类型进行有效检查。\n * 类型检查代码是临时地，而不是被标准定义地。\n * 递归实现在编译时地开销可能非常昂贵，也会占用大量地编译器内存。\n\n\n# 8.4.1 折叠表达式\n\ntemplate<number... t>\nint sum(t... v)\n{\n    return (v + ... + 0);\t// 将v中所有元素与0累和\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里，(v + ... + 0)表示把v中的所有元素加起来，从0开始。首先做加法的元素是最右边的那个（也就是索引最大的那个）：（v[0]+(v[1]+(v[2]+(v[3]+(v[4]+0))))。从右边开始的叫作右折叠。\n\n这个sum()函数可以接受任意数量、任意类型的参数：\n\nint x = sum(1,2,3,4,5);\t\t// x变成15\nint y = sum('a', 2.4, x);\t// y变成114（2.4被取整，‘a'的值是97\n\n\n1\n2\n\n\n反之，左折叠：\n\ntemplate<number... t>\nint sum(t... v)\n{\n    return (0 + ... + v);\t// 将v中所有元素与0累和\n}\n\n\n1\n2\n3\n4\n5\n\n\n(((((0+v[0])+v[1])+v[2])+v[3])+v[4])\n\n除此之外，折叠表达式不仅限于算术操作。\n\ntemplate<printable ...t>\nvoid print(t&&... args)\n{\n    (std::cout << ... << args) << '\\n';\t\t// 打印输出所有参数\n}\n// (((((std::cout << \"hello!\"s) << ' ') << \"world \") << 2017) << '\\n');\nprint(\"hello!\"s,' ',\"world \",2017);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n出现2017，是因为fold()的特性实在cpp2017标准中被添加的。\n\n\n# 8.4.2 完美转发参数\n\n使用可变参数模板时，保证参数在通过接口传递的过程中完全不变，有时非常有用。\n\n\n# 8.5 建议\n\n。。。",charsets:{cjk:!0}},{title:"第9章 标准库",frontmatter:{title:"第9章 标准库",date:"2023-11-24T15:54:58.000Z",permalink:"/pages/48ac45/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/01.Cpp%E4%B9%8B%E6%97%85/10.%E7%AC%AC9%E7%AB%A0%20%E6%A0%87%E5%87%86%E5%BA%93.html",relativePath:"01.CPP语言/01.Cpp之旅/10.第9章 标准库.md",key:"v-07650679",path:"/pages/48ac45/",headers:[{level:2,title:"9.1 引言",slug:"_9-1-引言",normalizedTitle:"9.1 引言",charIndex:60},{level:2,title:"9.2 标准库组件",slug:"_9-2-标准库组件",normalizedTitle:"9.2 标准库组件",charIndex:255},{level:2,title:"9.3 标准库的组织",slug:"_9-3-标准库的组织",normalizedTitle:"9.3 标准库的组织",charIndex:727},{level:3,title:"9.3.1 命名空间",slug:"_9-3-1-命名空间",normalizedTitle:"9.3.1 命名空间",charIndex:785},{level:3,title:"9.3.2 ranges命名空间",slug:"_9-3-2-ranges命名空间",normalizedTitle:"9.3.2 ranges命名空间",charIndex:1423},{level:3,title:"9.3.3 模块",slug:"_9-3-3-模块",normalizedTitle:"9.3.3 模块",charIndex:2033},{level:2,title:"9.4 建议",slug:"_9-4-建议",normalizedTitle:"9.4 建议",charIndex:2109}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.86,time:51600,words:172},headersStr:"9.1 引言 9.2 标准库组件 9.3 标准库的组织 9.3.1 命名空间 9.3.2 ranges命名空间 9.3.3 模块 9.4 建议",content:"# Cpp之旅（学习笔记）第9章 标准库\n\n> 当无知稍纵即逝时，又何必浪费时间学习呢？\n> \n> ——霍布斯\n\n\n# 9.1 引言\n\n第9~18章将对重要的标准库工具和方法给出一个概要性的介绍。如：string、ostream、variant、vector、map、path、unique_ptr、thread、regex、system_clock、time_zone和complex。\n\n作者说：不要因为对某些细节理解不够充分而心烦或气馁。本章的目的是让我们对最有用的标准库工具有一个基本的了解。\n\n\n# 9.2 标准库组件\n\n标准库提供的工具和方法可以分为如下几类：\n\n太多了，只写几个关键的能记住的吧\n\n * 运行时语言支持库（例如：对资源分配、异常和运行时类型信息的支持）。\n * C标准库。\n * 字符串库。\n * 正则表达式库。\n * I/O流库。\n * 以可移植的方式处理文件系统的文件操作库。\n * 容器框架库（vector、map）和算法库（find()、sort()、merge()）。也习惯称为标准模板库（STL）。\n * 。。。。。。\n * 并发程序支持库，包括thread和锁机制。\n * 同步协程库及异步协程库。\n * 并行库，包含部分数学算法及大多数STL算法的并行版本，比如sort()、reduce()。\n * 支持模板元程序设计的工具库（类型特性）、STL风格的泛型程序设计（pair）和通用程序设计（variant和optional）。\n * 用于资源管理的“智能指针”库（unique_ptr和shared_ptr）。\n * 特殊用途容器库（array、bitset、tuple）。\n * 。。。。。。\n\n\n# 9.3 标准库的组织\n\n标准库的所有设施都被放在名为std的命名空间中，用户可以通过模板或者头文件来访问。\n\n\n# 9.3.1 命名空间\n\n一般来说，将命名空间中的所有名字都导入全局命名空间并不是好的编程习惯。\n\n * std::chrono：chrono时间库，其中包括std::literals::chrono_literals\n * std::listerals::chrono_literals：后缀y表示年，d表示日，h表示小时，min表示分钟，ms表示毫秒，s表示秒，us表示微妙\n * std::literals::complex_literals：后缀i表示双精度虚数，if表示单精度虚数，il表示long double类型的虚数\n * std::literals::string_literals：后缀s表示字符串类\n * std::literals::string_view_literals：后缀sv表示字符字符串视图\n * std::numbers 提供数学常数\n * std::pmr 表示多态内存资源\n\n要使用子命名空间中的后缀，必须将它引入当前的命名空间。\n\n例如：\n\n//没有引入complex_literals\nauto z1 = 2+3i;\t\t\t\t\t\t\t\t//错误：没有后缀i\n\nusing namespace literals::complex_literals;\t//引入complex literals 声明的后缀\nauto z2 = 2+3i;\t\t\t\t\t\t\t\t//可行：z2是complex<double>类型的\n\n\n1\n2\n3\n4\n5\n\n\n\n# 9.3.2 ranges命名空间\n\n标准库提供的sort()和copy()，有两个版本：\n\n * 传统版本，接受两个迭代器作为参数：sort(begin(v),v.end());。\n * 范围版本，接受一个单独的范围：sort(v);。\n\n理想情况下：这两个版本（参数不同）应当可以直接重载而不需要任何特殊的动作。但是实际上不行：\n\nusing namespace std;\nusing namespace ranges;\nvoid f(vector<int>& v) {\n    sort(v.begin(),v.end());\t\t// 错误：有歧义\n    sort(v);\t\t\t\t\t\t// 错误：有歧义\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n为避免使用非限定模板时造成的歧义，标准规定了范围版本必须在作用域内显示声明：\n\nusing namespace std;\nvoid g(vector<int>& v) {\n    sort(v.begin(),v.end());\t\t// 可行\n    sort(v);\t\t\t\t\t\t// 错误：没有匹配的函数（在std命名空间内）\n    ranges::sort(v);\t\t\t\t// 可行\n    using ranges::sort;\t\t\t\t// sort(v)现在可行了\n    sort(v);\t\t\t\t\t\t// 可行\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 9.3.3 模块\n\n目前为止，无任何标准库模块，作者说Cpp23很可能会弥补这个遗漏。\n\n目前：作者使用可能称为标准的 module std。\n\n\n# 9.4 建议\n\n * 不要重新发明轮子，应该使用库。\n * 当有选择时，优先选择标准库而不是其他库。\n * 不使用模块时，记得用#include包含相应的头文件。\n * 记住，标准库工具和方法都被定义在命名空间std中。\n * 在使用ranges时，记得显示限定算法名称。\n * （如果可用）尽量使用import模块代替#include头文件。",normalizedContent:"# cpp之旅（学习笔记）第9章 标准库\n\n> 当无知稍纵即逝时，又何必浪费时间学习呢？\n> \n> ——霍布斯\n\n\n# 9.1 引言\n\n第9~18章将对重要的标准库工具和方法给出一个概要性的介绍。如：string、ostream、variant、vector、map、path、unique_ptr、thread、regex、system_clock、time_zone和complex。\n\n作者说：不要因为对某些细节理解不够充分而心烦或气馁。本章的目的是让我们对最有用的标准库工具有一个基本的了解。\n\n\n# 9.2 标准库组件\n\n标准库提供的工具和方法可以分为如下几类：\n\n太多了，只写几个关键的能记住的吧\n\n * 运行时语言支持库（例如：对资源分配、异常和运行时类型信息的支持）。\n * c标准库。\n * 字符串库。\n * 正则表达式库。\n * i/o流库。\n * 以可移植的方式处理文件系统的文件操作库。\n * 容器框架库（vector、map）和算法库（find()、sort()、merge()）。也习惯称为标准模板库（stl）。\n * 。。。。。。\n * 并发程序支持库，包括thread和锁机制。\n * 同步协程库及异步协程库。\n * 并行库，包含部分数学算法及大多数stl算法的并行版本，比如sort()、reduce()。\n * 支持模板元程序设计的工具库（类型特性）、stl风格的泛型程序设计（pair）和通用程序设计（variant和optional）。\n * 用于资源管理的“智能指针”库（unique_ptr和shared_ptr）。\n * 特殊用途容器库（array、bitset、tuple）。\n * 。。。。。。\n\n\n# 9.3 标准库的组织\n\n标准库的所有设施都被放在名为std的命名空间中，用户可以通过模板或者头文件来访问。\n\n\n# 9.3.1 命名空间\n\n一般来说，将命名空间中的所有名字都导入全局命名空间并不是好的编程习惯。\n\n * std::chrono：chrono时间库，其中包括std::literals::chrono_literals\n * std::listerals::chrono_literals：后缀y表示年，d表示日，h表示小时，min表示分钟，ms表示毫秒，s表示秒，us表示微妙\n * std::literals::complex_literals：后缀i表示双精度虚数，if表示单精度虚数，il表示long double类型的虚数\n * std::literals::string_literals：后缀s表示字符串类\n * std::literals::string_view_literals：后缀sv表示字符字符串视图\n * std::numbers 提供数学常数\n * std::pmr 表示多态内存资源\n\n要使用子命名空间中的后缀，必须将它引入当前的命名空间。\n\n例如：\n\n//没有引入complex_literals\nauto z1 = 2+3i;\t\t\t\t\t\t\t\t//错误：没有后缀i\n\nusing namespace literals::complex_literals;\t//引入complex literals 声明的后缀\nauto z2 = 2+3i;\t\t\t\t\t\t\t\t//可行：z2是complex<double>类型的\n\n\n1\n2\n3\n4\n5\n\n\n\n# 9.3.2 ranges命名空间\n\n标准库提供的sort()和copy()，有两个版本：\n\n * 传统版本，接受两个迭代器作为参数：sort(begin(v),v.end());。\n * 范围版本，接受一个单独的范围：sort(v);。\n\n理想情况下：这两个版本（参数不同）应当可以直接重载而不需要任何特殊的动作。但是实际上不行：\n\nusing namespace std;\nusing namespace ranges;\nvoid f(vector<int>& v) {\n    sort(v.begin(),v.end());\t\t// 错误：有歧义\n    sort(v);\t\t\t\t\t\t// 错误：有歧义\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n为避免使用非限定模板时造成的歧义，标准规定了范围版本必须在作用域内显示声明：\n\nusing namespace std;\nvoid g(vector<int>& v) {\n    sort(v.begin(),v.end());\t\t// 可行\n    sort(v);\t\t\t\t\t\t// 错误：没有匹配的函数（在std命名空间内）\n    ranges::sort(v);\t\t\t\t// 可行\n    using ranges::sort;\t\t\t\t// sort(v)现在可行了\n    sort(v);\t\t\t\t\t\t// 可行\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 9.3.3 模块\n\n目前为止，无任何标准库模块，作者说cpp23很可能会弥补这个遗漏。\n\n目前：作者使用可能称为标准的 module std。\n\n\n# 9.4 建议\n\n * 不要重新发明轮子，应该使用库。\n * 当有选择时，优先选择标准库而不是其他库。\n * 不使用模块时，记得用#include包含相应的头文件。\n * 记住，标准库工具和方法都被定义在命名空间std中。\n * 在使用ranges时，记得显示限定算法名称。\n * （如果可用）尽量使用import模块代替#include头文件。",charsets:{cjk:!0}},{title:"第2章 变量和基本类型",frontmatter:{title:"第2章 变量和基本类型",date:"2023-12-01T17:21:11.000Z",permalink:"/pages/279e62/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/20.Cpp%E4%B8%93%E6%A0%8F/01.%E7%AC%AC2%E7%AB%A0%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.html",relativePath:"01.CPP语言/20.Cpp专栏/01.第2章 变量和基本类型.md",key:"v-dbcac10c",path:"/pages/279e62/",headers:[{level:2,title:"2.1 基本内置类型",slug:"_2-1-基本内置类型",normalizedTitle:"2.1 基本内置类型",charIndex:185},{level:3,title:"2.1.1 算术类型",slug:"_2-1-1-算术类型",normalizedTitle:"2.1.1 算术类型",charIndex:290},{level:3,title:"2.1.1 练习",slug:"_2-1-1-练习",normalizedTitle:"2.1.1 练习",charIndex:1325},{level:3,title:"2.1.2 类型转换",slug:"_2-1-2-类型转换",normalizedTitle:"2.1.2 类型转换",charIndex:1957},{level:3,title:"2.1.3 字面值常量",slug:"_2-1-3-字面值常量",normalizedTitle:"2.1.3 字面值常量",charIndex:3264},{level:2,title:"2.2 变量",slug:"_2-2-变量",normalizedTitle:"2.2 变量",charIndex:3830},{level:3,title:"2.2.1 变量定义",slug:"_2-2-1-变量定义",normalizedTitle:"2.2.1 变量定义",charIndex:3841},{level:3,title:"2.2.2 变量声明和定义的关系",slug:"_2-2-2-变量声明和定义的关系",normalizedTitle:"2.2.2 变量声明和定义的关系",charIndex:3977},{level:2,title:"2.3 复合类型",slug:"_2-3-复合类型",normalizedTitle:"2.3 复合类型",charIndex:4281},{level:3,title:"2.3.1 引用",slug:"_2-3-1-引用",normalizedTitle:"2.3.1 引用",charIndex:4294},{level:3,title:"2.3.2 指针",slug:"_2-3-2-指针",normalizedTitle:"2.3.2 指针",charIndex:5353},{level:2,title:"2.4 const限定符",slug:"_2-4-const限定符",normalizedTitle:"2.4 const限定符",charIndex:7020},{level:3,title:"2.4.1 const 的引用",slug:"_2-4-1-const-的引用",normalizedTitle:"2.4.1 const 的引用",charIndex:7871},{level:3,title:"2.4.2 指针和 const",slug:"_2-4-2-指针和-const",normalizedTitle:"2.4.2 指针和 const",charIndex:9121},{level:3,title:"2.4.3 顶层 const",slug:"_2-4-3-顶层-const",normalizedTitle:"2.4.3 顶层 const",charIndex:10382},{level:3,title:"2.4.4 constexpr 和常量表达式",slug:"_2-4-4-constexpr-和常量表达式",normalizedTitle:"2.4.4 constexpr 和常量表达式",charIndex:11371},{level:2,title:"2.5 处理类型",slug:"_2-5-处理类型",normalizedTitle:"2.5 处理类型",charIndex:12469},{level:3,title:"2.5.1 类型别名",slug:"_2-5-1-类型别名",normalizedTitle:"2.5.1 类型别名",charIndex:12482},{level:3,title:"2.5.2 auto 类型说明符",slug:"_2-5-2-auto-类型说明符",normalizedTitle:"2.5.2 auto 类型说明符",charIndex:13949},{level:3,title:"2.5.3 decltype 类型指示符",slug:"_2-5-3-decltype-类型指示符",normalizedTitle:"2.5.3 decltype 类型指示符",charIndex:14965},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:15453}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"9 min read",minutes:8.525,time:511500,words:1705},headersStr:"2.1 基本内置类型 2.1.1 算术类型 2.1.1 练习 2.1.2 类型转换 2.1.3 字面值常量 2.2 变量 2.2.1 变量定义 2.2.2 变量声明和定义的关系 2.3 复合类型 2.3.1 引用 2.3.2 指针 2.4 const限定符 2.4.1 const 的引用 2.4.2 指针和 const 2.4.3 顶层 const 2.4.4 constexpr 和常量表达式 2.5 处理类型 2.5.1 类型别名 2.5.2 auto 类型说明符 2.5.3 decltype 类型指示符 小结",content:'# 第2章 变量和基本类型\n\n本章介绍了Cpp的几种典型数据类型，它们分别是：\n\n * 基本内置类型\n * 复合类型\n * 自定义数据结构\n\n其中，char、 int、 long、 float、 double、 bool 是最常见的基本内置类型；\n\n引用和指针是两种最重要的复合类型；struct 关键字和 class 关键字则常用于声明用户自定义的数据结构。\n\n\n# 2.1 基本内置类型\n\n基本数据类型主要有算术类型和空类型（void）：\n\n * 算数类型：字符、整数型、布尔值、浮点数。\n * 空类型：不对应具体值，例如：函数不返回任何值时使用空类型作为返回类型。\n\n\n# 2.1.1 算术类型\n\n算术类型可分两类：\n\n * 整型（integral type ，包括字符和布尔类型）；\n * 浮点型。\n\n> 尺寸：该类型数据所占的比特数\n\n表 2.1 列出了 Cpp 标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。\n\n\n\n==Cpp语言规定一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。==（long long 是在 Cpp11 中新定义的）\n\n> 可寻址的最小内存块称为“字节”。\n\n> 存储的基本单元称为“字（word）”\n\n> 字由32比特（4字节）或64比特（8字节）构成。即 4字节=字32比特；8字节=字64比特\n> \n> ==关系：1个字 = 4字节 = 32比特==\n\n在一个字节为8比特，字为32比特的机器上，（其实就是4字节）一个字的内存区域如下：\n\n\n\n其中，左侧是字节的地址，右侧是字节中8比特的具体内容。\n\n----------------------------------------\n\n浮点型可分为：\n\n * 单精度；\n * 双精度；\n * 扩展精度值。\n\n通常：\n\n * float = 1个字（32比特）\n * double = 2个字（64比特）\n * long double = 3个字（96比特）或者4个字（128比特）\n\n带符号类型和无符号类型\n\n * 带符号类型（signed）：可以表示整数、负数或者0\n   * int、short、long、long long 都是带符号的\n * 无符号类型（unsigned）：仅能表示大于等于0的值\n   * 在其他类型前面添加 unsigned 就可以的到无符号类型\n\n==建议：如何选择类型==\n\n * 当明确知晓数值不可能为负时，选用无符号类型；\n * 使用 int 执行整数运算。在实际应用中，long 一般和 int 有一样的尺寸。如果你的数值超过了 int 的表示范围，选用 long long。\n * 在算术表达式中不要使用 char 和 bool，只有在存放字符或布尔值时才使用它们。如果使用一个不大的整数，请明确指定它的类型是 signed char 或者 unsigned char。\n * 执行浮点数运算选用 double，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。\n\n\n# 2.1.1 练习\n\n练习 2.1： 类型 int、long、long long、short的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double 的区别是什么？\n\n> 解答：\n> \n> 在 Cpp 语言中，int、long、long long、short 都属于整型，区别是 Cpp 标准规定的尺寸的最小值（即改类型在内存中所占的比特数）不同。其中， short 是短整型，占 16 位；int 是整型，占16位；long 和 long long 均为长整型，分别占 32 位和 64 位。\n> \n> 大多数整型都可以划分为无符号类型和带符号类型，在无符号类型中所有比特都用来存储数值，但是仅能表示大于等于 0 的值；带符号类型可以表示整数、负数或者 0。\n> \n> float 和 double 分别是单精度浮点数和双精度浮点数，区别主要是内存中所占的比特数不同，以及默认规定的有效位数不同。\n\n练习 2.2： 计算按揭贷款时，对于利率、本金、付款分别应选择何种数据类型？说明你的理由。\n\n> 解答：\n> \n> 利率、本金、付款既有可能是整数，也有可能是普通的实数。因此应该选择一种浮点类型来表示。float、double、long double，其中 double 和float 的计算代价比较接近且表示范围更广，long double 的计算代价则相对较大，一般情况下没有选择的必要。因此，选择 double 是比较恰当的。\n\n\n# 2.1.2 类型转换\n\n将对象从一种给定的类型转换为另一种相关类型。\n\n * 将一个非布尔类型的算术值赋给布尔类型，初始值为 0 则结果为 false，否则结果为 true。\n * 把一个布尔类型赋值给非布尔类型，初始值为 false 结果为 0，初始值为 true 则结果为 1。\n * 把一个浮点数赋值给整数类型，会进行近似处理。结果值将仅保留浮点数中小数点之前的部分。\n * 把一个整数赋值给浮点类型，小数部分记为 0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。\n * 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。\n   * 例如：8 比特大小的 unsigned char 可以表示 0 至 255 区间内的值，如果赋了一个区间以外的值，则实际的结果是该值对 256 取模后所得的余数。因此，如果把 -1 赋给 8 比特大小的 unsigned char 所得的结果是 255。\n * 赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。程序可能继续工作、可能崩溃，也可能生成垃圾数据。\n\n----------------------------------------\n\n无符号数不会小于 0 这一事实同样关系到循环的写法。\n\nfor(int i = 10; i >= 0; --i)\n    std::cout << i << std::endl;\n// 可能你会觉得反正也不会输出负数，打算用无符号数来重写这个循环。\n// 但是，这个改变却会导致死循环：\n// 错误：变量 u 永远也不会小于 0，循环条件一直成立\nfor(unsigned u = 10; u >= 0; --u)\n    std::cout << u << std::endl;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当 u 等于 0 时会发生什么，这次迭代输出 0 ，然后继续执行 for 语句里的表达时。表达式 --u 从 u 当中减去 1 ，得到的结果 -1 并不满足无符号数的要求，此时像所有表达式范围之外的其他数字一样， -1 被自动转换为一个合法的无符号数。假设 int 类型占 32 位，则当 u 等于 0 时， --u 的结果将会是 4294967295。\n\n解决办法是：用 while 循环代替 for 语句\n\nunsigned u = 11;\t// 确定要输出的最大数，从比它大 1 的数开始\nwhile(u > 0) {\n    --u;\t\t\t// 先减 1，这样最后一次迭代时就会输出 0\n    std::cout << u << std::endl;\n}\n\n\n1\n2\n3\n4\n5\n\n\n改写后的循环先执行对循环控制变量减 1 操作，这样最后一次迭代时，进入循环的 u 值为 1。此时将其减 1，则这次迭代输出的数就是 0：下一次在检验循环条件时，u 的值等于 0 而无法在进入循环。因为我们要先做减 1 的操作，所以初始化 u 的值应该比要输出的最大值大 1。这里，u 的初始化为 11，输出的最大数为10。\n\n\n# 2.1.3 字面值常量\n\n浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 E 和 e 标识：\n\n> 3.14159 3.14159E0 0. 0e0 .001\n\n字符和字符串字面值\n\n单引号括起来的一个字符称为 char 型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。\n\n\'a\'\t\t\t\t// 字符字面值\n"Hello World!"\t// 字符串字面值\n\n\n1\n2\n\n\n字符串字面值的类型实际上是由常量字符构成的数组（array）。\n\n编译器在每个字符串的结尾处添加一个空字符（\'\\0\'），因此，字符串字面值的实际长度要比它的内容多 1。\n\n例如：字面值 \'A\'表示的就是单独的字符 A，而字符串 "A"则代表了一个字符的数组，包含字母 A、另一个是空字符。\n\n如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行不太合适时，就可以采取分开书写的方式：\n\n// 分多行书写的字符串字面值\nstd::cout << "a really, really long string literal "\n    \t\t "that spans two lines" << std::endl;\n\n\n1\n2\n3\n\n\n指定字面值的类型\n\n\n\n\n# 2.2 变量\n\n\n# 2.2.1 变量定义\n\n> 何为对象？\n> \n> 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。\n\n初始化不等于赋值，注意区分！\n\n> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。\n\n\n# 2.2.2 变量声明和定义的关系\n\n如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：\n\nextern int i;\t// 声明 i 而非定义 i\nint j;\t\t\t// 声明并定义 j\n\n\n1\n2\n\n\n但是如果给 extern 语句赋一个初值就变成定义了，这么做就抵消了 extern 的作用。\n\n> 变量能且只能被定义一次，但是可以被多次声明。\n\n> ==关键概念：静态类型==\n> \n> Cpp 是一种静态类型 (statically typed) 语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查 (type checking)。\n\n\n# 2.3 复合类型\n\n\n# 2.3.1 引用\n\n> 当我们使用术语“引用”时，指的其实是“左值引用”\n\n * 引用：就是给某个对象起别名，将声明符写成 &d 的形式来定义引用类型，d 是声明的变量名；\n * 一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用；\n * 一旦绑定便无法更改，因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。\n * 为引用赋值，实际上是把值赋给了与引用绑定的对象，获取引用的值，实际上是获取了与引用绑定的对象的值；\n * 引用本身不是一个对象，所以不能定义引用的引用。\n\nint ival = 1024;\nint &refVal = ival;\t\t//refVal指向ival（是ival的另一个名字）\nint &refVal2;\t\t\t//报错：引用必须被初始化\nrefVal = 2;\t\t\t\t//把2赋给refVal指向的对象，此处即是赋给了ival\nint ii = refVal;\t\t//与ii = ival执行结果一样\nint &refVal3 = refVal;\t//正确：refVal绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上\nint i = refVal;\t\t\t//正确：i被初始化为ival的值\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起\n * 引用的类型要和与之绑定的对象严格匹配\n\nint &refVal4 = 10;\t //错误：引用类型的初始值必须是一个对象\ndouble dval = 3.14;\nint &refVal5 = dval; //错误：此处引用类型的初始值必须是int型对象\n\n\n1\n2\n3\n\n\n引用的类型要和与之绑定的对象严格匹配，但有两种例外情况：\n\n 1. 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。\n 2. 允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。\n\nint i = 42;\nconst int &r1 = i;//允许将const int& 绑定到一个普通int对象上\nconst int &r2 = 42;  //正确：r1是一个常量引用\nconst int &r3 = r1*2;//正确：r3是一个常量引用\nint &r4 = r1*2;      //正确：r4是一个普通的非常量引用\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.3.2 指针\n\n> 与引用类似，指针也实现了对其他对象的间接访问。\n\n * 定义指针类型的方法将声明符写成 *d 的形式，d是变量名。如果一条语句中定义了几个指针变量，每个变量前面都必须有符号 *；\n * 指针本身就是一个对象，允许对指针赋值和拷贝，在指针的声明周期内它可以先后指向几个不用的对象;\n * 指针无须再定义时赋初值，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n\nint *ip1, *ip2;\t\t//ip1和ip2都是直指向int型对象的指针\ndouble dp, *dp2;\t//dp2是指向double型对象的指针，dp是double型对象\n\n\n1\n2\n\n\n除了有两种情况可以例外，其他所有指针的类型都要和它所指向的对象严格匹配：\n\ndouble dval;\ndouble *pd = &dval;//正确：初始值是double型对象的地址\ndouble *pd2 = pd;  //正确：初始值是指向double对象的指针\n\nint *pi = pd;\t   //错误：指针pi的类型和pd的类型不匹配\npi = &dval;\t\t   //错误：试图把double型对象的地址赋给int型指针\n\n\n1\n2\n3\n4\n5\n6\n\n\n因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。\n\n第一种例外情况：允许令一个指向常量的指针指向一个非常量对象：\n\nconst double pi = 3.14;\nconst double *cptr = &pi;\ndouble dval = 3.14；//dval是一个双精度浮点数，它的值可以改变\ncptr = &dval;\t\t//正确：但是不能通过cptr改变dval的值\n\n\n1\n2\n3\n4\n\n\n==指针值应属下列4种状态之一：==\n\n 1. 指向一个对象；\n 2. 指向紧邻对象所占空间的下一个位置；\n 3. 空指针，意味着指针没有指向任何对象；\n 4. 无效指针，也就是上述情况之外的其他值。\n\n对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：\n\n*p = 0;\t  //由符号*得到指针p所指的对象，即可经由p为变量ival赋值\ncout << *p; //输出0\n\n\n1\n2\n\n\n> 要搞清楚一条赋值语句到底改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。\n\npi = &ival;  //pi的值被改变，现在pi指向了ival\n//意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。\n\n*pi = 0;\t //ival的值被改变，指针pi并没有改变\n//则*pi（也就是指针pi指向的那个对象）发生改变。\n\n\n1\n2\n3\n4\n5\n\n\n==指针相等有以下三种情况：==\n\n 1. 都为空；\n 2. 都指向同一个对象；\n 3. 都指向了同一个对象的下一地址。\n\n> void*指针是一种特殊的指针类型，可用于存放任意对象的地址。\n\n指向指针的引用\n\n引用本身不是一个对象，因此不能定义只想引用的指针。但指针式对象，所以存在对指针的引用。\n\nint i = 42;\nint *p;\t\t//p是一个int型指针\nint *&r = p;//r是一个对指针p的引用\n\nr = &i;\t\t//r引用了一个指针，因此给r赋值&i就是令p指向i\n*r = 0;\t\t//解引用r得到i，也就是p指向的对象，将i的值改为0\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。\n\nint *&r = p;\n\n\n1\n\n\n离变量名最近的符号（此例中式&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。\n\n\n# 2.4 const限定符\n\nconst 对象一旦创建后其值就不能在改变，所以 const 对象必须初始化。\n\nconst int i = get_size();//正确：运行时初始化\nconst int j = 42;\t\t //正确：编译时初始化\nconst int k;\t\t\t //错误：k是一个未经初始化的常量\n\n\n1\n2\n3\n\n\n初始化和 const\n\n如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要：\n\nint i = 42;\nconst int ci = i;\t//正确：i的值被拷贝给了ci\nint j = ci;\t\t\t//正确：ci的值被拷贝给了j\n\n\n1\n2\n3\n\n\n尽管 ci 是整形常量，但无论如何 ci 中的值还是一个整型数。ci 的常量特征仅仅在执行改变 ci 的操作时才会发挥作用。当用 ci 去初始化j时，根本无须在意 ci 是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。\n\n默认const对象仅在文件内有效\n\n默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。\n\n如果我们不希望编译器为每个文件分别生成独立的变量，想要只在一个文件中定义const，而在其他多个文件中声明并使用它。\n\n==解决办法是，对于const变量不管是声明还是定义都添加extern关键字，== 这样她只需定义一次就可以了：\n\n//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问\nextern const int bufSize = fcn();\n//file_1.h头文件\nextern const int bufSize;//与file_1.cc中定义的bufSize是同一个\n\n\n1\n2\n3\n4\n\n\n> Note：如果想在多个文件之间共享 const 对象，必须在变量的定义之前添加 extern 关键字。\n\n\n# 2.4.1 const 的引用\n\n对常量的引用不能被用作修改它所绑定的对象：\n\nconst int ci = 1024;\nconst int &r1 = ci;  //正确：引用及其对应的对象都是常量\nr1 = 42;\t\t   \t //错误：r1是对常量的引用\nint &r2 = ci;\t   \t //错误：试图让一个非常量引用指向一个常量对象\n\n\n1\n2\n3\n4\n\n\n因为不允许直接为 ci 赋值，当然也就不能通过引用去改变ci。因此，对 r2 的初始化是错误的。假设该初始化合法，则可以通过 r2 来改变它引用对象的值，这显然是不正确的。\n\n> 术语：常量引用是对 const 的引用\n\n初始化和对const的引用\n\n引用的类型要和与之绑定的对象严格匹配，但有两种例外情况：\n\n 1. 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。\n 2. 允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。\n\nint i = 42;\nconst int &r1 = i;\t //允许将const int& 绑定到一个普通int对象上\nconst int &r2 = 42;  //正确：r1是一个常量引用\nconst int &r3 = r1*2;//正确：r3是一个常量引用\nint &r4 = r1*2;      //正确：r4是一个普通的非常量引用\n\n\n1\n2\n3\n4\n5\n\n\n==要理解这种例外情况：最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：==\n\ndouble dval = 3.14;\nconst int &ri = dval;\n\n\n1\n2\n\n\n此处 ri 引用了一个 int 型的数，对 ri 的操作应该是整数运算，但 dval 是一个双精度浮点数而非整数。因此为了确保让 ri 绑定一个整数，编译器把上述代码变成了如下形式：\n\nconst int temp = dval;\t//由双精度浮点数生成一个临时的整形常量\nconst int &ri = temp;\t//让ri绑定这个临时量\n\n\n1\n2\n\n\n在这种情况下，ri 绑定了一个临时量对象。对临时变量操作是被归为非法的，因为对临时变量的操作并不会影响 dval ，这并没有什么意义。\n\n对const的引用可能引用一个并非const的对象\n\nint i = 42;\nint &r1 = i;\t\t//引用ri绑定对象i\nconst int &r2 = i;  //r2也绑定对象i，但是不允许通过r2修改i的值\nr1 = 0;\t\t\t\t//r1并非常量，i的值修改为0\nr2 = 0;\t\t\t\t//错误：r2是一个常量引用\n\n\n1\n2\n3\n4\n5\n\n\nr2 绑定（非常量）整数 i 是合法的行为。然而，不允许通过 r2 修改i的值。尽管如此，i 的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像 r1 一样绑定到i的其他引用来修改。\n\n\n# 2.4.2 指针和 const\n\n==要想存放常量对象的地址，只能使用指向常量的指针：==\n\nconst double pi = 3.14;\t\t//pi是个常量，它的值不能改变\ndouble *ptr = &pi;\t\t\t//错误：ptr是一个普通指针\nconst double *cptr = &pi;\t//正确：cptr可以指向一个双精度常量\n*cptr = 42;\t\t\t\t\t//错误：不能给*cptr赋值\n\n\n1\n2\n3\n4\n\n\n前面提到，指针的类型必须与其所指对象的类型一致，但是有两个例外情况：\n\n==第一种例外情况：允许令一个指向常量的指针指向一个非常量对象：==\n\nconst double pi = 3.14;\nconst double *cptr = &pi;\ndouble dval = 3.14;\t\t\t//dval是一个双精度浮点数，它的值可以改变\ncptr = &dval;\t\t\t\t//正确：但是不能通过cptr改变dval的值\n\n\n1\n2\n3\n4\n\n\n和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。\n\n> Tip：可以这样想，所谓指向常量的指针或引用，不过是指针或引用 “自以为是” 罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象地值。\n\nconst指针\n\n指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定位常量。\n\n常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。\n\n把*放在 const 关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：\n\nint errNumb = 0;\nint *const curErr = &errNumb; //curErr将一直指向errNumb\nconst double pi = 3.14159;\nconst double *const pip = &pi;//pip是一个指向常量对象的常量指针\n\n\n1\n2\n3\n4\n\n\n==要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。==\n\n离 curErr 最近的的符号是const，意味着 curErr 本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是 curErr 是一个常量指针。指针存储的那个地址不能改变，但是指向的一个一般的非常量整数，那么就完全可以用curErr去修改 errNumb 的值。\n\n*pip = 2.72;\t//错误：pip是一个指向常量的指针\n//如果curErr所指的对象（也就是errNumb）的值不为0\nif(*curErr) {\n    errorHandler();\n    *curErr = 0;//正确：把curErr所指的对象的值重置\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.4.3 顶层 const\n\n指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。\n\n * 顶层const（top-level const）表示指针本身是个常量；\n   \n   * 顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。\n\n * 底层const（low-level const）表示指针所指的对象是一个常量。\n   \n   * 底层const则与指针和引用等符合类型的基本类型部分有关。\n\n==特殊的是：指针类型既可以是顶层const也可以是底层const。==\n\nint i = 0;\nint *const p1 = &i;\t\t\t//不能改变p1的值，这是一个顶层const\nconst int ci = 42; \t\t\t//不能改变ci的值，这是一个顶层const\nconst int *p2 = &ci;\t\t//允许改变p2的值，这是一个底层const\nconst int *const p3 = p2;\t//靠右的const是顶层const，靠左的是底层const\nconst int &r = ci;\t\t\t//用于声明引用的const都是底层const\n\n\n1\n2\n3\n4\n5\n6\n\n\n当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显：\n\n顶层const不受什么影响：\n\ni = ci;\t//正确：拷贝ci的值，ci是一个顶层const，对此操作无影响\np2 = p3;//正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响\n\n\n1\n2\n\n\n底层const的限制不能忽视：\n\n当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行：\n\nint *p = p3;\t  //错误：p3包含底层const的定义，而p没有\np2 = p3;\t\t  //正确：p2和p3都是底层const\np2 = &i;\t\t  //正确：int* 能转换成const int*\nint &r = ci;\t  //错误：普通的int&不能绑定到int常量上\nconst int &r2 = i;//正确：const int&可以绑定到一个普通int上\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.4.4 constexpr 和常量表达式\n\n常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。\n\n属于常量表达式的：\n\n 1. 字面值；\n 2. 用常量表达式初始化的 const 对象也是常量表达式。\n\nconst int max_files = 20;\t\t//max_files是常量表达式\nconst int limit = max_files + 1;//limit是常量表达式\nint staff_size = 27;\t\t\t//staff_size不是常量表达式\nconst int sz = get_size();\t\t//sz不是常量表达式\n\n\n1\n2\n3\n4\n\n\n尽管 sz 本身是一个常量，但它地具体值直到运行时才能获取到，所以也不是常量表达式。\n\nconstexpr 常量\n\nCpp11 新标准规定，允许将声明变量声明为 constexpr 类型以便由编译器来验证变量地值是否是一个常量表达式。\n\nconstexpr int mf = 20;\t\t // 20 是常量表达式\nconstexpr int limit = mf + 1;// mf+1 是常量表达式\nconstexpr int sz = size();\t //只有size是一个constexpr函数时才是一条正确的声明语句\n\n\n1\n2\n3\n\n\n> 一般来说，如果你认定变量是一个常量表达式，那就把它声明成 constexpr 类型。\n\n字面值类型\n\n> 字面值类型指的是：类型简单、值也显而易见、容易得到，就把它们称为“字面值类型”。\n\n比如：\n\n * 属于字面值类型的：算术类型、引用、指针\n * 不属于字面值类型的：自定义类、IO 库、string 类型\n\n指针和引用都能定义成 constexpr ，但它们的初始值都受到严格限制。一个 constexpr 指针的初始值必须是 nullptr 或者 0，或者是存储与某个固定地址中的对象。\n\n指针和 constexpr\n\n必须明确一点：在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关；\n\nconst int *p = nullptr;  \t// p是一个指向整形常量的指针\nconstexpr int *q = nullptr;\t// q是一个指向整数的常量指针\n\n\n1\n2\n\n\np和q的类型相差甚远：\n\n * p是一个指向常量的指针。\n * q是一个常量指针，关键在于 constexpr 把它所定义的对象置为了顶层 const。\n\n\n# 2.5 处理类型\n\n\n# 2.5.1 类型别名\n\n> 类型别名（type alias）是一个名字，它是某种类型的同义词。\n\n传统的方式，使用关键字 typedef 定义类型别名的两种方法：\n\ntypedef double wages;\t// wages 是 double 的同义词\ntypedef wages base, *p;\t// base 是 double 的同义词，p 是 double* 的同义词\n\n\n1\n2\n\n\n新规定，使用别名声明：\n\nusing SI = Sales_item;\t// SI 是 Sales_item 的同义词\n\n\n1\n\n\n类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：\n\nwages hourly, weekly;\t// 等价于 double hourly、weekly\nSI item;\t\t\t\t// 等价于 Sales_item item\n\n\n1\n2\n\n\n指针、常量和类型别名\n\n> 书中主要讲了在Cpp中使用类型别名时可能出现的误解，特别是涉及到指针、常量和类型别名组合的情况。 ==不可以简单地将类型别名替换为其原始类型==\n\n让我逐步解释一下：\n\n 1. 类型别名的定义：\n    \n    typedef char *pstring;\n    \n    \n    1\n    \n    \n    这里定义了一个类型别名 pstring，它是 char* 的别名，即指向字符的指针。\n\n 2. 使用类型别名和常量的声明：\n    \n    const pstring cstr = 0;\n    \n    \n    1\n    \n    \n    这一行声明了一个常量指针 cstr，它指向字符 (char)，并被声明为常量。但是，由于 pstring 是 char* 的别名，这实际上是一个指向字符的常量指针。\n\n 3. 使用类型别名和指针的声明：\n    \n    const pstring *ps;\n    \n    \n    1\n    \n    \n    这一行声明了一个指针 ps，它指向的对象是指向字符的常量指针。\n\n 4. 错误的理解： 作者指出，在阅读这样的声明时，人们可能错误地尝试将类型别名替换为其原始类型，以理解声明的含义。例如，尝试将 const pstring cstr 理解为 const char *cstr。这是错误的，因为 const pstring 表示指向字符的常量指针，而不是指向常量字符的指针。\n\n 5. 改写示例：\n    \n    const char *cstr = 0;\n    \n    \n    1\n    \n    \n    这是错误理解的改写，它将 const pstring cstr 错误地理解为 const char *cstr。这样改写的结果是声明了一个指向常量字符的指针，而不是指向字符的常量指针。这两种声明的含义是截然不同的。\n\n 6. 正确的改写应该是：\n    \n    const char *const cstr = 0;\n    \n    \n    1\n    \n    \n    这表示 cstr 是一个指向字符的常量指针，并且它本身也是一个常量。这样的改写保持了原始声明的含义，即 cstr 是一个指向字符的常量指针。\n\n总的来说，这段话强调了在使用类型别名时，特别是涉及到指针和常量的情况下，需要正确理解类型别名的含义，而不能简单地将其替换为原始类型。这有助于避免在代码理解上的混淆和错误。\n\n\n# 2.5.2 auto 类型说明符\n\nauto 可在一条语句中声明多个变量，但是初始基本数据类型都必须一样：\n\nauto i = 0, *p = &i;\t// 正确：i 是整数、p是整数指针\nauto sz = 0, pi = 3.14;\t// 错误：sz 和 pi 的类型不一致\n\n\n1\n2\n\n\n复合类型、常量、auto\n\nauto 一般会忽略掉顶层 const，同时底层 const 则会保留下来，比如当初始值是一个指向常量的指针时：\n\nconst int ci = i, &cr = ci;\nauto b = ci;\t\t// b 是一个整数(ci 的顶层const 特性被忽略掉了)\nauto c = cr;\t\t// c 是一个整数(cr 是 ci 的别名，ci 本身是一个顶层 const)\nauto d = &i;\t\t// d 是一个整型指针(整数的地址就是指向整数的指针)\nauto e = &ci;\t\t// e 是一个指向整数常量的指针(对常量对象取地址是一种底层 const)\n\n\n1\n2\n3\n4\n5\n\n\n如果希望推断出的 auto 类型是一个顶层 const，需要明确指出：\n\nconst auto f = ci;\t// ci 的推演类型是 int，f 是 const int\n\n\n1\n\n\n还可以将引用的类型设为 auto，此时原来的初始化规则仍然适用:\n\nauto &g = ci;\t\t// g 是一个整型常量引用，绑定到 ci\nauto &h = 42;\t\t// 错误:不能为非常量引用绑定字面值\nconst auto &j = 42;\t// 正确:可以为常量引用绑定字面值\n\n\n1\n2\n3\n\n\n设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。 要在一条语句中定义多个变量，切记，符号 & 和 * 只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:\n\nauto k = ci, &l = i;\t// k 是整数，1 是整型引用\nauto &m = ci,*p = &ci; \t// m 是对整型常量的引用，p 是指向整型常量的指针\n\t\t\t\t\t\t// 错误: i 的类型是 int 而 &ci 的类型是 const int\nauto &n = i, *p2 = &ci;\n\n\n1\n2\n3\n4\n\n\n\n# 2.5.3 decltype 类型指示符\n\nCpp11 新标准引入的第二种类型说明符 decltype，它的作用是选择并返回操作数的数据类型。\n\n在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n\ndecltype(f()) sum = x;\t// sum 的类型就是函数 f 的返回类型\n\n\n1\n\n\n编译器不会实际调用函数 f，而是使用当调用发生时 f 的返回值类型作为 sum 的类型。\n\ndecltype 处理顶层 const 和引用的方式与 auto 有些许不同。如果 decltype 使用的表达式是一个变量,则 decltype 返回该变量的类型(包括顶层 const 和引用在内)：\n\nconst int ci = 0, &cj = ci;\ndecltype(ci) x = 0;\t\t\t// x 的类型是 const int\ndecltype(cj) y = xi;\t\t// y 的类型是 const int&，y 绑定到变量 x\ndecltype(cj) z;\t\t\t\t// 错误: z 是一个引用，必须初始化\n\n\n1\n2\n3\n4\n\n\n\n# 小结\n\n类型是 Cpp 编程的基础。\n\n类型规定了其对象的存储要求和所能执行的操作。Cpp 语言提供了一套基础内置类型，如 int 和 char 等，这些类型与实现它们的机器硬件密切相关。类型分为非常量和常量，一个常量对象必须初始化，而且一旦初始化其值就不能再改变。此外，还可以定义复合类型，如指针和引用等。复合类型的定义以其他类型为基础。\n\nCpp 语言允许用户以类的形式自定义类型。Cpp 库通过类提供了一套高级抽象类型，如输入输出和string 等。',normalizedContent:'# 第2章 变量和基本类型\n\n本章介绍了cpp的几种典型数据类型，它们分别是：\n\n * 基本内置类型\n * 复合类型\n * 自定义数据结构\n\n其中，char、 int、 long、 float、 double、 bool 是最常见的基本内置类型；\n\n引用和指针是两种最重要的复合类型；struct 关键字和 class 关键字则常用于声明用户自定义的数据结构。\n\n\n# 2.1 基本内置类型\n\n基本数据类型主要有算术类型和空类型（void）：\n\n * 算数类型：字符、整数型、布尔值、浮点数。\n * 空类型：不对应具体值，例如：函数不返回任何值时使用空类型作为返回类型。\n\n\n# 2.1.1 算术类型\n\n算术类型可分两类：\n\n * 整型（integral type ，包括字符和布尔类型）；\n * 浮点型。\n\n> 尺寸：该类型数据所占的比特数\n\n表 2.1 列出了 cpp 标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。\n\n\n\n==cpp语言规定一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。==（long long 是在 cpp11 中新定义的）\n\n> 可寻址的最小内存块称为“字节”。\n\n> 存储的基本单元称为“字（word）”\n\n> 字由32比特（4字节）或64比特（8字节）构成。即 4字节=字32比特；8字节=字64比特\n> \n> ==关系：1个字 = 4字节 = 32比特==\n\n在一个字节为8比特，字为32比特的机器上，（其实就是4字节）一个字的内存区域如下：\n\n\n\n其中，左侧是字节的地址，右侧是字节中8比特的具体内容。\n\n----------------------------------------\n\n浮点型可分为：\n\n * 单精度；\n * 双精度；\n * 扩展精度值。\n\n通常：\n\n * float = 1个字（32比特）\n * double = 2个字（64比特）\n * long double = 3个字（96比特）或者4个字（128比特）\n\n带符号类型和无符号类型\n\n * 带符号类型（signed）：可以表示整数、负数或者0\n   * int、short、long、long long 都是带符号的\n * 无符号类型（unsigned）：仅能表示大于等于0的值\n   * 在其他类型前面添加 unsigned 就可以的到无符号类型\n\n==建议：如何选择类型==\n\n * 当明确知晓数值不可能为负时，选用无符号类型；\n * 使用 int 执行整数运算。在实际应用中，long 一般和 int 有一样的尺寸。如果你的数值超过了 int 的表示范围，选用 long long。\n * 在算术表达式中不要使用 char 和 bool，只有在存放字符或布尔值时才使用它们。如果使用一个不大的整数，请明确指定它的类型是 signed char 或者 unsigned char。\n * 执行浮点数运算选用 double，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。\n\n\n# 2.1.1 练习\n\n练习 2.1： 类型 int、long、long long、short的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double 的区别是什么？\n\n> 解答：\n> \n> 在 cpp 语言中，int、long、long long、short 都属于整型，区别是 cpp 标准规定的尺寸的最小值（即改类型在内存中所占的比特数）不同。其中， short 是短整型，占 16 位；int 是整型，占16位；long 和 long long 均为长整型，分别占 32 位和 64 位。\n> \n> 大多数整型都可以划分为无符号类型和带符号类型，在无符号类型中所有比特都用来存储数值，但是仅能表示大于等于 0 的值；带符号类型可以表示整数、负数或者 0。\n> \n> float 和 double 分别是单精度浮点数和双精度浮点数，区别主要是内存中所占的比特数不同，以及默认规定的有效位数不同。\n\n练习 2.2： 计算按揭贷款时，对于利率、本金、付款分别应选择何种数据类型？说明你的理由。\n\n> 解答：\n> \n> 利率、本金、付款既有可能是整数，也有可能是普通的实数。因此应该选择一种浮点类型来表示。float、double、long double，其中 double 和float 的计算代价比较接近且表示范围更广，long double 的计算代价则相对较大，一般情况下没有选择的必要。因此，选择 double 是比较恰当的。\n\n\n# 2.1.2 类型转换\n\n将对象从一种给定的类型转换为另一种相关类型。\n\n * 将一个非布尔类型的算术值赋给布尔类型，初始值为 0 则结果为 false，否则结果为 true。\n * 把一个布尔类型赋值给非布尔类型，初始值为 false 结果为 0，初始值为 true 则结果为 1。\n * 把一个浮点数赋值给整数类型，会进行近似处理。结果值将仅保留浮点数中小数点之前的部分。\n * 把一个整数赋值给浮点类型，小数部分记为 0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。\n * 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。\n   * 例如：8 比特大小的 unsigned char 可以表示 0 至 255 区间内的值，如果赋了一个区间以外的值，则实际的结果是该值对 256 取模后所得的余数。因此，如果把 -1 赋给 8 比特大小的 unsigned char 所得的结果是 255。\n * 赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。程序可能继续工作、可能崩溃，也可能生成垃圾数据。\n\n----------------------------------------\n\n无符号数不会小于 0 这一事实同样关系到循环的写法。\n\nfor(int i = 10; i >= 0; --i)\n    std::cout << i << std::endl;\n// 可能你会觉得反正也不会输出负数，打算用无符号数来重写这个循环。\n// 但是，这个改变却会导致死循环：\n// 错误：变量 u 永远也不会小于 0，循环条件一直成立\nfor(unsigned u = 10; u >= 0; --u)\n    std::cout << u << std::endl;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当 u 等于 0 时会发生什么，这次迭代输出 0 ，然后继续执行 for 语句里的表达时。表达式 --u 从 u 当中减去 1 ，得到的结果 -1 并不满足无符号数的要求，此时像所有表达式范围之外的其他数字一样， -1 被自动转换为一个合法的无符号数。假设 int 类型占 32 位，则当 u 等于 0 时， --u 的结果将会是 4294967295。\n\n解决办法是：用 while 循环代替 for 语句\n\nunsigned u = 11;\t// 确定要输出的最大数，从比它大 1 的数开始\nwhile(u > 0) {\n    --u;\t\t\t// 先减 1，这样最后一次迭代时就会输出 0\n    std::cout << u << std::endl;\n}\n\n\n1\n2\n3\n4\n5\n\n\n改写后的循环先执行对循环控制变量减 1 操作，这样最后一次迭代时，进入循环的 u 值为 1。此时将其减 1，则这次迭代输出的数就是 0：下一次在检验循环条件时，u 的值等于 0 而无法在进入循环。因为我们要先做减 1 的操作，所以初始化 u 的值应该比要输出的最大值大 1。这里，u 的初始化为 11，输出的最大数为10。\n\n\n# 2.1.3 字面值常量\n\n浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用 e 和 e 标识：\n\n> 3.14159 3.14159e0 0. 0e0 .001\n\n字符和字符串字面值\n\n单引号括起来的一个字符称为 char 型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。\n\n\'a\'\t\t\t\t// 字符字面值\n"hello world!"\t// 字符串字面值\n\n\n1\n2\n\n\n字符串字面值的类型实际上是由常量字符构成的数组（array）。\n\n编译器在每个字符串的结尾处添加一个空字符（\'\\0\'），因此，字符串字面值的实际长度要比它的内容多 1。\n\n例如：字面值 \'a\'表示的就是单独的字符 a，而字符串 "a"则代表了一个字符的数组，包含字母 a、另一个是空字符。\n\n如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行不太合适时，就可以采取分开书写的方式：\n\n// 分多行书写的字符串字面值\nstd::cout << "a really, really long string literal "\n    \t\t "that spans two lines" << std::endl;\n\n\n1\n2\n3\n\n\n指定字面值的类型\n\n\n\n\n# 2.2 变量\n\n\n# 2.2.1 变量定义\n\n> 何为对象？\n> \n> 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。\n\n初始化不等于赋值，注意区分！\n\n> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。\n\n\n# 2.2.2 变量声明和定义的关系\n\n如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：\n\nextern int i;\t// 声明 i 而非定义 i\nint j;\t\t\t// 声明并定义 j\n\n\n1\n2\n\n\n但是如果给 extern 语句赋一个初值就变成定义了，这么做就抵消了 extern 的作用。\n\n> 变量能且只能被定义一次，但是可以被多次声明。\n\n> ==关键概念：静态类型==\n> \n> cpp 是一种静态类型 (statically typed) 语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查 (type checking)。\n\n\n# 2.3 复合类型\n\n\n# 2.3.1 引用\n\n> 当我们使用术语“引用”时，指的其实是“左值引用”\n\n * 引用：就是给某个对象起别名，将声明符写成 &d 的形式来定义引用类型，d 是声明的变量名；\n * 一般初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用；\n * 一旦绑定便无法更改，因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。\n * 为引用赋值，实际上是把值赋给了与引用绑定的对象，获取引用的值，实际上是获取了与引用绑定的对象的值；\n * 引用本身不是一个对象，所以不能定义引用的引用。\n\nint ival = 1024;\nint &refval = ival;\t\t//refval指向ival（是ival的另一个名字）\nint &refval2;\t\t\t//报错：引用必须被初始化\nrefval = 2;\t\t\t\t//把2赋给refval指向的对象，此处即是赋给了ival\nint ii = refval;\t\t//与ii = ival执行结果一样\nint &refval3 = refval;\t//正确：refval绑定到了那个与refval绑定的对象上，这里就是绑定到ival上\nint i = refval;\t\t\t//正确：i被初始化为ival的值\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起\n * 引用的类型要和与之绑定的对象严格匹配\n\nint &refval4 = 10;\t //错误：引用类型的初始值必须是一个对象\ndouble dval = 3.14;\nint &refval5 = dval; //错误：此处引用类型的初始值必须是int型对象\n\n\n1\n2\n3\n\n\n引用的类型要和与之绑定的对象严格匹配，但有两种例外情况：\n\n 1. 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。\n 2. 允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。\n\nint i = 42;\nconst int &r1 = i;//允许将const int& 绑定到一个普通int对象上\nconst int &r2 = 42;  //正确：r1是一个常量引用\nconst int &r3 = r1*2;//正确：r3是一个常量引用\nint &r4 = r1*2;      //正确：r4是一个普通的非常量引用\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.3.2 指针\n\n> 与引用类似，指针也实现了对其他对象的间接访问。\n\n * 定义指针类型的方法将声明符写成 *d 的形式，d是变量名。如果一条语句中定义了几个指针变量，每个变量前面都必须有符号 *；\n * 指针本身就是一个对象，允许对指针赋值和拷贝，在指针的声明周期内它可以先后指向几个不用的对象;\n * 指针无须再定义时赋初值，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n\nint *ip1, *ip2;\t\t//ip1和ip2都是直指向int型对象的指针\ndouble dp, *dp2;\t//dp2是指向double型对象的指针，dp是double型对象\n\n\n1\n2\n\n\n除了有两种情况可以例外，其他所有指针的类型都要和它所指向的对象严格匹配：\n\ndouble dval;\ndouble *pd = &dval;//正确：初始值是double型对象的地址\ndouble *pd2 = pd;  //正确：初始值是指向double对象的指针\n\nint *pi = pd;\t   //错误：指针pi的类型和pd的类型不匹配\npi = &dval;\t\t   //错误：试图把double型对象的地址赋给int型指针\n\n\n1\n2\n3\n4\n5\n6\n\n\n因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。\n\n第一种例外情况：允许令一个指向常量的指针指向一个非常量对象：\n\nconst double pi = 3.14;\nconst double *cptr = &pi;\ndouble dval = 3.14；//dval是一个双精度浮点数，它的值可以改变\ncptr = &dval;\t\t//正确：但是不能通过cptr改变dval的值\n\n\n1\n2\n3\n4\n\n\n==指针值应属下列4种状态之一：==\n\n 1. 指向一个对象；\n 2. 指向紧邻对象所占空间的下一个位置；\n 3. 空指针，意味着指针没有指向任何对象；\n 4. 无效指针，也就是上述情况之外的其他值。\n\n对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：\n\n*p = 0;\t  //由符号*得到指针p所指的对象，即可经由p为变量ival赋值\ncout << *p; //输出0\n\n\n1\n2\n\n\n> 要搞清楚一条赋值语句到底改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。\n\npi = &ival;  //pi的值被改变，现在pi指向了ival\n//意思是为pi赋一个新的值，也就是改变了那个存放在pi内的地址值。\n\n*pi = 0;\t //ival的值被改变，指针pi并没有改变\n//则*pi（也就是指针pi指向的那个对象）发生改变。\n\n\n1\n2\n3\n4\n5\n\n\n==指针相等有以下三种情况：==\n\n 1. 都为空；\n 2. 都指向同一个对象；\n 3. 都指向了同一个对象的下一地址。\n\n> void*指针是一种特殊的指针类型，可用于存放任意对象的地址。\n\n指向指针的引用\n\n引用本身不是一个对象，因此不能定义只想引用的指针。但指针式对象，所以存在对指针的引用。\n\nint i = 42;\nint *p;\t\t//p是一个int型指针\nint *&r = p;//r是一个对指针p的引用\n\nr = &i;\t\t//r引用了一个指针，因此给r赋值&i就是令p指向i\n*r = 0;\t\t//解引用r得到i，也就是p指向的对象，将i的值改为0\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。\n\nint *&r = p;\n\n\n1\n\n\n离变量名最近的符号（此例中式&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。\n\n\n# 2.4 const限定符\n\nconst 对象一旦创建后其值就不能在改变，所以 const 对象必须初始化。\n\nconst int i = get_size();//正确：运行时初始化\nconst int j = 42;\t\t //正确：编译时初始化\nconst int k;\t\t\t //错误：k是一个未经初始化的常量\n\n\n1\n2\n3\n\n\n初始化和 const\n\n如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要：\n\nint i = 42;\nconst int ci = i;\t//正确：i的值被拷贝给了ci\nint j = ci;\t\t\t//正确：ci的值被拷贝给了j\n\n\n1\n2\n3\n\n\n尽管 ci 是整形常量，但无论如何 ci 中的值还是一个整型数。ci 的常量特征仅仅在执行改变 ci 的操作时才会发挥作用。当用 ci 去初始化j时，根本无须在意 ci 是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。\n\n默认const对象仅在文件内有效\n\n默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。\n\n如果我们不希望编译器为每个文件分别生成独立的变量，想要只在一个文件中定义const，而在其他多个文件中声明并使用它。\n\n==解决办法是，对于const变量不管是声明还是定义都添加extern关键字，== 这样她只需定义一次就可以了：\n\n//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问\nextern const int bufsize = fcn();\n//file_1.h头文件\nextern const int bufsize;//与file_1.cc中定义的bufsize是同一个\n\n\n1\n2\n3\n4\n\n\n> note：如果想在多个文件之间共享 const 对象，必须在变量的定义之前添加 extern 关键字。\n\n\n# 2.4.1 const 的引用\n\n对常量的引用不能被用作修改它所绑定的对象：\n\nconst int ci = 1024;\nconst int &r1 = ci;  //正确：引用及其对应的对象都是常量\nr1 = 42;\t\t   \t //错误：r1是对常量的引用\nint &r2 = ci;\t   \t //错误：试图让一个非常量引用指向一个常量对象\n\n\n1\n2\n3\n4\n\n\n因为不允许直接为 ci 赋值，当然也就不能通过引用去改变ci。因此，对 r2 的初始化是错误的。假设该初始化合法，则可以通过 r2 来改变它引用对象的值，这显然是不正确的。\n\n> 术语：常量引用是对 const 的引用\n\n初始化和对const的引用\n\n引用的类型要和与之绑定的对象严格匹配，但有两种例外情况：\n\n 1. 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。\n 2. 允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。\n\nint i = 42;\nconst int &r1 = i;\t //允许将const int& 绑定到一个普通int对象上\nconst int &r2 = 42;  //正确：r1是一个常量引用\nconst int &r3 = r1*2;//正确：r3是一个常量引用\nint &r4 = r1*2;      //正确：r4是一个普通的非常量引用\n\n\n1\n2\n3\n4\n5\n\n\n==要理解这种例外情况：最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：==\n\ndouble dval = 3.14;\nconst int &ri = dval;\n\n\n1\n2\n\n\n此处 ri 引用了一个 int 型的数，对 ri 的操作应该是整数运算，但 dval 是一个双精度浮点数而非整数。因此为了确保让 ri 绑定一个整数，编译器把上述代码变成了如下形式：\n\nconst int temp = dval;\t//由双精度浮点数生成一个临时的整形常量\nconst int &ri = temp;\t//让ri绑定这个临时量\n\n\n1\n2\n\n\n在这种情况下，ri 绑定了一个临时量对象。对临时变量操作是被归为非法的，因为对临时变量的操作并不会影响 dval ，这并没有什么意义。\n\n对const的引用可能引用一个并非const的对象\n\nint i = 42;\nint &r1 = i;\t\t//引用ri绑定对象i\nconst int &r2 = i;  //r2也绑定对象i，但是不允许通过r2修改i的值\nr1 = 0;\t\t\t\t//r1并非常量，i的值修改为0\nr2 = 0;\t\t\t\t//错误：r2是一个常量引用\n\n\n1\n2\n3\n4\n5\n\n\nr2 绑定（非常量）整数 i 是合法的行为。然而，不允许通过 r2 修改i的值。尽管如此，i 的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像 r1 一样绑定到i的其他引用来修改。\n\n\n# 2.4.2 指针和 const\n\n==要想存放常量对象的地址，只能使用指向常量的指针：==\n\nconst double pi = 3.14;\t\t//pi是个常量，它的值不能改变\ndouble *ptr = &pi;\t\t\t//错误：ptr是一个普通指针\nconst double *cptr = &pi;\t//正确：cptr可以指向一个双精度常量\n*cptr = 42;\t\t\t\t\t//错误：不能给*cptr赋值\n\n\n1\n2\n3\n4\n\n\n前面提到，指针的类型必须与其所指对象的类型一致，但是有两个例外情况：\n\n==第一种例外情况：允许令一个指向常量的指针指向一个非常量对象：==\n\nconst double pi = 3.14;\nconst double *cptr = &pi;\ndouble dval = 3.14;\t\t\t//dval是一个双精度浮点数，它的值可以改变\ncptr = &dval;\t\t\t\t//正确：但是不能通过cptr改变dval的值\n\n\n1\n2\n3\n4\n\n\n和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。\n\n> tip：可以这样想，所谓指向常量的指针或引用，不过是指针或引用 “自以为是” 罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象地值。\n\nconst指针\n\n指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定位常量。\n\n常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。\n\n把*放在 const 关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：\n\nint errnumb = 0;\nint *const curerr = &errnumb; //curerr将一直指向errnumb\nconst double pi = 3.14159;\nconst double *const pip = &pi;//pip是一个指向常量对象的常量指针\n\n\n1\n2\n3\n4\n\n\n==要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。==\n\n离 curerr 最近的的符号是const，意味着 curerr 本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是 curerr 是一个常量指针。指针存储的那个地址不能改变，但是指向的一个一般的非常量整数，那么就完全可以用curerr去修改 errnumb 的值。\n\n*pip = 2.72;\t//错误：pip是一个指向常量的指针\n//如果curerr所指的对象（也就是errnumb）的值不为0\nif(*curerr) {\n    errorhandler();\n    *curerr = 0;//正确：把curerr所指的对象的值重置\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.4.3 顶层 const\n\n指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。\n\n * 顶层const（top-level const）表示指针本身是个常量；\n   \n   * 顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。\n\n * 底层const（low-level const）表示指针所指的对象是一个常量。\n   \n   * 底层const则与指针和引用等符合类型的基本类型部分有关。\n\n==特殊的是：指针类型既可以是顶层const也可以是底层const。==\n\nint i = 0;\nint *const p1 = &i;\t\t\t//不能改变p1的值，这是一个顶层const\nconst int ci = 42; \t\t\t//不能改变ci的值，这是一个顶层const\nconst int *p2 = &ci;\t\t//允许改变p2的值，这是一个底层const\nconst int *const p3 = p2;\t//靠右的const是顶层const，靠左的是底层const\nconst int &r = ci;\t\t\t//用于声明引用的const都是底层const\n\n\n1\n2\n3\n4\n5\n6\n\n\n当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显：\n\n顶层const不受什么影响：\n\ni = ci;\t//正确：拷贝ci的值，ci是一个顶层const，对此操作无影响\np2 = p3;//正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响\n\n\n1\n2\n\n\n底层const的限制不能忽视：\n\n当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行：\n\nint *p = p3;\t  //错误：p3包含底层const的定义，而p没有\np2 = p3;\t\t  //正确：p2和p3都是底层const\np2 = &i;\t\t  //正确：int* 能转换成const int*\nint &r = ci;\t  //错误：普通的int&不能绑定到int常量上\nconst int &r2 = i;//正确：const int&可以绑定到一个普通int上\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.4.4 constexpr 和常量表达式\n\n常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。\n\n属于常量表达式的：\n\n 1. 字面值；\n 2. 用常量表达式初始化的 const 对象也是常量表达式。\n\nconst int max_files = 20;\t\t//max_files是常量表达式\nconst int limit = max_files + 1;//limit是常量表达式\nint staff_size = 27;\t\t\t//staff_size不是常量表达式\nconst int sz = get_size();\t\t//sz不是常量表达式\n\n\n1\n2\n3\n4\n\n\n尽管 sz 本身是一个常量，但它地具体值直到运行时才能获取到，所以也不是常量表达式。\n\nconstexpr 常量\n\ncpp11 新标准规定，允许将声明变量声明为 constexpr 类型以便由编译器来验证变量地值是否是一个常量表达式。\n\nconstexpr int mf = 20;\t\t // 20 是常量表达式\nconstexpr int limit = mf + 1;// mf+1 是常量表达式\nconstexpr int sz = size();\t //只有size是一个constexpr函数时才是一条正确的声明语句\n\n\n1\n2\n3\n\n\n> 一般来说，如果你认定变量是一个常量表达式，那就把它声明成 constexpr 类型。\n\n字面值类型\n\n> 字面值类型指的是：类型简单、值也显而易见、容易得到，就把它们称为“字面值类型”。\n\n比如：\n\n * 属于字面值类型的：算术类型、引用、指针\n * 不属于字面值类型的：自定义类、io 库、string 类型\n\n指针和引用都能定义成 constexpr ，但它们的初始值都受到严格限制。一个 constexpr 指针的初始值必须是 nullptr 或者 0，或者是存储与某个固定地址中的对象。\n\n指针和 constexpr\n\n必须明确一点：在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关；\n\nconst int *p = nullptr;  \t// p是一个指向整形常量的指针\nconstexpr int *q = nullptr;\t// q是一个指向整数的常量指针\n\n\n1\n2\n\n\np和q的类型相差甚远：\n\n * p是一个指向常量的指针。\n * q是一个常量指针，关键在于 constexpr 把它所定义的对象置为了顶层 const。\n\n\n# 2.5 处理类型\n\n\n# 2.5.1 类型别名\n\n> 类型别名（type alias）是一个名字，它是某种类型的同义词。\n\n传统的方式，使用关键字 typedef 定义类型别名的两种方法：\n\ntypedef double wages;\t// wages 是 double 的同义词\ntypedef wages base, *p;\t// base 是 double 的同义词，p 是 double* 的同义词\n\n\n1\n2\n\n\n新规定，使用别名声明：\n\nusing si = sales_item;\t// si 是 sales_item 的同义词\n\n\n1\n\n\n类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：\n\nwages hourly, weekly;\t// 等价于 double hourly、weekly\nsi item;\t\t\t\t// 等价于 sales_item item\n\n\n1\n2\n\n\n指针、常量和类型别名\n\n> 书中主要讲了在cpp中使用类型别名时可能出现的误解，特别是涉及到指针、常量和类型别名组合的情况。 ==不可以简单地将类型别名替换为其原始类型==\n\n让我逐步解释一下：\n\n 1. 类型别名的定义：\n    \n    typedef char *pstring;\n    \n    \n    1\n    \n    \n    这里定义了一个类型别名 pstring，它是 char* 的别名，即指向字符的指针。\n\n 2. 使用类型别名和常量的声明：\n    \n    const pstring cstr = 0;\n    \n    \n    1\n    \n    \n    这一行声明了一个常量指针 cstr，它指向字符 (char)，并被声明为常量。但是，由于 pstring 是 char* 的别名，这实际上是一个指向字符的常量指针。\n\n 3. 使用类型别名和指针的声明：\n    \n    const pstring *ps;\n    \n    \n    1\n    \n    \n    这一行声明了一个指针 ps，它指向的对象是指向字符的常量指针。\n\n 4. 错误的理解： 作者指出，在阅读这样的声明时，人们可能错误地尝试将类型别名替换为其原始类型，以理解声明的含义。例如，尝试将 const pstring cstr 理解为 const char *cstr。这是错误的，因为 const pstring 表示指向字符的常量指针，而不是指向常量字符的指针。\n\n 5. 改写示例：\n    \n    const char *cstr = 0;\n    \n    \n    1\n    \n    \n    这是错误理解的改写，它将 const pstring cstr 错误地理解为 const char *cstr。这样改写的结果是声明了一个指向常量字符的指针，而不是指向字符的常量指针。这两种声明的含义是截然不同的。\n\n 6. 正确的改写应该是：\n    \n    const char *const cstr = 0;\n    \n    \n    1\n    \n    \n    这表示 cstr 是一个指向字符的常量指针，并且它本身也是一个常量。这样的改写保持了原始声明的含义，即 cstr 是一个指向字符的常量指针。\n\n总的来说，这段话强调了在使用类型别名时，特别是涉及到指针和常量的情况下，需要正确理解类型别名的含义，而不能简单地将其替换为原始类型。这有助于避免在代码理解上的混淆和错误。\n\n\n# 2.5.2 auto 类型说明符\n\nauto 可在一条语句中声明多个变量，但是初始基本数据类型都必须一样：\n\nauto i = 0, *p = &i;\t// 正确：i 是整数、p是整数指针\nauto sz = 0, pi = 3.14;\t// 错误：sz 和 pi 的类型不一致\n\n\n1\n2\n\n\n复合类型、常量、auto\n\nauto 一般会忽略掉顶层 const，同时底层 const 则会保留下来，比如当初始值是一个指向常量的指针时：\n\nconst int ci = i, &cr = ci;\nauto b = ci;\t\t// b 是一个整数(ci 的顶层const 特性被忽略掉了)\nauto c = cr;\t\t// c 是一个整数(cr 是 ci 的别名，ci 本身是一个顶层 const)\nauto d = &i;\t\t// d 是一个整型指针(整数的地址就是指向整数的指针)\nauto e = &ci;\t\t// e 是一个指向整数常量的指针(对常量对象取地址是一种底层 const)\n\n\n1\n2\n3\n4\n5\n\n\n如果希望推断出的 auto 类型是一个顶层 const，需要明确指出：\n\nconst auto f = ci;\t// ci 的推演类型是 int，f 是 const int\n\n\n1\n\n\n还可以将引用的类型设为 auto，此时原来的初始化规则仍然适用:\n\nauto &g = ci;\t\t// g 是一个整型常量引用，绑定到 ci\nauto &h = 42;\t\t// 错误:不能为非常量引用绑定字面值\nconst auto &j = 42;\t// 正确:可以为常量引用绑定字面值\n\n\n1\n2\n3\n\n\n设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。 要在一条语句中定义多个变量，切记，符号 & 和 * 只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:\n\nauto k = ci, &l = i;\t// k 是整数，1 是整型引用\nauto &m = ci,*p = &ci; \t// m 是对整型常量的引用，p 是指向整型常量的指针\n\t\t\t\t\t\t// 错误: i 的类型是 int 而 &ci 的类型是 const int\nauto &n = i, *p2 = &ci;\n\n\n1\n2\n3\n4\n\n\n\n# 2.5.3 decltype 类型指示符\n\ncpp11 新标准引入的第二种类型说明符 decltype，它的作用是选择并返回操作数的数据类型。\n\n在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n\ndecltype(f()) sum = x;\t// sum 的类型就是函数 f 的返回类型\n\n\n1\n\n\n编译器不会实际调用函数 f，而是使用当调用发生时 f 的返回值类型作为 sum 的类型。\n\ndecltype 处理顶层 const 和引用的方式与 auto 有些许不同。如果 decltype 使用的表达式是一个变量,则 decltype 返回该变量的类型(包括顶层 const 和引用在内)：\n\nconst int ci = 0, &cj = ci;\ndecltype(ci) x = 0;\t\t\t// x 的类型是 const int\ndecltype(cj) y = xi;\t\t// y 的类型是 const int&，y 绑定到变量 x\ndecltype(cj) z;\t\t\t\t// 错误: z 是一个引用，必须初始化\n\n\n1\n2\n3\n4\n\n\n\n# 小结\n\n类型是 cpp 编程的基础。\n\n类型规定了其对象的存储要求和所能执行的操作。cpp 语言提供了一套基础内置类型，如 int 和 char 等，这些类型与实现它们的机器硬件密切相关。类型分为非常量和常量，一个常量对象必须初始化，而且一旦初始化其值就不能再改变。此外，还可以定义复合类型，如指针和引用等。复合类型的定义以其他类型为基础。\n\ncpp 语言允许用户以类的形式自定义类型。cpp 库通过类提供了一套高级抽象类型，如输入输出和string 等。',charsets:{cjk:!0}},{title:"Cpp11新标准",frontmatter:{title:"Cpp11新标准",date:"2023-12-01T17:20:37.000Z",permalink:"/pages/518856/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/20.Cpp%E4%B8%93%E6%A0%8F/02.Cpp11%E6%96%B0%E6%A0%87%E5%87%86.html",relativePath:"01.CPP语言/20.Cpp专栏/02.Cpp11新标准.md",key:"v-4a2741a2",path:"/pages/518856/",headers:[{level:2,title:"1、Cpp11有哪些新特性？",slug:"_1、cpp11有哪些新特性",normalizedTitle:"1、cpp11有哪些新特性？",charIndex:15},{level:2,title:"2、auto、decltype和decltype(auto)的用法",slug:"_2、auto、decltype和decltype-auto-的用法",normalizedTitle:"2、auto、decltype和decltype(auto)的用法",charIndex:211},{level:3,title:"(1) auto",slug:"_1-auto",normalizedTitle:"(1) auto",charIndex:249},{level:4,title:"底层const顶层const到底是什么？",slug:"底层const顶层const到底是什么",normalizedTitle:"底层const顶层const到底是什么？",charIndex:808},{level:4,title:"auto的3个推导规则：",slug:"auto的3个推导规则",normalizedTitle:"auto的3个推导规则：",charIndex:1142},{level:3,title:"(2) decltype",slug:"_2-decltype",normalizedTitle:"(2) decltype",charIndex:1412},{level:3,title:"(3) decltype(auto)",slug:"_3-decltype-auto",normalizedTitle:"(3) decltype(auto)",charIndex:2743},{level:2,title:"3、Cpp中NULL和nullptr区别",slug:"_3、cpp中null和nullptr区别",normalizedTitle:"3、cpp中null和nullptr区别",charIndex:2970},{level:2,title:"4、智能指针的原理、常用的智能指针及实现",slug:"_4、智能指针的原理、常用的智能指针及实现",normalizedTitle:"4、智能指针的原理、常用的智能指针及实现",charIndex:5129},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:5136},{level:3,title:"常用的智能指针",slug:"常用的智能指针",normalizedTitle:"常用的智能指针",charIndex:5139},{level:4,title:"(1) shared_ptr",slug:"_1-shared-ptr",normalizedTitle:"(1) shared_ptr",charIndex:5334},{level:4,title:"(2) unique_ptr",slug:"_2-unique-ptr",normalizedTitle:"(2) unique_ptr",charIndex:5863},{level:4,title:"(3) weak_ptr",slug:"_3-weak-ptr",normalizedTitle:"(3) weak_ptr",charIndex:6122},{level:4,title:"(4) auto_ptr",slug:"_4-auto-ptr",normalizedTitle:"(4) auto_ptr",charIndex:6612},{level:2,title:"5、说⼀说你了解的关于lambda函数的全部知识",slug:"_5、说一说你了解的关于lambda函数的全部知识",normalizedTitle:"5、说⼀说你了解的关于lambda函数的全部知识",charIndex:7791},{level:2,title:"6、智能指针的作用",slug:"_6、智能指针的作用",normalizedTitle:"6、智能指针的作用",charIndex:8725},{level:2,title:"7、说说你了解的auto_ptr作用",slug:"_7、说说你了解的auto-ptr作用",normalizedTitle:"7、说说你了解的auto_ptr作用",charIndex:10040},{level:2,title:"8、智能指针的循环引用",slug:"_8、智能指针的循环引用",normalizedTitle:"8、智能指针的循环引用",charIndex:10602}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"5 min read",minutes:4.32,time:259200.00000000006,words:864},headersStr:"1、Cpp11有哪些新特性？ 2、auto、decltype和decltype(auto)的用法 (1) auto 底层const顶层const到底是什么？ auto的3个推导规则： (2) decltype (3) decltype(auto) 3、Cpp中NULL和nullptr区别 4、智能指针的原理、常用的智能指针及实现 原理 常用的智能指针 (1) shared_ptr (2) unique_ptr (3) weak_ptr (4) auto_ptr 5、说⼀说你了解的关于lambda函数的全部知识 6、智能指针的作用 7、说说你了解的auto_ptr作用 8、智能指针的循环引用",content:'# Cpp11新标准\n\n\n# 1、Cpp11有哪些新特性？\n\n * nullptr替代 NULL\n * 引⼊了 auto 和 decltype 这两个关键字实现了类型推导\n * 基于范围的 for 循环for(auto& i : res){}\n * 类和结构体的中初始化列表\n * Lambda 表达式（匿名函数）\n * std::forward_list（单向链表）\n * 右值引用和move语义\n * ...\n\n\n# 2、auto、decltype和decltype(auto)的用法\n\n\n# (1) auto\n\n> Cpp11新标准引⼊了auto类型说明符，⽤它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种 特定的类型说明符(例如 int)不同\n\nauto 让编译器通过初始值来进⾏类型推演。从⽽获得定义变量的类型，所以说 auto 定义的变量必须有初始值。\n\n举个例⼦：\n\n//普通；类型\nint a = 1, b = 3;\nauto c = a + b;// c为int型\n\n//const类型\nconst int i = 5;\nauto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int\nauto k = &i; // 变量i是⼀个常量, 对常量取地址是⼀种底层const, 所以k的类型是const int*\nconst auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前⾯加上cosnt\n\n//引⽤和指针类型\nint x = 2;\nint& y = x;\nauto z = y; //z是int型不是int& 型\nauto& p1 = y; //p1是int&型\nauto p2 = &x; //p2是指针类型int*\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 底层const顶层const到底是什么？\n\nint* const p1 = &a;\t\t// p1是顶层const\nconst int* p2 = &a;\t\t// p2是底层const\n\n\n1\n2\n\n\n> 区分很简单，看const修饰的是哪个。前者修饰的是p1，即指针本身，所以为顶层属性；后者修饰的*p2，即指针的指向地址的值，所以为底层属性。p1又称为常量指针，p2又称为指向常量的指针。\n\n 1. 顶层const在赋值给其他变量时，可以忽略顶层属性；\n 2. 底层const在赋值给其他变量时，不能忽略底层属性；\n 3. int*类型可以转换为顶层和底层const，所以它可以给顶层和底层的const赋值；\n 4. 底层const无法转换为顶层const。\n\n# auto的3个推导规则：\n\n**规则1：**声明为auto（不是auto&）的变量，忽视掉初始化表达式的顶层const。即对有const的普通类型(int 、double等)忽视const，对常量指针（顶层const）变为普通指针，对指向常量（底层const）的常量指针（顶层cosnt）变为指向常量的指针（底层const）。\n\n**规则2：**声明为auto&的变量，保持初始化表达式的顶层const或volatile 属性。\n\n**规则3：****若希望auto推导的是顶层const，加上const，即const auto。\n\n\n# (2) decltype\n\n有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想⽤表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以Cpp11⼜引⼊了第⼆种类型说明符decltype，它的作⽤是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进⾏实际的计算表达式的值。\n\nint func() {return 0};\n//普通类型\ndecltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调⽤函数func()\nint a = 0;\ndecltype(a) b = 4; // a的类型是int, 所以b的类型也是int\n\n//不论是顶层const还是底层const, decltype都会保留 \nconst int c = 3;\ndecltype(c) d = c; // d的类型和c是⼀样的, 都是顶层const\nint e = 4;\nconst int* f = &e; // f是底层const\ndecltype(f) g = f; // g也是底层const\n\n//引⽤与指针类型\n//1. 如果表达式是引⽤类型, 那么decltype的类型也是引⽤\nconst int i = 3, &j = i;\ndecltype(j) k = 5; // k的类型是 const int&\n\n//2. 如果表达式是引⽤类型, 但是想要得到这个引⽤所指向的类型, 需要修改表达式:\nint i = 3, &r = i;\ndecltype(r + 0) t = 5; // 此时是int类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n//3. 对指针的解引⽤操作返回的是引⽤类型\nint i = 3, j = 6, *p = &i;\ndecltype(*p) c = j; // c是int&类型, c和j绑定在⼀起\n\n\n1\n2\n3\n\n\n在这段代码中，i和j都是int类型的变量，分别被初始化为3和6。p是一个指向i的整型指针。decltype(*p)表示*p的类型，即int&类型的引用。 因此，c是一个int&类型的引用，它被初始化为j的值。由于c是一个引用，它引用的是j的地址，因此对c的修改会影响到j的值，反之亦然。\n\n//4. 如果⼀个表达式的类型不是引⽤, 但是我们需要推断出引⽤, 那么可以加上⼀对括号, 就变成了引⽤类型了\nint i = 3;\ndecltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了⼀起\n\n\n1\n2\n3\n\n\n在这段代码中，i是一个int类型的变量，被初始化为3。(i)是一个表达式，它是一个左值引用，引用的是i的地址。因此，decltype((i))表示(i)的类型，即int&类型的引用。 因此，j是一个int&类型的引用，它被初始化为i的值。由于j是一个引用，它引用的是i的地址，因此对j的修改会影响到i的值，反之亦然。\n\n\n# (3) decltype(auto)\n\ndecltype(auto)是Cpp14新增的类型指示符，可以⽤来声明变量以及指示函数返回类型。在使⽤时，会将“=”号左边的表达式替换成auto，再根据decltype的语法规则来确定类型。\n\n举个例子：\n\nint e = 4;\nconst int* f = &e; // f是底层const\ndecltype(auto) j = f;//j的类型是const int* 并且指向的是e\n\n\n1\n2\n3\n\n\n\n# 3、Cpp中NULL和nullptr区别\n\n算是为了与C语言进行兼容而定义的⼀个问题吧\n\nNULL来⾃C语⾔，⼀般由宏定义实现，⽽ nullptr 则是Cpp11的新增关键字。在C语言中，NULL被定义为(void)0, 而在Cpp语言中，NULL则被定义为整数0*。编译器⼀般对其实际定义如下：\n\n#ifdef __cplusplus\n#define NULL 0\n#else\n#define NULL ((void *)0)\n#endif\n\n\n1\n2\n3\n4\n5\n\n\n在Cpp中指针必须有明确的类型定义。但是将NULL定义为0带来的另⼀个问题是无法与整数的0区分。因为Cpp中允许有函数重载，所以可以试想如下函数定义情况：\n\n#include <iostream>\nusing namespace std;\nvoid fun(char* p) {\n cout << "char*" << endl;\n}\nvoid fun(int p) {\n cout << "int" << endl;\n}\nint main()\n{\n fun(NULL);\n return 0;\n}\n//输出结果：int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n那么在传⼊NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr 在Cpp11被引入用于解决这⼀问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针 类型，但不会被转换为任何整型，所以不会造成参数传递错误。\n\nnullptr的⼀种实现⽅式如下：\n\nconst class nullptr_t{\npublic:\n\ttemplate<class T> inline operator T*() const{ return 0; }\n\ttemplate<class C, class T> inline operator T C::*() const { return 0; }\nprivate:\n\tvoid operator&() const;\n} nullptr = {};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这段代码定义了一个名为nullptr_t的类，它是Cpp11标准中用于表示空指针常量的类型。nullptr_t类中定义了两个模板类型转换运算符，用于将nullptr转换为指针类型或类成员指针类型。\n\n * 第一个模板类型转换运算符将nullptr转换为任意类型的指针类型，其返回值为0，即空指针常量。\n * 第二个模板类型转换运算符将nullptr转换为任意类的成员指针类型，其返回值也为0。\n\nnullptr_t类还声明了一个私有的地址运算符operator&()，它的作用是禁止将nullptr取地址，从而保证nullptr只能被直接赋值给指针类型或类成员指针类型，而不能被用于一些不安全的指针操作。 最后，代码中还定义了一个名为nullptr的对象，它是一个默认初始化的nullptr_t类型的空指针常量对象。\n\n#include <iostream>\nint main() {\n    int* p1 = nullptr; // 将nullptr赋值给指针类型\n    int MyClass::* p2 = nullptr; // 将nullptr赋值给类成员指针类型\n    // int* p3 = &nullptr; // 错误，nullptr不能被取地址\n    std::cout << p1 << std::endl; // 输出 0\n    std::cout << p2 << std::endl; // 输出 0\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。但nullptr仍然存在⼀定问题，例如：\n\n#include <iostream>\nusing namespace std;\n\nvoid fun(char* p) {\n\tcout<< "char* p" <<endl;\n}\nvoid fun(int* p) {\n\tcout<< "int* p" <<endl;\n}\n\nvoid fun(int p) {\n\tcout<< "int p" <<endl;\n}\nint main() {\n\tfun((char*)nullptr);//语句1\n\tfun(nullptr);//语句2\n\tfun(NULL);//语句3\n\treturn 0;\n}\n//运⾏结果：\n//语句1：char* p\n//语句2:报错，有多个匹配\n//语句3：int p\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在这种情况下存在对不同指针类型的函数重载，此时如果传⼊nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。\n\n\n# 4、智能指针的原理、常用的智能指针及实现\n\n\n# 原理\n\n智能指针是⼀个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给⼀个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源。\n\n> 智能指针的实现一般通过一个类来完成，该类中包含一个指向动态分配对象的原始指针，以及一些管理规则，例如引用计数、作用域、线程安全等。\n\n\n# 常用的智能指针\n\n# (1) shared_ptr\n\n> 实现原理：主要依赖于引用计数器的方法和控制块的概念，当创建一个std::shared_ptr对象时，会同时创建一个控制块(control block)，该控制块中包含一个引用计数和指向所管理对象的原始指针。引用计数记录了有多少个std::shared_ptr对象共享该控制块，初始值为1。当有新的std::shared_ptr对象指向该控制块时，引用计数加1。当一个std::shared_ptr对象被销毁时，引用计数减1。当引用计数为0时，即没有std::shared_ptr对象指向该控制块时，该控制块所管理的对象会被销毁，同时控制块本身也会被销毁。\n\n * 智能指针将⼀个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同⼀指针\n * 每次创建类的新对象时，初始化指针并将引用计数置为1\n * 当对象作为另⼀对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数\n * 对⼀个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数\n * 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）\n\n# (2) unique_ptr\n\n> 实现原理：unique_ptr采用的是移动语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所有unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝⼀个 unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同⼀内存指针多次释放而导致程序崩溃。\n\n# (3) weak_ptr\n\nweak_ptr：弱引用。引用计数有⼀个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr通过将其中一个或多个std::shared_ptr对象转换为std::weak_ptr对象，来打破环形引用。weak_ptr是⼀个弱引用，它是为了配合shared_ptr而引入的⼀种智能指针，它指向⼀个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果⼀块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存⼀定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。\n\n需要注意的是，std::weak_ptr对象不能直接访问所管理的对象，需要先将其转换为std::shared_ptr对象才能访问所管理的对象。如果在转换过程中发现该对象已经被销毁，则转换后的std::shared_ptr对象会变成null指针。\n\n# (4) auto_ptr\n\n主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。\n\nauto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。\n\nauto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能再STL中使用。\n\n智能指针shared_ptr代码实现：\n\ntemplate<typename T>\nclass SharedPtr\n{\npublic:\n \tSharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1)){}\n    \n\tSharedPtr(const SharedPtr& s):_ptr(s._ptr), _pcount(s._pcount) {\n \t\t(*_pcount)++;\n \t}\n\tSharedPtr<T>& operator=(const SharedPtr& s)\n    {\n \t\tif (this != &s)\n \t\t{\n \t\t\tif (--(*(this->_pcount)) == 0)\n \t\t\t{\n \t\t\t\tdelete this->_ptr;\n \t\t\t\tdelete this->_pcount;\n \t\t\t}\n \t\t\t_ptr = s._ptr;\n \t\t\t_pcount = s._pcount;\n \t\t\t*(_pcount)++;\n \t\t}\n \t\treturn *this;\n  \t}\n \tT& operator*()\n \t{\n \t\treturn *(this->_ptr);\n \t}\n\tT* operator->()\n \t{\n \t\treturn this->_ptr;\n \t}\n \t~SharedPtr()\n \t{\n \t\t--(*(this->_pcount));\n \t\tif (*(this->_pcount) == 0)\n \t\t{\n \t\t\tdelete _ptr;\n \t\t\t_ptr = NULL;\n \t\t\tdelete _pcount;\n \t\t\t_pcount = NULL;\n \t\t}\n \t}\nprivate:\n \tT* _ptr;\n \tint* _pcount;//指向引⽤计数的指针\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 5、说⼀说你了解的关于lambda函数的全部知识\n\n 1. 利用lambda表达式可以编写内嵌的匿名函数，⽤以替换独立函数或者函数对象；\n\n 2. 每当你定义⼀个lambda表达式后，编译器会自动生成⼀个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回⼀个匿名的闭包实例，其实是⼀个右值。所以，我们上面的lambda表达式的结果就是⼀个个闭包。闭包的⼀个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们⼜将其称为 lambda捕捉块。\n    \n    >  * 值捕获：通过值捕获，将外部变量复制一份到Lambda函数内部，Lambda函数内部对该变量的修改不会影响到外部变量。\n    >  * 引用捕获：通过引用捕获，将外部变量的引用传递给Lambda函数，Lambda函数内部对该变量的修改会影响到外部变量。\n\n 3. lambda表达式的语法定义如下：\n    \n    [capture](parameters)mutable -> return-type {statement};\n    //capture是捕获列表，用于指定Lambda函数所能访问的外部变量\n    \t// =：以值捕获方式捕获所有外部变量。\n    \t// &：以引用捕获方式捕获所有外部变量。\n    \t// 变量名：以值捕获方式捕获指定的外部变量。\n    \t// &变量名：以引用捕获方式捕获指定的外部变量。\n    \n    //parameters是参数列表，用于指定Lambda函数的参数\n    //return-type是返回值类型，用于指定Lambda函数的返回值类型\n    //statement是函数体，用于实现Lambda函数的具体功能\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 4. lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；\n\n\n# 6、智能指针的作用\n\n 1. Cpp11中引入了智能指针的概念，⽅便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），⼆次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。\n\n 2. 智能指针在Cpp11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、weak_ptr。 shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每⼀个shared_ptr的拷贝都指向相同的内存。每使用他⼀次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。\n\n 3. 初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给⼀个智能指针，⼀个是类，⼀个是指针。例如std::shared_ptr p4 = new int(1);的写法是错误的。\n    \n    > 拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。\n\n 4. unique_ptr“唯⼀”拥有其所指对象，同⼀时刻只能有⼀个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset⽅法重新指定、通过release方法释放所有权、通过移动语义转移所有权。\n\n 5. 智能指针类将⼀个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同⼀指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另⼀对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对⼀个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。\n\n 6. weak_ptr 是⼀种不控制对象生命周期的智能指针, 它指向⼀个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的⼀个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的⼀种智能指针来协助 shared_ptr 工作, 它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少.\n\n\n# 7、说说你了解的auto_ptr作用\n\n 1. auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；\n 2. auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建⼀个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；\n 3. auto_ptr的构造函数是explicit，阻止了⼀般指针隐式转换为 auto_ptr的构造，所以不能直接将⼀般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；\n 4. 由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同⼀个指针；\n 5. Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；\n 6. auto_ptr支持所拥有的指针类型之间的隐式类型转换。\n 7. 可以通过*和->运算符对auto_ptr所有用的指针进行提领操作；\n 8. T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。\n\n\n# 8、智能指针的循环引用\n\n循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例⼦：\n\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nclass Node\n{\npublic:\n \tNode(const T& value)\n \t:_pPre(NULL)\n \t, _pNext(NULL)\n \t, _value(value)\n \t{\n \t\tcout << "Node()" << endl;\n \t}\n \t~Node()\n \t{\n \t\tcout << "~Node()" << endl;\n \t\tcout << "this:" << this << endl;\n \t}\n \tshared_ptr<Node<T>> _pPre;\n \tshared_ptr<Node<T>> _pNext;\n \tT _value;\n};\n\nvoid Funtest()\n{\n \tshared_ptr<Node<int>> sp1(new Node<int>(1));\n \tshared_ptr<Node<int>> sp2(new Node<int>(2));\n \t\n    cout << "sp1.use_count:" << sp1.use_count() << endl;\n \tcout << "sp2.use_count:" << sp2.use_count() << endl;\n \n    sp1->_pNext = sp2; //sp2的引⽤+1\n \tsp2->_pPre = sp1; //sp1的引⽤+1\n \t\n    cout << "sp1.use_count:" << sp1.use_count() << endl;\n \tcout << "sp2.use_count:" << sp2.use_count() << endl;\n}\n\nint main()\n{\n \tFuntest();\n \tsystem("pause");\n \treturn 0;\n}\n//输出结果\n//Node()\n//Node()\n//sp1.use_count:1\n//sp2.use_count:1\n//sp1.use_count:2\n//sp2.use_count:2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n',normalizedContent:'# cpp11新标准\n\n\n# 1、cpp11有哪些新特性？\n\n * nullptr替代 null\n * 引⼊了 auto 和 decltype 这两个关键字实现了类型推导\n * 基于范围的 for 循环for(auto& i : res){}\n * 类和结构体的中初始化列表\n * lambda 表达式（匿名函数）\n * std::forward_list（单向链表）\n * 右值引用和move语义\n * ...\n\n\n# 2、auto、decltype和decltype(auto)的用法\n\n\n# (1) auto\n\n> cpp11新标准引⼊了auto类型说明符，⽤它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种 特定的类型说明符(例如 int)不同\n\nauto 让编译器通过初始值来进⾏类型推演。从⽽获得定义变量的类型，所以说 auto 定义的变量必须有初始值。\n\n举个例⼦：\n\n//普通；类型\nint a = 1, b = 3;\nauto c = a + b;// c为int型\n\n//const类型\nconst int i = 5;\nauto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int\nauto k = &i; // 变量i是⼀个常量, 对常量取地址是⼀种底层const, 所以k的类型是const int*\nconst auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前⾯加上cosnt\n\n//引⽤和指针类型\nint x = 2;\nint& y = x;\nauto z = y; //z是int型不是int& 型\nauto& p1 = y; //p1是int&型\nauto p2 = &x; //p2是指针类型int*\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 底层const顶层const到底是什么？\n\nint* const p1 = &a;\t\t// p1是顶层const\nconst int* p2 = &a;\t\t// p2是底层const\n\n\n1\n2\n\n\n> 区分很简单，看const修饰的是哪个。前者修饰的是p1，即指针本身，所以为顶层属性；后者修饰的*p2，即指针的指向地址的值，所以为底层属性。p1又称为常量指针，p2又称为指向常量的指针。\n\n 1. 顶层const在赋值给其他变量时，可以忽略顶层属性；\n 2. 底层const在赋值给其他变量时，不能忽略底层属性；\n 3. int*类型可以转换为顶层和底层const，所以它可以给顶层和底层的const赋值；\n 4. 底层const无法转换为顶层const。\n\n# auto的3个推导规则：\n\n**规则1：**声明为auto（不是auto&）的变量，忽视掉初始化表达式的顶层const。即对有const的普通类型(int 、double等)忽视const，对常量指针（顶层const）变为普通指针，对指向常量（底层const）的常量指针（顶层cosnt）变为指向常量的指针（底层const）。\n\n**规则2：**声明为auto&的变量，保持初始化表达式的顶层const或volatile 属性。\n\n**规则3：****若希望auto推导的是顶层const，加上const，即const auto。\n\n\n# (2) decltype\n\n有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想⽤表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以cpp11⼜引⼊了第⼆种类型说明符decltype，它的作⽤是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进⾏实际的计算表达式的值。\n\nint func() {return 0};\n//普通类型\ndecltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调⽤函数func()\nint a = 0;\ndecltype(a) b = 4; // a的类型是int, 所以b的类型也是int\n\n//不论是顶层const还是底层const, decltype都会保留 \nconst int c = 3;\ndecltype(c) d = c; // d的类型和c是⼀样的, 都是顶层const\nint e = 4;\nconst int* f = &e; // f是底层const\ndecltype(f) g = f; // g也是底层const\n\n//引⽤与指针类型\n//1. 如果表达式是引⽤类型, 那么decltype的类型也是引⽤\nconst int i = 3, &j = i;\ndecltype(j) k = 5; // k的类型是 const int&\n\n//2. 如果表达式是引⽤类型, 但是想要得到这个引⽤所指向的类型, 需要修改表达式:\nint i = 3, &r = i;\ndecltype(r + 0) t = 5; // 此时是int类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n//3. 对指针的解引⽤操作返回的是引⽤类型\nint i = 3, j = 6, *p = &i;\ndecltype(*p) c = j; // c是int&类型, c和j绑定在⼀起\n\n\n1\n2\n3\n\n\n在这段代码中，i和j都是int类型的变量，分别被初始化为3和6。p是一个指向i的整型指针。decltype(*p)表示*p的类型，即int&类型的引用。 因此，c是一个int&类型的引用，它被初始化为j的值。由于c是一个引用，它引用的是j的地址，因此对c的修改会影响到j的值，反之亦然。\n\n//4. 如果⼀个表达式的类型不是引⽤, 但是我们需要推断出引⽤, 那么可以加上⼀对括号, 就变成了引⽤类型了\nint i = 3;\ndecltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了⼀起\n\n\n1\n2\n3\n\n\n在这段代码中，i是一个int类型的变量，被初始化为3。(i)是一个表达式，它是一个左值引用，引用的是i的地址。因此，decltype((i))表示(i)的类型，即int&类型的引用。 因此，j是一个int&类型的引用，它被初始化为i的值。由于j是一个引用，它引用的是i的地址，因此对j的修改会影响到i的值，反之亦然。\n\n\n# (3) decltype(auto)\n\ndecltype(auto)是cpp14新增的类型指示符，可以⽤来声明变量以及指示函数返回类型。在使⽤时，会将“=”号左边的表达式替换成auto，再根据decltype的语法规则来确定类型。\n\n举个例子：\n\nint e = 4;\nconst int* f = &e; // f是底层const\ndecltype(auto) j = f;//j的类型是const int* 并且指向的是e\n\n\n1\n2\n3\n\n\n\n# 3、cpp中null和nullptr区别\n\n算是为了与c语言进行兼容而定义的⼀个问题吧\n\nnull来⾃c语⾔，⼀般由宏定义实现，⽽ nullptr 则是cpp11的新增关键字。在c语言中，null被定义为(void)0, 而在cpp语言中，null则被定义为整数0*。编译器⼀般对其实际定义如下：\n\n#ifdef __cplusplus\n#define null 0\n#else\n#define null ((void *)0)\n#endif\n\n\n1\n2\n3\n4\n5\n\n\n在cpp中指针必须有明确的类型定义。但是将null定义为0带来的另⼀个问题是无法与整数的0区分。因为cpp中允许有函数重载，所以可以试想如下函数定义情况：\n\n#include <iostream>\nusing namespace std;\nvoid fun(char* p) {\n cout << "char*" << endl;\n}\nvoid fun(int p) {\n cout << "int" << endl;\n}\nint main()\n{\n fun(null);\n return 0;\n}\n//输出结果：int\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n那么在传⼊null参数时，会把null当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr 在cpp11被引入用于解决这⼀问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针 类型，但不会被转换为任何整型，所以不会造成参数传递错误。\n\nnullptr的⼀种实现⽅式如下：\n\nconst class nullptr_t{\npublic:\n\ttemplate<class t> inline operator t*() const{ return 0; }\n\ttemplate<class c, class t> inline operator t c::*() const { return 0; }\nprivate:\n\tvoid operator&() const;\n} nullptr = {};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这段代码定义了一个名为nullptr_t的类，它是cpp11标准中用于表示空指针常量的类型。nullptr_t类中定义了两个模板类型转换运算符，用于将nullptr转换为指针类型或类成员指针类型。\n\n * 第一个模板类型转换运算符将nullptr转换为任意类型的指针类型，其返回值为0，即空指针常量。\n * 第二个模板类型转换运算符将nullptr转换为任意类的成员指针类型，其返回值也为0。\n\nnullptr_t类还声明了一个私有的地址运算符operator&()，它的作用是禁止将nullptr取地址，从而保证nullptr只能被直接赋值给指针类型或类成员指针类型，而不能被用于一些不安全的指针操作。 最后，代码中还定义了一个名为nullptr的对象，它是一个默认初始化的nullptr_t类型的空指针常量对象。\n\n#include <iostream>\nint main() {\n    int* p1 = nullptr; // 将nullptr赋值给指针类型\n    int myclass::* p2 = nullptr; // 将nullptr赋值给类成员指针类型\n    // int* p3 = &nullptr; // 错误，nullptr不能被取地址\n    std::cout << p1 << std::endl; // 输出 0\n    std::cout << p2 << std::endl; // 输出 0\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。但nullptr仍然存在⼀定问题，例如：\n\n#include <iostream>\nusing namespace std;\n\nvoid fun(char* p) {\n\tcout<< "char* p" <<endl;\n}\nvoid fun(int* p) {\n\tcout<< "int* p" <<endl;\n}\n\nvoid fun(int p) {\n\tcout<< "int p" <<endl;\n}\nint main() {\n\tfun((char*)nullptr);//语句1\n\tfun(nullptr);//语句2\n\tfun(null);//语句3\n\treturn 0;\n}\n//运⾏结果：\n//语句1：char* p\n//语句2:报错，有多个匹配\n//语句3：int p\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在这种情况下存在对不同指针类型的函数重载，此时如果传⼊nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。\n\n\n# 4、智能指针的原理、常用的智能指针及实现\n\n\n# 原理\n\n智能指针是⼀个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给⼀个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源。\n\n> 智能指针的实现一般通过一个类来完成，该类中包含一个指向动态分配对象的原始指针，以及一些管理规则，例如引用计数、作用域、线程安全等。\n\n\n# 常用的智能指针\n\n# (1) shared_ptr\n\n> 实现原理：主要依赖于引用计数器的方法和控制块的概念，当创建一个std::shared_ptr对象时，会同时创建一个控制块(control block)，该控制块中包含一个引用计数和指向所管理对象的原始指针。引用计数记录了有多少个std::shared_ptr对象共享该控制块，初始值为1。当有新的std::shared_ptr对象指向该控制块时，引用计数加1。当一个std::shared_ptr对象被销毁时，引用计数减1。当引用计数为0时，即没有std::shared_ptr对象指向该控制块时，该控制块所管理的对象会被销毁，同时控制块本身也会被销毁。\n\n * 智能指针将⼀个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同⼀指针\n * 每次创建类的新对象时，初始化指针并将引用计数置为1\n * 当对象作为另⼀对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数\n * 对⼀个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数\n * 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）\n\n# (2) unique_ptr\n\n> 实现原理：unique_ptr采用的是移动语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所有unique_ptr不支持普通的拷贝和赋值操作，不能用在stl标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝⼀个 unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同⼀内存指针多次释放而导致程序崩溃。\n\n# (3) weak_ptr\n\nweak_ptr：弱引用。引用计数有⼀个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr通过将其中一个或多个std::shared_ptr对象转换为std::weak_ptr对象，来打破环形引用。weak_ptr是⼀个弱引用，它是为了配合shared_ptr而引入的⼀种智能指针，它指向⼀个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果⼀块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存⼀定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。\n\n需要注意的是，std::weak_ptr对象不能直接访问所管理的对象，需要先将其转换为std::shared_ptr对象才能访问所管理的对象。如果在转换过程中发现该对象已经被销毁，则转换后的std::shared_ptr对象会变成null指针。\n\n# (4) auto_ptr\n\n主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。\n\nauto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。\n\nauto_ptr不支持拷贝和赋值操作，不能用在stl标准容器中。stl容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能再stl中使用。\n\n智能指针shared_ptr代码实现：\n\ntemplate<typename t>\nclass sharedptr\n{\npublic:\n \tsharedptr(t* ptr = null):_ptr(ptr), _pcount(new int(1)){}\n    \n\tsharedptr(const sharedptr& s):_ptr(s._ptr), _pcount(s._pcount) {\n \t\t(*_pcount)++;\n \t}\n\tsharedptr<t>& operator=(const sharedptr& s)\n    {\n \t\tif (this != &s)\n \t\t{\n \t\t\tif (--(*(this->_pcount)) == 0)\n \t\t\t{\n \t\t\t\tdelete this->_ptr;\n \t\t\t\tdelete this->_pcount;\n \t\t\t}\n \t\t\t_ptr = s._ptr;\n \t\t\t_pcount = s._pcount;\n \t\t\t*(_pcount)++;\n \t\t}\n \t\treturn *this;\n  \t}\n \tt& operator*()\n \t{\n \t\treturn *(this->_ptr);\n \t}\n\tt* operator->()\n \t{\n \t\treturn this->_ptr;\n \t}\n \t~sharedptr()\n \t{\n \t\t--(*(this->_pcount));\n \t\tif (*(this->_pcount) == 0)\n \t\t{\n \t\t\tdelete _ptr;\n \t\t\t_ptr = null;\n \t\t\tdelete _pcount;\n \t\t\t_pcount = null;\n \t\t}\n \t}\nprivate:\n \tt* _ptr;\n \tint* _pcount;//指向引⽤计数的指针\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 5、说⼀说你了解的关于lambda函数的全部知识\n\n 1. 利用lambda表达式可以编写内嵌的匿名函数，⽤以替换独立函数或者函数对象；\n\n 2. 每当你定义⼀个lambda表达式后，编译器会自动生成⼀个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回⼀个匿名的闭包实例，其实是⼀个右值。所以，我们上面的lambda表达式的结果就是⼀个个闭包。闭包的⼀个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们⼜将其称为 lambda捕捉块。\n    \n    >  * 值捕获：通过值捕获，将外部变量复制一份到lambda函数内部，lambda函数内部对该变量的修改不会影响到外部变量。\n    >  * 引用捕获：通过引用捕获，将外部变量的引用传递给lambda函数，lambda函数内部对该变量的修改会影响到外部变量。\n\n 3. lambda表达式的语法定义如下：\n    \n    [capture](parameters)mutable -> return-type {statement};\n    //capture是捕获列表，用于指定lambda函数所能访问的外部变量\n    \t// =：以值捕获方式捕获所有外部变量。\n    \t// &：以引用捕获方式捕获所有外部变量。\n    \t// 变量名：以值捕获方式捕获指定的外部变量。\n    \t// &变量名：以引用捕获方式捕获指定的外部变量。\n    \n    //parameters是参数列表，用于指定lambda函数的参数\n    //return-type是返回值类型，用于指定lambda函数的返回值类型\n    //statement是函数体，用于实现lambda函数的具体功能\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 4. lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；\n\n\n# 6、智能指针的作用\n\n 1. cpp11中引入了智能指针的概念，⽅便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），⼆次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。\n\n 2. 智能指针在cpp11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、weak_ptr。 shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每⼀个shared_ptr的拷贝都指向相同的内存。每使用他⼀次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。\n\n 3. 初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给⼀个智能指针，⼀个是类，⼀个是指针。例如std::shared_ptr p4 = new int(1);的写法是错误的。\n    \n    > 拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。\n\n 4. unique_ptr“唯⼀”拥有其所指对象，同⼀时刻只能有⼀个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其raii的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset⽅法重新指定、通过release方法释放所有权、通过移动语义转移所有权。\n\n 5. 智能指针类将⼀个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同⼀指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另⼀对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对⼀个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。\n\n 6. weak_ptr 是⼀种不控制对象生命周期的智能指针, 它指向⼀个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的⼀个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的⼀种智能指针来协助 shared_ptr 工作, 它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少.\n\n\n# 7、说说你了解的auto_ptr作用\n\n 1. auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；\n 2. auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建⼀个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；\n 3. auto_ptr的构造函数是explicit，阻止了⼀般指针隐式转换为 auto_ptr的构造，所以不能直接将⼀般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；\n 4. 由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同⼀个指针；\n 5. auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；\n 6. auto_ptr支持所拥有的指针类型之间的隐式类型转换。\n 7. 可以通过*和->运算符对auto_ptr所有用的指针进行提领操作；\n 8. t* get(),获得auto_ptr所拥有的指针；t* release()，释放auto_ptr的所有权，并将所有用的指针返回。\n\n\n# 8、智能指针的循环引用\n\n循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例⼦：\n\n#include <iostream>\nusing namespace std;\n\ntemplate <typename t>\nclass node\n{\npublic:\n \tnode(const t& value)\n \t:_ppre(null)\n \t, _pnext(null)\n \t, _value(value)\n \t{\n \t\tcout << "node()" << endl;\n \t}\n \t~node()\n \t{\n \t\tcout << "~node()" << endl;\n \t\tcout << "this:" << this << endl;\n \t}\n \tshared_ptr<node<t>> _ppre;\n \tshared_ptr<node<t>> _pnext;\n \tt _value;\n};\n\nvoid funtest()\n{\n \tshared_ptr<node<int>> sp1(new node<int>(1));\n \tshared_ptr<node<int>> sp2(new node<int>(2));\n \t\n    cout << "sp1.use_count:" << sp1.use_count() << endl;\n \tcout << "sp2.use_count:" << sp2.use_count() << endl;\n \n    sp1->_pnext = sp2; //sp2的引⽤+1\n \tsp2->_ppre = sp1; //sp1的引⽤+1\n \t\n    cout << "sp1.use_count:" << sp1.use_count() << endl;\n \tcout << "sp2.use_count:" << sp2.use_count() << endl;\n}\n\nint main()\n{\n \tfuntest();\n \tsystem("pause");\n \treturn 0;\n}\n//输出结果\n//node()\n//node()\n//sp1.use_count:1\n//sp2.use_count:1\n//sp1.use_count:2\n//sp2.use_count:2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n',charsets:{cjk:!0}},{title:"探索C++14新特性：更强大、更高效的编程",frontmatter:{title:"探索C++14新特性：更强大、更高效的编程",date:"2023-12-05T16:27:17.000Z",permalink:"/pages/2f7f31/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/20.Cpp%E4%B8%93%E6%A0%8F/03.%E6%8E%A2%E7%B4%A2C++14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E6%9B%B4%E5%BC%BA%E5%A4%A7%E3%80%81%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E7%BC%96%E7%A8%8B.html",relativePath:"01.CPP语言/20.Cpp专栏/03.探索C++14新特性：更强大、更高效的编程.md",key:"v-164b59d5",path:"/pages/2f7f31/",headers:[{level:2,title:"1、引言",slug:"_1、引言",normalizedTitle:"1、引言",charIndex:206},{level:3,title:"1.1新的语言特性",slug:"_1-1新的语言特性",normalizedTitle:"1.1新的语言特性",charIndex:215},{level:3,title:"1.2新库功能",slug:"_1-2新库功能",normalizedTitle:"1.2新库功能",charIndex:357},{level:2,title:"2、变量模板",slug:"_2、变量模板",normalizedTitle:"2、变量模板",charIndex:591},{level:2,title:"3、lambda 表达式的新增功能",slug:"_3、lambda-表达式的新增功能",normalizedTitle:"3、lambda 表达式的新增功能",charIndex:1153},{level:3,title:"3.1 泛化",slug:"_3-1-泛化",normalizedTitle:"3.1 泛化",charIndex:1175},{level:3,title:"3.2 对捕获的变量和引用进行初始化",slug:"_3-2-对捕获的变量和引用进行初始化",normalizedTitle:"3.2 对捕获的变量和引用进行初始化",charIndex:1633},{level:2,title:"4、constexpr 函数可以包含多个语句",slug:"_4、constexpr-函数可以包含多个语句",normalizedTitle:"4、constexpr 函数可以包含多个语句",charIndex:2147},{level:2,title:"5、整型字面量",slug:"_5、整型字面量",normalizedTitle:"5、整型字面量",charIndex:3594},{level:3,title:"5.1 二进制字面量",slug:"_5-1-二进制字面量",normalizedTitle:"5.1 二进制字面量",charIndex:3606},{level:3,title:"5.2 数字分隔符",slug:"_5-2-数字分隔符",normalizedTitle:"5.2 数字分隔符",charIndex:3686},{level:2,title:"6、返回类型自动推导",slug:"_6、返回类型自动推导",normalizedTitle:"6、返回类型自动推导",charIndex:3779},{level:2,title:"7、exchange",slug:"_7、exchange",normalizedTitle:"7、exchange",charIndex:4513},{level:2,title:"8、quoted",slug:"_8、quoted",normalizedTitle:"8、quoted",charIndex:5058},{level:2,title:"9、C++14 经常考到的知识点",slug:"_9、c-14-经常考到的知识点",normalizedTitle:"9、c++14 经常考到的知识点",charIndex:5980},{level:3,title:"9.1 C++14 引入了哪些新特性？",slug:"_9-1-c-14-引入了哪些新特性",normalizedTitle:"9.1 c++14 引入了哪些新特性？",charIndex:6001},{level:3,title:"9.2 C++14 中 auto 关键字的用法和限制是什么？",slug:"_9-2-c-14-中-auto-关键字的用法和限制是什么",normalizedTitle:"9.2 c++14 中 auto 关键字的用法和限制是什么？",charIndex:6370},{level:3,title:"9.3 C++14 中如何使用 Lambda 表达式？有什么改进？",slug:"_9-3-c-14-中如何使用-lambda-表达式-有什么改进",normalizedTitle:"9.3 c++14 中如何使用 lambda 表达式？有什么改进？",charIndex:7143},{level:3,title:"9.4 C++14 对于 constexpr 关键字有何改进？",slug:"_9-4-c-14-对于-constexpr-关键字有何改进",normalizedTitle:"9.4 c++14 对于 constexpr 关键字有何改进？",charIndex:7916},{level:3,title:"9.5 C++14 中提供了哪些新的标准库组件和功能？",slug:"_9-5-c-14-中提供了哪些新的标准库组件和功能",normalizedTitle:"9.5 c++14 中提供了哪些新的标准库组件和功能？",charIndex:8317},{level:3,title:"9.6 在 C++14 中，变长参数模板是如何使用的？",slug:"_9-6-在-c-14-中-变长参数模板是如何使用的",normalizedTitle:"9.6 在 c++14 中，变长参数模板是如何使用的？",charIndex:8761},{level:3,title:"9.7 在 C++14 中，是否允许在 lambda 函数内定义其他函数或类？",slug:"_9-7-在-c-14-中-是否允许在-lambda-函数内定义其他函数或类",normalizedTitle:"9.7 在 c++14 中，是否允许在 lambda 函数内定义其他函数或类？",charIndex:9582},{level:3,title:"9.8 C++14 是否支持原始字符串字面量（raw string literals）？如何使用它们？",slug:"_9-8-c-14-是否支持原始字符串字面量-raw-string-literals-如何使用它们",normalizedTitle:"9.8 c++14 是否支持原始字符串字面量（raw string literals）？如何使用它们？",charIndex:9909},{level:3,title:"9.9 在 C++14 中，std::makeunique和std::makeshared这两个函数的作用是什么？",slug:"_9-9-在-c-14-中-std-make-unique和std-make-shared这两个函数的作用是什么",normalizedTitle:"9.9 在 c++14 中，std::makeunique和std::makeshared这两个函数的作用是什么？",charIndex:null},{level:3,title:"9.10 C++14 引入了统一初始化语法（uniform initialization syntax），具体有哪些变化？",slug:"_9-10-c-14-引入了统一初始化语法-uniform-initialization-syntax-具体有哪些变化",normalizedTitle:"9.10 c++14 引入了统一初始化语法（uniform initialization syntax），具体有哪些变化？",charIndex:10970}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"7 min read",minutes:6.755,time:405300,words:1351},headersStr:"1、引言 1.1新的语言特性 1.2新库功能 2、变量模板 3、lambda 表达式的新增功能 3.1 泛化 3.2 对捕获的变量和引用进行初始化 4、constexpr 函数可以包含多个语句 5、整型字面量 5.1 二进制字面量 5.2 数字分隔符 6、返回类型自动推导 7、exchange 8、quoted 9、C++14 经常考到的知识点 9.1 C++14 引入了哪些新特性？ 9.2 C++14 中 auto 关键字的用法和限制是什么？ 9.3 C++14 中如何使用 Lambda 表达式？有什么改进？ 9.4 C++14 对于 constexpr 关键字有何改进？ 9.5 C++14 中提供了哪些新的标准库组件和功能？ 9.6 在 C++14 中，变长参数模板是如何使用的？ 9.7 在 C++14 中，是否允许在 lambda 函数内定义其他函数或类？ 9.8 C++14 是否支持原始字符串字面量（raw string literals）？如何使用它们？ 9.9 在 C++14 中，std::makeunique和std::makeshared这两个函数的作用是什么？ 9.10 C++14 引入了统一初始化语法（uniform initialization syntax），具体有哪些变化？",content:'# 探索C++14新特性：更强大、更高效的编程\n\nC++14并没有太大的改动，就连官方说明中也指出，C++14相对于C++11来说是一个比较小的改动，但是在很大程度上完善了C++11，所以可以说C++14就是在C++11标准上的查漏补缺。\n\nC++14在2014年8月18日正式批准宣布，同年12月15日正式发布release版本。本文中将就变动部分做一个总结，有需要改进和提升的地方希望大家批评指正。\n\n\n# 1、引言\n\n\n# 1.1新的语言特性\n\n * 变量模板\n * 泛型 lambda\n * lambda 初始化捕获\n * 新建/删除省略\n * 放宽对 constexpr 函数的限制\n * 二进制文字\n * 数字分隔符\n * 函数的返回类型推导\n * 具有默认非静态成员初始值设定项的 聚合类。\n\n\n# 1.2新库功能\n\n * std::make_unique\n\n * std::shared_timed_mutex 和 std::shared_lock\n\n * std::整数序列\n\n * 标准::交换\n\n * std::引用\n\n * 以及对现有图书馆设施的许多小改进，例如\n   \n   * 某些算法的两范围重载\n   \n   * 类型特征的类型别名版本\n   \n   * 用户定义的basic_string、持续时间和复杂的文字\n   \n   * ETC。\n\n\n# 2、变量模板\n\n在C++11 及之前，我们只有针对类和函数的模板。C++14 中，新增了变量模板：\n\ntemplate<class T>\nconstexpr T pi = T(3.1415926535897932385L);\ntemplate<class T>\nT circular_area(T r)\n{\n\treturn pi<T> *r * r;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n变量模板同样可以在类变量中使用：\n\ntemplate<class T>\nclass X {\n\tstatic T s;\n};\ntemplate<class T>\nT X<T>::s = 0;\n\nX<int> x_int;\nX<float> x_float;\n\nint main() {\n    int value_int = X<int>::s;       // 获取 int 类型的静态成员变量值\n    float value_float = X<float>::s; // 获取 float 类型的静态成员变量值\n\n    // ...\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n类似函数和类模板，当变量模板被引用时，则会发生实例化。\n\n\n# 3、lambda 表达式的新增功能\n\n\n# 3.1 泛化\n\n支持在 lambda 表达式中使用 auto 定义变量类型：这一特性允许 Lambda 的形参或者内部变量的类型由编译器自动推导，而不必显式指定。\n\n#include <iostream>\n#include <algorithm>\n\nint main() {\n    // Lambda 表达式 glambda，用于输出元素\n    auto glambda = [](auto& a) { std::cout << a << " "; };\n    int a[] = { 4, 2, 6, 3, 7, 5 };\n    // 使用 for_each 算法遍历数组，并对每个元素调用 Lambda 表达式 glambda\n    std::for_each(a, a + sizeof(a) / sizeof(int), glambda);\n    std::cout << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.2 对捕获的变量和引用进行初始化\n\ninclude <iostream>\nusing namespace std;\nint main()\n{\n\tint x = 4;\n\tauto y = [&r = x, x = x + 1]()->int\n\t{\n\t\tr += 2;\n\t\treturn x * x;\n\t}(); \n\tcout << "x = " << x << " y = " << y << endl;\n}\n// 输出结果：x = 6 y = 25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nauto y = [&r = x, x = x + 1]() -> int { ... }(); 定义了Lambda表达式并立即调用。\n\n * [&r = x, x = x + 1]：捕获了变量 x，通过引用捕获了 r，同时对 x 进行了初始化，将 x 的值增加了1。\n * ()->int { r += 2; return x * x; }：Lambda表达式的主体，对捕获的变量进行操作。r 是通过引用捕获的，所以对 r 的修改会影响到外部的 x。Lambda表达式返回 x * x 的结果。\n\n\n# 4、constexpr 函数可以包含多个语句\n\n在 C++11 中，如果想使用 constexpr 方法，只能包含一个返回语句。\n\n#include <iostream>\nconstexpr int square(int x) {\n    return x * x;\n}\nint main() {\n    constexpr int result = square(5); // 合法的 constexpr 函数调用\n    // 在 C++11 中，下面的调用将导致编译错误\n    // constexpr int invalidResult = []() {\n    //     int sum = 0;\n    //     for (int i = 1; i <= 5; ++i) {\n    //         sum += i;\n    //     }\n    //     return sum;\n    // }();\n    std::cout << "Result: " << result << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nC++14 中，放宽了此要求，允许 constexpr 函数中声明变量，使用循环和条件语句等：\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\nconstexpr bool isPrimitive(int number) {\n\tif (number <= 0) {\n\t\treturn false;\n\t}\n\tfor (int i = 2; i <= sqrt(number) + 1; ++i) {\n\t\tif (number % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\tcout << boolalpha << isPrimitive(102) << " " << isPrimitive(103);\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n需要注意的是，虽然C++14对constexpr函数的要求放宽了一些，但仍然有一些限制。例如，递归和复杂的控制流结构可能仍然无法在constexpr函数中使用。\n\n在C++11中，我们一般需要通过递归来实现相同的功能：\n\nconstexpr bool isPrimitive(int number, int currentFactor, int maxFactor) {\n\treturn currentFactor == maxFactor ? true : \n\t\t\t(number % currentFactor == 0 ? false : \n\t\t\t\tisPrimitive(number, currentFactor + 1, maxFactor));\n}\nconstexpr bool isPrimitive(int number) {\n\treturn number <= 0 ? false : isPrimitive(number, 2, sqrt(number) + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5、整型字面量\n\n\n# 5.1 二进制字面量\n\n支持使用 0b 开头的一串数字作为二进制表示的整型：\n\nint a = 0b10101001110; // 1358\n\n\n1\n\n\n\n# 5.2 数字分隔符\n\n支持在数字中使用单引号进行分割（便于阅读）。在编译时，这些单引号会被忽略。\n\nint a = 123\'456\'789; // 123456789\n\n\n1\n\n\n\n# 6、返回类型自动推导\n\n在 C++14 中，我们可以使用 auto 作为函数返回值并且不需要指明其返回类型的推导表达式\n\nint x = 1;\nauto f() { return x; }\n/* c++11\nauto f() -> decltype(x) { return x; } \n*/\n\n\n1\n2\n3\n4\n5\n\n\n这种类型推导有一些限制：\n\n 1. 相同类型的推导： 在一个函数中，所有的返回语句必须推导出相同的类型。\n    \n    int x = 1;\n    auto f() { return x; }  // 合法\n    \n    \n    1\n    2\n    \n\n 2. 使用 {} 包裹的数据： 对于使用 {} 包裹的数据作为返回值时，无法推导其类型。\n    \n    auto g() { return {1, 2, 3}; }  // 不合法\n    \n    \n    1\n    \n\n 3. 虚函数和 coroutine 不能被推导： 虚函数和协程不能使用此类型推导。\n\n 4. 函数模板中的类型推导： 函数模板中可以使用类型推导，但显式实例化和特化版本必须使用相同的返回类型描述符。\n    \n    template <typename T>\n    auto h(T value) { return value; }\n    \n    template auto h<int>(int);  // 合法\n    \n    \n    1\n    2\n    3\n    4\n    \n\n这些限制是为了保证类型推导的一致性和可靠性。虽然C++14引入了更多的自动类型推导，但在一些情况下，显式指定返回类型仍然是必要的。\n\n\n# 7、exchange\n\nexchange 用于移动语义，可以使用指定的新值替换掉原值，并返回原值。其定义在C++20中被简单修改如下：\n\ntemplate<class T, class U = T>\nconstexpr // since C++20\nT exchange(T& obj, U&& new_value)\n{\n    T old_value = std::move(obj);\n    obj = std::forward<U>(new_value);\n    return old_value;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n其使用如下：\n\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\nint main() {\n\tvector<int> v = {5, 6, 7};\n\tstd::exchange(v, { 1,2,3,4 });\n\tstd::copy(begin(v), end(v), ostream_iterator<int>(cout, " "));\n\tcout << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 8、quoted\n\n该类用于字符串转义的处理。使用 out << quoted(s, delim, escape)的形式，可以将字符串 s 的转义格式写入输出流中；\n\n使用 in >> quoted(s, delim, escape) 可以将输入流去除转义格式后写入字符串 s 中。其中，delim 指明了需要转义的字符，escape 指明了修饰该转移字符的字符：\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\nusing namespace std;\nint main() {\n\tstringstream ss;\n\tstring in = "String with spaces, and embedded \\"quotes\\" too";\n\tstring out;\n\tauto show = [&](const auto& what) {\n\t\t&what == &in\n\t\t\t? cout << "read in     [" << in << "]\\n"\n\t\t\t<< "stored as   [" << ss.str() << "]\\n"\n\t\t\t: cout << "written out [" << out << "]\\n\\n";\n\t};\n\tss << quoted(in); \n\tshow(in);\n\tss >> quoted(out);\n\tshow(out);\n\tss.str(""); \n\tin = "String with spaces, and embedded $quotes$ too";\n\tconst char delim{ \'$\' };\n\tconst char escape{ \'%\' };\n\tss << quoted(in, delim, escape);\n\tshow(in);\n\tss >> quoted(out, delim, escape);\n\tshow(out);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n\n\n# 9、C++14 经常考到的知识点\n\n\n# 9.1 C++14 引入了哪些新特性？\n\nC++14 引入了一些新特性，包括但不限于以下内容：\n\n 1. 通用Lambda表达式：允许在lambda函数中使用auto关键字来推导参数类型。\n 2. 自动返回类型推导：允许使用auto关键字自动推导函数返回值类型。\n 3. 初始化列表的泛型支持：可以使用auto关键字在初始化列表中推导元素类型。\n 4. 带有二进制分隔符的整数字面量：可以在整数常量中使用单撇号作为分隔符，提高可读性。\n 5. constexpr函数的扩展：constexpr函数可以包含更多操作，例如循环和条件判断。\n 6. 变长参数模板（Variadic Templates）的改进：支持递归处理变长参数模板的展开。\n 7. 返回void类型的lambda表达式：允许定义返回void类型的lambda函数。\n\n\n# 9.2 C++14 中 auto 关键字的用法和限制是什么？\n\n在 C++14 中，auto 关键字用于自动类型推导，可以根据初始化表达式的类型来确定变量的类型。它的使用和限制如下：\n\n 1. 自动类型推导：使用 auto 关键字声明变量时，编译器会根据初始化表达式的类型自动推导出变量的类型。 auto x = 42; // 推导为int型 auto name = "John"; // 推导为const char*型\n 2. 声明时必须初始化：使用auto声明变量时，必须进行初始化。因为编译器需要根据初始化表达式来推导出变量的类型。 auto y; // 错误，未初始化\n 3. 可与引用结合使用：auto关键字可以与引用一起使用，从而推导出引用的类型。 int a = 10; auto& ref = a; // 推导为int&型，ref是a的引用\n 4. 不支持数组或函数指针：auto不能直接用于数组或函数指针的声明。但可以通过decltype结合auto来实现对数组或函数指针类型进行推导。 int arr[] = {1, 2, 3}; auto arrRef = arr; // 错误，无法推导arr的数组类型 decltype(arr) arrType; // 使用decltype获取arr的数组类型并声明arrType void foo(); auto funcPtr = foo; // 错误，无法推导foo的函数指针类型 decltype(foo)* funcPtrType; // 使用decltype获取foo的函数指针类型并声明funcPtrType\n\n需要注意的是，auto 在 C++14 中的用法和限制可能与之后的标准（如 C++17、C++20 等）有所不同，具体取决于编译器和所使用的标准版本。\n\n\n# 9.3 C++14 中如何使用 Lambda 表达式？有什么改进？\n\n在C++14中，使用Lambda表达式的语法与之前的C++版本相似。Lambda表达式是一种可以在代码中内联定义匿名函数的方式。\n\n下面是一个使用Lambda表达式的示例：\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    // 使用Lambda表达式进行遍历打印\n    std::for_each(numbers.begin(), numbers.end(), [](int num) {\n        std::cout << num << " ";\n    });\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在 Lambda 表达式中，方括号 [] 用于捕获外部变量（可选）。小括号 ( ) 内指定参数列表（可选），箭头 -> 后面指定返回类型（可选）。\n\nC++14 对于 Lambda 表达式有一些改进，其中最显著的改进是可以自动推导返回类型。这意味着你不需要显式地指定返回类型，编译器会根据表达式体来推断返回类型。\n\n以下是一个示例：\n\nauto lambda = [](int a, int b) {\n    return a + b;\n};\n\n\n1\n2\n3\n\n\n在上述示例中，我们没有显式指定返回类型，但编译器会自动推断出返回类型为整数（因为a和b都是整数）。\n\n此外，在 C++14 中还引入了泛型 lambda，使得可以在 lambda 函数中使用 auto 关键字作为参数类型，更加灵活和方便。\n\n\n# 9.4 C++14 对于 constexpr 关键字有何改进？\n\nC++14 对于 constexpr 关键字进行了一些改进，使得其更加灵活和强大。在 C++11 中，constexpr只能用于表示常量表达式的函数和构造函数，而在 C++14 中，它还可以用于一些额外的情况。\n\n首先，在 C++14 中，constexpr函数可以包含一些非常量表达式的逻辑，只要这部分逻辑在运行时不会执行即可。这意味着我们可以在constexpr函数内使用循环、条件语句等非常量表达式的控制流程。\n\n其次，C++14引入了对变量模板（Variable Templates）的支持，并且允许将变量声明为constexpr。这样我们就可以定义并初始化一个编译期间可计算的常量变量。\n\n此外，在 C++14 中，对于某些标准库类型（如数组、字符串等），它们也提供了更多的支持以便于使用在编译期间计算出来的常量值。\n\n\n# 9.5 C++14 中提供了哪些新的标准库组件和功能？\n\nC++14引入了一些新的标准库组件和功能，以下是其中的一些主要特性：\n\n 1. std::make_unique：提供了在堆上创建 unique_ptr 对象的便捷方式。\n 2. std::integer_sequence：支持编译时整数序列的操作，用于元编程。\n 3. std::user_defined_literals：允许用户定义自己的字面量后缀，扩展了语言的表达能力。\n 4. 通用 lambda 表达式：允许使用 auto 参数声明参数类型，使得 lambda 表达式更加灵活。\n 5. 变长模板参数折叠（Variadic template parameter packs expansion）：可以将多个参数打包传递给模板函数或类，并且可以对它们进行展开操作。\n 6. std::experimental 命名空间：引入了一些实验性质的标准库组件，如 optional、any、string_view 等。\n\n\n# 9.6 在 C++14 中，变长参数模板是如何使用的？\n\n在 C++14 中，可以使用变长参数模板（Variadic Templates）来处理可变数量的函数参数。通过使用递归展开参数包的方式，可以灵活地处理任意数量的参数。\n\n下面是一个示例：\n\n#include <iostream>\n// 递归终止条件：当没有剩余参数时停止递归\nvoid printArgs() {\n    std::cout << "All arguments have been printed." << std::endl;\n}\n// 可变参数模板：展开第一个参数并调用自身处理剩余参数\ntemplate<typename T, typename... Args>\nvoid printArgs(T first, Args... args) {\n    std::cout << "Argument: " << first << std::endl;\n    printArgs(args...); // 递归调用自身处理剩余参数\n}\nint main() {\n    printArgs(1, "Hello", 3.14, \'A\');\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n输出结果：\n\nArgument: 1\nArgument: Hello\nArgument: 3.14\nArgument: A\nAll arguments have been printed.\n\n\n1\n2\n3\n4\n5\n\n\n在上述代码中，printArgs 是一个可变参数模板函数。它首先处理第一个传入的参数 first，然后递归地调用自身处理剩余的 args 参数。当所有参数都被展开并打印完毕后，最终会到达递归终止条件。\n\n这种方式使得我们能够在编译时处理不同数量和类型的函数参数，并且可以灵活地进行操作。\n\n\n# 9.7 在 C++14 中，是否允许在 lambda 函数内定义其他函数或类？\n\n在 C++14 中，lambda 函数内是不允许定义其他函数或类的。Lambda 函数是一个匿名的函数对象，它通常用于简化代码，提供一种在局部范围内编写小型函数的方式。Lambda 函数本质上是一个闭包，它可以捕获外部作用域中的变量，并且具有与普通函数相似的行为。\n\n然而，在 C++17 中引入了嵌套lambda的概念，使得在 lambda 函数内定义其他 lambda 函数成为可能。在这种情况下，内层的 lambda 函数可以访问外层 lambda 函数的变量。所以如果你想要在 C++14 中定义其他函数或类，建议将其定义在 lambda 之外的范围内。\n\n\n# 9.8 C++14 是否支持原始字符串字面量（raw string literals）？如何使用它们？\n\n是的，C++14 支持原始字符串字面量（raw string literals）。\n\n原始字符串字面量可以用来表示包含特殊字符（例如转义序列和引号）的字符串，而无需使用转义符号。它们由R"delim(raw_characters)delim"的语法表示，其中delim可以是任何非空字符序列，并且在开始和结束位置上必须匹配。\n\n以下是一个示例：\n\n#include <iostream>\nint main() {\n    const char* str1 = R"(Hello \\n World!)";\n    std::cout << str1 << std::endl;  // 输出：Hello \\n World!\n    const char* str2 = R"###(This is a "quoted" string.)###";\n    std::cout << str2 << std::endl;  // 输出：This is a "quoted" string.\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在上面的示例中，我们使用了原始字符串字面量来创建包含特殊字符的字符串，而不需要使用额外的转义符号。\n\n\n# 9.9 在 C++14 中，std::make_unique和std::make_shared这两个函数的作用是什么？\n\n在 C++14 中，std::make_unique和std::make_shared是用于创建智能指针的函数模板。\n\n * std::make_unique：用于创建一个std::unique_ptr对象，它拥有独占所有权的动态分配对象。这个函数接受参数并返回一个std::unique_ptr，它会自动管理内存释放。示例：\n\nauto ptr = std::make_unique<int>(42);\n\n\n1\n\n * std::make_shared：用于创建一个std::shared_ptr对象，它可以被多个指针共享的动态分配对象。这个函数接受参数并返回一个std::shared_ptr，它使用引用计数来管理内存释放。示例：\n\nauto ptr = std::make_shared<int>(42);\n\n\n1\n\n\n这两个函数可以减少手动进行资源管理的工作量，并提供了更安全、更简洁的方式来处理动态分配对象。\n\n\n# 9.10 C++14 引入了统一初始化语法（uniform initialization syntax），具体有哪些变化？\n\nC++14 引入了统一初始化语法（uniform initialization syntax），它允许使用一种更统一和一致的方式进行初始化。具体的变化包括以下几个方面：\n\n 1. 初始化列表（initializer list）：可以使用花括号 {} 来初始化对象，无论是简单类型还是复杂类型。例如： int num{ 42 }; std::vector vec{ 1, 2, 3 };\n 2. 自动类型推导：在使用统一初始化语法时，编译器可以自动推导出变量的类型。 auto value{ 3.14 }; // 推导为 double 类型 auto str{ "Hello" }; // 推导为 const char[6] 类型\n 3. 统一构造函数调用语法：通过统一初始化语法，可以直接调用类的构造函数进行对象的创建。 class MyClass { public: MyClass(int value) { /* 构造函数实现 */ } // ... }; MyClass obj{ 42 }; // 调用构造函数创建对象\n 4. 空初始化：可以使用 {} 或 () 进行空初始化，不再需要显式地指定默认值。 int num{}; // 初始化为0 std::string str{}; // 初始化为空字符串\n\n这些变化使得初始化更加灵活和一致，并且提供了更强大的类型推导能力。注意，在使用统一初始化语法时，要注意类型的精确匹配和可能的隐式转换。',normalizedContent:'# 探索c++14新特性：更强大、更高效的编程\n\nc++14并没有太大的改动，就连官方说明中也指出，c++14相对于c++11来说是一个比较小的改动，但是在很大程度上完善了c++11，所以可以说c++14就是在c++11标准上的查漏补缺。\n\nc++14在2014年8月18日正式批准宣布，同年12月15日正式发布release版本。本文中将就变动部分做一个总结，有需要改进和提升的地方希望大家批评指正。\n\n\n# 1、引言\n\n\n# 1.1新的语言特性\n\n * 变量模板\n * 泛型 lambda\n * lambda 初始化捕获\n * 新建/删除省略\n * 放宽对 constexpr 函数的限制\n * 二进制文字\n * 数字分隔符\n * 函数的返回类型推导\n * 具有默认非静态成员初始值设定项的 聚合类。\n\n\n# 1.2新库功能\n\n * std::make_unique\n\n * std::shared_timed_mutex 和 std::shared_lock\n\n * std::整数序列\n\n * 标准::交换\n\n * std::引用\n\n * 以及对现有图书馆设施的许多小改进，例如\n   \n   * 某些算法的两范围重载\n   \n   * 类型特征的类型别名版本\n   \n   * 用户定义的basic_string、持续时间和复杂的文字\n   \n   * etc。\n\n\n# 2、变量模板\n\n在c++11 及之前，我们只有针对类和函数的模板。c++14 中，新增了变量模板：\n\ntemplate<class t>\nconstexpr t pi = t(3.1415926535897932385l);\ntemplate<class t>\nt circular_area(t r)\n{\n\treturn pi<t> *r * r;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n变量模板同样可以在类变量中使用：\n\ntemplate<class t>\nclass x {\n\tstatic t s;\n};\ntemplate<class t>\nt x<t>::s = 0;\n\nx<int> x_int;\nx<float> x_float;\n\nint main() {\n    int value_int = x<int>::s;       // 获取 int 类型的静态成员变量值\n    float value_float = x<float>::s; // 获取 float 类型的静态成员变量值\n\n    // ...\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n类似函数和类模板，当变量模板被引用时，则会发生实例化。\n\n\n# 3、lambda 表达式的新增功能\n\n\n# 3.1 泛化\n\n支持在 lambda 表达式中使用 auto 定义变量类型：这一特性允许 lambda 的形参或者内部变量的类型由编译器自动推导，而不必显式指定。\n\n#include <iostream>\n#include <algorithm>\n\nint main() {\n    // lambda 表达式 glambda，用于输出元素\n    auto glambda = [](auto& a) { std::cout << a << " "; };\n    int a[] = { 4, 2, 6, 3, 7, 5 };\n    // 使用 for_each 算法遍历数组，并对每个元素调用 lambda 表达式 glambda\n    std::for_each(a, a + sizeof(a) / sizeof(int), glambda);\n    std::cout << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3.2 对捕获的变量和引用进行初始化\n\ninclude <iostream>\nusing namespace std;\nint main()\n{\n\tint x = 4;\n\tauto y = [&r = x, x = x + 1]()->int\n\t{\n\t\tr += 2;\n\t\treturn x * x;\n\t}(); \n\tcout << "x = " << x << " y = " << y << endl;\n}\n// 输出结果：x = 6 y = 25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nauto y = [&r = x, x = x + 1]() -> int { ... }(); 定义了lambda表达式并立即调用。\n\n * [&r = x, x = x + 1]：捕获了变量 x，通过引用捕获了 r，同时对 x 进行了初始化，将 x 的值增加了1。\n * ()->int { r += 2; return x * x; }：lambda表达式的主体，对捕获的变量进行操作。r 是通过引用捕获的，所以对 r 的修改会影响到外部的 x。lambda表达式返回 x * x 的结果。\n\n\n# 4、constexpr 函数可以包含多个语句\n\n在 c++11 中，如果想使用 constexpr 方法，只能包含一个返回语句。\n\n#include <iostream>\nconstexpr int square(int x) {\n    return x * x;\n}\nint main() {\n    constexpr int result = square(5); // 合法的 constexpr 函数调用\n    // 在 c++11 中，下面的调用将导致编译错误\n    // constexpr int invalidresult = []() {\n    //     int sum = 0;\n    //     for (int i = 1; i <= 5; ++i) {\n    //         sum += i;\n    //     }\n    //     return sum;\n    // }();\n    std::cout << "result: " << result << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nc++14 中，放宽了此要求，允许 constexpr 函数中声明变量，使用循环和条件语句等：\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\nconstexpr bool isprimitive(int number) {\n\tif (number <= 0) {\n\t\treturn false;\n\t}\n\tfor (int i = 2; i <= sqrt(number) + 1; ++i) {\n\t\tif (number % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint main() {\n\tcout << boolalpha << isprimitive(102) << " " << isprimitive(103);\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n需要注意的是，虽然c++14对constexpr函数的要求放宽了一些，但仍然有一些限制。例如，递归和复杂的控制流结构可能仍然无法在constexpr函数中使用。\n\n在c++11中，我们一般需要通过递归来实现相同的功能：\n\nconstexpr bool isprimitive(int number, int currentfactor, int maxfactor) {\n\treturn currentfactor == maxfactor ? true : \n\t\t\t(number % currentfactor == 0 ? false : \n\t\t\t\tisprimitive(number, currentfactor + 1, maxfactor));\n}\nconstexpr bool isprimitive(int number) {\n\treturn number <= 0 ? false : isprimitive(number, 2, sqrt(number) + 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5、整型字面量\n\n\n# 5.1 二进制字面量\n\n支持使用 0b 开头的一串数字作为二进制表示的整型：\n\nint a = 0b10101001110; // 1358\n\n\n1\n\n\n\n# 5.2 数字分隔符\n\n支持在数字中使用单引号进行分割（便于阅读）。在编译时，这些单引号会被忽略。\n\nint a = 123\'456\'789; // 123456789\n\n\n1\n\n\n\n# 6、返回类型自动推导\n\n在 c++14 中，我们可以使用 auto 作为函数返回值并且不需要指明其返回类型的推导表达式\n\nint x = 1;\nauto f() { return x; }\n/* c++11\nauto f() -> decltype(x) { return x; } \n*/\n\n\n1\n2\n3\n4\n5\n\n\n这种类型推导有一些限制：\n\n 1. 相同类型的推导： 在一个函数中，所有的返回语句必须推导出相同的类型。\n    \n    int x = 1;\n    auto f() { return x; }  // 合法\n    \n    \n    1\n    2\n    \n\n 2. 使用 {} 包裹的数据： 对于使用 {} 包裹的数据作为返回值时，无法推导其类型。\n    \n    auto g() { return {1, 2, 3}; }  // 不合法\n    \n    \n    1\n    \n\n 3. 虚函数和 coroutine 不能被推导： 虚函数和协程不能使用此类型推导。\n\n 4. 函数模板中的类型推导： 函数模板中可以使用类型推导，但显式实例化和特化版本必须使用相同的返回类型描述符。\n    \n    template <typename t>\n    auto h(t value) { return value; }\n    \n    template auto h<int>(int);  // 合法\n    \n    \n    1\n    2\n    3\n    4\n    \n\n这些限制是为了保证类型推导的一致性和可靠性。虽然c++14引入了更多的自动类型推导，但在一些情况下，显式指定返回类型仍然是必要的。\n\n\n# 7、exchange\n\nexchange 用于移动语义，可以使用指定的新值替换掉原值，并返回原值。其定义在c++20中被简单修改如下：\n\ntemplate<class t, class u = t>\nconstexpr // since c++20\nt exchange(t& obj, u&& new_value)\n{\n    t old_value = std::move(obj);\n    obj = std::forward<u>(new_value);\n    return old_value;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n其使用如下：\n\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\nint main() {\n\tvector<int> v = {5, 6, 7};\n\tstd::exchange(v, { 1,2,3,4 });\n\tstd::copy(begin(v), end(v), ostream_iterator<int>(cout, " "));\n\tcout << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 8、quoted\n\n该类用于字符串转义的处理。使用 out << quoted(s, delim, escape)的形式，可以将字符串 s 的转义格式写入输出流中；\n\n使用 in >> quoted(s, delim, escape) 可以将输入流去除转义格式后写入字符串 s 中。其中，delim 指明了需要转义的字符，escape 指明了修饰该转移字符的字符：\n\n#include <iostream>\n#include <iomanip>\n#include <sstream>\nusing namespace std;\nint main() {\n\tstringstream ss;\n\tstring in = "string with spaces, and embedded \\"quotes\\" too";\n\tstring out;\n\tauto show = [&](const auto& what) {\n\t\t&what == &in\n\t\t\t? cout << "read in     [" << in << "]\\n"\n\t\t\t<< "stored as   [" << ss.str() << "]\\n"\n\t\t\t: cout << "written out [" << out << "]\\n\\n";\n\t};\n\tss << quoted(in); \n\tshow(in);\n\tss >> quoted(out);\n\tshow(out);\n\tss.str(""); \n\tin = "string with spaces, and embedded $quotes$ too";\n\tconst char delim{ \'$\' };\n\tconst char escape{ \'%\' };\n\tss << quoted(in, delim, escape);\n\tshow(in);\n\tss >> quoted(out, delim, escape);\n\tshow(out);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n\n\n# 9、c++14 经常考到的知识点\n\n\n# 9.1 c++14 引入了哪些新特性？\n\nc++14 引入了一些新特性，包括但不限于以下内容：\n\n 1. 通用lambda表达式：允许在lambda函数中使用auto关键字来推导参数类型。\n 2. 自动返回类型推导：允许使用auto关键字自动推导函数返回值类型。\n 3. 初始化列表的泛型支持：可以使用auto关键字在初始化列表中推导元素类型。\n 4. 带有二进制分隔符的整数字面量：可以在整数常量中使用单撇号作为分隔符，提高可读性。\n 5. constexpr函数的扩展：constexpr函数可以包含更多操作，例如循环和条件判断。\n 6. 变长参数模板（variadic templates）的改进：支持递归处理变长参数模板的展开。\n 7. 返回void类型的lambda表达式：允许定义返回void类型的lambda函数。\n\n\n# 9.2 c++14 中 auto 关键字的用法和限制是什么？\n\n在 c++14 中，auto 关键字用于自动类型推导，可以根据初始化表达式的类型来确定变量的类型。它的使用和限制如下：\n\n 1. 自动类型推导：使用 auto 关键字声明变量时，编译器会根据初始化表达式的类型自动推导出变量的类型。 auto x = 42; // 推导为int型 auto name = "john"; // 推导为const char*型\n 2. 声明时必须初始化：使用auto声明变量时，必须进行初始化。因为编译器需要根据初始化表达式来推导出变量的类型。 auto y; // 错误，未初始化\n 3. 可与引用结合使用：auto关键字可以与引用一起使用，从而推导出引用的类型。 int a = 10; auto& ref = a; // 推导为int&型，ref是a的引用\n 4. 不支持数组或函数指针：auto不能直接用于数组或函数指针的声明。但可以通过decltype结合auto来实现对数组或函数指针类型进行推导。 int arr[] = {1, 2, 3}; auto arrref = arr; // 错误，无法推导arr的数组类型 decltype(arr) arrtype; // 使用decltype获取arr的数组类型并声明arrtype void foo(); auto funcptr = foo; // 错误，无法推导foo的函数指针类型 decltype(foo)* funcptrtype; // 使用decltype获取foo的函数指针类型并声明funcptrtype\n\n需要注意的是，auto 在 c++14 中的用法和限制可能与之后的标准（如 c++17、c++20 等）有所不同，具体取决于编译器和所使用的标准版本。\n\n\n# 9.3 c++14 中如何使用 lambda 表达式？有什么改进？\n\n在c++14中，使用lambda表达式的语法与之前的c++版本相似。lambda表达式是一种可以在代码中内联定义匿名函数的方式。\n\n下面是一个使用lambda表达式的示例：\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    // 使用lambda表达式进行遍历打印\n    std::for_each(numbers.begin(), numbers.end(), [](int num) {\n        std::cout << num << " ";\n    });\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在 lambda 表达式中，方括号 [] 用于捕获外部变量（可选）。小括号 ( ) 内指定参数列表（可选），箭头 -> 后面指定返回类型（可选）。\n\nc++14 对于 lambda 表达式有一些改进，其中最显著的改进是可以自动推导返回类型。这意味着你不需要显式地指定返回类型，编译器会根据表达式体来推断返回类型。\n\n以下是一个示例：\n\nauto lambda = [](int a, int b) {\n    return a + b;\n};\n\n\n1\n2\n3\n\n\n在上述示例中，我们没有显式指定返回类型，但编译器会自动推断出返回类型为整数（因为a和b都是整数）。\n\n此外，在 c++14 中还引入了泛型 lambda，使得可以在 lambda 函数中使用 auto 关键字作为参数类型，更加灵活和方便。\n\n\n# 9.4 c++14 对于 constexpr 关键字有何改进？\n\nc++14 对于 constexpr 关键字进行了一些改进，使得其更加灵活和强大。在 c++11 中，constexpr只能用于表示常量表达式的函数和构造函数，而在 c++14 中，它还可以用于一些额外的情况。\n\n首先，在 c++14 中，constexpr函数可以包含一些非常量表达式的逻辑，只要这部分逻辑在运行时不会执行即可。这意味着我们可以在constexpr函数内使用循环、条件语句等非常量表达式的控制流程。\n\n其次，c++14引入了对变量模板（variable templates）的支持，并且允许将变量声明为constexpr。这样我们就可以定义并初始化一个编译期间可计算的常量变量。\n\n此外，在 c++14 中，对于某些标准库类型（如数组、字符串等），它们也提供了更多的支持以便于使用在编译期间计算出来的常量值。\n\n\n# 9.5 c++14 中提供了哪些新的标准库组件和功能？\n\nc++14引入了一些新的标准库组件和功能，以下是其中的一些主要特性：\n\n 1. std::make_unique：提供了在堆上创建 unique_ptr 对象的便捷方式。\n 2. std::integer_sequence：支持编译时整数序列的操作，用于元编程。\n 3. std::user_defined_literals：允许用户定义自己的字面量后缀，扩展了语言的表达能力。\n 4. 通用 lambda 表达式：允许使用 auto 参数声明参数类型，使得 lambda 表达式更加灵活。\n 5. 变长模板参数折叠（variadic template parameter packs expansion）：可以将多个参数打包传递给模板函数或类，并且可以对它们进行展开操作。\n 6. std::experimental 命名空间：引入了一些实验性质的标准库组件，如 optional、any、string_view 等。\n\n\n# 9.6 在 c++14 中，变长参数模板是如何使用的？\n\n在 c++14 中，可以使用变长参数模板（variadic templates）来处理可变数量的函数参数。通过使用递归展开参数包的方式，可以灵活地处理任意数量的参数。\n\n下面是一个示例：\n\n#include <iostream>\n// 递归终止条件：当没有剩余参数时停止递归\nvoid printargs() {\n    std::cout << "all arguments have been printed." << std::endl;\n}\n// 可变参数模板：展开第一个参数并调用自身处理剩余参数\ntemplate<typename t, typename... args>\nvoid printargs(t first, args... args) {\n    std::cout << "argument: " << first << std::endl;\n    printargs(args...); // 递归调用自身处理剩余参数\n}\nint main() {\n    printargs(1, "hello", 3.14, \'a\');\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n输出结果：\n\nargument: 1\nargument: hello\nargument: 3.14\nargument: a\nall arguments have been printed.\n\n\n1\n2\n3\n4\n5\n\n\n在上述代码中，printargs 是一个可变参数模板函数。它首先处理第一个传入的参数 first，然后递归地调用自身处理剩余的 args 参数。当所有参数都被展开并打印完毕后，最终会到达递归终止条件。\n\n这种方式使得我们能够在编译时处理不同数量和类型的函数参数，并且可以灵活地进行操作。\n\n\n# 9.7 在 c++14 中，是否允许在 lambda 函数内定义其他函数或类？\n\n在 c++14 中，lambda 函数内是不允许定义其他函数或类的。lambda 函数是一个匿名的函数对象，它通常用于简化代码，提供一种在局部范围内编写小型函数的方式。lambda 函数本质上是一个闭包，它可以捕获外部作用域中的变量，并且具有与普通函数相似的行为。\n\n然而，在 c++17 中引入了嵌套lambda的概念，使得在 lambda 函数内定义其他 lambda 函数成为可能。在这种情况下，内层的 lambda 函数可以访问外层 lambda 函数的变量。所以如果你想要在 c++14 中定义其他函数或类，建议将其定义在 lambda 之外的范围内。\n\n\n# 9.8 c++14 是否支持原始字符串字面量（raw string literals）？如何使用它们？\n\n是的，c++14 支持原始字符串字面量（raw string literals）。\n\n原始字符串字面量可以用来表示包含特殊字符（例如转义序列和引号）的字符串，而无需使用转义符号。它们由r"delim(raw_characters)delim"的语法表示，其中delim可以是任何非空字符序列，并且在开始和结束位置上必须匹配。\n\n以下是一个示例：\n\n#include <iostream>\nint main() {\n    const char* str1 = r"(hello \\n world!)";\n    std::cout << str1 << std::endl;  // 输出：hello \\n world!\n    const char* str2 = r"###(this is a "quoted" string.)###";\n    std::cout << str2 << std::endl;  // 输出：this is a "quoted" string.\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在上面的示例中，我们使用了原始字符串字面量来创建包含特殊字符的字符串，而不需要使用额外的转义符号。\n\n\n# 9.9 在 c++14 中，std::make_unique和std::make_shared这两个函数的作用是什么？\n\n在 c++14 中，std::make_unique和std::make_shared是用于创建智能指针的函数模板。\n\n * std::make_unique：用于创建一个std::unique_ptr对象，它拥有独占所有权的动态分配对象。这个函数接受参数并返回一个std::unique_ptr，它会自动管理内存释放。示例：\n\nauto ptr = std::make_unique<int>(42);\n\n\n1\n\n * std::make_shared：用于创建一个std::shared_ptr对象，它可以被多个指针共享的动态分配对象。这个函数接受参数并返回一个std::shared_ptr，它使用引用计数来管理内存释放。示例：\n\nauto ptr = std::make_shared<int>(42);\n\n\n1\n\n\n这两个函数可以减少手动进行资源管理的工作量，并提供了更安全、更简洁的方式来处理动态分配对象。\n\n\n# 9.10 c++14 引入了统一初始化语法（uniform initialization syntax），具体有哪些变化？\n\nc++14 引入了统一初始化语法（uniform initialization syntax），它允许使用一种更统一和一致的方式进行初始化。具体的变化包括以下几个方面：\n\n 1. 初始化列表（initializer list）：可以使用花括号 {} 来初始化对象，无论是简单类型还是复杂类型。例如： int num{ 42 }; std::vector vec{ 1, 2, 3 };\n 2. 自动类型推导：在使用统一初始化语法时，编译器可以自动推导出变量的类型。 auto value{ 3.14 }; // 推导为 double 类型 auto str{ "hello" }; // 推导为 const char[6] 类型\n 3. 统一构造函数调用语法：通过统一初始化语法，可以直接调用类的构造函数进行对象的创建。 class myclass { public: myclass(int value) { /* 构造函数实现 */ } // ... }; myclass obj{ 42 }; // 调用构造函数创建对象\n 4. 空初始化：可以使用 {} 或 () 进行空初始化，不再需要显式地指定默认值。 int num{}; // 初始化为0 std::string str{}; // 初始化为空字符串\n\n这些变化使得初始化更加灵活和一致，并且提供了更强大的类型推导能力。注意，在使用统一初始化语法时，要注意类型的精确匹配和可能的隐式转换。',charsets:{cjk:!0}},{title:"条款1-4 让自己习惯Cpp",frontmatter:{title:"条款1-4 让自己习惯Cpp",date:"2023-11-24T15:59:26.000Z",permalink:"/pages/801755/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/30.Effetcive_CPP/01.%E6%9D%A1%E6%AC%BE1-4%20%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC++.html",relativePath:"01.CPP语言/30.Effetcive_CPP/01.条款1-4 让自己习惯C++.md",key:"v-5c088d6b",path:"/pages/801755/",lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.71,time:102600,words:342},headersStr:null,content:'# 让自己习惯Cpp\n\n\n# 条款1：视Cpp为一个语言联邦\n\n条款1中提到了将Cpp看作为一个“语言联邦”的概念。具体来说，“语言联邦”是指将Cpp看作由多种不同的子语言组成的联邦。每种子语言都有自己的惯用法、工具和库，可以用来解决特定的问题。因此，Cpp程序员应该了解这些子语言，并选择最适合解决特定问题的子语言。 这个概念的含义可以从以下几个方面来解释：\n\n 1. 多种子语言：Cpp由多种子语言组成，每种子语言都有自己的规则、习惯和约定。例如，面向对象编程（OOP）子语言、模板元编程（TMP）子语言等。这些子语言都有自己的语法和语义，可以用来解决特定的问题。\n 2. 惯用法和工具：每种子语言都有自己的惯用法和工具。例如，OOP中常用的类、继承、多态等概念，以及与之对应的工具和库，如STL、Boost等。熟悉这些惯用法和工具可以提高程序员的开发效率和代码质量。\n 3. 选择最适合的子语言：Cpp程序员应该了解这些子语言，并选择最适合解决特定问题的子语言。例如，如果要处理大量的数值计算，可以选择使用TMP子语言中的模板元编程技术，来提高程序的性能；如果要实现一些复杂的数据结构和算法，可以使用STL等库来简化代码。\n\n总的来说，可以将Cpp视为一个由4个次语言组成的联邦而非单一语言：\n\n 1. C，说到底Cpp仍是以C为基础。\n 2. object-oriented Cpp，包括封装、继承、多态等面向对象设计。\n 3. template Cpp，泛型编程，衍生出模板元编程（在各个新标准中逐步完善）。\n 4. STL，包括容器、迭代器、算法与函数对象。\n\n\n# 条款2：尽量以const、enum、inline替换#define\n\n条款2中提到了尽量使用const、enum和inline来替代#define的概念。具体来说，#define是一种预处理指令，可以将一个标识符定义为一个值或一个字符串。而const、enum和inline都是Cpp语言中的关键字，也可以用于定义常量和函数。以下是对这个条款的一些解释：\n\n 1. #define的缺点：使用#define定义常量存在一些缺点，例如它不会进行类型检查，容易引起意外的副作用，也不会被语法检查工具正确地处理。\n 2. const的优点：使用const定义常量可以避免#define的缺点。const定义的常量有类型，可以被编译器检查和优化，也可以被调试器和其他工具正确地处理。\n 3. enum的优点：如果要定义一系列相关的常量，可以使用enum枚举类型。enum定义的常量有类型，可以被编译器检查和优化，同时也可以提高代码的可读性和可维护性。\n 4. inline的优点：如果要定义一个简单的函数或者函数模板，可以使用inline关键字。inline函数在编译时会被展开，从而避免了函数调用的开销。同时，inline函数也可以提高代码的可读性和可维护性。\n\n#define可以用来定义一些变量、函数，但它只是一方面单纯的文本替换，并且没有任何类型检查，导致容易引起莫名其妙的问题，另一方面预处理后已经消失，编译链接过程中没有其符号信息，出问题时无法定位到它。\n\n#define CALL_WITH_MAX(a,b) f((a)>(b)?(a):(b))\n\nint a=5,b=0;\nCALL_WITH_MAX(++a,b);\nCALL_WITH_MAX(++a,b+10);\n\n\n1\n2\n3\n4\n5\n\n\n即使上文的宏已经仔细地为所有参数添加小括号，仍然出现了问题：第一次调用中a被累加两次，第二次调用中a被累加一次。\n\n> CALL_WITH_MAX(++a,b)在展开后变成了f((++a)>(b)?(++a):(b))，其中a的值被多次递增。\n> \n> 而CALL_WITH_MAX(++a,b+10)在展开后变成了f((++a)>(b+10)?(++a):(b+10))，其中a的值也被多次递增。\n> \n> 因此，这两个调用会导致a的值被递增多次，结果可能不是我们所期望的。\n> \n> 为了避免这个问题，更加可预测并且类型安全的写法是，可以使用函数模板来替代#define宏。使用const对象（对于一系列常量，使用枚举或枚举类，而不是一系列#define）\n> \n> 例如，可以定义一个template<typename T> inline void callWithMax(const T& a, const T& b)函数来替代CALL_WITH_MAX宏。\n> \n> 这样做不仅可以避免上述问题，还可以提高代码的可读性和可维护性。例如：\n> \n> template<typename T>\n> inline void callWithMax(const T& a, const T& b)\n> {\n> f(a > b ? a : b);\n> }\n> int a = 5, b = 0;\n> callWithMax(++a, b);\n> callWithMax(++a, b + 10);\n> // 这段代码中，a的值只会被递增一次，符合我们的预期。\n> // 不过inline目前主要指多重定义而非内联\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n\n# 条款3：尽可能使用const\n\n条款3中提到了尽可能使用const的概念。具体来说，const是Cpp语言中的关键字，用于定义常量。以下是对这个条款的一些解释：\n\n 1. const的作用：使用const可以将变量定义为常量，即不能被修改。常量可以提高代码的可读性和可维护性，同时也可以避免意外的修改导致的错误。\n 2. const的使用场景：在Cpp中，const可以用于定义常量、函数参数和函数返回值等。使用const定义常量时，可以使用const关键字加上变量的类型，例如const int MAX_SIZE = 1024;。使用const定义函数参数时，可以在参数类型前加上const关键字，例如void foo(const std::string& str);。使用const定义函数返回值时，可以在函数声明和定义中返回类型前加上const关键字，例如const std::string& foo() const;。\n 3. const的作用域：在Cpp中，const变量和const函数的作用域与普通变量和函数的作用域相同。如果const变量或const函数在某个作用域内定义，那么它们只能在该作用域内使用。\n 4. const和指针：使用指针时，const可以用于限定指针本身或指针所指向的内容是否可修改。例如，const int* p表示指向const int类型的指针，即指针所指向的内容不能被修改；int* const p表示指向int类型的const指针，即指针本身不能被修改。另外，const还可以同时限定指针本身和指针所指向的内容是否可修改，例如const int* const p表示指向const int类型的const指针。\n\nchar greeting[] = "Hello";\nchar* p1 = greeting;\nconst char* p2 = greeting;       //被指物不可修改\nchar* const p3 = greeting        //指针不可修改\nconst char* const p4 = greeting; //皆不可修改\n\n\n1\n2\n3\n4\n5\n\n\n真正威力强大的用法是面对函数声明时，const可以和函数返回值、各参数、成员函数自身产生关联。例如令函数返回const，往往可以降低因用户错误而造成的意外，又不至于放弃安全性和高效性。\n\nclass Rational{...};\nconst Rational operator*(const Rational& lhs,const Rational& rhs);\n//上述写法可以避免用户写出 a*b = c\n\n\n1\n2\n3\n\n\n对于成员函数自身的const，编译器强制实施bitwise const，即强制不能修改任何成员变量。**这意味着，在const成员函数中，即使我们使用了mutable关键字，也不能修改任何非mutable成员变量。**但实际上很多情况下我们需要的是logical const，即const成员函数也应该可以修改某些客户不可见的数据，这时可以用mutable成员变量来绕过const成员函数的限制。\n\n例如对于一个文本块的对象而言，其内部很可能存在高速缓存；对于查询文本块长度这样的const操作，仍然需要更新高速缓存：\n\nclass TextBlock{\npublic:\n  std::size_t length() const;\nprivate:\n  char *pText;\n  mutable std::size_t text_length;\n  mutable bool length_is_valid;\n};\n\nstd::size_t TextBlock::length() const{\n  if(!length_is_valid){\n    text_length = std::strlen(pText);\n    length_is_valid = true;\n  }\n  return text_length;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这是一个名为TextBlock的类，其中包含一个私有成员变量char *pText，表示一个C风格的字符串。该类还包含了两个mutable类型的私有成员变量std::size_t text_length和bool length_is_valid，用于缓存字符串长度和标记长度是否已经被计算。该类还定义了一个公有成员函数std::size_t length() const，用于获取字符串的长度。下面是对该类的解释：\n\n 1. TextBlock类中的char *pText表示一个C风格的字符串，但是没有提供构造函数或析构函数来管理字符串的内存，这样会存在内存泄漏的风险，需要在类中添加构造函数和析构函数来管理字符串的内存。\n 2. **TextBlock类中的text_length和length_is_valid成员变量被声明为mutable类型，表示即使在const函数中也可以被修改。**这是==因为length()函数需要计算字符串的长度，如果多次调用该函数，每次都重新计算字符串长度会浪费时间，因此使用mutable类型的成员变量缓存计算结果，避免重复计算。==\n 3. TextBlock类中的length()函数是一个const函数，表示该函数不会修改类的成员变量，因此可以在const对象中调用。在函数中使用!length_is_valid判断是否需要重新计算字符串长度，如果需要计算，则调用std::strlen(pText)计算字符串长度，再将计算结果缓存到text_length中，并将length_is_valid标记为true。最后，返回缓存的字符串长度。\n 4. 由于TextBlock类中的pText变量是一个C风格的字符串，并且没有提供构造函数和析构函数来管理内存，因此在使用该类时需要特别注意内存泄漏的问题。可以通过使用std::string等Cpp标准库提供的字符串类型来避免这个问题。\n\nCpp中两个函数如果只是常量性不同，也可以重载。当const成员函数与非const成员函数有着实质等价的实现时，为了避免冗余，可以令non-const版本调用const版本：\n\nclass TextBlock{\npublic:\n  const char& operator[](std::size_t position) const{\n    ...\n  }\n  char& operator[](std::size_t position){\n    return const_cast<char&>(static_cast<const TextBlock&>(*this)[position]);\n  }\n};\n//后者首先将自身转换为const对象\n//随后调用const成员函数，返回const引用\n//最后转换为non-const引用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这是一个名为TextBlock的类，其中定义了两个下标运算符operator[]，用于访问类中的字符数据。第一个下标运算符是一个const成员函数，返回一个const char&类型的引用，表示在指定位置的字符数据。第二个下标运算符是一个非const成员函数，返回一个char&类型的引用，表示在指定位置的字符数据。下面是对该代码的解释：\n\n 1. 第一个下标运算符是一个const成员函数，表示该函数不会修改类的成员变量。在函数中，使用const关键字修饰函数的返回值，表示返回的是一个常量引用。该函数返回指定位置的字符数据，并且由于返回的是一个常量引用，因此客户端无法通过该函数修改类的成员变量。\n 2. 第二个下标运算符是一个非const成员函数，表示该函数可以修改类的成员变量。在函数中，我们使用了const_cast和static_cast两个操作符，将该函数转换成了一个const成员函数的调用。具体来说，我们首先使用static_cast<const TextBlock&>(*this)将当前对象转换成一个const TextBlock&类型的对象，然后调用第一个下标运算符，返回在指定位置的字符数据的常量引用。接着，我们使用const_cast<char&>将常量引用转换为一个非常量引用，从而使得客户端可以通过该函数修改类的成员变量。==需要注意的是，这种使用const_cast的方式是有风险的，因为它可以绕过函数的const限制，可能导致程序的未定义行为和内存安全问题。==\n 3. 如果我们希望在第二个下标运算符中修改一些客户端不可见的数据，可以使用mutable关键字修饰一个成员变量，避免使用const_cast绕过const限制。\n\n\n# 条款4：确定对象被使用前已先被初始化\n\n条款4的意思是，在使用一个对象之前，必须确保该对象已经被正确地初始化。如果一个对象没有被正确地初始化，那么它的行为是未定义的，可能会导致程序崩溃、数据损坏等不可预测的结果。 在Cpp中，对象的初始化方式有多种，包括默认初始化、值初始化、直接初始化、拷贝初始化等。不同的初始化方式会对对象的状态产生不同的影响。为了保证对象被正确地初始化，我们应该遵循以下几个原则：\n\n 1. **明确对象的初始化方式。**在定义对象时，应该清楚地指定对象的初始化方式，避免使用未初始化的对象。\n 2. **尽可能使用构造函数进行初始化。**构造函数是一种专门用于初始化对象的函数，可以保证对象的状态正确。因此，在定义对象时，应该尽可能使用构造函数进行初始化。\n 3. **避免使用未定义的对象。**在使用对象之前，应该确保对象已经被正确地初始化。如果不确定对象是否已经被初始化，就应该避免使用该对象。\n 4. **避免使用未定义的成员变量。**在定义类时，应该确保类的成员变量都被正确地初始化。如果一个成员变量没有被正确地初始化，那么该成员变量的行为也是未定义的，可能会导致程序崩溃、数据损坏等不可预测的结果。\n\nCpp中变量并非一定会进行初始化。最佳处理办法是：对于内置类型必须手动初始化，而对于用户定义的对象，在使用对象前将其初始化（责任落在构造函数上）。\n\n构造函数包含成员初值列与函数体。\n\n 1. 最好使用成员初始列的初始化而非函数体内的赋值，否则对象会在成员初始列的步骤中进行默认初始化，再在赋值的过程中进行拷贝，成本增高。\n 2. 成员初始列的排列顺序应与在类中的声明次序一致，因为成员初始化顺序只与后者有关，前者若与后者不一致的话可能导致误解。\n\n只剩最后一个难点：函数内的静态变量称为local静态变量，其他的都是non-local；而不同编译单元（一个编译单元指产出单一目标文件的源码们）内定义的non-local静态对象的初始化顺序并未规定。倘若存在这样的两个变量a和b，且b的初始化需要使用a，如果a尚未初始化就被b使用了，显然程序会出错。\n\n> local静态变量指的是函数内定义的静态变量，只在函数的作用域内可见；\n> \n> 而non-local静态变量指的是在全局作用域或命名空间内定义的静态变量，可以被多个函数使用。\n> \n> 在Cpp中，对于non-local静态变量的初始化顺序并没有严格的规定。这意味着，如果存在两个non-local静态变量a和b，且b的初始化需要使用a，那么如果a尚未初始化就被b使用了，就会导致程序出错。这是因为，如果a尚未初始化，那么它的值是不确定的，可能是一个随机值，也可能是0或其他默认值。如果b在使用a之前被初始化，那么它使用的a的值是不确定的，这可能会导致程序出错。\n> \n> 为了避免这种问题，我们可以采用一些编程技巧和约定来确保non-local静态变量的正确初始化顺序。例如，可以使用单例模式等设计模式来确保对象的初始化顺序；或者可以将non-local静态变量的初始化工作放在函数内部，以确保它们在第一次使用之前被正确地初始化。此外，我们还可以使用编译器提供的一些选项来控制non-local静态变量的初始化顺序，但这种方法并不是跨平台的，可能会导致代码的可移植性问题。\n\n解决方法也很简单：将每个non-local静态变量移到自己的专属函数内，这些函数返回该静态变量的引用，用户使用这些函数而非直接使用变量（类似单例模式）。至此，non-local静态变量被local静态变量取代。\n\nclass FileSystem{...};\nFileSystem& tfs(){\n  static FileSystem fs;\n  return fs;\n}\nclass Directory{...};\nDirectory::Directory(...){\n    ...\n   std::size_t disks = tfs().num_disks();\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段代码定义了一个名为FileSystem的类和一个名为tfs()的函数，以及另一个名为Directory的类和它的一个构造函数。\n\n在tfs()函数内部，定义了一个名为fs的静态对象，它是FileSystem类的一个实例，并且返回了这个静态对象的引用。\n\n在Directory类的构造函数内部，首先执行了一些初始化工作，然后通过调用tfs()函数获取到了FileSystem对象的引用，并通过该引用调用了num_disks()函数，将返回值存储在了一个名为disks的变量中。\n\n由于tfs()函数内部定义的fs对象是一个静态对象，因此它在程序运行期间只会被创建一次，并且在整个程序的生命周期内都存在。\n\n每次调用tfs()函数时，都会返回同一个静态对象的引用。这种方式可以保证FileSystem类的实例只有一个，并且可以在全局范围内被访问。\n\n在Directory类的构造函数内部，通过调用tfs()函数获取到了FileSystem对象的引用，并且调用了它的num_disks()函数，这种方式可以确保Directory类的实例可以访问到全局唯一的FileSystem对象，并且可以获取到该对象的属性和方法。\n\n总之，这段代码通过使用静态变量和函数，实现了一个全局唯一的FileSystem对象，并且可以在其他类的构造函数中使用该对象，从而避免了对象的多次创建和初始化，提高了程序的效率和可读性。同时，该代码还展示了Cpp中静态变量和静态函数的用法，可以作为学习Cpp语言的参考。',normalizedContent:'# 让自己习惯cpp\n\n\n# 条款1：视cpp为一个语言联邦\n\n条款1中提到了将cpp看作为一个“语言联邦”的概念。具体来说，“语言联邦”是指将cpp看作由多种不同的子语言组成的联邦。每种子语言都有自己的惯用法、工具和库，可以用来解决特定的问题。因此，cpp程序员应该了解这些子语言，并选择最适合解决特定问题的子语言。 这个概念的含义可以从以下几个方面来解释：\n\n 1. 多种子语言：cpp由多种子语言组成，每种子语言都有自己的规则、习惯和约定。例如，面向对象编程（oop）子语言、模板元编程（tmp）子语言等。这些子语言都有自己的语法和语义，可以用来解决特定的问题。\n 2. 惯用法和工具：每种子语言都有自己的惯用法和工具。例如，oop中常用的类、继承、多态等概念，以及与之对应的工具和库，如stl、boost等。熟悉这些惯用法和工具可以提高程序员的开发效率和代码质量。\n 3. 选择最适合的子语言：cpp程序员应该了解这些子语言，并选择最适合解决特定问题的子语言。例如，如果要处理大量的数值计算，可以选择使用tmp子语言中的模板元编程技术，来提高程序的性能；如果要实现一些复杂的数据结构和算法，可以使用stl等库来简化代码。\n\n总的来说，可以将cpp视为一个由4个次语言组成的联邦而非单一语言：\n\n 1. c，说到底cpp仍是以c为基础。\n 2. object-oriented cpp，包括封装、继承、多态等面向对象设计。\n 3. template cpp，泛型编程，衍生出模板元编程（在各个新标准中逐步完善）。\n 4. stl，包括容器、迭代器、算法与函数对象。\n\n\n# 条款2：尽量以const、enum、inline替换#define\n\n条款2中提到了尽量使用const、enum和inline来替代#define的概念。具体来说，#define是一种预处理指令，可以将一个标识符定义为一个值或一个字符串。而const、enum和inline都是cpp语言中的关键字，也可以用于定义常量和函数。以下是对这个条款的一些解释：\n\n 1. #define的缺点：使用#define定义常量存在一些缺点，例如它不会进行类型检查，容易引起意外的副作用，也不会被语法检查工具正确地处理。\n 2. const的优点：使用const定义常量可以避免#define的缺点。const定义的常量有类型，可以被编译器检查和优化，也可以被调试器和其他工具正确地处理。\n 3. enum的优点：如果要定义一系列相关的常量，可以使用enum枚举类型。enum定义的常量有类型，可以被编译器检查和优化，同时也可以提高代码的可读性和可维护性。\n 4. inline的优点：如果要定义一个简单的函数或者函数模板，可以使用inline关键字。inline函数在编译时会被展开，从而避免了函数调用的开销。同时，inline函数也可以提高代码的可读性和可维护性。\n\n#define可以用来定义一些变量、函数，但它只是一方面单纯的文本替换，并且没有任何类型检查，导致容易引起莫名其妙的问题，另一方面预处理后已经消失，编译链接过程中没有其符号信息，出问题时无法定位到它。\n\n#define call_with_max(a,b) f((a)>(b)?(a):(b))\n\nint a=5,b=0;\ncall_with_max(++a,b);\ncall_with_max(++a,b+10);\n\n\n1\n2\n3\n4\n5\n\n\n即使上文的宏已经仔细地为所有参数添加小括号，仍然出现了问题：第一次调用中a被累加两次，第二次调用中a被累加一次。\n\n> call_with_max(++a,b)在展开后变成了f((++a)>(b)?(++a):(b))，其中a的值被多次递增。\n> \n> 而call_with_max(++a,b+10)在展开后变成了f((++a)>(b+10)?(++a):(b+10))，其中a的值也被多次递增。\n> \n> 因此，这两个调用会导致a的值被递增多次，结果可能不是我们所期望的。\n> \n> 为了避免这个问题，更加可预测并且类型安全的写法是，可以使用函数模板来替代#define宏。使用const对象（对于一系列常量，使用枚举或枚举类，而不是一系列#define）\n> \n> 例如，可以定义一个template<typename t> inline void callwithmax(const t& a, const t& b)函数来替代call_with_max宏。\n> \n> 这样做不仅可以避免上述问题，还可以提高代码的可读性和可维护性。例如：\n> \n> template<typename t>\n> inline void callwithmax(const t& a, const t& b)\n> {\n> f(a > b ? a : b);\n> }\n> int a = 5, b = 0;\n> callwithmax(++a, b);\n> callwithmax(++a, b + 10);\n> // 这段代码中，a的值只会被递增一次，符合我们的预期。\n> // 不过inline目前主要指多重定义而非内联\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n\n# 条款3：尽可能使用const\n\n条款3中提到了尽可能使用const的概念。具体来说，const是cpp语言中的关键字，用于定义常量。以下是对这个条款的一些解释：\n\n 1. const的作用：使用const可以将变量定义为常量，即不能被修改。常量可以提高代码的可读性和可维护性，同时也可以避免意外的修改导致的错误。\n 2. const的使用场景：在cpp中，const可以用于定义常量、函数参数和函数返回值等。使用const定义常量时，可以使用const关键字加上变量的类型，例如const int max_size = 1024;。使用const定义函数参数时，可以在参数类型前加上const关键字，例如void foo(const std::string& str);。使用const定义函数返回值时，可以在函数声明和定义中返回类型前加上const关键字，例如const std::string& foo() const;。\n 3. const的作用域：在cpp中，const变量和const函数的作用域与普通变量和函数的作用域相同。如果const变量或const函数在某个作用域内定义，那么它们只能在该作用域内使用。\n 4. const和指针：使用指针时，const可以用于限定指针本身或指针所指向的内容是否可修改。例如，const int* p表示指向const int类型的指针，即指针所指向的内容不能被修改；int* const p表示指向int类型的const指针，即指针本身不能被修改。另外，const还可以同时限定指针本身和指针所指向的内容是否可修改，例如const int* const p表示指向const int类型的const指针。\n\nchar greeting[] = "hello";\nchar* p1 = greeting;\nconst char* p2 = greeting;       //被指物不可修改\nchar* const p3 = greeting        //指针不可修改\nconst char* const p4 = greeting; //皆不可修改\n\n\n1\n2\n3\n4\n5\n\n\n真正威力强大的用法是面对函数声明时，const可以和函数返回值、各参数、成员函数自身产生关联。例如令函数返回const，往往可以降低因用户错误而造成的意外，又不至于放弃安全性和高效性。\n\nclass rational{...};\nconst rational operator*(const rational& lhs,const rational& rhs);\n//上述写法可以避免用户写出 a*b = c\n\n\n1\n2\n3\n\n\n对于成员函数自身的const，编译器强制实施bitwise const，即强制不能修改任何成员变量。**这意味着，在const成员函数中，即使我们使用了mutable关键字，也不能修改任何非mutable成员变量。**但实际上很多情况下我们需要的是logical const，即const成员函数也应该可以修改某些客户不可见的数据，这时可以用mutable成员变量来绕过const成员函数的限制。\n\n例如对于一个文本块的对象而言，其内部很可能存在高速缓存；对于查询文本块长度这样的const操作，仍然需要更新高速缓存：\n\nclass textblock{\npublic:\n  std::size_t length() const;\nprivate:\n  char *ptext;\n  mutable std::size_t text_length;\n  mutable bool length_is_valid;\n};\n\nstd::size_t textblock::length() const{\n  if(!length_is_valid){\n    text_length = std::strlen(ptext);\n    length_is_valid = true;\n  }\n  return text_length;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这是一个名为textblock的类，其中包含一个私有成员变量char *ptext，表示一个c风格的字符串。该类还包含了两个mutable类型的私有成员变量std::size_t text_length和bool length_is_valid，用于缓存字符串长度和标记长度是否已经被计算。该类还定义了一个公有成员函数std::size_t length() const，用于获取字符串的长度。下面是对该类的解释：\n\n 1. textblock类中的char *ptext表示一个c风格的字符串，但是没有提供构造函数或析构函数来管理字符串的内存，这样会存在内存泄漏的风险，需要在类中添加构造函数和析构函数来管理字符串的内存。\n 2. **textblock类中的text_length和length_is_valid成员变量被声明为mutable类型，表示即使在const函数中也可以被修改。**这是==因为length()函数需要计算字符串的长度，如果多次调用该函数，每次都重新计算字符串长度会浪费时间，因此使用mutable类型的成员变量缓存计算结果，避免重复计算。==\n 3. textblock类中的length()函数是一个const函数，表示该函数不会修改类的成员变量，因此可以在const对象中调用。在函数中使用!length_is_valid判断是否需要重新计算字符串长度，如果需要计算，则调用std::strlen(ptext)计算字符串长度，再将计算结果缓存到text_length中，并将length_is_valid标记为true。最后，返回缓存的字符串长度。\n 4. 由于textblock类中的ptext变量是一个c风格的字符串，并且没有提供构造函数和析构函数来管理内存，因此在使用该类时需要特别注意内存泄漏的问题。可以通过使用std::string等cpp标准库提供的字符串类型来避免这个问题。\n\ncpp中两个函数如果只是常量性不同，也可以重载。当const成员函数与非const成员函数有着实质等价的实现时，为了避免冗余，可以令non-const版本调用const版本：\n\nclass textblock{\npublic:\n  const char& operator[](std::size_t position) const{\n    ...\n  }\n  char& operator[](std::size_t position){\n    return const_cast<char&>(static_cast<const textblock&>(*this)[position]);\n  }\n};\n//后者首先将自身转换为const对象\n//随后调用const成员函数，返回const引用\n//最后转换为non-const引用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这是一个名为textblock的类，其中定义了两个下标运算符operator[]，用于访问类中的字符数据。第一个下标运算符是一个const成员函数，返回一个const char&类型的引用，表示在指定位置的字符数据。第二个下标运算符是一个非const成员函数，返回一个char&类型的引用，表示在指定位置的字符数据。下面是对该代码的解释：\n\n 1. 第一个下标运算符是一个const成员函数，表示该函数不会修改类的成员变量。在函数中，使用const关键字修饰函数的返回值，表示返回的是一个常量引用。该函数返回指定位置的字符数据，并且由于返回的是一个常量引用，因此客户端无法通过该函数修改类的成员变量。\n 2. 第二个下标运算符是一个非const成员函数，表示该函数可以修改类的成员变量。在函数中，我们使用了const_cast和static_cast两个操作符，将该函数转换成了一个const成员函数的调用。具体来说，我们首先使用static_cast<const textblock&>(*this)将当前对象转换成一个const textblock&类型的对象，然后调用第一个下标运算符，返回在指定位置的字符数据的常量引用。接着，我们使用const_cast<char&>将常量引用转换为一个非常量引用，从而使得客户端可以通过该函数修改类的成员变量。==需要注意的是，这种使用const_cast的方式是有风险的，因为它可以绕过函数的const限制，可能导致程序的未定义行为和内存安全问题。==\n 3. 如果我们希望在第二个下标运算符中修改一些客户端不可见的数据，可以使用mutable关键字修饰一个成员变量，避免使用const_cast绕过const限制。\n\n\n# 条款4：确定对象被使用前已先被初始化\n\n条款4的意思是，在使用一个对象之前，必须确保该对象已经被正确地初始化。如果一个对象没有被正确地初始化，那么它的行为是未定义的，可能会导致程序崩溃、数据损坏等不可预测的结果。 在cpp中，对象的初始化方式有多种，包括默认初始化、值初始化、直接初始化、拷贝初始化等。不同的初始化方式会对对象的状态产生不同的影响。为了保证对象被正确地初始化，我们应该遵循以下几个原则：\n\n 1. **明确对象的初始化方式。**在定义对象时，应该清楚地指定对象的初始化方式，避免使用未初始化的对象。\n 2. **尽可能使用构造函数进行初始化。**构造函数是一种专门用于初始化对象的函数，可以保证对象的状态正确。因此，在定义对象时，应该尽可能使用构造函数进行初始化。\n 3. **避免使用未定义的对象。**在使用对象之前，应该确保对象已经被正确地初始化。如果不确定对象是否已经被初始化，就应该避免使用该对象。\n 4. **避免使用未定义的成员变量。**在定义类时，应该确保类的成员变量都被正确地初始化。如果一个成员变量没有被正确地初始化，那么该成员变量的行为也是未定义的，可能会导致程序崩溃、数据损坏等不可预测的结果。\n\ncpp中变量并非一定会进行初始化。最佳处理办法是：对于内置类型必须手动初始化，而对于用户定义的对象，在使用对象前将其初始化（责任落在构造函数上）。\n\n构造函数包含成员初值列与函数体。\n\n 1. 最好使用成员初始列的初始化而非函数体内的赋值，否则对象会在成员初始列的步骤中进行默认初始化，再在赋值的过程中进行拷贝，成本增高。\n 2. 成员初始列的排列顺序应与在类中的声明次序一致，因为成员初始化顺序只与后者有关，前者若与后者不一致的话可能导致误解。\n\n只剩最后一个难点：函数内的静态变量称为local静态变量，其他的都是non-local；而不同编译单元（一个编译单元指产出单一目标文件的源码们）内定义的non-local静态对象的初始化顺序并未规定。倘若存在这样的两个变量a和b，且b的初始化需要使用a，如果a尚未初始化就被b使用了，显然程序会出错。\n\n> local静态变量指的是函数内定义的静态变量，只在函数的作用域内可见；\n> \n> 而non-local静态变量指的是在全局作用域或命名空间内定义的静态变量，可以被多个函数使用。\n> \n> 在cpp中，对于non-local静态变量的初始化顺序并没有严格的规定。这意味着，如果存在两个non-local静态变量a和b，且b的初始化需要使用a，那么如果a尚未初始化就被b使用了，就会导致程序出错。这是因为，如果a尚未初始化，那么它的值是不确定的，可能是一个随机值，也可能是0或其他默认值。如果b在使用a之前被初始化，那么它使用的a的值是不确定的，这可能会导致程序出错。\n> \n> 为了避免这种问题，我们可以采用一些编程技巧和约定来确保non-local静态变量的正确初始化顺序。例如，可以使用单例模式等设计模式来确保对象的初始化顺序；或者可以将non-local静态变量的初始化工作放在函数内部，以确保它们在第一次使用之前被正确地初始化。此外，我们还可以使用编译器提供的一些选项来控制non-local静态变量的初始化顺序，但这种方法并不是跨平台的，可能会导致代码的可移植性问题。\n\n解决方法也很简单：将每个non-local静态变量移到自己的专属函数内，这些函数返回该静态变量的引用，用户使用这些函数而非直接使用变量（类似单例模式）。至此，non-local静态变量被local静态变量取代。\n\nclass filesystem{...};\nfilesystem& tfs(){\n  static filesystem fs;\n  return fs;\n}\nclass directory{...};\ndirectory::directory(...){\n    ...\n   std::size_t disks = tfs().num_disks();\n   ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段代码定义了一个名为filesystem的类和一个名为tfs()的函数，以及另一个名为directory的类和它的一个构造函数。\n\n在tfs()函数内部，定义了一个名为fs的静态对象，它是filesystem类的一个实例，并且返回了这个静态对象的引用。\n\n在directory类的构造函数内部，首先执行了一些初始化工作，然后通过调用tfs()函数获取到了filesystem对象的引用，并通过该引用调用了num_disks()函数，将返回值存储在了一个名为disks的变量中。\n\n由于tfs()函数内部定义的fs对象是一个静态对象，因此它在程序运行期间只会被创建一次，并且在整个程序的生命周期内都存在。\n\n每次调用tfs()函数时，都会返回同一个静态对象的引用。这种方式可以保证filesystem类的实例只有一个，并且可以在全局范围内被访问。\n\n在directory类的构造函数内部，通过调用tfs()函数获取到了filesystem对象的引用，并且调用了它的num_disks()函数，这种方式可以确保directory类的实例可以访问到全局唯一的filesystem对象，并且可以获取到该对象的属性和方法。\n\n总之，这段代码通过使用静态变量和函数，实现了一个全局唯一的filesystem对象，并且可以在其他类的构造函数中使用该对象，从而避免了对象的多次创建和初始化，提高了程序的效率和可读性。同时，该代码还展示了cpp中静态变量和静态函数的用法，可以作为学习cpp语言的参考。',charsets:{cjk:!0}},{title:"条款5-12 构造析构赋值运算",frontmatter:{title:"条款5-12 构造析构赋值运算",date:"2023-11-24T15:59:26.000Z",permalink:"/pages/4fc2cb/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/30.Effetcive_CPP/02.%E6%9D%A1%E6%AC%BE5-%2012%20%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97.html",relativePath:"01.CPP语言/30.Effetcive_CPP/02.条款5- 12 构造析构赋值运算.md",key:"v-afd5090a",path:"/pages/4fc2cb/",lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.37,time:142200.00000000003,words:474},headersStr:null,content:'# 构造/析构/赋值运算\n\n\n# 条款5：了解Cpp默认编写并调用哪些函数\n\n条款5是指，在设计Cpp类时，必须要了解Cpp默认编写并调用哪些函数。具体来说，Cpp默认编写并调用的函数有以下几个：\n\n 1. 默认构造函数：如果用户没有显式地定义构造函数，则Cpp会自动生成一个默认构造函数，该函数不带任何参数，不执行任何操作。默认构造函数的作用是初始化对象的成员变量，如果没有定义，则成员变量的值是不确定的。\n 2. 默认析构函数：如果用户没有显式地定义析构函数，则Cpp会自动生成一个默认析构函数，该函数不带任何参数，用于释放对象所占用的资源。默认析构函数的作用是清理对象的状态，防止内存泄漏。\n 3. 默认拷贝构造函数：如果用户没有显式地定义拷贝构造函数，则Cpp会自动生成一个默认拷贝构造函数，该函数用于复制对象的成员变量。默认拷贝构造函数的作用是实现对象的复制功能，如果没有定义，则对象的复制会出现问题。\n 4. 默认拷贝赋值函数：如果用户没有显式地定义拷贝赋值函数，则Cpp会自动生成一个默认拷贝赋值函数，该函数用于将一个对象的值赋给另一个对象。默认拷贝赋值函数的作用是实现对象的赋值功能，如果没有定义，则对象的赋值会出现问题。\n 5. 默认移动构造函数和移动赋值函数：如果用户没有显式地定义移动构造函数和移动赋值函数，则Cpp会自动生成默认的移动构造函数和移动赋值函数，用于进行对象的移动操作。移动构造函数和移动赋值函数的作用是实现对象的移动操作，提高程序的效率。\n\n通常情况下，如果代码中没有声明构造函数、拷贝构造函数、拷贝运算符、析构函数，编译器会在需要时创建他们，但这往往只能满足编译器的需求，很可能无法满足程序的需求。\n\n实际的生成规则复杂一些，可以查阅cppreference。\n\nclass Empty{};\n//上面的空类好比下面的类\nclass Empty{\npublic:\n  Empty() { ... }\n  Empty(const Empty& rhs) { ... }\n  ~Empty() { ... }\n  \n  Empty& operator=(const Empty& rhs) { ... }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n编译器生成的构造函数/析构函数是只是调用基类和非静态成员变量的构造函数/析构函数；生成的析构函数是非虚的，除非基类有虚析构函数。\n\n至于生成的拷贝构造函数和拷贝操作符只是单纯将每个非静态成员变量拷贝；有const成员或者引用成员时，以及基类拒绝拷贝操作符时，默认生成的拷贝操作符没有意义，必须自己定义。\n\n----------------------------------------\n\n\n# 条款6：若不想使用编译器自动生成的函数，就该明确拒绝\n\n条款6是指，在设计Cpp类时，如果不想使用编译器自动生成的函数，就应该明确拒绝。具体来说，如果类的某些函数不应该被自动生成（如拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、析构函数等），则应该通过显式声明和私有化的方式来明确拒绝它们的生成和使用。这种做法可以避免编译器自动生成的函数的使用带来的问题，同时也能够提高程序的可读性和可维护性。 具体的实现方式是，通过在类的定义中声明并私有化某些函数，来防止编译器自动生成它们。例如，可以通过将拷贝构造函数和拷贝赋值函数声明为私有函数来禁止对象的复制。代码示例如下：\n\nclass MyClass {\npublic:\n    // 默认构造函数和析构函数是必须的，不能拒绝\n    MyClass() = default;\n    ~MyClass() = default;\n    // 显式声明并私有化拷贝构造函数和拷贝赋值函数，明确拒绝它们的生成和使用\n    MyClass(const MyClass&) = delete;\n    MyClass& operator=(const MyClass&) = delete;\n    // 正常声明其他函数\n    void foo();\n    void bar();\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在上面的代码中，我们通过=delete语句来显式地声明并私有化了拷贝构造函数和拷贝赋值函数，从而明确拒绝它们的生成和使用。这样一来，在其他地方调用这些函数时，编译器就会报错，从而提醒程序员需要注意。\n\n很多时候，你并不希望某些类被拷贝，而仅仅不实现拷贝构造/拷贝运算符是不够的，因为编译器可能会自行生成。\n\n为此，可以把拷贝构造/拷贝运算符声明为"=delete"，或者声明为private（后者较为过时）。\n\nclass Uncopyable{\npublic:\n  Uncopyable() = delete;\n  Uncopyable& operator=(const Uncopyable&) = delete;\n};\n\n\n1\n2\n3\n4\n5\n\n\n事实上，对于析构函数中需要释放资源的类，为了防止内存问题，除非真的需要拷贝功能，否则最好都禁止拷贝。\n\n可以让它们继承上面的类，即可禁止编译器生成拷贝操作：编译器试图为它们生成拷贝构造/拷贝运算符时会尝试调用基类Uncopyable的对应操作，而这会被拒绝。\n\nclass SomeClass: private Uncopyable{ ... };\n\n\n1\n\n\n----------------------------------------\n\n\n# 条款7：为多态基类声明virtual析构函数\n\n条款7是指，在Cpp中，如果一个类是多态基类，那么应该为它声明虚析构函数。具体来说，如果一个类将会被其他类所继承，并且这些派生类被用作多态基类，那么这个类的析构函数应该被声明为虚函数，以保证在派生类对象被销毁时正确地调用析构函数。因为在Cpp中，如果一个类的析构函数不是虚函数，那么在销毁一个指向派生类对象的基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致内存泄漏和程序错误。 为了解释这个问题，我们可以看下面这个例子：\n\nclass Base {\npublic:\n    Base() {}\n    ~Base() { cout << "Base destructor called" << endl; }\n};\nclass Derived : public Base {\npublic:\n    Derived() {}\n    ~Derived() { cout << "Derived destructor called" << endl; }\n};\nint main() {\n    Base* ptr = new Derived();\n    delete ptr;  // 只会调用Base的析构函数，导致Derived的析构函数没有被调用，内存泄漏\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在这个例子中，我们定义了一个基类Base和一个派生类Derived，并在main函数中创建了一个指向派生类对象的基类指针ptr。然后，我们调用delete语句释放ptr所指向的对象，期望同时调用Base和Derived的析构函数。但是，由于Base的析构函数不是虚函数，所以在销毁ptr时只调用了Base的析构函数，而没有调用Derived的析构函数，从而导致内存泄漏和程序错误。 为了解决这个问题，我们可以将Base的析构函数声明为虚函数，代码示例如下：\n\nclass Base {\npublic:\n    Base() {}\n    virtual ~Base() { cout << "Base destructor called" << endl; }  // 声明为虚函数\n};\nclass Derived : public Base {\npublic:\n    Derived() {}\n    ~Derived() { cout << "Derived destructor called" << endl; }\n};\nint main() {\n    Base* ptr = new Derived();\n    delete ptr;  // 此时会依次调用Derived和Base的析构函数，避免内存泄漏\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在这个例子中，我们将Base的析构函数声明为虚函数，这样在销毁ptr时就会依次调用Derived和Base的析构函数，从而正确地释放对象的内存。\n\n----------------------------------------\n\nCpp中多态性质体现于虚函数：基类指针或引用调用虚函数时会检查指向的对象是基类还是派生类，再调用对应的函数。\n\n> 在Cpp中，实现多态性的核心机制是虚函数。虚函数是在基类中声明的，可以在派生类中重写。在使用基类指针或引用调用虚函数时，编译器会在运行时检查指向的对象是基类还是派生类，然后调用对应的函数。具体实现可以分为两个步骤：虚函数表和动态绑定。\n> \n>  1. 虚函数表：每个类都有一个虚函数表，也叫虚表(virtual table)，用来存储该类的虚函数地址。\n> \n> 虚函数表是在编译阶段生成的，每个类都有自己的虚函数表，其中存储着该类的虚函数地址。\n> \n> 虚函数表通常被作为类的第一个成员，在对象的内存布局中，虚表指针被放在对象的最前面，以便访问虚函数表中的地址。\n> \n> 对于包含虚函数的类，编译器会在编译阶段自动生成一个虚函数表，其中存储了该类的虚函数地址。\n> \n> 虚函数表是一个数组，每个元素对应一个虚函数的地址。在类的构造函数中，会将该类的虚表指针指向该类的虚函数表。\n> \n> 在调用虚函数时，编译器会通过虚表指针找到该类的虚函数表，并根据函数在虚函数表中的位置调用相应的函数。\n> \n>  2. 动态绑定：动态绑定是指在运行时确定函数的调用地址的过程。\n> \n> 当使用基类指针或引用调用虚函数时，编译器会在运行时检查指向的对象是基类还是派生类，然后根据对象的实际类型来确定调用哪个函数。这个过程被称为动态绑定或后期绑定。\n> \n> **动态绑定的实现需要依赖虚表指针。**当使用基类指针或引用调用虚函数时，编译器会根据指针或引用的静态类型确定该类的虚表指针，然后根据虚表指针找到该类的虚函数表，再根据虚函数在虚函数表中的位置找到对应的函数地址。然后在运行时根据对象的实际类型调用相应的函数。\n> \n> **总的来说，Cpp中多态的实现是基于虚函数表和动态绑定的。**虚函数表存储了类的虚函数地址，而动态绑定则根据对象的实际类型来确定调用哪个函数。虽然虚函数表和动态绑定会增加程序的运行时开销，但是它们是实现多态的核心机制，使得程序能够更加灵活和可扩展。\n\n当这样的一个指向派生类的基类指针析构时，如果析构函数不是虚函数，则直接调用基类的析构函数，那么派生类获取的资源未释放，则会造成内存泄漏。\n\n而当析构函数是虚函数时则先调用对应的派生类析构函数，再调用基类析构函数，资源全部释放。\n\n不过这种操作只有在基类是多态用途时才需要注意，也有很多类不是为了多态的用途，例如STL容器和上文的Uncopyable。\n\n----------------------------------------\n\n\n# 条款8：别让异常逃离析构函数\n\nCpp中抛出异常时会逐步展开其函数调用栈，清空局部资源，直到异常被catch。\n\n如果析构函数可以抛出异常，那么清空局部资源时局部对象的析构函数再次异常时同时存在两个异常，Cpp无法处理，可能会过早结束或出现不明确行为。因此，析构函数绝对不要抛出异常，应通过try-catch捕获任何异常。\n\n有时，客户需要处理某些异常，那么类应该提供一个普通成员函数执行相关操作，供用户调用并处理异常。\n\n例如数据库连接这样的类中，假设用户需要处理关闭连接时的异常，同时析构函数不能抛出异常，可以这样：\n\nclass DBConn{\npublic:\n  void close(){\n    db.close();\n    closed = true;\n  }\n  ~DBConn()\n  {\n    if(!closed)\n    {\n        try{\n          db.close();\n        }catch(...){\n        //记录相关信息\n        }\n    }\n  }\nprivate:\n  DBConnection db;\n  bool closed;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n----------------------------------------\n\n\n# 条款9：绝不在构造和析构过程中调用virtual函数\n\nCpp的构造过程是先构造基类再构造子类、先初始化再进入构造函数体；析构过程相反。\n\n对于派生类的构造函数而言，进入其中时基类部分已构造完而派生类部分未构造完，对象类型是基类，故而此时调用虚函数，实际上使用的是基类的虚函数。\n\n析构函数同理。进入析构函数后派生类部分呈未定义值，对象类型是基类，调用的是基类的虚函数。\n\n总而言之，在构造函数与析构函数中虚函数的行为有特殊变化；为了避免出错，不要在其过程中使用虚函数。如果确实需要在构造函数或析构函数中调用虚函数，可以使用非虚函数或纯虚函数代替虚函数，或者在构造函数或析构函数中显式调用基类中的函数。\n\n----------------------------------------\n\n\n# 条款10：令operator=返回一个reference to *this\n\n> 条款10提醒我们在实现自定义的赋值运算符(operator=)时，应该将其返回类型定义为引用(reference)类型，并返回一个指向当前对象的指针(*this)，以便实现连续赋值和链式调用的功能。这种做法被称为“返回一个reference to *this”。\n\nCpp中通常支持连锁赋值，采用右结合律：\n\nint a,b,c;\na = b = c = 15;\n// a = (b = (c = 15));\n\n\n1\n2\n3\n\n\n> 具体来说，如果我们将赋值运算符的返回类型定义为值(value)类型，那么在进行多次赋值时，每次都会创建一个新的临时对象，这会导致不必要的内存分配和拷贝，降低程序的执行效率。而如果将赋值运算符的返回类型定义为引用类型，可以避免创建临时对象，提高程序的执行效率。\n> \n> 同时，返回一个指向当前对象的指针(*this)也可以实现链式调用的功能。在链式调用中，每个函数调用的返回值都是当前对象的引用，这样就可以一直链式调用下去，从而使代码更加简洁和易读。\n\n为了支持这个常规，拷贝运算符需要返回一个引用。这一条款并不强制，但约定俗成。\n\nclass Widget{\npublic:\n  Widget& operator=(const Widget& rhs){\n    ...\n    return *this;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 条款11：在operator=中处理“自我赋值”\n\n> 条款11提醒我们在实现自定义的赋值运算符(operator=)时，需要特别注意处理“自我赋值”(self-assignment)的情况，即将一个对象赋值给它自身。 如果没有正确处理自我赋值的情况，可能会导致对象的状态出现错误，甚至导致程序崩溃。因此，在实现赋值运算符时，必须处理自我赋值的情况，以保证程序的正确性和稳定性。\n\n处理自我赋值的方法通常有两种：\n\n 1. 引入临时对象。在处理自我赋值时，可以先创建一个临时对象，将原对象的状态拷贝到临时对象中，然后再将临时对象的状态赋值给原对象。这样可以避免在拷贝原对象的状态时被自我赋值所影响。需要注意的是，在创建临时对象时，应该使用拷贝构造函数而不是赋值运算符，以避免在处理自我赋值时再次调用赋值运算符。\n\n 2. 检查自我赋值。在处理赋值运算符时，可以先检查赋值运算符的左右两边是否是同一个对象，如果是，则直接返回该对象，不进行任何操作。这样可以避免在处理自我赋值时出现错误。 需要注意的是，处理自我赋值时，不仅要考虑到对象的成员变量，还需要考虑到对象可能维护的资源，如内存、文件句柄等。如果对象维护了资源，需要在处理自我赋值时特别注意释放和重新分配资源的顺序，以避免出现资源泄漏或访问非法内存等问题。\n    \n    因此，在实现自定义的赋值运算符时，需要特别注意处理自我赋值的情况。处理自我赋值的方法可以是引入临时对象或检查自我赋值，需要根据具体情况选择合适的方法。同时，需要注意处理对象维护的资源，以保证程序的正确性和稳定性。\n\n考虑这样一个类，其中管理了一个堆对象\n\nclass Widget{\n  ...\nprivate:\n  Bitmap* pb; //一个堆对象\n};\n\n\n1\n2\n3\n4\n5\n\n\n总有些时候，会出现实质上“a=a”这种自我赋值的情况。那么这样简单的拷贝运算符就会出错，先释放了自身的pb，又使用了pb：\n\nWidget& Widget::operator=(const Widget& rhs){\n  delete pb;\n  pb = new Bitmap(*rhs.pb);\n  return *this;\n}\n\n\n1\n2\n3\n4\n5\n\n\n传统做法是函数开头添加一个测试：\n\nif(this == &rhs) return *this;\n\n\n1\n\n\n这种做法具备“自我赋值安全性”，但不具备“异常安全性”：例如当new Bitmap异常时，pb指向被删除的内存。\n\n常用的方法有两种，兼顾了“自我赋值安全性”与“异常安全性”：\n\n//第一种\nWidget& Widget::operator=(const Widget& rhs){\n  Bitmap* pb_original = pb;\n  pb = new Bitmap(*rhs.pb);\n  delete pb_original;\n  return *this;\n}\n//第二种\nvoid Widget::swap(Widget& rhs){\n  ...\n};\nWidget& Widget::operator=(const Widget& rhs){\n  Widget temp(rhs);\n  swap(temp);\n  return *this;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 条款12：复制对象时勿忘其每一个成分\n\n当自己实现拷贝构造/拷贝运算符时，编译器不会警告你遗漏了某些成员变量。因此，必须仔细地复制所有派生类成员，并调用基类的拷贝操作来复制基类成员。\n\nDerived::Derived(const Derived& rhs)\n  :Base(rhs),some_member(rhs.some_member){}\n\nDerived& Derived::operator=(const Derived& rhs){\n  Base::operator=(rhs);\n  some_member = rhs.some_member;\n  return *this;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n拷贝构造和拷贝运算符中很可能有相当多重复的操作，但因为两个函数性质完全不同，因此不能用其中一个调用另一个来减少冗余。\n\n可以把共同功能放在第三个函数中，并由两个拷贝操作共同调用。',normalizedContent:'# 构造/析构/赋值运算\n\n\n# 条款5：了解cpp默认编写并调用哪些函数\n\n条款5是指，在设计cpp类时，必须要了解cpp默认编写并调用哪些函数。具体来说，cpp默认编写并调用的函数有以下几个：\n\n 1. 默认构造函数：如果用户没有显式地定义构造函数，则cpp会自动生成一个默认构造函数，该函数不带任何参数，不执行任何操作。默认构造函数的作用是初始化对象的成员变量，如果没有定义，则成员变量的值是不确定的。\n 2. 默认析构函数：如果用户没有显式地定义析构函数，则cpp会自动生成一个默认析构函数，该函数不带任何参数，用于释放对象所占用的资源。默认析构函数的作用是清理对象的状态，防止内存泄漏。\n 3. 默认拷贝构造函数：如果用户没有显式地定义拷贝构造函数，则cpp会自动生成一个默认拷贝构造函数，该函数用于复制对象的成员变量。默认拷贝构造函数的作用是实现对象的复制功能，如果没有定义，则对象的复制会出现问题。\n 4. 默认拷贝赋值函数：如果用户没有显式地定义拷贝赋值函数，则cpp会自动生成一个默认拷贝赋值函数，该函数用于将一个对象的值赋给另一个对象。默认拷贝赋值函数的作用是实现对象的赋值功能，如果没有定义，则对象的赋值会出现问题。\n 5. 默认移动构造函数和移动赋值函数：如果用户没有显式地定义移动构造函数和移动赋值函数，则cpp会自动生成默认的移动构造函数和移动赋值函数，用于进行对象的移动操作。移动构造函数和移动赋值函数的作用是实现对象的移动操作，提高程序的效率。\n\n通常情况下，如果代码中没有声明构造函数、拷贝构造函数、拷贝运算符、析构函数，编译器会在需要时创建他们，但这往往只能满足编译器的需求，很可能无法满足程序的需求。\n\n实际的生成规则复杂一些，可以查阅cppreference。\n\nclass empty{};\n//上面的空类好比下面的类\nclass empty{\npublic:\n  empty() { ... }\n  empty(const empty& rhs) { ... }\n  ~empty() { ... }\n  \n  empty& operator=(const empty& rhs) { ... }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n编译器生成的构造函数/析构函数是只是调用基类和非静态成员变量的构造函数/析构函数；生成的析构函数是非虚的，除非基类有虚析构函数。\n\n至于生成的拷贝构造函数和拷贝操作符只是单纯将每个非静态成员变量拷贝；有const成员或者引用成员时，以及基类拒绝拷贝操作符时，默认生成的拷贝操作符没有意义，必须自己定义。\n\n----------------------------------------\n\n\n# 条款6：若不想使用编译器自动生成的函数，就该明确拒绝\n\n条款6是指，在设计cpp类时，如果不想使用编译器自动生成的函数，就应该明确拒绝。具体来说，如果类的某些函数不应该被自动生成（如拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、析构函数等），则应该通过显式声明和私有化的方式来明确拒绝它们的生成和使用。这种做法可以避免编译器自动生成的函数的使用带来的问题，同时也能够提高程序的可读性和可维护性。 具体的实现方式是，通过在类的定义中声明并私有化某些函数，来防止编译器自动生成它们。例如，可以通过将拷贝构造函数和拷贝赋值函数声明为私有函数来禁止对象的复制。代码示例如下：\n\nclass myclass {\npublic:\n    // 默认构造函数和析构函数是必须的，不能拒绝\n    myclass() = default;\n    ~myclass() = default;\n    // 显式声明并私有化拷贝构造函数和拷贝赋值函数，明确拒绝它们的生成和使用\n    myclass(const myclass&) = delete;\n    myclass& operator=(const myclass&) = delete;\n    // 正常声明其他函数\n    void foo();\n    void bar();\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在上面的代码中，我们通过=delete语句来显式地声明并私有化了拷贝构造函数和拷贝赋值函数，从而明确拒绝它们的生成和使用。这样一来，在其他地方调用这些函数时，编译器就会报错，从而提醒程序员需要注意。\n\n很多时候，你并不希望某些类被拷贝，而仅仅不实现拷贝构造/拷贝运算符是不够的，因为编译器可能会自行生成。\n\n为此，可以把拷贝构造/拷贝运算符声明为"=delete"，或者声明为private（后者较为过时）。\n\nclass uncopyable{\npublic:\n  uncopyable() = delete;\n  uncopyable& operator=(const uncopyable&) = delete;\n};\n\n\n1\n2\n3\n4\n5\n\n\n事实上，对于析构函数中需要释放资源的类，为了防止内存问题，除非真的需要拷贝功能，否则最好都禁止拷贝。\n\n可以让它们继承上面的类，即可禁止编译器生成拷贝操作：编译器试图为它们生成拷贝构造/拷贝运算符时会尝试调用基类uncopyable的对应操作，而这会被拒绝。\n\nclass someclass: private uncopyable{ ... };\n\n\n1\n\n\n----------------------------------------\n\n\n# 条款7：为多态基类声明virtual析构函数\n\n条款7是指，在cpp中，如果一个类是多态基类，那么应该为它声明虚析构函数。具体来说，如果一个类将会被其他类所继承，并且这些派生类被用作多态基类，那么这个类的析构函数应该被声明为虚函数，以保证在派生类对象被销毁时正确地调用析构函数。因为在cpp中，如果一个类的析构函数不是虚函数，那么在销毁一个指向派生类对象的基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致内存泄漏和程序错误。 为了解释这个问题，我们可以看下面这个例子：\n\nclass base {\npublic:\n    base() {}\n    ~base() { cout << "base destructor called" << endl; }\n};\nclass derived : public base {\npublic:\n    derived() {}\n    ~derived() { cout << "derived destructor called" << endl; }\n};\nint main() {\n    base* ptr = new derived();\n    delete ptr;  // 只会调用base的析构函数，导致derived的析构函数没有被调用，内存泄漏\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在这个例子中，我们定义了一个基类base和一个派生类derived，并在main函数中创建了一个指向派生类对象的基类指针ptr。然后，我们调用delete语句释放ptr所指向的对象，期望同时调用base和derived的析构函数。但是，由于base的析构函数不是虚函数，所以在销毁ptr时只调用了base的析构函数，而没有调用derived的析构函数，从而导致内存泄漏和程序错误。 为了解决这个问题，我们可以将base的析构函数声明为虚函数，代码示例如下：\n\nclass base {\npublic:\n    base() {}\n    virtual ~base() { cout << "base destructor called" << endl; }  // 声明为虚函数\n};\nclass derived : public base {\npublic:\n    derived() {}\n    ~derived() { cout << "derived destructor called" << endl; }\n};\nint main() {\n    base* ptr = new derived();\n    delete ptr;  // 此时会依次调用derived和base的析构函数，避免内存泄漏\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在这个例子中，我们将base的析构函数声明为虚函数，这样在销毁ptr时就会依次调用derived和base的析构函数，从而正确地释放对象的内存。\n\n----------------------------------------\n\ncpp中多态性质体现于虚函数：基类指针或引用调用虚函数时会检查指向的对象是基类还是派生类，再调用对应的函数。\n\n> 在cpp中，实现多态性的核心机制是虚函数。虚函数是在基类中声明的，可以在派生类中重写。在使用基类指针或引用调用虚函数时，编译器会在运行时检查指向的对象是基类还是派生类，然后调用对应的函数。具体实现可以分为两个步骤：虚函数表和动态绑定。\n> \n>  1. 虚函数表：每个类都有一个虚函数表，也叫虚表(virtual table)，用来存储该类的虚函数地址。\n> \n> 虚函数表是在编译阶段生成的，每个类都有自己的虚函数表，其中存储着该类的虚函数地址。\n> \n> 虚函数表通常被作为类的第一个成员，在对象的内存布局中，虚表指针被放在对象的最前面，以便访问虚函数表中的地址。\n> \n> 对于包含虚函数的类，编译器会在编译阶段自动生成一个虚函数表，其中存储了该类的虚函数地址。\n> \n> 虚函数表是一个数组，每个元素对应一个虚函数的地址。在类的构造函数中，会将该类的虚表指针指向该类的虚函数表。\n> \n> 在调用虚函数时，编译器会通过虚表指针找到该类的虚函数表，并根据函数在虚函数表中的位置调用相应的函数。\n> \n>  2. 动态绑定：动态绑定是指在运行时确定函数的调用地址的过程。\n> \n> 当使用基类指针或引用调用虚函数时，编译器会在运行时检查指向的对象是基类还是派生类，然后根据对象的实际类型来确定调用哪个函数。这个过程被称为动态绑定或后期绑定。\n> \n> **动态绑定的实现需要依赖虚表指针。**当使用基类指针或引用调用虚函数时，编译器会根据指针或引用的静态类型确定该类的虚表指针，然后根据虚表指针找到该类的虚函数表，再根据虚函数在虚函数表中的位置找到对应的函数地址。然后在运行时根据对象的实际类型调用相应的函数。\n> \n> **总的来说，cpp中多态的实现是基于虚函数表和动态绑定的。**虚函数表存储了类的虚函数地址，而动态绑定则根据对象的实际类型来确定调用哪个函数。虽然虚函数表和动态绑定会增加程序的运行时开销，但是它们是实现多态的核心机制，使得程序能够更加灵活和可扩展。\n\n当这样的一个指向派生类的基类指针析构时，如果析构函数不是虚函数，则直接调用基类的析构函数，那么派生类获取的资源未释放，则会造成内存泄漏。\n\n而当析构函数是虚函数时则先调用对应的派生类析构函数，再调用基类析构函数，资源全部释放。\n\n不过这种操作只有在基类是多态用途时才需要注意，也有很多类不是为了多态的用途，例如stl容器和上文的uncopyable。\n\n----------------------------------------\n\n\n# 条款8：别让异常逃离析构函数\n\ncpp中抛出异常时会逐步展开其函数调用栈，清空局部资源，直到异常被catch。\n\n如果析构函数可以抛出异常，那么清空局部资源时局部对象的析构函数再次异常时同时存在两个异常，cpp无法处理，可能会过早结束或出现不明确行为。因此，析构函数绝对不要抛出异常，应通过try-catch捕获任何异常。\n\n有时，客户需要处理某些异常，那么类应该提供一个普通成员函数执行相关操作，供用户调用并处理异常。\n\n例如数据库连接这样的类中，假设用户需要处理关闭连接时的异常，同时析构函数不能抛出异常，可以这样：\n\nclass dbconn{\npublic:\n  void close(){\n    db.close();\n    closed = true;\n  }\n  ~dbconn()\n  {\n    if(!closed)\n    {\n        try{\n          db.close();\n        }catch(...){\n        //记录相关信息\n        }\n    }\n  }\nprivate:\n  dbconnection db;\n  bool closed;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n----------------------------------------\n\n\n# 条款9：绝不在构造和析构过程中调用virtual函数\n\ncpp的构造过程是先构造基类再构造子类、先初始化再进入构造函数体；析构过程相反。\n\n对于派生类的构造函数而言，进入其中时基类部分已构造完而派生类部分未构造完，对象类型是基类，故而此时调用虚函数，实际上使用的是基类的虚函数。\n\n析构函数同理。进入析构函数后派生类部分呈未定义值，对象类型是基类，调用的是基类的虚函数。\n\n总而言之，在构造函数与析构函数中虚函数的行为有特殊变化；为了避免出错，不要在其过程中使用虚函数。如果确实需要在构造函数或析构函数中调用虚函数，可以使用非虚函数或纯虚函数代替虚函数，或者在构造函数或析构函数中显式调用基类中的函数。\n\n----------------------------------------\n\n\n# 条款10：令operator=返回一个reference to *this\n\n> 条款10提醒我们在实现自定义的赋值运算符(operator=)时，应该将其返回类型定义为引用(reference)类型，并返回一个指向当前对象的指针(*this)，以便实现连续赋值和链式调用的功能。这种做法被称为“返回一个reference to *this”。\n\ncpp中通常支持连锁赋值，采用右结合律：\n\nint a,b,c;\na = b = c = 15;\n// a = (b = (c = 15));\n\n\n1\n2\n3\n\n\n> 具体来说，如果我们将赋值运算符的返回类型定义为值(value)类型，那么在进行多次赋值时，每次都会创建一个新的临时对象，这会导致不必要的内存分配和拷贝，降低程序的执行效率。而如果将赋值运算符的返回类型定义为引用类型，可以避免创建临时对象，提高程序的执行效率。\n> \n> 同时，返回一个指向当前对象的指针(*this)也可以实现链式调用的功能。在链式调用中，每个函数调用的返回值都是当前对象的引用，这样就可以一直链式调用下去，从而使代码更加简洁和易读。\n\n为了支持这个常规，拷贝运算符需要返回一个引用。这一条款并不强制，但约定俗成。\n\nclass widget{\npublic:\n  widget& operator=(const widget& rhs){\n    ...\n    return *this;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 条款11：在operator=中处理“自我赋值”\n\n> 条款11提醒我们在实现自定义的赋值运算符(operator=)时，需要特别注意处理“自我赋值”(self-assignment)的情况，即将一个对象赋值给它自身。 如果没有正确处理自我赋值的情况，可能会导致对象的状态出现错误，甚至导致程序崩溃。因此，在实现赋值运算符时，必须处理自我赋值的情况，以保证程序的正确性和稳定性。\n\n处理自我赋值的方法通常有两种：\n\n 1. 引入临时对象。在处理自我赋值时，可以先创建一个临时对象，将原对象的状态拷贝到临时对象中，然后再将临时对象的状态赋值给原对象。这样可以避免在拷贝原对象的状态时被自我赋值所影响。需要注意的是，在创建临时对象时，应该使用拷贝构造函数而不是赋值运算符，以避免在处理自我赋值时再次调用赋值运算符。\n\n 2. 检查自我赋值。在处理赋值运算符时，可以先检查赋值运算符的左右两边是否是同一个对象，如果是，则直接返回该对象，不进行任何操作。这样可以避免在处理自我赋值时出现错误。 需要注意的是，处理自我赋值时，不仅要考虑到对象的成员变量，还需要考虑到对象可能维护的资源，如内存、文件句柄等。如果对象维护了资源，需要在处理自我赋值时特别注意释放和重新分配资源的顺序，以避免出现资源泄漏或访问非法内存等问题。\n    \n    因此，在实现自定义的赋值运算符时，需要特别注意处理自我赋值的情况。处理自我赋值的方法可以是引入临时对象或检查自我赋值，需要根据具体情况选择合适的方法。同时，需要注意处理对象维护的资源，以保证程序的正确性和稳定性。\n\n考虑这样一个类，其中管理了一个堆对象\n\nclass widget{\n  ...\nprivate:\n  bitmap* pb; //一个堆对象\n};\n\n\n1\n2\n3\n4\n5\n\n\n总有些时候，会出现实质上“a=a”这种自我赋值的情况。那么这样简单的拷贝运算符就会出错，先释放了自身的pb，又使用了pb：\n\nwidget& widget::operator=(const widget& rhs){\n  delete pb;\n  pb = new bitmap(*rhs.pb);\n  return *this;\n}\n\n\n1\n2\n3\n4\n5\n\n\n传统做法是函数开头添加一个测试：\n\nif(this == &rhs) return *this;\n\n\n1\n\n\n这种做法具备“自我赋值安全性”，但不具备“异常安全性”：例如当new bitmap异常时，pb指向被删除的内存。\n\n常用的方法有两种，兼顾了“自我赋值安全性”与“异常安全性”：\n\n//第一种\nwidget& widget::operator=(const widget& rhs){\n  bitmap* pb_original = pb;\n  pb = new bitmap(*rhs.pb);\n  delete pb_original;\n  return *this;\n}\n//第二种\nvoid widget::swap(widget& rhs){\n  ...\n};\nwidget& widget::operator=(const widget& rhs){\n  widget temp(rhs);\n  swap(temp);\n  return *this;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n\n# 条款12：复制对象时勿忘其每一个成分\n\n当自己实现拷贝构造/拷贝运算符时，编译器不会警告你遗漏了某些成员变量。因此，必须仔细地复制所有派生类成员，并调用基类的拷贝操作来复制基类成员。\n\nderived::derived(const derived& rhs)\n  :base(rhs),some_member(rhs.some_member){}\n\nderived& derived::operator=(const derived& rhs){\n  base::operator=(rhs);\n  some_member = rhs.some_member;\n  return *this;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n拷贝构造和拷贝运算符中很可能有相当多重复的操作，但因为两个函数性质完全不同，因此不能用其中一个调用另一个来减少冗余。\n\n可以把共同功能放在第三个函数中，并由两个拷贝操作共同调用。',charsets:{cjk:!0}},{title:"条款26-31 实现",frontmatter:{title:"条款26-31 实现",date:"2023-11-24T15:59:26.000Z",permalink:"/pages/ec62b4/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/30.Effetcive_CPP/03.%E6%9D%A1%E6%AC%BE26-31%20%E5%AE%9E%E7%8E%B0.html",relativePath:"01.CPP语言/30.Effetcive_CPP/03.条款26-31 实现.md",key:"v-2f55ed6a",path:"/pages/ec62b4/",lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.07,time:64200,words:214},headersStr:null,content:'# 实现\n\n\n# 条款26：尽可能延后变量定义式的出现时间\n\n\n# 条款27：尽量少做转型动作\n\n\n# 条款28：避免返回handles指向对象内部成分\n\n在Cpp中，handles是指一个指向对象的指针或引用，用于访问该对象的成员函数或成员变量。\n\n而条款28所说的“返回handles指向对象内部成分”，是指返回指向该对象的私有成员或受保护成员的指针或引用。\n\n这样做的问题在于，如果对该成员进行修改或者删除操作，可能会破坏该对象的不变量（invariant）或者类的封装性，导致程序出现不可预测的结果。\n\n另外，如果返回的指针或引用是指向临时对象或已经被释放的对象，则会导致指针悬挂（dangling pointer）或引用无效的问题。\n\n为了避免这种问题，建议使用对象的公有成员函数访问该对象的内部成分，而不是返回指向内部成分的指针或引用。\n\n如果必须返回指针或引用，可以考虑使用智能指针（如std::shared_ptr或std::unique_ptr）来确保对象的生命周期，或者返回const指针或引用，防止被修改。\n\n假设有一个类Person，其中有一个私有变量age表示年龄，如下所示：\n\nclass Person {\npublic:\n    void SetAge(int age) { this->age = age; }  // 设置年龄\n    int GetAge() const { return age; }  // 获取年龄\nprivate:\n    int age;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果在该类中返回对age的引用或指针，就会存在返回handles指向对象内部成分的问题。例如：\n\nconst int& GetAgeRef() const { return age; }  // 返回对age的引用\nconst int* GetAgePtr() const { return &age; }  // 返回指向age的指针\n\n\n1\n2\n\n\n在这种情况下，如果返回的引用或指针被用于修改或者删除age，将会破坏Person类的封装性，导致程序出现不可预测的结果。 为了解决这个问题，可以使用对象的公有成员函数访问该对象的内部成分，而不是返回指向内部成分的指针或引用。例如：\n\nclass Person {\npublic:\n    void SetAge(int age) { this->age = age; }  // 设置年龄\n    int GetAge() const { return age; }  // 获取年龄\n    void SetAgeViaFunction(int age) { SetAge(age); }  // 通过公有成员函数设置年龄\nprivate:\n    int age;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在这个例子中，我们新增了一个公有成员函数SetAgeViaFunction，用于通过公有成员函数SetAge来设置年龄。这样，外部代码就不能直接访问age，而是必须通过SetAgeViaFunction来访问age，从而保证了Person类的封装性。\n\n\n# 条款29：为“异常安全”而努力是值得的\n\n> “异常安全”是指程序在面对异常时，能够保持正确性、资源不泄漏、不破坏数据结构等性质。\n> \n> 在Cpp中，异常安全是非常重要的，因为Cpp支持异常机制，如果程序无法正确处理异常，可能会导致资源泄漏、内存泄漏、数据结构损坏等问题，从而影响程序的正确性和稳定性。\n\n请记住：\n\n 1. 异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。\n 2. “强烈保证”往往能够以 copy-and-swap 实现出来，但“强烈保证“并非对所有函数都可实现或具备现实意义。\n 3. 函数提供的”异常安全保证“通常最高只等于其所调用的各个函数的”异常安全保证“中的最弱者。\n\n因此，为了确保程序的异常安全性，我们需要在编写代码时，考虑并努力实现异常安全。具体来说，我们需要注意以下几点：\n\n 1. 确保不会让异常逃逸：在函数中抛出异常后，应该确保异常被正确地处理掉，而不是让它逃逸到函数外部，导致资源泄漏或数据结构损坏。为了避免异常逃逸，可以使用RAII技术，通过在对象构造函数中获取资源，在对象析构函数中释放资源，来保证资源的正确获取和释放。\n\n 2. 考虑异常安全的级别：异常安全性有三个级别，分别是基本保证、弱异常安全和强异常安全。在编写代码时，应该根据情况选择最佳的异常安全级别。\n    \n    基本保证是指：如果函数出现异常，程序状态不会受到破坏，但是可能会发生资源泄漏。\n    \n    弱异常安全是指：如果函数出现异常，程序状态和资源都不会受到破坏，但是可能会出现不一致的状态。\n    \n    强异常安全是指：如果函数出现异常，程序状态和资源都不会受到破坏，而且程序状态和资源都会回到调用函数前的状态。\n\n 3. 使用异常处理机制：在编写代码时，应该使用异常处理机制来处理异常。通过抛出异常并捕获异常，可以避免程序崩溃，并将异常抛出给调用者进行处理。在抛出异常时，应该提供一个清晰的异常信息，方便调用者进行处理。\n\n\n# 条款30：透彻了解inlining的里里外外\n\n条款30中的"inlining"是指Cpp中的内联函数，它是一种编译器的优化技术，可以将函数调用处直接替换为函数体，从而减少函数调用的开销，提高程序的性能。但是，内联函数也有一些限制和缺点，因此，在使用内联函数时，需要透彻了解其里里外外，以便能够正确地使用和优化内联函数。\n\n具体来说，理解"inlining"的里里外外需要注意以下几点：\n\n 1. 内联函数的适用范围：内联函数适用于函数体比较小、被频繁调用的函数。如果函数体比较大，内联函数可能会导致代码膨胀，从而影响程序的性能。因此，在使用内联函数时，需要根据实际情况进行选择。\n 2. 内联函数的定义：内联函数通常需要在头文件中进行定义，以便编译器能够在编译时进行函数替换。在定义内联函数时，需要注意函数体不能包含循环、递归等语句，否则会导致编译器无法进行内联。\n 3. 内联函数的声明：内联函数的声明通常也需要在头文件中进行，以便其他文件能够调用内联函数。**在声明内联函数时，需要使用inline关键字，**以便告诉编译器该函数需要进行内联。\n 4. 内联函数的优化：在使用内联函数时，需要注意优化内联函数的代码，以提高程序的性能。可以使用一些技巧，如避免多余的函数调用、避免局部变量过多、使用常量表达式等。\n 5. 内联函数的限制：内联函数也有一些限制，例如不能取地址、不能有静态变量等。在使用内联函数时，需要注意这些限制，以便正确地使用内联函数。\n\n请记住：\n\n 1. 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。\n 2. 不要只因为function templates 出现在头文件，就将它们声明为inline\n\n> ==如何理解“不要只因为function templates 出现在头文件，就将它们声明为inline”这句话？==\n\n在Cpp中，函数模板（function templates）是一种通用的函数定义方式，它可以用来定义多个具有相同功能但类型不同的函数。**由于函数模板通常需要在头文件中进行定义，因此很容易将它们声明为内联函数（inline）以提高程序的性能。**但是，在使用函数模板时，不要只因为它们出现在头文件中，就将它们声明为内联函数，而应该根据实际情况进行选择。 具体来说，不要将所有函数模板都声明为内联函数的原因有以下几点：\n\n 1. 函数模板的大小不确定：由于函数模板可以用于定义多个函数，因此其大小在编译时是不确定的。如果将所有函数模板都声明为内联函数，可能会导致代码膨胀，从而影响程序的性能。\n 2. 内联函数的适用范围有限：内联函数适用于函数体比较小、被频繁调用的函数。对于函数模板来说，其具体调用情况是不确定的，因此并不是所有函数模板都适合声明为内联函数。\n 3. 其他优化方式：除了将函数模板声明为内联函数之外，还有其他一些优化方式，如使用编译器的优化选项、避免多余的函数调用等。在使用函数模板时，应该根据实际情况选择最合适的优化方式。\n\n因此，不要只因为函数模板出现在头文件中，就将它们声明为内联函数。应该根据实际情况进行选择，综合考虑函数模板的大小、调用情况、优化方式等因素，以便选取最合适的优化方案。\n\n> ==如何理解“将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。”这句话？==\n\n这句话指出了在使用内联函数时应该将大多数内联函数限制在小型、被频繁调用的函数中，以便最大化程序的速度提升机会，并最小化潜在的代码膨胀问题，同时也方便了日后的调试过程和二进制升级。 具体来说，这句话的含义可以从以下几个方面进行解释：\n\n 1. 内联函数的适用范围：内联函数适用于函数体比较小、被频繁调用的函数。将大多数内联函数限制在这样的函数中，可以最大化程序的速度提升机会，因为内联函数可以减少函数调用的开销。\n 2. 调试和升级的问题：将内联函数限制在小型、被频繁调用的函数中，可以使调试过程更加容易，因为这些函数的代码比较简单，容易定位和排查问题。同时，也方便了二进制升级，因为这些函数的代码不会对其他部分的代码产生过多的影响。\n 3. 代码膨胀问题：内联函数会将函数体直接嵌入到调用处，从而增加代码的长度。如果将所有函数都声明为内联函数，可能会导致代码膨胀，从而影响程序的性能。将大多数内联函数限制在小型、被频繁调用的函数中，可以最小化潜在的代码膨胀问题，并提高程序的性能。\n\n综上所述，将大多数内联函数限制在小型、被频繁调用的函数中，可以最大化程序的速度提升机会，最小化潜在的代码膨胀问题，并方便了日后的调试过程和二进制升级。\n\n\n# 条款31：将文件间的编译依存关系降至最低\n\n条款31指出了在软件开发中，应该尽可能地将文件间的编译依存关系降至最低，以便实现更好的模块化和可重用性。具体来说，可以从以下几个方面来理解这个条款：\n\n 1. 编译依存关系：文件间的编译依存关系指的是一个源文件（或头文件）在编译时所依赖的其他源文件（或头文件）。如果一个源文件依赖于另外的源文件，那么在编译时就需要将这些源文件一起编译，从而增加了编译时间和编译的复杂性。\n\n 2. 最小化编译依存关系的好处：将文件间的编译依存关系降至最低，可以实现更好的模块化和可重用性。\n    \n    模块化指的是将软件系统分解为多个独立的模块，每个模块都具有清晰的接口和功能；\n    \n    可重用性指的是可以将一个模块在不同的系统中重复使用。\n    \n    最小化编译依存关系可以使得每个模块都具有清晰的接口和功能，从而提高了模块化和可重用性。\n\n 3. 实现最小化编译依存关系的方法：实现最小化编译依存关系的方法有很多，比如使用前置声明（forward declaration）、将接口和实现分离、使用接口类（interface class）等。\n    \n    前置声明可以减少头文件之间的相互依赖；将接口和实现分离可以使得模块之间的依赖更加清晰；\n    \n    使用接口类可以将模块之间的依赖限制在接口上，从而提高了模块化和可重用性。\n\n以下是对该条款的理解和一些实践建议：\n\n 1. 减少头文件的依赖：尽量减少头文件之间的相互包含，只包含必要的头文件。这样可以降低编译依存关系，避免引入不必要的依赖关系。\n\n 2. 使用前向声明（Forward Declaration）：如果在头文件中只需要使用某个类的指针或引用而不需要知道其具体实现细节，可以使用前向声明来代替包含整个头文件。这样可以减少头文件的依赖关系。\n\n 3. 使用接口类（Interface Class）：将公共接口定义在一个独立的接口类中，然后在其他文件中使用该接口类而不是具体的实现类。这样可以降低对具体实现类的依赖，提高代码的可扩展性和可替换性。\n\n 4. 使用编译器前置声明（Compiler Firewall）：在某个实现文件中使用前向声明和指针/引用，然后在该文件的头文件中包含所需的具体实现。这样可以将依赖关系局限在该实现文件内部，减少对其他文件的影响。\n\n 5. 使用纯虚函数（Pure Virtual Functions）：如果某个类在其他文件中只需要通过指针或引用进行操作，可以将该类设计为纯虚函数的基类，然后使用基类的指针或引用来操作具体的子类。这样可以降低对具体子类的依赖，提高代码的灵活性和可扩展性。\n\n总的来说，条款31的目标是通过降低文件间的编译依存关系，减少代码间的耦合性，从而提高代码的可维护性和可扩展性。通过合理的头文件设计、前向声明、接口类和编译器前置声明等技术手段，可以将依赖关系限制在合适的范围内，使代码更加模块化、可重用和易于维护。',normalizedContent:'# 实现\n\n\n# 条款26：尽可能延后变量定义式的出现时间\n\n\n# 条款27：尽量少做转型动作\n\n\n# 条款28：避免返回handles指向对象内部成分\n\n在cpp中，handles是指一个指向对象的指针或引用，用于访问该对象的成员函数或成员变量。\n\n而条款28所说的“返回handles指向对象内部成分”，是指返回指向该对象的私有成员或受保护成员的指针或引用。\n\n这样做的问题在于，如果对该成员进行修改或者删除操作，可能会破坏该对象的不变量（invariant）或者类的封装性，导致程序出现不可预测的结果。\n\n另外，如果返回的指针或引用是指向临时对象或已经被释放的对象，则会导致指针悬挂（dangling pointer）或引用无效的问题。\n\n为了避免这种问题，建议使用对象的公有成员函数访问该对象的内部成分，而不是返回指向内部成分的指针或引用。\n\n如果必须返回指针或引用，可以考虑使用智能指针（如std::shared_ptr或std::unique_ptr）来确保对象的生命周期，或者返回const指针或引用，防止被修改。\n\n假设有一个类person，其中有一个私有变量age表示年龄，如下所示：\n\nclass person {\npublic:\n    void setage(int age) { this->age = age; }  // 设置年龄\n    int getage() const { return age; }  // 获取年龄\nprivate:\n    int age;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果在该类中返回对age的引用或指针，就会存在返回handles指向对象内部成分的问题。例如：\n\nconst int& getageref() const { return age; }  // 返回对age的引用\nconst int* getageptr() const { return &age; }  // 返回指向age的指针\n\n\n1\n2\n\n\n在这种情况下，如果返回的引用或指针被用于修改或者删除age，将会破坏person类的封装性，导致程序出现不可预测的结果。 为了解决这个问题，可以使用对象的公有成员函数访问该对象的内部成分，而不是返回指向内部成分的指针或引用。例如：\n\nclass person {\npublic:\n    void setage(int age) { this->age = age; }  // 设置年龄\n    int getage() const { return age; }  // 获取年龄\n    void setageviafunction(int age) { setage(age); }  // 通过公有成员函数设置年龄\nprivate:\n    int age;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在这个例子中，我们新增了一个公有成员函数setageviafunction，用于通过公有成员函数setage来设置年龄。这样，外部代码就不能直接访问age，而是必须通过setageviafunction来访问age，从而保证了person类的封装性。\n\n\n# 条款29：为“异常安全”而努力是值得的\n\n> “异常安全”是指程序在面对异常时，能够保持正确性、资源不泄漏、不破坏数据结构等性质。\n> \n> 在cpp中，异常安全是非常重要的，因为cpp支持异常机制，如果程序无法正确处理异常，可能会导致资源泄漏、内存泄漏、数据结构损坏等问题，从而影响程序的正确性和稳定性。\n\n请记住：\n\n 1. 异常安全函数（exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。\n 2. “强烈保证”往往能够以 copy-and-swap 实现出来，但“强烈保证“并非对所有函数都可实现或具备现实意义。\n 3. 函数提供的”异常安全保证“通常最高只等于其所调用的各个函数的”异常安全保证“中的最弱者。\n\n因此，为了确保程序的异常安全性，我们需要在编写代码时，考虑并努力实现异常安全。具体来说，我们需要注意以下几点：\n\n 1. 确保不会让异常逃逸：在函数中抛出异常后，应该确保异常被正确地处理掉，而不是让它逃逸到函数外部，导致资源泄漏或数据结构损坏。为了避免异常逃逸，可以使用raii技术，通过在对象构造函数中获取资源，在对象析构函数中释放资源，来保证资源的正确获取和释放。\n\n 2. 考虑异常安全的级别：异常安全性有三个级别，分别是基本保证、弱异常安全和强异常安全。在编写代码时，应该根据情况选择最佳的异常安全级别。\n    \n    基本保证是指：如果函数出现异常，程序状态不会受到破坏，但是可能会发生资源泄漏。\n    \n    弱异常安全是指：如果函数出现异常，程序状态和资源都不会受到破坏，但是可能会出现不一致的状态。\n    \n    强异常安全是指：如果函数出现异常，程序状态和资源都不会受到破坏，而且程序状态和资源都会回到调用函数前的状态。\n\n 3. 使用异常处理机制：在编写代码时，应该使用异常处理机制来处理异常。通过抛出异常并捕获异常，可以避免程序崩溃，并将异常抛出给调用者进行处理。在抛出异常时，应该提供一个清晰的异常信息，方便调用者进行处理。\n\n\n# 条款30：透彻了解inlining的里里外外\n\n条款30中的"inlining"是指cpp中的内联函数，它是一种编译器的优化技术，可以将函数调用处直接替换为函数体，从而减少函数调用的开销，提高程序的性能。但是，内联函数也有一些限制和缺点，因此，在使用内联函数时，需要透彻了解其里里外外，以便能够正确地使用和优化内联函数。\n\n具体来说，理解"inlining"的里里外外需要注意以下几点：\n\n 1. 内联函数的适用范围：内联函数适用于函数体比较小、被频繁调用的函数。如果函数体比较大，内联函数可能会导致代码膨胀，从而影响程序的性能。因此，在使用内联函数时，需要根据实际情况进行选择。\n 2. 内联函数的定义：内联函数通常需要在头文件中进行定义，以便编译器能够在编译时进行函数替换。在定义内联函数时，需要注意函数体不能包含循环、递归等语句，否则会导致编译器无法进行内联。\n 3. 内联函数的声明：内联函数的声明通常也需要在头文件中进行，以便其他文件能够调用内联函数。**在声明内联函数时，需要使用inline关键字，**以便告诉编译器该函数需要进行内联。\n 4. 内联函数的优化：在使用内联函数时，需要注意优化内联函数的代码，以提高程序的性能。可以使用一些技巧，如避免多余的函数调用、避免局部变量过多、使用常量表达式等。\n 5. 内联函数的限制：内联函数也有一些限制，例如不能取地址、不能有静态变量等。在使用内联函数时，需要注意这些限制，以便正确地使用内联函数。\n\n请记住：\n\n 1. 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。\n 2. 不要只因为function templates 出现在头文件，就将它们声明为inline\n\n> ==如何理解“不要只因为function templates 出现在头文件，就将它们声明为inline”这句话？==\n\n在cpp中，函数模板（function templates）是一种通用的函数定义方式，它可以用来定义多个具有相同功能但类型不同的函数。**由于函数模板通常需要在头文件中进行定义，因此很容易将它们声明为内联函数（inline）以提高程序的性能。**但是，在使用函数模板时，不要只因为它们出现在头文件中，就将它们声明为内联函数，而应该根据实际情况进行选择。 具体来说，不要将所有函数模板都声明为内联函数的原因有以下几点：\n\n 1. 函数模板的大小不确定：由于函数模板可以用于定义多个函数，因此其大小在编译时是不确定的。如果将所有函数模板都声明为内联函数，可能会导致代码膨胀，从而影响程序的性能。\n 2. 内联函数的适用范围有限：内联函数适用于函数体比较小、被频繁调用的函数。对于函数模板来说，其具体调用情况是不确定的，因此并不是所有函数模板都适合声明为内联函数。\n 3. 其他优化方式：除了将函数模板声明为内联函数之外，还有其他一些优化方式，如使用编译器的优化选项、避免多余的函数调用等。在使用函数模板时，应该根据实际情况选择最合适的优化方式。\n\n因此，不要只因为函数模板出现在头文件中，就将它们声明为内联函数。应该根据实际情况进行选择，综合考虑函数模板的大小、调用情况、优化方式等因素，以便选取最合适的优化方案。\n\n> ==如何理解“将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。”这句话？==\n\n这句话指出了在使用内联函数时应该将大多数内联函数限制在小型、被频繁调用的函数中，以便最大化程序的速度提升机会，并最小化潜在的代码膨胀问题，同时也方便了日后的调试过程和二进制升级。 具体来说，这句话的含义可以从以下几个方面进行解释：\n\n 1. 内联函数的适用范围：内联函数适用于函数体比较小、被频繁调用的函数。将大多数内联函数限制在这样的函数中，可以最大化程序的速度提升机会，因为内联函数可以减少函数调用的开销。\n 2. 调试和升级的问题：将内联函数限制在小型、被频繁调用的函数中，可以使调试过程更加容易，因为这些函数的代码比较简单，容易定位和排查问题。同时，也方便了二进制升级，因为这些函数的代码不会对其他部分的代码产生过多的影响。\n 3. 代码膨胀问题：内联函数会将函数体直接嵌入到调用处，从而增加代码的长度。如果将所有函数都声明为内联函数，可能会导致代码膨胀，从而影响程序的性能。将大多数内联函数限制在小型、被频繁调用的函数中，可以最小化潜在的代码膨胀问题，并提高程序的性能。\n\n综上所述，将大多数内联函数限制在小型、被频繁调用的函数中，可以最大化程序的速度提升机会，最小化潜在的代码膨胀问题，并方便了日后的调试过程和二进制升级。\n\n\n# 条款31：将文件间的编译依存关系降至最低\n\n条款31指出了在软件开发中，应该尽可能地将文件间的编译依存关系降至最低，以便实现更好的模块化和可重用性。具体来说，可以从以下几个方面来理解这个条款：\n\n 1. 编译依存关系：文件间的编译依存关系指的是一个源文件（或头文件）在编译时所依赖的其他源文件（或头文件）。如果一个源文件依赖于另外的源文件，那么在编译时就需要将这些源文件一起编译，从而增加了编译时间和编译的复杂性。\n\n 2. 最小化编译依存关系的好处：将文件间的编译依存关系降至最低，可以实现更好的模块化和可重用性。\n    \n    模块化指的是将软件系统分解为多个独立的模块，每个模块都具有清晰的接口和功能；\n    \n    可重用性指的是可以将一个模块在不同的系统中重复使用。\n    \n    最小化编译依存关系可以使得每个模块都具有清晰的接口和功能，从而提高了模块化和可重用性。\n\n 3. 实现最小化编译依存关系的方法：实现最小化编译依存关系的方法有很多，比如使用前置声明（forward declaration）、将接口和实现分离、使用接口类（interface class）等。\n    \n    前置声明可以减少头文件之间的相互依赖；将接口和实现分离可以使得模块之间的依赖更加清晰；\n    \n    使用接口类可以将模块之间的依赖限制在接口上，从而提高了模块化和可重用性。\n\n以下是对该条款的理解和一些实践建议：\n\n 1. 减少头文件的依赖：尽量减少头文件之间的相互包含，只包含必要的头文件。这样可以降低编译依存关系，避免引入不必要的依赖关系。\n\n 2. 使用前向声明（forward declaration）：如果在头文件中只需要使用某个类的指针或引用而不需要知道其具体实现细节，可以使用前向声明来代替包含整个头文件。这样可以减少头文件的依赖关系。\n\n 3. 使用接口类（interface class）：将公共接口定义在一个独立的接口类中，然后在其他文件中使用该接口类而不是具体的实现类。这样可以降低对具体实现类的依赖，提高代码的可扩展性和可替换性。\n\n 4. 使用编译器前置声明（compiler firewall）：在某个实现文件中使用前向声明和指针/引用，然后在该文件的头文件中包含所需的具体实现。这样可以将依赖关系局限在该实现文件内部，减少对其他文件的影响。\n\n 5. 使用纯虚函数（pure virtual functions）：如果某个类在其他文件中只需要通过指针或引用进行操作，可以将该类设计为纯虚函数的基类，然后使用基类的指针或引用来操作具体的子类。这样可以降低对具体子类的依赖，提高代码的灵活性和可扩展性。\n\n总的来说，条款31的目标是通过降低文件间的编译依存关系，减少代码间的耦合性，从而提高代码的可维护性和可扩展性。通过合理的头文件设计、前向声明、接口类和编译器前置声明等技术手段，可以将依赖关系限制在合适的范围内，使代码更加模块化、可重用和易于维护。',charsets:{cjk:!0}},{title:"条款32-40 继承与面向对象设计",frontmatter:{title:"条款32-40 继承与面向对象设计",date:"2023-11-24T15:59:26.000Z",permalink:"/pages/b4a7fb/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/30.Effetcive_CPP/04.%E6%9D%A1%E6%AC%BE32-40%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1.html",relativePath:"01.CPP语言/30.Effetcive_CPP/04.条款32-40 继承与面向对象设计.md",key:"v-0ae8e482",path:"/pages/b4a7fb/",lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"4 min read",minutes:3.08,time:184800,words:616},headersStr:null,content:'# 继承与面向对象设计\n\n\n# 条款32：确定你的pubilc继承塑模出is-a关系\n\n条款32强调使用公共继承（public inheritance）时，需要确保所使用的继承能够正确地塑模出"is-a"关系。这意味着子类对象应该能够被视为基类对象的一种特殊类型。\n\n下面是对该条款的理解和一些建议：\n\n 1. 理解"is-a"关系：在公共继承中，子类继承了基类的接口和行为，并且可以通过基类指针或引用进行操作。这意味着子类对象应该能够被视为基类对象的一种特殊类型，即子类对象应该可以替代基类对象使用，并且在行为和使用方式上与基类对象相似。\n\n 2. 遵循Liskov替换原则：Liskov替换原则指出，子类对象应该能够替换基类对象并且不会破坏程序的正确性。也就是说，在使用基类对象的地方，如果用子类对象替换后程序仍然正确运行，则说明公共继承的"is-a"关系得到了正确地塑模。\n\n 3. 注意虚函数的重写：在公共继承中，子类可以重写基类的虚函数以改变其行为。但是，需要确保重写的虚函数在行为上与基类的虚函数是一致的，并且满足Liskov替换原则。这样，在使用基类指针或引用操作子类对象时，能够获得预期的行为。\n\n 4. 避免破坏类的不变式：在子类中进行继承时，需要避免破坏基类所定义的类不变式（class invariants）。类不变式是描述类对象状态约束的规则，继承关系应该遵循这些规则，以确保对象的一致性和正确性。\n\n 5. 慎重使用非虚继承：非虚继承（non-virtual inheritance）==用于处理多继承时的菱形继承问题，但它不适用于"is-a"关系的建立。==非虚继承更适用于表示某种组合关系（has-a）而不是"is-a"关系，因此在公共继承中应慎重使用非虚继承。\n\n总结来说，条款32的目标是确保使用公共继承能够正确地塑模出"is-a"关系，即子类对象能够替代基类对象并且在行为和使用方式上与基类对象相似。遵循Liskov替换原则、注意虚函数的重写、避免破坏类的不变式等原则，可以帮助我们正确使用公共继承并避免问题。\n\n==请记住：==\n\n==“public 继承”意味 is-a 。适用于base classes 身上的每一件事情一定也适用于derived classes 身上，因为每一个derived class 对象也都是一个base class 对象。==\n\n\n# 条款33：避免遮掩继承而来的名称\n\n条款33强调避免在派生类中遮掩（hide）继承而来的名称。当派生类中定义了与基类相同名称的成员函数或成员变量时，这些新定义的成员会遮掩基类中相同名称的成员，使其在派生类中不可见。\n\n以下是对该条款的理解和一些建议：\n\n 1. 名称遮掩的问题：当派生类中定义了与基类相同名称的成员时，派生类的成员会隐藏（hide）基类的成员。这可能导致代码中的名称冲突和不一致，使得基类的成员在派生类中不可见。\n\n 2. 使用作用域解析运算符：如果在派生类中需要访问基类中被遮掩的成员，可以使用作用域解析运算符（::）来显式指定所属的作用域。例如，可以使用Base::foo()来调用基类中的foo()函数。\n\n 3. 重载与隐藏的区别：派生类中的函数重载（overload）是指在派生类中定义了与基类同名但参数列表不同的成员函数。**重载不会导致基类的同名函数被遮掩，而是构成了函数重载集。**只有当函数名和参数列表完全相同时，才会发生名称遮掩。\n\n 4. 使用using声明：如果希望在派生类中保留基类中的同名成员的可见性，可以使用using声明来引入基类的名称。使用using Base::foo;可以使基类中的foo在派生类中可见，并且可以直接调用。\n\n 5. 使用转交函数(function forwarding)：\n    \n    在派生类中定义一个与基类同名的函数，这个函数将被外部调用。\n    \n    在派生类的同名函数中，调用基类的同名函数，可以使用作用域解析运算符（::）来显式指定基类的作用域。\n    \n    以下是一个示例代码：\n    \n    class Base {\n    public:\n        void foo() {\n            // 基类的函数实现\n        }\n    };\n    \n    class Derived : public Base {\n    public:\n        void foo() {\n            Base::foo();  // 转交函数，调用基类的同名函数\n            // 派生类的其他操作\n        }\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    在上述示例中，派生类Derived中的foo函数转交了基类Base中的foo函数的调用，即在派生类的foo函数中先调用基类的foo函数，然后再执行派生类的其他操作。\n\n总结来说，条款33的目标是避免在派生类中遮掩继承而来的名称，以避免名称冲突和不一致性。通过使用作用域解析运算符、重载和using声明、转交函数等技术手段，可以解决名称遮掩的问题，确保基类的成员在派生类中仍然可见并且可用。这样可以提高代码的可读性和可维护性。\n\n==请记住：==\n\n==derived classes 内的名称会遮掩base classes 内的名称。在public 继承下从来没有人希望如此。==\n\n==为了让被遮掩的名称再见天日，可使用using 声明式或转交函数（forwarding functions）。==\n\n\n# 条款34：区分接口继承和和实现继承\n\n这个条款的核心思想是，继承应该被用于两种不同的目的：接口继承和实现继承。这两种继承方式有着不同的目标和应用场景。\n\n 1. 接口继承（Interface Inheritance）：\n    \n    * 接口继承指的是从基类中继承纯虚函数，即只有函数签名而没有实际实现的函数。\n    * 接口继承的目的是创建一个抽象的基类，用于定义一组规范或接口，而不关注具体的实现细节。\n    * 派生类必须实现基类中的纯虚函数，以便成为一个具体的类。\n    * 通过接口继承，可以实现多态，允许将派生类对象赋值给基类指针或引用，并在运行时调用正确的实现。\n\n 2. 实现继承（Implementation Inheritance）：\n    \n    * 实现继承指的是从基类继承具有实际实现的函数。\n    * 实现继承的目的是通过基类的共同实现来重用代码。\n    * 实现继承可以将基类的功能直接继承到派生类中，但它会将基类和派生类紧密地耦合在一起，可能导致较高的继承层次结构复杂性。\n    * 使用实现继承时，派生类在某种程度上是基类的"特例"，它拥有基类的所有功能，并可能添加自己的特定实现。\n\n==请记住：==\n\n * ==接口继承和实现继承不同。在public 继承之下，derived classes 总是继承base classes 的接口。==\n * ==声明一个pure virtual 函数的目的是为了让derived classes 只继承函数接口。==\n * ==声明简朴的（非纯）impure virtual 函数的目的，是让derived classes 继承该函数的接口和缺省实现。==\n * ==声明non-virtual 函数的目的是为了令derived classes 继承函数的接口及一份强制性实现，non-virtual 函数代表的意义是不变性凌驾特异性，所以它绝不该在derived class 中被重新定义。==\n\n\n# 条款35：考虑virtual 函数以外的其他选择\n\n这个条款的目的是引导开发者在使用虚函数之前，先考虑一些替代方案。\n\n虚函数允许在基类中声明函数，并允许派生类重写该函数以实现特定行为。然而，使用虚函数可能会引入一些开销，如虚表指针（vptr）和虚表（vtable），以及运行时的动态绑定。在某些情况下，这些开销可能是不必要的或不适用的。\n\n在条款35中，Meyers提供了一些替代虚函数的选择：\n\n 1. 将函数声明为非虚函数：\n    \n    * 如果确定某个函数在派生类中不需要被重写，可以将其声明为非虚函数。\n    * 这样做可以避免虚函数带来的运行时开销，并且使编译器能够进行更多的优化。\n\n 2. 使用非虚函数接口（non-virtual interface，NVI）手法来实现模板方法模式（Template Method Pattern）：\n    \n    > 这一基本设计，也就是“令客户通过public non-virtual 成员函数间接调用 private virtual 函数”，称为 non-virtual interface (NVI)手法。它是所谓Template Method 设计模式（与Cpp templates 并无关联）的一个独特变现形式。侯捷把这个non-virtual 函数称为virtual 函数的外覆器（wrapper）。\n    \n    * 这种方法利用了Cpp的多态性和访问控制机制，允许派生类在模板方法中实现自己的行为。\n    \n    * 模板方法模式是一种设计模式，其中基类定义了一个模板方法（template method），该方法定义了算法的骨架，但允许派生类实现其中的一些步骤。\n    \n    * 模板方法模式通过将可变的部分交给派生类来实现，从而提供了一种替代虚函数的方法。\n    \n    * 下面是通过非虚函数接口手法实现模板方法模式的步骤：\n      \n      1. 定义基类（抽象类）：首先，定义一个基类，它包含一个公共的非虚函数接口方法，用于定义模板方法的结构。该方法通常称为模板方法。\n      \n      class Base {\n      public:\n          void templateMethod(/* 参数列表 */) {\n              // 通用的处理代码...\n      \n              // 调用派生类实现的虚函数\n              doSomething(/* 参数列表 */);\n      \n              // 通用的处理代码...\n          }\n      \n      private:\n          virtual void doSomething(/* 参数列表 */) = 0; // 纯虚函数，由派生类实现\n      };\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      \n      2. 派生类实现：派生类继承自基类，并实现基类中的纯虚函数，提供自己的行为。\n      \n      class Derived : public Base {\n      private:\n          void doSomething(/* 参数列表 */) override {\n              // 派生类的特定实现...\n          }\n      };\n      \n      // 可以定义更多的派生类，每个派生类提供自己的行为...\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n      3. 使用模板方法：创建基类或派生类的实例，并调用模板方法。\n      \n      Base* obj = new Derived(); // 使用基类指针指向派生类对象\n      \n      obj->templateMethod(/* 参数列表 */); // 调用模板方法\n      \n      \n      1\n      2\n      3\n      \n      \n      通过使用非虚函数接口（NVI）手法，基类中的模板方法可以定义算法的结构，同时调用派生类实现的非虚函数。这样，派生类可以在模板方法中实现自己的行为，从而实现了模板方法模式。非虚函数接口手法通过将派生类的实现封装在非虚函数中，将多态性限制在基类的内部，并提供更好的控制和灵活性。\n      \n      需要注意的是，NVI手法并不是Cpp中的特定功能或语言特性，而是一种设计模式实践。它利用了Cpp中的多态性和访问控制机制，将模板方法模式应用于具体的类设计中。\n\n 3. 使用函数对象（Function Objects）：\n    \n    * 函数对象是可调用对象，可以像函数一样使用。它们可以通过重载operator()来实现多态行为。\n    * 使用函数对象可以避免虚函数的开销，并提供更大的灵活性和可扩展性。\n\n 4. 藉由Function Pointers 实现策略模式（Strategy Pattern）：\n    \n    * 策略模式是一种设计模式，其中算法被封装在不同的策略类中，并通过基类指针或引用在运行时选择合适的策略。\n    \n    * 使用策略模式可以避免虚函数的开销，并提供更大的灵活性和可维护性。\n    \n    * 下面是通过函数指针实现策略模式的步骤：\n      \n      1. 定义函数指针类型：首先，定义一个函数指针类型，它与策略函数的签名相匹配。\n      \n      using StrategyFunctionPtr = void (*)(/* 参数列表 */);\n      \n      \n      1\n      \n      2. 定义策略函数：然后，实现具体的策略函数，这些函数与策略函数指针的签名匹配。\n      \n      void ConcreteStrategy1(/* 参数列表 */) {\n          // 具体策略1的实现...\n      }\n      \n      void ConcreteStrategy2(/* 参数列表 */) {\n          // 具体策略2的实现...\n      }\n      \n      // 定义更多的具体策略函数...\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      \n      3. 使用函数指针存储策略：声明一个函数指针变量，并根据需要，将不同的策略函数的地址赋值给它。\n      \n      StrategyFunctionPtr strategy; // 声明函数指针变量\n      \n      // 选择具体策略1\n      strategy = &ConcreteStrategy1;\n      \n      // 选择具体策略2\n      strategy = &ConcreteStrategy2;\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n      4. 执行策略：通过调用函数指针，执行选定的策略函数。\n      \n      strategy(/* 参数列表 */); // 执行选定的策略函数（具体策略1或具体策略2）\n      \n      \n      1\n      \n      \n      使用函数指针可以实现策略模式的动态选择和执行。通过将不同的策略函数的地址赋值给函数指针，可以在运行时根据需要选择适当的策略。这种方法提供了一种简单而有效的策略模式实现方式，但需要注意函数指针的签名匹配。\n      \n      需要注意的是，使用函数指针实现策略模式可能存在一些限制，例如无法存储具有不同签名的策略函数，以及难以处理需要状态或上下文的策略。在这种情况下，使用函数对象（如前面提到的std::function）可能更加灵活和方便。\n\n 5. 藉由tr1::function完成Strategy模式\n    \n    提及的tr1::function是指Cpp Technical Report 1（TR1）中引入的函数对象类型。在当前的Cpp标准（Cpp11及以后），std::function是相应的功能。\n    \n    理解通过std::function（或tr1::function）来完成策略模式，可以采用以下步骤：\n    \n    1. 定义策略接口：首先，定义一个策略接口（或基类），其中包含定义所有策略对象都必须实现的纯虚函数。\n    \n    class StrategyInterface {\n    public:\n        virtual void execute() = 0;\n        // 其他纯虚函数或接口方法...\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    2. 实现具体策略：接下来，为每个具体的策略实现一个类，这些类派生自策略接口，并提供自己的实现。\n    \n    class ConcreteStrategy1 : public StrategyInterface {\n    public:\n        void execute() override {\n            // 具体策略1的实现...\n        }\n    };\n    \n    class ConcreteStrategy2 : public StrategyInterface {\n    public:\n        void execute() override {\n            // 具体策略2的实现...\n        }\n    };\n    \n    // 可以定义更多的具体策略类...\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    3. 使用std::function存储策略：使用std::function来存储不同策略对象的可调用实例。这样可以实现运行时的策略选择。\n    \n    #include <functional>\n    \n    std::function<void()> strategy; // 使用std::function存储策略对象\n    \n    // 选择具体策略1\n    strategy = []() {\n        ConcreteStrategy1 strategy1;\n        strategy1.execute();\n    };\n    \n    // 选择具体策略2\n    strategy = []() {\n        ConcreteStrategy2 strategy2;\n        strategy2.execute();\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    4. 执行策略：通过调用std::function中存储的策略对象，执行相应的策略。\n    \n    strategy(); // 执行选定的策略（具体策略1或具体策略2）\n    \n    \n    1\n    \n    \n    使用std::function（或tr1::function）可以方便地存储不同策略对象，并在运行时选择和执行特定的策略。通过使用函数对象类型，可以实现策略模式的灵活性和可扩展性，而无需修改现有的策略接口和具体策略类。\n    \n    请注意，自Cpp11起，使用std::function更为常见和推荐，而非tr1::function。\n\n==请记住：==\n\n * ==virtual 函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method 设计模式。==\n\n * ==将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。==\n\n * ==tr1::function 对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。==\n\n\n# 条款36：绝不重新定义继承而来的non-virtual函数\n\n这个原则强调了在继承关系中对于非虚函数的使用和重写的限制。\n\n理解条款36的关键点如下：\n\n 1. 非虚函数与虚函数的区别：非虚函数是在基类中定义的普通成员函数，而虚函数是在基类中定义且使用virtual关键字声明的函数。虚函数支持运行时的动态绑定，而非虚函数则使用静态绑定。\n\n 2. 非虚函数的继承行为：当派生类继承一个非虚函数时，基类中的非虚函数会在派生类中保持相同的行为，不会被派生类重新定义或覆盖。\n\n 3. 危险的重新定义：重新定义（override）一个继承而来的非虚函数是危险的行为。这是因为在继承链中，通过基类指针或引用调用非虚函数时，实际调用的是静态类型（基类）的函数，而不是动态类型（派生类）的函数。这可能导致意外的行为和不一致的结果。\n\n 4. 虚函数的重写：与非虚函数不同，派生类可以通过在派生类中重新定义（override）虚函数来改变其行为。这样，当通过基类指针或引用调用虚函数时，会根据实际的动态类型调用正确的函数。\n\n总而言之，条款36建议避免重新定义继承而来的非虚函数，以防止意外的行为和不一致性。如果需要改变继承而来的函数的行为，应该将该函数声明为虚函数，并在派生类中进行重写。这样可以确保正确的多态行为，并遵循Liskov替换原则（Liskov Substitution Principle）的规定。\n\n==请记住：==\n\n * ==绝对不要重新定义继承而来的non-virtual函数。==\n\n> Liskov替换原则是什么？\n> \n> Liskov替换原则（Liskov Substitution Principle）是面向对象设计的一个重要原则，由计算机科学家Barbara Liskov提出。该原则指导着正确和合理地使用继承和多态性，以确保软件系统的可靠性和可扩展性。\n> \n> Liskov替换原则可以简要描述为：\n> \n> "如果S是T的子类型，那么在不破坏程序的正确性的前提下，任何程序中的T类型的对象都可以被替换为S类型的对象。"\n> \n> 换句话说，子类型（派生类）应该能够替换其基类型（基类）在任何程序中的使用，而不会引入错误或破坏程序的行为。这个原则的目标是保持代码的一致性、可维护性和可扩展性。\n> \n> 遵循Liskov替换原则的关键要点如下：\n> \n>  1. 子类型的行为：子类型（派生类）应该完全符合其基类型（基类）的约定、协议和合约。即，子类型应该实现基类型的所有接口，并保持相同的行为和预期结果。\n> \n>  2. 不破坏基类型的不变量：子类型的操作和行为不应破坏基类型的不变量、约束和规范。即，子类型不应该放宽基类型的前置条件、加强后置条件或改变基类型的约束。\n> \n>  3. 不破坏客户端代码：子类型的使用不应该强制客户端代码进行特定的类型检查或假设。即，客户端代码应该能够以基类型的方式使用子类型对象，而不需要做任何额外的处理。\n> \n> 遵循Liskov替换原则有助于构建稳健和可靠的软件系统。它鼓励设计合理的继承关系，正确使用多态性，并确保代码的一致性和可扩展性。同时，它也提供了一种指导原则，帮助开发者评估和调整继承关系中的设计选择和决策。\n\n\n# 条款37：绝不重新定义继承而来的缺省参数值\n\n这个原则强调了在继承关系中对于缺省参数的使用和重新定义的限制。\n\n理解条款37的关键点如下：\n\n 1. 缺省参数值的作用：在函数声明中，可以为参数提供缺省参数值，这样在调用函数时，如果没有提供相应参数的值，将使用缺省参数值作为参数的值。这使得函数调用更加灵活和简洁。\n\n 2. 缺省参数值的定义位置：缺省参数值是在函数的声明或定义中指定的，并不是在函数的调用处指定的。因此，在函数声明或定义中指定的缺省参数值在整个继承层次结构中保持不变。\n\n 3. 重新定义缺省参数值的危险性：当派生类重新定义（override）一个继承而来的带有缺省参数值的函数时，如果重新定义的函数中提供了不同的缺省参数值，会导致继承链中的函数调用出现二义性和不一致的结果。\n\n 4. 缺省参数值的使用原则：为了避免重新定义缺省参数值带来的问题，应该在继承关系中避免重新定义带有缺省参数值的函数。如果需要不同的缺省参数值，可以通过重载（overloading）或使用函数重写（function overriding）来实现。\n\n总而言之，条款37建议避免重新定义继承而来的带有缺省参数值的函数，以防止二义性和不一致性的问题。如果需要不同的缺省参数值或参数列表，应该使用重载或函数重写的方式来实现。这样可以确保函数调用的一致性和可预测性，并遵循正确的函数重载和继承的原则。\n\n==请记住：==\n\n * ==绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。==\n\n\n# 条款38：通过复合塑模出has-a或“根据某物实现出”\n\n这个条款强调了使用复合而不是继承来构建对象之间的关系的重要性。\n\n理解条款38的关键点如下：\n\n 1. 继承与复合的区别：继承是一种对象之间的关系，其中派生类继承了基类的特性和行为。而复合是一种对象之间的关系，其中一个对象包含另一个对象作为其一部分。\n\n 2. has-a关系：has-a关系表示一个对象具有另一个对象作为其一部分的关系。例如，一个汽车has-a引擎，一个公司has-a员工。这种关系通常可以通过复合来实现。\n\n 3. “根据某物实现出”关系：有时，一个类可以通过复合另一个类来实现其功能。这意味着类的实现依赖于另一个类的实现。例如，一个集合类可以“根据某物实现出”迭代器功能，即通过复合一个迭代器对象来实现迭代功能。\n\n 4. 复合的优势：相比继承，复合具有更大的灵活性和可定制性。通过复合，可以将对象之间的关系限制在需要的范围内，并避免继承链的复杂性和脆弱性。复合还可以提供更好的封装和模块化，使对象之间的依赖关系更清晰。\n\n总而言之，条款38鼓励使用复合来构建对象之间的关系，特别是has-a关系或“根据某物实现出”关系。通过复合，可以实现更灵活、可定制和可维护的代码。继承仍然是一种有用的工具，但在设计对象之间的关系时，应该优先考虑使用复合。\n\n==请记住：==\n\n * ==复合（composition）的意义和public继承完全不同==\n * ==在应用域（application domain），复合意味has-a（有一个）。在实现域（implementation domain），复合意味is-implemented-in-terms-of（根据某物实现出）。==\n\n\n# 条款39：明智而审慎地使用private继承\n\n理解条款39的关键点如下：\n\n 1. 继承关系的访问控制：Cpp中的继承关系可以通过不同的访问控制符（public、protected、private）来指定对基类成员的访问权限。其中，private继承将基类的成员作为派生类的私有成员。\n\n 2. private继承的含义：使用private继承意味着派生类从基类那里继承了实现细节（implementation details），而不是接口（interface）。这种继承形式用于实现派生类“is-implemented-in-terms-of”基类的关系。\n\n 3. private继承的适用情况：private继承通常用于以下情况：\n    \n    * 当派生类需要重新定义（override）基类的虚函数，以提供自己的实现。\n    * 当派生类需要访问基类的保护成员，以在派生类中实现特定行为。\n    * 当派生类需要实现某种特定的接口或协议，基类提供了一些实现细节，但不需要对外公开。\n\n 4. 使用private继承的注意事项：在使用private继承时，需要注意以下事项：\n    \n    * private继承并不表示“是一个”（is-a）关系，而是一种实现关系。\n    * private继承不应被滥用，应该慎重考虑是否需要使用它。\n    * private继承应该与组合（composition）相比较，确保选择最适合的关系来实现设计需求。\n\n总之，条款39建议在使用private继承时要明智而审慎。它强调了private继承的特殊含义和适用情况，并提醒开发者在选择继承关系时要仔细考虑，并与组合关系进行比较和评估。正确地使用private继承可以提供灵活性和实现的便利性，同时保持良好的设计和代码的可维护性。\n\n==请记住：==\n\n * ==Private继承意味is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）地级别低。但是当derived class 需要访问protected base class 的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。==\n * ==和复合（composition）不同，private继承考研造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。==\n\n\n# 条款40：明智而审慎地使用多重继承\n\n理解条款40的关键点如下：\n\n 1. 多重继承的含义：多重继承是Cpp中一种允许一个派生类从多个基类继承特性和行为的机制。派生类可以获得多个基类的成员和接口。\n 2. 多重继承的优势：多重继承可以在某些情况下提供灵活性和复用性。它可以使派生类具有不同基类的特性，以实现更丰富和复杂的功能。\n 3. 多重继承的适用情况：多重继承通常用于以下情况：\n    * 当派生类需要从多个基类中继承不同的接口和行为时。\n    * 当派生类需要在多个不相关的类之间共享代码和数据。\n 4. 使用多重继承的注意事项：在使用多重继承时，需要注意以下事项：\n    * 显示指定基类的构造函数和析构函数。\n    * 虚拟继承（virtual inheritance）可以解决菱形继承（diamond inheritance）问题。\n    * 菱形继承问题（diamond inheritance problem）：当派生类通过多条路径继承同一个基类时，可能导致二义性和冗余。\n\n正确地使用多重继承可以提供灵活性和功能复用，但也需要处理潜在的二义性和冗余问题。\n\n==请记住：==\n\n * ==多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承地需要。==\n * ==virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes 不带任何数据，将是最具使用价值的情况。==\n * ==多重继承的确有正当途径。其中一个情节涉及“public”继承某个Interface class“和”private继承某个协助实现的class“的两相结合。==',normalizedContent:'# 继承与面向对象设计\n\n\n# 条款32：确定你的pubilc继承塑模出is-a关系\n\n条款32强调使用公共继承（public inheritance）时，需要确保所使用的继承能够正确地塑模出"is-a"关系。这意味着子类对象应该能够被视为基类对象的一种特殊类型。\n\n下面是对该条款的理解和一些建议：\n\n 1. 理解"is-a"关系：在公共继承中，子类继承了基类的接口和行为，并且可以通过基类指针或引用进行操作。这意味着子类对象应该能够被视为基类对象的一种特殊类型，即子类对象应该可以替代基类对象使用，并且在行为和使用方式上与基类对象相似。\n\n 2. 遵循liskov替换原则：liskov替换原则指出，子类对象应该能够替换基类对象并且不会破坏程序的正确性。也就是说，在使用基类对象的地方，如果用子类对象替换后程序仍然正确运行，则说明公共继承的"is-a"关系得到了正确地塑模。\n\n 3. 注意虚函数的重写：在公共继承中，子类可以重写基类的虚函数以改变其行为。但是，需要确保重写的虚函数在行为上与基类的虚函数是一致的，并且满足liskov替换原则。这样，在使用基类指针或引用操作子类对象时，能够获得预期的行为。\n\n 4. 避免破坏类的不变式：在子类中进行继承时，需要避免破坏基类所定义的类不变式（class invariants）。类不变式是描述类对象状态约束的规则，继承关系应该遵循这些规则，以确保对象的一致性和正确性。\n\n 5. 慎重使用非虚继承：非虚继承（non-virtual inheritance）==用于处理多继承时的菱形继承问题，但它不适用于"is-a"关系的建立。==非虚继承更适用于表示某种组合关系（has-a）而不是"is-a"关系，因此在公共继承中应慎重使用非虚继承。\n\n总结来说，条款32的目标是确保使用公共继承能够正确地塑模出"is-a"关系，即子类对象能够替代基类对象并且在行为和使用方式上与基类对象相似。遵循liskov替换原则、注意虚函数的重写、避免破坏类的不变式等原则，可以帮助我们正确使用公共继承并避免问题。\n\n==请记住：==\n\n==“public 继承”意味 is-a 。适用于base classes 身上的每一件事情一定也适用于derived classes 身上，因为每一个derived class 对象也都是一个base class 对象。==\n\n\n# 条款33：避免遮掩继承而来的名称\n\n条款33强调避免在派生类中遮掩（hide）继承而来的名称。当派生类中定义了与基类相同名称的成员函数或成员变量时，这些新定义的成员会遮掩基类中相同名称的成员，使其在派生类中不可见。\n\n以下是对该条款的理解和一些建议：\n\n 1. 名称遮掩的问题：当派生类中定义了与基类相同名称的成员时，派生类的成员会隐藏（hide）基类的成员。这可能导致代码中的名称冲突和不一致，使得基类的成员在派生类中不可见。\n\n 2. 使用作用域解析运算符：如果在派生类中需要访问基类中被遮掩的成员，可以使用作用域解析运算符（::）来显式指定所属的作用域。例如，可以使用base::foo()来调用基类中的foo()函数。\n\n 3. 重载与隐藏的区别：派生类中的函数重载（overload）是指在派生类中定义了与基类同名但参数列表不同的成员函数。**重载不会导致基类的同名函数被遮掩，而是构成了函数重载集。**只有当函数名和参数列表完全相同时，才会发生名称遮掩。\n\n 4. 使用using声明：如果希望在派生类中保留基类中的同名成员的可见性，可以使用using声明来引入基类的名称。使用using base::foo;可以使基类中的foo在派生类中可见，并且可以直接调用。\n\n 5. 使用转交函数(function forwarding)：\n    \n    在派生类中定义一个与基类同名的函数，这个函数将被外部调用。\n    \n    在派生类的同名函数中，调用基类的同名函数，可以使用作用域解析运算符（::）来显式指定基类的作用域。\n    \n    以下是一个示例代码：\n    \n    class base {\n    public:\n        void foo() {\n            // 基类的函数实现\n        }\n    };\n    \n    class derived : public base {\n    public:\n        void foo() {\n            base::foo();  // 转交函数，调用基类的同名函数\n            // 派生类的其他操作\n        }\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    \n    \n    在上述示例中，派生类derived中的foo函数转交了基类base中的foo函数的调用，即在派生类的foo函数中先调用基类的foo函数，然后再执行派生类的其他操作。\n\n总结来说，条款33的目标是避免在派生类中遮掩继承而来的名称，以避免名称冲突和不一致性。通过使用作用域解析运算符、重载和using声明、转交函数等技术手段，可以解决名称遮掩的问题，确保基类的成员在派生类中仍然可见并且可用。这样可以提高代码的可读性和可维护性。\n\n==请记住：==\n\n==derived classes 内的名称会遮掩base classes 内的名称。在public 继承下从来没有人希望如此。==\n\n==为了让被遮掩的名称再见天日，可使用using 声明式或转交函数（forwarding functions）。==\n\n\n# 条款34：区分接口继承和和实现继承\n\n这个条款的核心思想是，继承应该被用于两种不同的目的：接口继承和实现继承。这两种继承方式有着不同的目标和应用场景。\n\n 1. 接口继承（interface inheritance）：\n    \n    * 接口继承指的是从基类中继承纯虚函数，即只有函数签名而没有实际实现的函数。\n    * 接口继承的目的是创建一个抽象的基类，用于定义一组规范或接口，而不关注具体的实现细节。\n    * 派生类必须实现基类中的纯虚函数，以便成为一个具体的类。\n    * 通过接口继承，可以实现多态，允许将派生类对象赋值给基类指针或引用，并在运行时调用正确的实现。\n\n 2. 实现继承（implementation inheritance）：\n    \n    * 实现继承指的是从基类继承具有实际实现的函数。\n    * 实现继承的目的是通过基类的共同实现来重用代码。\n    * 实现继承可以将基类的功能直接继承到派生类中，但它会将基类和派生类紧密地耦合在一起，可能导致较高的继承层次结构复杂性。\n    * 使用实现继承时，派生类在某种程度上是基类的"特例"，它拥有基类的所有功能，并可能添加自己的特定实现。\n\n==请记住：==\n\n * ==接口继承和实现继承不同。在public 继承之下，derived classes 总是继承base classes 的接口。==\n * ==声明一个pure virtual 函数的目的是为了让derived classes 只继承函数接口。==\n * ==声明简朴的（非纯）impure virtual 函数的目的，是让derived classes 继承该函数的接口和缺省实现。==\n * ==声明non-virtual 函数的目的是为了令derived classes 继承函数的接口及一份强制性实现，non-virtual 函数代表的意义是不变性凌驾特异性，所以它绝不该在derived class 中被重新定义。==\n\n\n# 条款35：考虑virtual 函数以外的其他选择\n\n这个条款的目的是引导开发者在使用虚函数之前，先考虑一些替代方案。\n\n虚函数允许在基类中声明函数，并允许派生类重写该函数以实现特定行为。然而，使用虚函数可能会引入一些开销，如虚表指针（vptr）和虚表（vtable），以及运行时的动态绑定。在某些情况下，这些开销可能是不必要的或不适用的。\n\n在条款35中，meyers提供了一些替代虚函数的选择：\n\n 1. 将函数声明为非虚函数：\n    \n    * 如果确定某个函数在派生类中不需要被重写，可以将其声明为非虚函数。\n    * 这样做可以避免虚函数带来的运行时开销，并且使编译器能够进行更多的优化。\n\n 2. 使用非虚函数接口（non-virtual interface，nvi）手法来实现模板方法模式（template method pattern）：\n    \n    > 这一基本设计，也就是“令客户通过public non-virtual 成员函数间接调用 private virtual 函数”，称为 non-virtual interface (nvi)手法。它是所谓template method 设计模式（与cpp templates 并无关联）的一个独特变现形式。侯捷把这个non-virtual 函数称为virtual 函数的外覆器（wrapper）。\n    \n    * 这种方法利用了cpp的多态性和访问控制机制，允许派生类在模板方法中实现自己的行为。\n    \n    * 模板方法模式是一种设计模式，其中基类定义了一个模板方法（template method），该方法定义了算法的骨架，但允许派生类实现其中的一些步骤。\n    \n    * 模板方法模式通过将可变的部分交给派生类来实现，从而提供了一种替代虚函数的方法。\n    \n    * 下面是通过非虚函数接口手法实现模板方法模式的步骤：\n      \n      1. 定义基类（抽象类）：首先，定义一个基类，它包含一个公共的非虚函数接口方法，用于定义模板方法的结构。该方法通常称为模板方法。\n      \n      class base {\n      public:\n          void templatemethod(/* 参数列表 */) {\n              // 通用的处理代码...\n      \n              // 调用派生类实现的虚函数\n              dosomething(/* 参数列表 */);\n      \n              // 通用的处理代码...\n          }\n      \n      private:\n          virtual void dosomething(/* 参数列表 */) = 0; // 纯虚函数，由派生类实现\n      };\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      \n      2. 派生类实现：派生类继承自基类，并实现基类中的纯虚函数，提供自己的行为。\n      \n      class derived : public base {\n      private:\n          void dosomething(/* 参数列表 */) override {\n              // 派生类的特定实现...\n          }\n      };\n      \n      // 可以定义更多的派生类，每个派生类提供自己的行为...\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n      3. 使用模板方法：创建基类或派生类的实例，并调用模板方法。\n      \n      base* obj = new derived(); // 使用基类指针指向派生类对象\n      \n      obj->templatemethod(/* 参数列表 */); // 调用模板方法\n      \n      \n      1\n      2\n      3\n      \n      \n      通过使用非虚函数接口（nvi）手法，基类中的模板方法可以定义算法的结构，同时调用派生类实现的非虚函数。这样，派生类可以在模板方法中实现自己的行为，从而实现了模板方法模式。非虚函数接口手法通过将派生类的实现封装在非虚函数中，将多态性限制在基类的内部，并提供更好的控制和灵活性。\n      \n      需要注意的是，nvi手法并不是cpp中的特定功能或语言特性，而是一种设计模式实践。它利用了cpp中的多态性和访问控制机制，将模板方法模式应用于具体的类设计中。\n\n 3. 使用函数对象（function objects）：\n    \n    * 函数对象是可调用对象，可以像函数一样使用。它们可以通过重载operator()来实现多态行为。\n    * 使用函数对象可以避免虚函数的开销，并提供更大的灵活性和可扩展性。\n\n 4. 藉由function pointers 实现策略模式（strategy pattern）：\n    \n    * 策略模式是一种设计模式，其中算法被封装在不同的策略类中，并通过基类指针或引用在运行时选择合适的策略。\n    \n    * 使用策略模式可以避免虚函数的开销，并提供更大的灵活性和可维护性。\n    \n    * 下面是通过函数指针实现策略模式的步骤：\n      \n      1. 定义函数指针类型：首先，定义一个函数指针类型，它与策略函数的签名相匹配。\n      \n      using strategyfunctionptr = void (*)(/* 参数列表 */);\n      \n      \n      1\n      \n      2. 定义策略函数：然后，实现具体的策略函数，这些函数与策略函数指针的签名匹配。\n      \n      void concretestrategy1(/* 参数列表 */) {\n          // 具体策略1的实现...\n      }\n      \n      void concretestrategy2(/* 参数列表 */) {\n          // 具体策略2的实现...\n      }\n      \n      // 定义更多的具体策略函数...\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      \n      3. 使用函数指针存储策略：声明一个函数指针变量，并根据需要，将不同的策略函数的地址赋值给它。\n      \n      strategyfunctionptr strategy; // 声明函数指针变量\n      \n      // 选择具体策略1\n      strategy = &concretestrategy1;\n      \n      // 选择具体策略2\n      strategy = &concretestrategy2;\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n      4. 执行策略：通过调用函数指针，执行选定的策略函数。\n      \n      strategy(/* 参数列表 */); // 执行选定的策略函数（具体策略1或具体策略2）\n      \n      \n      1\n      \n      \n      使用函数指针可以实现策略模式的动态选择和执行。通过将不同的策略函数的地址赋值给函数指针，可以在运行时根据需要选择适当的策略。这种方法提供了一种简单而有效的策略模式实现方式，但需要注意函数指针的签名匹配。\n      \n      需要注意的是，使用函数指针实现策略模式可能存在一些限制，例如无法存储具有不同签名的策略函数，以及难以处理需要状态或上下文的策略。在这种情况下，使用函数对象（如前面提到的std::function）可能更加灵活和方便。\n\n 5. 藉由tr1::function完成strategy模式\n    \n    提及的tr1::function是指cpp technical report 1（tr1）中引入的函数对象类型。在当前的cpp标准（cpp11及以后），std::function是相应的功能。\n    \n    理解通过std::function（或tr1::function）来完成策略模式，可以采用以下步骤：\n    \n    1. 定义策略接口：首先，定义一个策略接口（或基类），其中包含定义所有策略对象都必须实现的纯虚函数。\n    \n    class strategyinterface {\n    public:\n        virtual void execute() = 0;\n        // 其他纯虚函数或接口方法...\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    2. 实现具体策略：接下来，为每个具体的策略实现一个类，这些类派生自策略接口，并提供自己的实现。\n    \n    class concretestrategy1 : public strategyinterface {\n    public:\n        void execute() override {\n            // 具体策略1的实现...\n        }\n    };\n    \n    class concretestrategy2 : public strategyinterface {\n    public:\n        void execute() override {\n            // 具体策略2的实现...\n        }\n    };\n    \n    // 可以定义更多的具体策略类...\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    3. 使用std::function存储策略：使用std::function来存储不同策略对象的可调用实例。这样可以实现运行时的策略选择。\n    \n    #include <functional>\n    \n    std::function<void()> strategy; // 使用std::function存储策略对象\n    \n    // 选择具体策略1\n    strategy = []() {\n        concretestrategy1 strategy1;\n        strategy1.execute();\n    };\n    \n    // 选择具体策略2\n    strategy = []() {\n        concretestrategy2 strategy2;\n        strategy2.execute();\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    4. 执行策略：通过调用std::function中存储的策略对象，执行相应的策略。\n    \n    strategy(); // 执行选定的策略（具体策略1或具体策略2）\n    \n    \n    1\n    \n    \n    使用std::function（或tr1::function）可以方便地存储不同策略对象，并在运行时选择和执行特定的策略。通过使用函数对象类型，可以实现策略模式的灵活性和可扩展性，而无需修改现有的策略接口和具体策略类。\n    \n    请注意，自cpp11起，使用std::function更为常见和推荐，而非tr1::function。\n\n==请记住：==\n\n * ==virtual 函数的替代方案包括nvi手法及strategy设计模式的多种形式。nvi手法自身是一个特殊形式的template method 设计模式。==\n\n * ==将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。==\n\n * ==tr1::function 对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。==\n\n\n# 条款36：绝不重新定义继承而来的non-virtual函数\n\n这个原则强调了在继承关系中对于非虚函数的使用和重写的限制。\n\n理解条款36的关键点如下：\n\n 1. 非虚函数与虚函数的区别：非虚函数是在基类中定义的普通成员函数，而虚函数是在基类中定义且使用virtual关键字声明的函数。虚函数支持运行时的动态绑定，而非虚函数则使用静态绑定。\n\n 2. 非虚函数的继承行为：当派生类继承一个非虚函数时，基类中的非虚函数会在派生类中保持相同的行为，不会被派生类重新定义或覆盖。\n\n 3. 危险的重新定义：重新定义（override）一个继承而来的非虚函数是危险的行为。这是因为在继承链中，通过基类指针或引用调用非虚函数时，实际调用的是静态类型（基类）的函数，而不是动态类型（派生类）的函数。这可能导致意外的行为和不一致的结果。\n\n 4. 虚函数的重写：与非虚函数不同，派生类可以通过在派生类中重新定义（override）虚函数来改变其行为。这样，当通过基类指针或引用调用虚函数时，会根据实际的动态类型调用正确的函数。\n\n总而言之，条款36建议避免重新定义继承而来的非虚函数，以防止意外的行为和不一致性。如果需要改变继承而来的函数的行为，应该将该函数声明为虚函数，并在派生类中进行重写。这样可以确保正确的多态行为，并遵循liskov替换原则（liskov substitution principle）的规定。\n\n==请记住：==\n\n * ==绝对不要重新定义继承而来的non-virtual函数。==\n\n> liskov替换原则是什么？\n> \n> liskov替换原则（liskov substitution principle）是面向对象设计的一个重要原则，由计算机科学家barbara liskov提出。该原则指导着正确和合理地使用继承和多态性，以确保软件系统的可靠性和可扩展性。\n> \n> liskov替换原则可以简要描述为：\n> \n> "如果s是t的子类型，那么在不破坏程序的正确性的前提下，任何程序中的t类型的对象都可以被替换为s类型的对象。"\n> \n> 换句话说，子类型（派生类）应该能够替换其基类型（基类）在任何程序中的使用，而不会引入错误或破坏程序的行为。这个原则的目标是保持代码的一致性、可维护性和可扩展性。\n> \n> 遵循liskov替换原则的关键要点如下：\n> \n>  1. 子类型的行为：子类型（派生类）应该完全符合其基类型（基类）的约定、协议和合约。即，子类型应该实现基类型的所有接口，并保持相同的行为和预期结果。\n> \n>  2. 不破坏基类型的不变量：子类型的操作和行为不应破坏基类型的不变量、约束和规范。即，子类型不应该放宽基类型的前置条件、加强后置条件或改变基类型的约束。\n> \n>  3. 不破坏客户端代码：子类型的使用不应该强制客户端代码进行特定的类型检查或假设。即，客户端代码应该能够以基类型的方式使用子类型对象，而不需要做任何额外的处理。\n> \n> 遵循liskov替换原则有助于构建稳健和可靠的软件系统。它鼓励设计合理的继承关系，正确使用多态性，并确保代码的一致性和可扩展性。同时，它也提供了一种指导原则，帮助开发者评估和调整继承关系中的设计选择和决策。\n\n\n# 条款37：绝不重新定义继承而来的缺省参数值\n\n这个原则强调了在继承关系中对于缺省参数的使用和重新定义的限制。\n\n理解条款37的关键点如下：\n\n 1. 缺省参数值的作用：在函数声明中，可以为参数提供缺省参数值，这样在调用函数时，如果没有提供相应参数的值，将使用缺省参数值作为参数的值。这使得函数调用更加灵活和简洁。\n\n 2. 缺省参数值的定义位置：缺省参数值是在函数的声明或定义中指定的，并不是在函数的调用处指定的。因此，在函数声明或定义中指定的缺省参数值在整个继承层次结构中保持不变。\n\n 3. 重新定义缺省参数值的危险性：当派生类重新定义（override）一个继承而来的带有缺省参数值的函数时，如果重新定义的函数中提供了不同的缺省参数值，会导致继承链中的函数调用出现二义性和不一致的结果。\n\n 4. 缺省参数值的使用原则：为了避免重新定义缺省参数值带来的问题，应该在继承关系中避免重新定义带有缺省参数值的函数。如果需要不同的缺省参数值，可以通过重载（overloading）或使用函数重写（function overriding）来实现。\n\n总而言之，条款37建议避免重新定义继承而来的带有缺省参数值的函数，以防止二义性和不一致性的问题。如果需要不同的缺省参数值或参数列表，应该使用重载或函数重写的方式来实现。这样可以确保函数调用的一致性和可预测性，并遵循正确的函数重载和继承的原则。\n\n==请记住：==\n\n * ==绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。==\n\n\n# 条款38：通过复合塑模出has-a或“根据某物实现出”\n\n这个条款强调了使用复合而不是继承来构建对象之间的关系的重要性。\n\n理解条款38的关键点如下：\n\n 1. 继承与复合的区别：继承是一种对象之间的关系，其中派生类继承了基类的特性和行为。而复合是一种对象之间的关系，其中一个对象包含另一个对象作为其一部分。\n\n 2. has-a关系：has-a关系表示一个对象具有另一个对象作为其一部分的关系。例如，一个汽车has-a引擎，一个公司has-a员工。这种关系通常可以通过复合来实现。\n\n 3. “根据某物实现出”关系：有时，一个类可以通过复合另一个类来实现其功能。这意味着类的实现依赖于另一个类的实现。例如，一个集合类可以“根据某物实现出”迭代器功能，即通过复合一个迭代器对象来实现迭代功能。\n\n 4. 复合的优势：相比继承，复合具有更大的灵活性和可定制性。通过复合，可以将对象之间的关系限制在需要的范围内，并避免继承链的复杂性和脆弱性。复合还可以提供更好的封装和模块化，使对象之间的依赖关系更清晰。\n\n总而言之，条款38鼓励使用复合来构建对象之间的关系，特别是has-a关系或“根据某物实现出”关系。通过复合，可以实现更灵活、可定制和可维护的代码。继承仍然是一种有用的工具，但在设计对象之间的关系时，应该优先考虑使用复合。\n\n==请记住：==\n\n * ==复合（composition）的意义和public继承完全不同==\n * ==在应用域（application domain），复合意味has-a（有一个）。在实现域（implementation domain），复合意味is-implemented-in-terms-of（根据某物实现出）。==\n\n\n# 条款39：明智而审慎地使用private继承\n\n理解条款39的关键点如下：\n\n 1. 继承关系的访问控制：cpp中的继承关系可以通过不同的访问控制符（public、protected、private）来指定对基类成员的访问权限。其中，private继承将基类的成员作为派生类的私有成员。\n\n 2. private继承的含义：使用private继承意味着派生类从基类那里继承了实现细节（implementation details），而不是接口（interface）。这种继承形式用于实现派生类“is-implemented-in-terms-of”基类的关系。\n\n 3. private继承的适用情况：private继承通常用于以下情况：\n    \n    * 当派生类需要重新定义（override）基类的虚函数，以提供自己的实现。\n    * 当派生类需要访问基类的保护成员，以在派生类中实现特定行为。\n    * 当派生类需要实现某种特定的接口或协议，基类提供了一些实现细节，但不需要对外公开。\n\n 4. 使用private继承的注意事项：在使用private继承时，需要注意以下事项：\n    \n    * private继承并不表示“是一个”（is-a）关系，而是一种实现关系。\n    * private继承不应被滥用，应该慎重考虑是否需要使用它。\n    * private继承应该与组合（composition）相比较，确保选择最适合的关系来实现设计需求。\n\n总之，条款39建议在使用private继承时要明智而审慎。它强调了private继承的特殊含义和适用情况，并提醒开发者在选择继承关系时要仔细考虑，并与组合关系进行比较和评估。正确地使用private继承可以提供灵活性和实现的便利性，同时保持良好的设计和代码的可维护性。\n\n==请记住：==\n\n * ==private继承意味is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）地级别低。但是当derived class 需要访问protected base class 的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。==\n * ==和复合（composition）不同，private继承考研造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。==\n\n\n# 条款40：明智而审慎地使用多重继承\n\n理解条款40的关键点如下：\n\n 1. 多重继承的含义：多重继承是cpp中一种允许一个派生类从多个基类继承特性和行为的机制。派生类可以获得多个基类的成员和接口。\n 2. 多重继承的优势：多重继承可以在某些情况下提供灵活性和复用性。它可以使派生类具有不同基类的特性，以实现更丰富和复杂的功能。\n 3. 多重继承的适用情况：多重继承通常用于以下情况：\n    * 当派生类需要从多个基类中继承不同的接口和行为时。\n    * 当派生类需要在多个不相关的类之间共享代码和数据。\n 4. 使用多重继承的注意事项：在使用多重继承时，需要注意以下事项：\n    * 显示指定基类的构造函数和析构函数。\n    * 虚拟继承（virtual inheritance）可以解决菱形继承（diamond inheritance）问题。\n    * 菱形继承问题（diamond inheritance problem）：当派生类通过多条路径继承同一个基类时，可能导致二义性和冗余。\n\n正确地使用多重继承可以提供灵活性和功能复用，但也需要处理潜在的二义性和冗余问题。\n\n==请记住：==\n\n * ==多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承地需要。==\n * ==virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes 不带任何数据，将是最具使用价值的情况。==\n * ==多重继承的确有正当途径。其中一个情节涉及“public”继承某个interface class“和”private继承某个协助实现的class“的两相结合。==',charsets:{cjk:!0}},{title:"条款41-48 模板和泛型编程",frontmatter:{title:"条款41-48 模板和泛型编程",date:"2023-11-24T15:59:26.000Z",permalink:"/pages/799b40/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/30.Effetcive_CPP/05.%E6%9D%A1%E6%AC%BE41-48%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B.html",relativePath:"01.CPP语言/30.Effetcive_CPP/05.条款41-48 模板和泛型编程.md",key:"v-4d99aed0",path:"/pages/799b40/",headers:[{level:2,title:"1、存在的问题：",slug:"_1、存在的问题",normalizedTitle:"1、存在的问题：",charIndex:1273},{level:2,title:"2、解决方法：",slug:"_2、解决方法",normalizedTitle:"2、解决方法：",charIndex:1902},{level:3,title:"a）使用this->",slug:"a-使用this",normalizedTitle:"a）使用this-&gt;",charIndex:null},{level:3,title:"b） 使用using声明",slug:"b-使用using声明",normalizedTitle:"b） 使用using声明",charIndex:2145},{level:3,title:"C） 指明被调函数所在类：基类资格修饰符",slug:"c-指明被调函数所在类-基类资格修饰符",normalizedTitle:"c） 指明被调函数所在类：基类资格修饰符",charIndex:2334},{level:2,title:"一、添加成员函数模板",slug:"一、添加成员函数模板",normalizedTitle:"一、添加成员函数模板",charIndex:5302},{level:3,title:"以一个例子引出，何时设计成员函数模板",slug:"以一个例子引出-何时设计成员函数模板",normalizedTitle:"以一个例子引出，何时设计成员函数模板",charIndex:5317},{level:2,title:"二、约束成员函数模板的行为",slug:"二、约束成员函数模板的行为",normalizedTitle:"二、约束成员函数模板的行为",charIndex:6809},{level:3,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:1904},{level:2,title:"三、设计赋值成员函数模板",slug:"三、设计赋值成员函数模板",normalizedTitle:"三、设计赋值成员函数模板",charIndex:7709},{level:3,title:"演示说明",slug:"演示说明",normalizedTitle:"演示说明",charIndex:7765},{level:2,title:"四、与默认函数的区别",slug:"四、与默认函数的区别",normalizedTitle:"四、与默认函数的区别",charIndex:8814},{level:2,title:"五、总结",slug:"五、总结",normalizedTitle:"五、总结",charIndex:9429},{level:2,title:"1、如果想写一个将迭代器移动d单位的函数",slug:"_1、如果想写一个将迭代器移动d单位的函数",normalizedTitle:"1、如果想写一个将迭代器移动d单位的函数",charIndex:11839},{level:2,title:"2、STL迭代器一共有5类",slug:"_2、stl迭代器一共有5类",normalizedTitle:"2、stl迭代器一共有5类",charIndex:12071},{level:2,title:"3、解决方式就是利用iterator_traits",slug:"_3、解决方式就是利用iterator-traits",normalizedTitle:"3、解决方式就是利用iterator_traits",charIndex:13070},{level:2,title:"1、内容",slug:"_1、内容",normalizedTitle:"1、内容",charIndex:14606},{level:2,title:"2、 总结",slug:"_2、-总结",normalizedTitle:"2、 总结",charIndex:16658}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"7 min read",minutes:6.345,time:380700,words:1269},headersStr:"1、存在的问题： 2、解决方法： a）使用this-> b） 使用using声明 C） 指明被调函数所在类：基类资格修饰符 一、添加成员函数模板 以一个例子引出，何时设计成员函数模板 二、约束成员函数模板的行为 解决方法 三、设计赋值成员函数模板 演示说明 四、与默认函数的区别 五、总结 1、如果想写一个将迭代器移动d单位的函数 2、STL迭代器一共有5类 3、解决方式就是利用iterator_traits 1、内容 2、 总结",content:'# 模板和泛型编程\n\n\n# 条款41：了解隐式接口和编译期多态\n\n理解条款41的关键点如下：\n\n 1. 隐式接口：隐式接口是指一个类或对象所提供的所有可用的成员函数和非成员函数，包括非虚函数、虚函数和重载函数。通过这些函数，对象向外部提供了一种使用的方式，形成了其隐式接口。\n\n 2. 编译期多态：编译期多态是通过函数重载和模板技术来实现的。在编译期间，**编译器可以根据函数的参数类型和模板实例化的类型进行静态类型推导和函数匹配，从而选择调用合适的函数。**这种多态性在编译期间解决，不涉及运行时的动态绑定。\n\n 3. 隐式接口和编译期多态的优势：理解隐式接口和编译期多态的概念可以提供更好的代码复用、可扩展性和可维护性。通过隐式接口，可以在不修改类定义的情况下添加新的功能和行为。通过编译期多态，可以在编译期间解决函数的调用问题，提高性能并避免运行时的开销。\n\n 4. 使用隐式接口和编译期多态：为了有效地利用隐式接口和编译期多态，应该遵循一些准则：\n    \n    * 尽量使用非成员函数，将算法和数据分离。\n    * 使用函数重载来处理不同参数类型的操作。\n    * 使用模板来实现通用的算法和数据结构。\n\n\n# 条款42：了解typename的双重意义\n\n理解条款42的关键点如下：\n\n 1. typename关键字的第一层意义：在Cpp模板中，当使用一个嵌套从属类型（nested dependent type）时，编译器无法确定这个从属类型是一个类型名（type name）还是一个静态成员变量（static member variable）。此时，需要使用typename关键字来明确告诉编译器这个从属类型是一个类型名。\n\n 2. typename关键字的第二层意义：在Cpp中，当定义模板的类型参数时，使用typename关键字来指定该参数是一个类型名。\n\n 3. typename的正确使用方式：在模板中，当使用从属类型时，如果编译器无法推断出这是一个类型名，需要使用typename关键字。例如：\n\ntemplate<typename T>\nvoid foo() {\n    typename T::NestedType* ptr; // 使用typename指定T::NestedType是一个类型名\n    // 其他代码...\n}\n\n\n1\n2\n3\n4\n5\n\n 4. typename关键字的限制：typename关键字只能在模板中使用，用于指定从属类型是一个类型名。在非模板代码中，不需要使用typename关键字。\n\n==请记住：==\n\n 1. ==声明template参数时，前缀关键字class和typename可互换。==\n 2. ==请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class 修饰符。==\n\n\n# 条款43：学习处理模板化基类内的名称\n\n\n# 1、存在的问题：\n\ntemplate<typename T1>\nclass Class_A{\npublic:\n\tvoid send1(T1 var);\n};\n\ntemplate <typename T1>\nclass Class_B:public Class_A< T1 >{\npublic:\n\tvoid send2(T1 var) { send1(var); } //编译错误，调用模板基类内函数失败\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n与普通继承的差别：==在一般继承体系中，派生类可以调用基类方法，但模板继承中存在问题。==\n\n原因：==由于base class template可能被特化，而特化版本可能不提供和一般性template模板相同的接口。因此编译器往往拒绝在templated base class（模板基类）内寻找继承而来的名称==\n\n例子：\n\ntemplate<>\nclass Class_A<Type_1>{ //特化模板类，类型为Type_1时的模板类\npublic:\n\tvoid send3(Type_1 var); // 该特化类中不存在send1函数\n};\n\n\n1\n2\n3\n4\n5\n\n\n知识点：template<>为特化模板标志 现象：由于特化类中不存在send1函数，因此派生类调用该函数失败**==。所以编译器由于知道基类模板可能被特化，使得接口不一致，所以禁止了这样的调用。==**\n\n\n# 2、解决方法：\n\n==解决方法的原理：对编译器承诺，base class template的任何版本（包括特化版本）都将支持一般版本所提供的的接口。==\n\n\n# a）使用this->\n\ntemplate <typename T1>\nclass Class_B:public Class_A< T1 >{\npublic:\n\tvoid send2(T1 var) { this->send1(var); }  // 告诉编译器，假设send1被继承\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# b） 使用using声明\n\ntemplate <typename T1>\nclass Class_B:public Class_A< T1 >{\npublic:\n\tusing Class_A< T1 >::send1; // 告诉编译器，send1在基类中\n\tvoid send2(T1 var) { send1(var); }  \n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# C） 指明被调函数所在类：基类资格修饰符\n\ntemplate <typename T1>\nclass Class_B:public Class_A< T1 >{\npublic:\n\tvoid send2(T1 var) { Class_A< T1 >::send1(var); }  // 告诉编译器，send1在基类中\n\t// 此方法不好若send1为虚函数，则Class_A< T1 >::修饰会关闭virtual绑定行为\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n==请记住：==\n\n 1. ==可在derived class templates内通过“this->”指涉base class template内的成员名称或藉由一个明白写出的“base class 资格修饰符”完成。==\n\n\n# 条款44：将与参数无关的代码抽离templates\n\ntemplate <typename T,std::size_t n>\nclass SquareMatrix{\npublic:\n    ...\n    void invert();\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n现在，考虑这些代码：\n\nSquareMatrix<double,5) sm1;\n...\nsm1.invert();\n\nSquareMatrix<double,10> sm2;\n...\nsm2.invert();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这样将会生成两份invert，这些函数并非完全相同，因为其中一个操作的是55矩阵而另一个是1010的矩阵，但除了常量5和10，两个函数的其他部分完全相同，这是templates引出代码膨胀的一个典型例子。\n\n可以发现这两个函数完全相同，只除了一个使用5而另一个使用10，那你会怎么做？以5和10来调用这个带参数的函数，而不重复代码。下面我们来进行第一次对SquareMatrix的修改：\n\n策略1：\n\ntemplate <typename T>\nclass SquareMatrixBase{\nprotected:\n    ...\n    void invert(std::size_t matrixSize);\n    ...\n};\ntemplate <typename T,std::size_t n>\nclass SquareMatrix:private SquareMatrixBase<T>{\nprivate:\n    using SquareMatrixBase<T>::invert;\n\npublic:\n    ...\n    void invert(){this->invert(n);}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n带参数的invert位于base class SquareMatrixBase中，和SquareMatrix一样，SquareMatrixBase也是个template，不同的是它只对“矩阵元素对象的类型”参数化，不对矩阵的尺寸参数化，因此对于某给定之元素对象那个类型，所有矩阵共享同一个（也是唯一一个）SquareMatrixbase class，它们也将因此共享这唯一一个class内的invert。注意这些函数中我们使用“this->”标记，因为如果不这样做，便如条款43所讲的那样，模板化基类内的函数名称会被derived class掩盖，同时我们这儿使用private继承的原因是base class SquareMatrixBase只是为了帮助derived class SquareMatrix是实现，子类和父类之间不是“is-a”关系。\n\n策略2： 针对SquareMatrixBase::invert的实现，我们该如何操作呢？解决办法是让SquareMatrixBase贮存一个指针，指向矩阵数值所在的内存，而只要它存储了这些东西，也就可能存储矩阵尺寸，如下：\n\ntemplate <typename T>\nclass SquareMatrixBase{\nprotected:\n    SquareMatrixBase(std::size_t n,T* pMem):size(n),pDate(pMem){\n\n    }\n    void setDataPtr(T* ptr){pData=ptr;}\n    ...\nprivate:\n    std::size_t size;\n    T* pData;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这允许derived class中决定内存分配方式，这里我们针对derived class有两种分配方式： 1）存储指针数组，这样可能导致对象吱声超级大！！！\n\ntemplate <typename T,std::size_t n>\nclass SquareMatrix:private SquareMatrixBase<T>{\npublic:\n    SquareMatrix():SquareMtrixBase<T>(n,data){}\n    ...\nprivate:\n    T data[n*n];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n2）把每一个矩阵的数据放进heap中，即通过new进行动态内存分配；\n\ntemplate <typename T,std::size_t n>\nclass SquareMatrix:private SquareMatrixBase<T>{\npublic:\n    SquareMatrix():SquareMatrixBase<T>(n,0),pData(new T[n*n]){\n    this->setDataPtr(pData.get());\n    }\n    ...\nprivate:\n    boost::scoped_array<T> pData;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 1）non-type template parameters（非类型模板参数）：模板参数并不局限于类型，template <<>typename T,int n>或者template <<>typename T,size_t n>等等，第二个就是非类型模板参数！ 2）type parameters：标准的类型模板参数，template <<>typename T>。\n\n==请记住：==\n\n 1. ==template生成多个classes和多个函数，所以任何template代码都不应该与某个造成膨胀的template参数产生相依关系；==\n 2. ==因类型模板参数（non-type template parameters）造成的代码膨胀，往往可以消除，做法是以函数参数或者class成员变量代替template参数；==\n 3. ==因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同的二进制表搜狐的具现类型共享实现码。==\n\n\n# 条款45：运用成员函数模板接受所有兼容类型\n\n\n# 一、添加成员函数模板\n\n\n# 以一个例子引出，何时设计成员函数模板\n\n * 第一步：我们知道指针的一个特点就是：支持隐式转换。\n * 例如“指向 non-const 对象的指针可以转换为指向 const 对象”，“派生类指针可以隐式转换为基类指针”等等。代码如下：\n\nclass Top {};\nclass Middle :public Top {};\nclass Bottom :public Middle {};\n \nTop* pt1 = new Middle;  //将Miffle*转换为Top*\nTop* pt2 = new Bottom;  //将Bottom*转换为Top*\nconst Top* pct2 = pt1;  //将Top*转换为const Top*\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * **第二步：**假设现在我们设计一个模板，用来模仿智能指针类，并且希望智能指针能像普通指针一样进行类型转换。例如：\n\nclass Top {};\nclass Middle :public Top {};\nclass Bottom :public Middle {};\n \n//自己设计的智能指针类\ntemplate<typename T>\nclass SmartPtr\n{\npublic:\n    explicit SmartPtr(T* realPtr);\n};\n \nint main()\n{\n    //下面是我们希望能完成的，但是还没有实现\n    SmartPtr<Top> pt1 = SmartPtr<Middle>(new Middle);\n    SmartPtr<Top> pt2 = SmartPtr<Bottom>(new Bottom);\n    SmartPtr<const Top> pct2 = pt1;\n \n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n * 第三步：根据上面的需求，我们希望让自己的智能指针类能像普通指针一样进行类型转换，那么我们可以为 SmartPtr 设计拷贝构造函数或拷贝赋值运算符，那么上面的功能就能实现了。\n   \n   * 一种低效的做法是：在 SmartPtr 模板中针对于每一个 Top 派生类定义一个拷贝构造函数和拷贝赋值运算符。但是这种做法十分低效，因为针对每一个派生类设计相对应的拷贝构造函数和拷贝赋值运算符会使 class 膨胀，并且如果将来加入新的派生类，那么还需要继续添加新的成员函数\n\n * 第四步：另一种做法是：为 SmartPtr 模板添加一个成员函数模板\n   \n   * 例如：根据下面的拷贝构造函数，我们可以对任何类型T和任何类型U，将一个SmartPtr<U>转换为SmartPtr<T>\n   * 下面的拷贝构造函数并未声明为 explicit：因为原始指针类型之间的转换是隐式转换，如果我们的模板类型为原始指针，那么要支持这种隐式转换，因为我们并未声明 explicit\n\ntemplate<typename T>\nclass SmartPtr\n{\npublic:\n    //拷贝构造函数，是一个成员函数模板\n    typename<typename U>\n    SmartPtr(const SmartPtr<U>& other);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 根据上面的介绍我们可以知道，为类模板设计一个成员函数模板是为了进行统一性与间接性，避免冗余操作\n\n\n# 二、约束成员函数模板的行为\n\n * 在“一”中，我们为智能指针类设计了拷贝构造函数，这样就可以根据类型进行类型转换了\n\n * 但是还有一些问题没有解决：\n   \n   * 那就是，对于类继承来说，派生类指针可以转换为基类指针，但是基类指针不能转换为派生类指针\n   * 类似的，对于普通类型来说，我们不能将int*转换为double*\n\n * 因此，即使我们设计了成员函数模板，那么还需要考虑一些转换的特殊情况（上面列出的）\n\n\n# 解决方法\n\n>  * 我们可以为自己的只能指针类提供一个类似于shared_ptr的get()成员函数，这个函数返回智能指针锁封装的那个原始指针\n> \n>  * 设计的代码如下：\n>    \n>    template<typename T>\n>    class SmartPtr\n>    {\n>    public:\n>        typename<typename U>\n>        SmartPtr(const SmartPtr<U>& other)\n>            :heldPtr(other.get())\n>        T get()const {\n>            return heldPtr;\n>        }\n>    private:\n>        T* heldPtr;\n>    };\n>    \n>    \n>    1\n>    2\n>    3\n>    4\n>    5\n>    6\n>    7\n>    8\n>    9\n>    10\n>    11\n>    12\n>    13\n>    \n> \n>  * 此处设计的原理：\n>    \n>    * get()成员函数返回原始指针\n>    * 在拷贝构造函数中，我们使用了成员初始化列表来进行初始化智能指针封装的原始指针\n>    * 因此，在拷贝构造函数的构造过程中，是根据原始指针进行转换的，因此如果原始指针会自己判断这种转换行为：如果可以转换，那么拷贝构造函数就正确执行；如果不能转换，那么拷贝构造函数出错\n\n\n# 三、设计赋值成员函数模板\n\n * 我们上面设计的智能指针模板不限于构造函数，而且还可以自己设计赋值操作\n\n\n# 演示说明\n\n>  * 例如shared_ ptr：\n>    * 支持所有“来自内置指针、shared_ptr、auto_ptr、weak_ptr”的构造函数\n>    * 支持上面所有（出去weak_ptr）的赋值操作\n>  * 例如下面是shared_ptr的源码摘录：（其中template参数强烈倾向使用class而不是typename）\n> \n> template<class T>\n> class shared_ptr\n> {\n> public:\n>     //下面都是拷贝构造函数(列出了一部分)\n>     template<class Y>\n>     explicit shared_ptr(Y* p);\n>     template<class Y>\n>     shared_ptr(shared_ptr<Y> const& r);\n>     template<class Y>\n>     explicit shared_ptr(weak_ptr<Y> const& r);\n>     template<class Y>\n>     explicit shared_ptr(auto_ptr<Y>& r);\n> \n>     //下面都是赋值操作(列出了一部分)\n>     template<class Y>\n>     shared_ptr& operator=(shared_ptr<Y> const& r);\n>     template<class Y>\n>     shared_ptr& operator=(auto_ptr<Y>& r);\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> \n>  * 代码说明：\n>    * 构造函数：都是explicit，除了“泛化copy构造函数”除外。因为从某个shared_ptr类型隐式转换为另一个shared_ptr是被允许的，但是从某个内置指针或从其他智能指针进行隐式转换为shared_ptr是不被允许的（除了使用cast进行强制类型转换）\n>    * auto_ptr：参数为auto_ptr的拷贝构造函数和赋值运算符，其参数都不是const的（条款13说过，当你赋值一个auto_ptr时，我们希望其所管理的对象被移动改动）\n\n\n# 四、与默认函数的区别\n\n * 我们曾说过，一个类如果没有提供构造函数、拷贝构造函数、拷贝赋值运算符，那么编译器会自动为类提供合成/默认的版本，这一规则同样适用于模板类\n * 因此，例如我们上面为自己的类添加了成员函数模板（拷贝构造函数），那么当我们使用拷贝构造函数的时候是调用哪一个版本呢？答案为：根据实际调用情况选择\n * 因此，如果我们自己设计成员函数模板还需要拷贝类为我们自己提供的合成版本，在必要时自己设计非成员函数模板\n * 例如，下面是shared_ptr的源码摘录：\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    //拷贝构造函数\n    shared_ptr (shared_ptr const& r);   //非泛化版本\n    template<class Y>\n    shared_ptr(shared_ptr<Y> const& r); //泛化版本\n \n    //拷贝赋值运算符\n    shared_ptr& operator=(shared_ptr const& r);    //非泛化版本\n    template<class Y>\n    shared_ptr& operator=(shared_ptr<Y> const& r); //泛化版本\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 五、总结\n\n==请记住：==\n\n * ==请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数==\n * ==如果你生命member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符==\n\n\n# 条款46：需要类型转换时请为模板定义非成员函数\n\n首先为什么类似于operator 这样的重载运算符要定义成非成员函数，主要是为了保证混合乘法2 Variant或者Variant * 2都可以通过编译，但是2不能同时进行隐式类型转换成某个Variant，再作this用。\n\n所以我们一般将之定义成友元函数，像下面这样：\n\nclass Variant\n{\npublic:\n    Variant(const int& value = 0) {}\n \n    friend const Variant operator* (const Variant&lhs, const Variant& rhs);\n};\n \nconst Variant operator* (const Variant&lhs, const Variant& rhs) \n{\n    return Variant();\n}\n \n//使用方式\nVariant val(1);             //ok\nVariant result = val * 1;   //ok\nresult = 2 * val;           //ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n现在引入模板，可以像下面这样写，注意这里的operator*是一个独立的模板函数：\n\ntemplate<typename T>\nclass Variant\n{\npublic:\n    Variant(const T& value = 0) {}\n};\n \ntemplate<typename T>\nconst Variant<T> operator* (const Variant<T>&lhs, const Variant<T>& rhs)\n{\n    return Variant<T>();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n但是这次不能通过编译并且在vs2015下的报错信息：\n\nC2784   “const Variant<T> operator *(const Variant<T> &,const Variant<T> &)”: 未能从“int”为“const Variant<T> &”推导 模板 参数 \n\n\n1\n\n\n原因是编译器推导T出现了困难，val * 1在编译器看来，可以由a是Variant将T推导成int，但是1是什么，理想情况下编译器会尝试将它先转换成一个Variant，并将T推导成int，但事实上编译器在“T推导过程中从不将隐式类型转换函数纳入考虑”。所以无论是val * 1还是1 * val 都是不能通过编译的，一句话，隐式转换+推导T不能被同时被编译器接受。\n\n解决问题的思路便接着产生，编译器既然不能同时接受这两个过程，就让它们事先满足好一个条件，再由编译器执行另一个过程好了。\n\n如果把这个operator*放在template class里面，也就是先在生成模板类的那一步就定下T，这样编译器只要执行隐式转换这一步就可以了。\n\n因此我们可以这样来改：\n\ntemplate<typename T>\nclass Variant\n{\npublic:\n    Variant(const T& value = 0) {}\n \n    friend const Variant<T> operator* (const Variant<T>&lhs, const Variant<T>& rhs);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在类中加一个友元。\n\n我们添加了一个友元函数的声明，果然编译通过了，但链接时又报错了，原因是链接器找不到operator*的定义，这里又要说模板类中的一个特殊情况了，它不同与普通的类，模板类的友元函数只能在类中实现，所以要把函数体部分移至到类内，像下面这样：\n\ntemplate<typename T>\nclass Variant\n{\npublic:\n    Variant(const T& value = 0) {}\n \n    friend const Variant<T> operator* (const Variant<T>&lhs, const Variant<T>& rhs)\n    {\n        return Variant<T>();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这下编译和链接都没有问题了。这里还要说一下，就是移至类内后，T的标识符可以不写了。\n\noperator里面只有一句话，但如果friend函数里面的东西太多了，可以定义一个辅助方法，比如Doxxx()，这个Doxxx可以放在类外去实现，Doxxx本身不支持混合乘法（2 * Variant或者Variant 2），但由于在operator*里面已经进行了隐式类型转换，所以到Doxxx()这一级是没有问题的。\n\n==请记住：==\n\n * ==当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。==\n\n\n# 条款47:请使用traits classes表现类型信息\n\n\n# 1、如果想写一个将迭代器移动d单位的函数\n\ntemplate<template IterT,typename DistT>\nvoid advance(IterT& iter,DistT d);//d>0前移，d<0后移\n\n\n1\n2\n\n\n具体过程该怎么写呢？直接写 iter += d 是行不通的，因为这种只有random acces（随机访问）迭代器才支持+=的操作，而其他威力不那么强大的迭代器种类，advance必须反复施行 ++ 或 --，共d次。\n\n\n# 2、STL迭代器一共有5类\n\n * input迭代器：**只能向前移动，一次一步，只能读取。**例如，模仿指向输入文件的读指针(read pointer)。Cpp程序库中的istream_iterators是这一分类的代表。\n\n * Output迭代器：**只能向前移动，一次一步，只能写。**例如，模仿指向输出文件的写指针(write pointer)。Cpp程序库中的ostream_iterators是这一分类的代表。\n\n> 以上两种迭代器是威力最小的两个迭代器分类。因为一次只能一步，所以它们只适合“一次性操作算法”\n\n * forward迭代器：可以做前述两种迭代器所能做的每一件事，而且可以读写其所指物一次以上，因此可施行于“多次性操作算法”，TR1 hashed容器可能是这一分类（这里说“可能”是因为hashed容器的迭代器可为单向也可为双向，取决于实现版本）。\n\n * Bidirectional迭代器：**除了可前移还可后移。**STL的list迭代器就属于这一分类，set，multiset，map和multimap的迭代器也都是这一分类。\n\n * random access迭代器：**威力最大的迭代器，可以执行“迭代器算术”，因此可在常量时间内前后随机移动任意的距离。**vector，deque和string提供的迭代器都是这一分类。有时内置指针也可被当做random access 迭代器使用。\n\n对于这5类，Cpp标准库分别提供tag struct（卷标结构）加以确认\n\nstruct input_iterator_tag{};\nstruct output_iterator_tag{};\nstruct forward_iterator_tag :public input_iterator_tag{};\nstruct bidirectional_iterator_tag :public forward_iterator_tag{};\nstruct random_access_iterator_tag :public bidirectional_iterator_tag{};\n\n\n1\n2\n3\n4\n5\n\n\n在写advance函数时前4类迭代器可以使用++，--，而最后一个可以使用iter+=d,所以我们就需要在编译期取得类型信息，知道是哪一种迭代器.\n\n\n# 3、解决方式就是利用iterator_traits\n\ntemplate<typename IterT> struct iterator_traits;//template,用来处理迭代器分类的相关信息\n\niterator_traits的运作方式是，针对每一个IterT,在struct iterator_traits<IterT>内一定声明某个typedef名为iterator_category。这个typedef用来确认IterT的迭代器分类。即首先要求用户自定义的迭代器类型必须嵌套一个typedef，名为iterator_category,用来确认适当的卷标结构\n\n例如\n\ntemplate<...>\nclass deque{\npublic:\n\tclass iterator{\n\tpublic:\n\t\ttypedef random_access_iterator_tag iterator_category;\n\t};\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\niterator_traits只是响应iterator class的嵌套式typedef\n\ntemplate<typename IterT>\nstruct iterator_traits{\n\ttypedef typename IterT::iterator_category iterator_category;\n};\n//针对指针,偏特化\ntemplate<typename IterT>\nstruct iterator_traits<IterT*>{\n\ttypedef typename IterT::iterator_category iterator_category;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n迭代器移动函数可这样实现\n\ntemplate<typename IterT,typename DistT>\nvoid doAdvance(IterT& iter, DistT d, std::bidirectional_iterator_tag)\n{\n\tif (d >= 0) \n\t{\n\t\twhile (d--)\n\t\t\t++iter;\n\t}\n\telse\n\t{\n\t\twhile (d++)\n\t\t\t--iter;\n\t}\n}\ntemplate<typename IterT, typename DistT>\nvoid doAdvance(IterT& iter, DistT d, std::input_iterator_tag)\n{\n\tif (d < 0)\n\t\tthrow std::out_of_range("Negative distance");\n\twhile(d--) ++iter;\n}\ntemplate<typename IterT, typename DistT>\nvoid advance(IterT& iter, DistT d)\n{\n\tdoAdvance(iter, d, typename std::iterator_traits<IterT>::iterator_category);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n==请记住==\n\n * ==Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现==\n * ==整合重载技术后，traits classes有可能在编译期对类型执行if...else测试==\n\n\n# 条款48：认识template元编程\n\n\n# 1、内容\n\n 1. template metaprogramming（TMP，模板元编程）是：编写 template Cpp 程序并执行于编译期的过程。所谓模板元程序就是：以 Cpp 写成，执行于 Cpp 编译器内的程序。该程序执行后产生具现的代码，和正常代码一并加入编译。也就说元编程可以做到用代码去生成代码。\n\n 2. TMP 伟大之处在于，由于 template metaprograms 执行于 Cpp 编译期，因此可以将很多工作从运行期转移到编译期。例如：\n    \n    * 某些错误原本通常在运行期才能检测到，现在可在编译器找出来。\n    \n    * 使用 TMP 的 Cpp 程序可能在每一方面都更加高效：比如较小的可执行文件，较短的运行期，较少的内存需求。\n\n 3. 在条款 47 我们曾提到如何实现一个 Move 函数：\n    \n    template <typename IteratorType>\n    void Move(IteratorType& Iterator, int Distance) {\n        // 使用类型信息\n        if (typeid(IteratorTraits<IteratorType>::IteratorTag) == typeid(RandomAccessIteratorTag)) {   \n            Iterator += Distance;\n        }\n        else {\n            if (Distance >= 0) {\n                while (Distance--)++Iterator;\n            }\n            else {\n                while (Distance++)--Iterator;\n            }\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    \n    并且我们曾描述这可能存在编译问题，现在就让我们看看是什么：虽然我们这里根据迭代器类型进行不同的操作，或 +=，或 ++，–，我们知道只有 Random Access Iterator 可以有 += 运算，但是 Cpp 要求：编译器必须确保所有源码都有效，即使是不会执行的源码。也就是说编译器会拿着其他不支持 += 的迭代器，进入 if 语句先测试是否支持 += 运算，无效则会报错。\n    \n    所以相比于要支持所有操作，Traits class 针对不同类型进行函数重载的做法显然更好。\n\n 4. 我们先简单了解一下 TMP 编程。TMP 已被证明是一个图灵完备（Turing-complete）机器，这意味着它可以计算任何事物，使用 TMP 你可以声明变量，执行循环，编写及调用函数…但这些相对于正常的 Cpp 的实现会有很大的不同。比如：TMP 并没有循环部件，所有的循环效果都由递归完成。如果你不了解递归，恐怕必须先解决这个问题。\n\n 5. 一个经典的入门案例是使用 TMP 计算阶乘：\n    \n    template <unsigned N>\n    struct Factorial {\n        static const int Value = N * Factorial<N - 1>::Value;\n    };\n    \n    template <>\n    struct Factorial<0> {\n        static const int Value = 1;\n    };\n    \n    inline void TryWithFactorial() {\n        std::cout << Factorial<10>::Value << "\\n";\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    \n    和所有递归行为一样，我们需要一个特殊情况来结束递归。对于 TMP 而言就是使用 template 的特化版本。\n    \n    正如 TryWithFactorial 函数所使用的，只要你声明Factorial<N>::Value 就可以得到 N 阶乘值。当然这里存在值溢出的问题。\n\n 6. TMP 目前是一个新生的技术，语法不直观，也缺少 template 相关的调试器，但它将运行期工作移至编译期所带来的效率提升还是很令人印象深刻。\n\n\n# 2、 总结\n\n==请记住：==\n\n * ==Template metaprogramming（TMP，模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。==\n * ==TMP 可被用来生成基于政策选择组合（based on combination of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不合适的代码。==',normalizedContent:'# 模板和泛型编程\n\n\n# 条款41：了解隐式接口和编译期多态\n\n理解条款41的关键点如下：\n\n 1. 隐式接口：隐式接口是指一个类或对象所提供的所有可用的成员函数和非成员函数，包括非虚函数、虚函数和重载函数。通过这些函数，对象向外部提供了一种使用的方式，形成了其隐式接口。\n\n 2. 编译期多态：编译期多态是通过函数重载和模板技术来实现的。在编译期间，**编译器可以根据函数的参数类型和模板实例化的类型进行静态类型推导和函数匹配，从而选择调用合适的函数。**这种多态性在编译期间解决，不涉及运行时的动态绑定。\n\n 3. 隐式接口和编译期多态的优势：理解隐式接口和编译期多态的概念可以提供更好的代码复用、可扩展性和可维护性。通过隐式接口，可以在不修改类定义的情况下添加新的功能和行为。通过编译期多态，可以在编译期间解决函数的调用问题，提高性能并避免运行时的开销。\n\n 4. 使用隐式接口和编译期多态：为了有效地利用隐式接口和编译期多态，应该遵循一些准则：\n    \n    * 尽量使用非成员函数，将算法和数据分离。\n    * 使用函数重载来处理不同参数类型的操作。\n    * 使用模板来实现通用的算法和数据结构。\n\n\n# 条款42：了解typename的双重意义\n\n理解条款42的关键点如下：\n\n 1. typename关键字的第一层意义：在cpp模板中，当使用一个嵌套从属类型（nested dependent type）时，编译器无法确定这个从属类型是一个类型名（type name）还是一个静态成员变量（static member variable）。此时，需要使用typename关键字来明确告诉编译器这个从属类型是一个类型名。\n\n 2. typename关键字的第二层意义：在cpp中，当定义模板的类型参数时，使用typename关键字来指定该参数是一个类型名。\n\n 3. typename的正确使用方式：在模板中，当使用从属类型时，如果编译器无法推断出这是一个类型名，需要使用typename关键字。例如：\n\ntemplate<typename t>\nvoid foo() {\n    typename t::nestedtype* ptr; // 使用typename指定t::nestedtype是一个类型名\n    // 其他代码...\n}\n\n\n1\n2\n3\n4\n5\n\n 4. typename关键字的限制：typename关键字只能在模板中使用，用于指定从属类型是一个类型名。在非模板代码中，不需要使用typename关键字。\n\n==请记住：==\n\n 1. ==声明template参数时，前缀关键字class和typename可互换。==\n 2. ==请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class 修饰符。==\n\n\n# 条款43：学习处理模板化基类内的名称\n\n\n# 1、存在的问题：\n\ntemplate<typename t1>\nclass class_a{\npublic:\n\tvoid send1(t1 var);\n};\n\ntemplate <typename t1>\nclass class_b:public class_a< t1 >{\npublic:\n\tvoid send2(t1 var) { send1(var); } //编译错误，调用模板基类内函数失败\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n与普通继承的差别：==在一般继承体系中，派生类可以调用基类方法，但模板继承中存在问题。==\n\n原因：==由于base class template可能被特化，而特化版本可能不提供和一般性template模板相同的接口。因此编译器往往拒绝在templated base class（模板基类）内寻找继承而来的名称==\n\n例子：\n\ntemplate<>\nclass class_a<type_1>{ //特化模板类，类型为type_1时的模板类\npublic:\n\tvoid send3(type_1 var); // 该特化类中不存在send1函数\n};\n\n\n1\n2\n3\n4\n5\n\n\n知识点：template<>为特化模板标志 现象：由于特化类中不存在send1函数，因此派生类调用该函数失败**==。所以编译器由于知道基类模板可能被特化，使得接口不一致，所以禁止了这样的调用。==**\n\n\n# 2、解决方法：\n\n==解决方法的原理：对编译器承诺，base class template的任何版本（包括特化版本）都将支持一般版本所提供的的接口。==\n\n\n# a）使用this->\n\ntemplate <typename t1>\nclass class_b:public class_a< t1 >{\npublic:\n\tvoid send2(t1 var) { this->send1(var); }  // 告诉编译器，假设send1被继承\n};\n\n\n1\n2\n3\n4\n5\n\n\n\n# b） 使用using声明\n\ntemplate <typename t1>\nclass class_b:public class_a< t1 >{\npublic:\n\tusing class_a< t1 >::send1; // 告诉编译器，send1在基类中\n\tvoid send2(t1 var) { send1(var); }  \n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# c） 指明被调函数所在类：基类资格修饰符\n\ntemplate <typename t1>\nclass class_b:public class_a< t1 >{\npublic:\n\tvoid send2(t1 var) { class_a< t1 >::send1(var); }  // 告诉编译器，send1在基类中\n\t// 此方法不好若send1为虚函数，则class_a< t1 >::修饰会关闭virtual绑定行为\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n==请记住：==\n\n 1. ==可在derived class templates内通过“this->”指涉base class template内的成员名称或藉由一个明白写出的“base class 资格修饰符”完成。==\n\n\n# 条款44：将与参数无关的代码抽离templates\n\ntemplate <typename t,std::size_t n>\nclass squarematrix{\npublic:\n    ...\n    void invert();\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n现在，考虑这些代码：\n\nsquarematrix<double,5) sm1;\n...\nsm1.invert();\n\nsquarematrix<double,10> sm2;\n...\nsm2.invert();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这样将会生成两份invert，这些函数并非完全相同，因为其中一个操作的是55矩阵而另一个是1010的矩阵，但除了常量5和10，两个函数的其他部分完全相同，这是templates引出代码膨胀的一个典型例子。\n\n可以发现这两个函数完全相同，只除了一个使用5而另一个使用10，那你会怎么做？以5和10来调用这个带参数的函数，而不重复代码。下面我们来进行第一次对squarematrix的修改：\n\n策略1：\n\ntemplate <typename t>\nclass squarematrixbase{\nprotected:\n    ...\n    void invert(std::size_t matrixsize);\n    ...\n};\ntemplate <typename t,std::size_t n>\nclass squarematrix:private squarematrixbase<t>{\nprivate:\n    using squarematrixbase<t>::invert;\n\npublic:\n    ...\n    void invert(){this->invert(n);}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n带参数的invert位于base class squarematrixbase中，和squarematrix一样，squarematrixbase也是个template，不同的是它只对“矩阵元素对象的类型”参数化，不对矩阵的尺寸参数化，因此对于某给定之元素对象那个类型，所有矩阵共享同一个（也是唯一一个）squarematrixbase class，它们也将因此共享这唯一一个class内的invert。注意这些函数中我们使用“this->”标记，因为如果不这样做，便如条款43所讲的那样，模板化基类内的函数名称会被derived class掩盖，同时我们这儿使用private继承的原因是base class squarematrixbase只是为了帮助derived class squarematrix是实现，子类和父类之间不是“is-a”关系。\n\n策略2： 针对squarematrixbase::invert的实现，我们该如何操作呢？解决办法是让squarematrixbase贮存一个指针，指向矩阵数值所在的内存，而只要它存储了这些东西，也就可能存储矩阵尺寸，如下：\n\ntemplate <typename t>\nclass squarematrixbase{\nprotected:\n    squarematrixbase(std::size_t n,t* pmem):size(n),pdate(pmem){\n\n    }\n    void setdataptr(t* ptr){pdata=ptr;}\n    ...\nprivate:\n    std::size_t size;\n    t* pdata;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这允许derived class中决定内存分配方式，这里我们针对derived class有两种分配方式： 1）存储指针数组，这样可能导致对象吱声超级大！！！\n\ntemplate <typename t,std::size_t n>\nclass squarematrix:private squarematrixbase<t>{\npublic:\n    squarematrix():squaremtrixbase<t>(n,data){}\n    ...\nprivate:\n    t data[n*n];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n2）把每一个矩阵的数据放进heap中，即通过new进行动态内存分配；\n\ntemplate <typename t,std::size_t n>\nclass squarematrix:private squarematrixbase<t>{\npublic:\n    squarematrix():squarematrixbase<t>(n,0),pdata(new t[n*n]){\n    this->setdataptr(pdata.get());\n    }\n    ...\nprivate:\n    boost::scoped_array<t> pdata;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 1）non-type template parameters（非类型模板参数）：模板参数并不局限于类型，template <<>typename t,int n>或者template <<>typename t,size_t n>等等，第二个就是非类型模板参数！ 2）type parameters：标准的类型模板参数，template <<>typename t>。\n\n==请记住：==\n\n 1. ==template生成多个classes和多个函数，所以任何template代码都不应该与某个造成膨胀的template参数产生相依关系；==\n 2. ==因类型模板参数（non-type template parameters）造成的代码膨胀，往往可以消除，做法是以函数参数或者class成员变量代替template参数；==\n 3. ==因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同的二进制表搜狐的具现类型共享实现码。==\n\n\n# 条款45：运用成员函数模板接受所有兼容类型\n\n\n# 一、添加成员函数模板\n\n\n# 以一个例子引出，何时设计成员函数模板\n\n * 第一步：我们知道指针的一个特点就是：支持隐式转换。\n * 例如“指向 non-const 对象的指针可以转换为指向 const 对象”，“派生类指针可以隐式转换为基类指针”等等。代码如下：\n\nclass top {};\nclass middle :public top {};\nclass bottom :public middle {};\n \ntop* pt1 = new middle;  //将miffle*转换为top*\ntop* pt2 = new bottom;  //将bottom*转换为top*\nconst top* pct2 = pt1;  //将top*转换为const top*\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * **第二步：**假设现在我们设计一个模板，用来模仿智能指针类，并且希望智能指针能像普通指针一样进行类型转换。例如：\n\nclass top {};\nclass middle :public top {};\nclass bottom :public middle {};\n \n//自己设计的智能指针类\ntemplate<typename t>\nclass smartptr\n{\npublic:\n    explicit smartptr(t* realptr);\n};\n \nint main()\n{\n    //下面是我们希望能完成的，但是还没有实现\n    smartptr<top> pt1 = smartptr<middle>(new middle);\n    smartptr<top> pt2 = smartptr<bottom>(new bottom);\n    smartptr<const top> pct2 = pt1;\n \n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n * 第三步：根据上面的需求，我们希望让自己的智能指针类能像普通指针一样进行类型转换，那么我们可以为 smartptr 设计拷贝构造函数或拷贝赋值运算符，那么上面的功能就能实现了。\n   \n   * 一种低效的做法是：在 smartptr 模板中针对于每一个 top 派生类定义一个拷贝构造函数和拷贝赋值运算符。但是这种做法十分低效，因为针对每一个派生类设计相对应的拷贝构造函数和拷贝赋值运算符会使 class 膨胀，并且如果将来加入新的派生类，那么还需要继续添加新的成员函数\n\n * 第四步：另一种做法是：为 smartptr 模板添加一个成员函数模板\n   \n   * 例如：根据下面的拷贝构造函数，我们可以对任何类型t和任何类型u，将一个smartptr<u>转换为smartptr<t>\n   * 下面的拷贝构造函数并未声明为 explicit：因为原始指针类型之间的转换是隐式转换，如果我们的模板类型为原始指针，那么要支持这种隐式转换，因为我们并未声明 explicit\n\ntemplate<typename t>\nclass smartptr\n{\npublic:\n    //拷贝构造函数，是一个成员函数模板\n    typename<typename u>\n    smartptr(const smartptr<u>& other);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 根据上面的介绍我们可以知道，为类模板设计一个成员函数模板是为了进行统一性与间接性，避免冗余操作\n\n\n# 二、约束成员函数模板的行为\n\n * 在“一”中，我们为智能指针类设计了拷贝构造函数，这样就可以根据类型进行类型转换了\n\n * 但是还有一些问题没有解决：\n   \n   * 那就是，对于类继承来说，派生类指针可以转换为基类指针，但是基类指针不能转换为派生类指针\n   * 类似的，对于普通类型来说，我们不能将int*转换为double*\n\n * 因此，即使我们设计了成员函数模板，那么还需要考虑一些转换的特殊情况（上面列出的）\n\n\n# 解决方法\n\n>  * 我们可以为自己的只能指针类提供一个类似于shared_ptr的get()成员函数，这个函数返回智能指针锁封装的那个原始指针\n> \n>  * 设计的代码如下：\n>    \n>    template<typename t>\n>    class smartptr\n>    {\n>    public:\n>        typename<typename u>\n>        smartptr(const smartptr<u>& other)\n>            :heldptr(other.get())\n>        t get()const {\n>            return heldptr;\n>        }\n>    private:\n>        t* heldptr;\n>    };\n>    \n>    \n>    1\n>    2\n>    3\n>    4\n>    5\n>    6\n>    7\n>    8\n>    9\n>    10\n>    11\n>    12\n>    13\n>    \n> \n>  * 此处设计的原理：\n>    \n>    * get()成员函数返回原始指针\n>    * 在拷贝构造函数中，我们使用了成员初始化列表来进行初始化智能指针封装的原始指针\n>    * 因此，在拷贝构造函数的构造过程中，是根据原始指针进行转换的，因此如果原始指针会自己判断这种转换行为：如果可以转换，那么拷贝构造函数就正确执行；如果不能转换，那么拷贝构造函数出错\n\n\n# 三、设计赋值成员函数模板\n\n * 我们上面设计的智能指针模板不限于构造函数，而且还可以自己设计赋值操作\n\n\n# 演示说明\n\n>  * 例如shared_ ptr：\n>    * 支持所有“来自内置指针、shared_ptr、auto_ptr、weak_ptr”的构造函数\n>    * 支持上面所有（出去weak_ptr）的赋值操作\n>  * 例如下面是shared_ptr的源码摘录：（其中template参数强烈倾向使用class而不是typename）\n> \n> template<class t>\n> class shared_ptr\n> {\n> public:\n>     //下面都是拷贝构造函数(列出了一部分)\n>     template<class y>\n>     explicit shared_ptr(y* p);\n>     template<class y>\n>     shared_ptr(shared_ptr<y> const& r);\n>     template<class y>\n>     explicit shared_ptr(weak_ptr<y> const& r);\n>     template<class y>\n>     explicit shared_ptr(auto_ptr<y>& r);\n> \n>     //下面都是赋值操作(列出了一部分)\n>     template<class y>\n>     shared_ptr& operator=(shared_ptr<y> const& r);\n>     template<class y>\n>     shared_ptr& operator=(auto_ptr<y>& r);\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> \n>  * 代码说明：\n>    * 构造函数：都是explicit，除了“泛化copy构造函数”除外。因为从某个shared_ptr类型隐式转换为另一个shared_ptr是被允许的，但是从某个内置指针或从其他智能指针进行隐式转换为shared_ptr是不被允许的（除了使用cast进行强制类型转换）\n>    * auto_ptr：参数为auto_ptr的拷贝构造函数和赋值运算符，其参数都不是const的（条款13说过，当你赋值一个auto_ptr时，我们希望其所管理的对象被移动改动）\n\n\n# 四、与默认函数的区别\n\n * 我们曾说过，一个类如果没有提供构造函数、拷贝构造函数、拷贝赋值运算符，那么编译器会自动为类提供合成/默认的版本，这一规则同样适用于模板类\n * 因此，例如我们上面为自己的类添加了成员函数模板（拷贝构造函数），那么当我们使用拷贝构造函数的时候是调用哪一个版本呢？答案为：根据实际调用情况选择\n * 因此，如果我们自己设计成员函数模板还需要拷贝类为我们自己提供的合成版本，在必要时自己设计非成员函数模板\n * 例如，下面是shared_ptr的源码摘录：\n\ntemplate<class t>\nclass shared_ptr\n{\npublic:\n    //拷贝构造函数\n    shared_ptr (shared_ptr const& r);   //非泛化版本\n    template<class y>\n    shared_ptr(shared_ptr<y> const& r); //泛化版本\n \n    //拷贝赋值运算符\n    shared_ptr& operator=(shared_ptr const& r);    //非泛化版本\n    template<class y>\n    shared_ptr& operator=(shared_ptr<y> const& r); //泛化版本\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 五、总结\n\n==请记住：==\n\n * ==请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数==\n * ==如果你生命member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符==\n\n\n# 条款46：需要类型转换时请为模板定义非成员函数\n\n首先为什么类似于operator 这样的重载运算符要定义成非成员函数，主要是为了保证混合乘法2 variant或者variant * 2都可以通过编译，但是2不能同时进行隐式类型转换成某个variant，再作this用。\n\n所以我们一般将之定义成友元函数，像下面这样：\n\nclass variant\n{\npublic:\n    variant(const int& value = 0) {}\n \n    friend const variant operator* (const variant&lhs, const variant& rhs);\n};\n \nconst variant operator* (const variant&lhs, const variant& rhs) \n{\n    return variant();\n}\n \n//使用方式\nvariant val(1);             //ok\nvariant result = val * 1;   //ok\nresult = 2 * val;           //ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n现在引入模板，可以像下面这样写，注意这里的operator*是一个独立的模板函数：\n\ntemplate<typename t>\nclass variant\n{\npublic:\n    variant(const t& value = 0) {}\n};\n \ntemplate<typename t>\nconst variant<t> operator* (const variant<t>&lhs, const variant<t>& rhs)\n{\n    return variant<t>();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n但是这次不能通过编译并且在vs2015下的报错信息：\n\nc2784   “const variant<t> operator *(const variant<t> &,const variant<t> &)”: 未能从“int”为“const variant<t> &”推导 模板 参数 \n\n\n1\n\n\n原因是编译器推导t出现了困难，val * 1在编译器看来，可以由a是variant将t推导成int，但是1是什么，理想情况下编译器会尝试将它先转换成一个variant，并将t推导成int，但事实上编译器在“t推导过程中从不将隐式类型转换函数纳入考虑”。所以无论是val * 1还是1 * val 都是不能通过编译的，一句话，隐式转换+推导t不能被同时被编译器接受。\n\n解决问题的思路便接着产生，编译器既然不能同时接受这两个过程，就让它们事先满足好一个条件，再由编译器执行另一个过程好了。\n\n如果把这个operator*放在template class里面，也就是先在生成模板类的那一步就定下t，这样编译器只要执行隐式转换这一步就可以了。\n\n因此我们可以这样来改：\n\ntemplate<typename t>\nclass variant\n{\npublic:\n    variant(const t& value = 0) {}\n \n    friend const variant<t> operator* (const variant<t>&lhs, const variant<t>& rhs);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在类中加一个友元。\n\n我们添加了一个友元函数的声明，果然编译通过了，但链接时又报错了，原因是链接器找不到operator*的定义，这里又要说模板类中的一个特殊情况了，它不同与普通的类，模板类的友元函数只能在类中实现，所以要把函数体部分移至到类内，像下面这样：\n\ntemplate<typename t>\nclass variant\n{\npublic:\n    variant(const t& value = 0) {}\n \n    friend const variant<t> operator* (const variant<t>&lhs, const variant<t>& rhs)\n    {\n        return variant<t>();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这下编译和链接都没有问题了。这里还要说一下，就是移至类内后，t的标识符可以不写了。\n\noperator里面只有一句话，但如果friend函数里面的东西太多了，可以定义一个辅助方法，比如doxxx()，这个doxxx可以放在类外去实现，doxxx本身不支持混合乘法（2 * variant或者variant 2），但由于在operator*里面已经进行了隐式类型转换，所以到doxxx()这一级是没有问题的。\n\n==请记住：==\n\n * ==当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。==\n\n\n# 条款47:请使用traits classes表现类型信息\n\n\n# 1、如果想写一个将迭代器移动d单位的函数\n\ntemplate<template itert,typename distt>\nvoid advance(itert& iter,distt d);//d>0前移，d<0后移\n\n\n1\n2\n\n\n具体过程该怎么写呢？直接写 iter += d 是行不通的，因为这种只有random acces（随机访问）迭代器才支持+=的操作，而其他威力不那么强大的迭代器种类，advance必须反复施行 ++ 或 --，共d次。\n\n\n# 2、stl迭代器一共有5类\n\n * input迭代器：**只能向前移动，一次一步，只能读取。**例如，模仿指向输入文件的读指针(read pointer)。cpp程序库中的istream_iterators是这一分类的代表。\n\n * output迭代器：**只能向前移动，一次一步，只能写。**例如，模仿指向输出文件的写指针(write pointer)。cpp程序库中的ostream_iterators是这一分类的代表。\n\n> 以上两种迭代器是威力最小的两个迭代器分类。因为一次只能一步，所以它们只适合“一次性操作算法”\n\n * forward迭代器：可以做前述两种迭代器所能做的每一件事，而且可以读写其所指物一次以上，因此可施行于“多次性操作算法”，tr1 hashed容器可能是这一分类（这里说“可能”是因为hashed容器的迭代器可为单向也可为双向，取决于实现版本）。\n\n * bidirectional迭代器：**除了可前移还可后移。**stl的list迭代器就属于这一分类，set，multiset，map和multimap的迭代器也都是这一分类。\n\n * random access迭代器：**威力最大的迭代器，可以执行“迭代器算术”，因此可在常量时间内前后随机移动任意的距离。**vector，deque和string提供的迭代器都是这一分类。有时内置指针也可被当做random access 迭代器使用。\n\n对于这5类，cpp标准库分别提供tag struct（卷标结构）加以确认\n\nstruct input_iterator_tag{};\nstruct output_iterator_tag{};\nstruct forward_iterator_tag :public input_iterator_tag{};\nstruct bidirectional_iterator_tag :public forward_iterator_tag{};\nstruct random_access_iterator_tag :public bidirectional_iterator_tag{};\n\n\n1\n2\n3\n4\n5\n\n\n在写advance函数时前4类迭代器可以使用++，--，而最后一个可以使用iter+=d,所以我们就需要在编译期取得类型信息，知道是哪一种迭代器.\n\n\n# 3、解决方式就是利用iterator_traits\n\ntemplate<typename itert> struct iterator_traits;//template,用来处理迭代器分类的相关信息\n\niterator_traits的运作方式是，针对每一个itert,在struct iterator_traits<itert>内一定声明某个typedef名为iterator_category。这个typedef用来确认itert的迭代器分类。即首先要求用户自定义的迭代器类型必须嵌套一个typedef，名为iterator_category,用来确认适当的卷标结构\n\n例如\n\ntemplate<...>\nclass deque{\npublic:\n\tclass iterator{\n\tpublic:\n\t\ttypedef random_access_iterator_tag iterator_category;\n\t};\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\niterator_traits只是响应iterator class的嵌套式typedef\n\ntemplate<typename itert>\nstruct iterator_traits{\n\ttypedef typename itert::iterator_category iterator_category;\n};\n//针对指针,偏特化\ntemplate<typename itert>\nstruct iterator_traits<itert*>{\n\ttypedef typename itert::iterator_category iterator_category;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n迭代器移动函数可这样实现\n\ntemplate<typename itert,typename distt>\nvoid doadvance(itert& iter, distt d, std::bidirectional_iterator_tag)\n{\n\tif (d >= 0) \n\t{\n\t\twhile (d--)\n\t\t\t++iter;\n\t}\n\telse\n\t{\n\t\twhile (d++)\n\t\t\t--iter;\n\t}\n}\ntemplate<typename itert, typename distt>\nvoid doadvance(itert& iter, distt d, std::input_iterator_tag)\n{\n\tif (d < 0)\n\t\tthrow std::out_of_range("negative distance");\n\twhile(d--) ++iter;\n}\ntemplate<typename itert, typename distt>\nvoid advance(itert& iter, distt d)\n{\n\tdoadvance(iter, d, typename std::iterator_traits<itert>::iterator_category);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n==请记住==\n\n * ==traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现==\n * ==整合重载技术后，traits classes有可能在编译期对类型执行if...else测试==\n\n\n# 条款48：认识template元编程\n\n\n# 1、内容\n\n 1. template metaprogramming（tmp，模板元编程）是：编写 template cpp 程序并执行于编译期的过程。所谓模板元程序就是：以 cpp 写成，执行于 cpp 编译器内的程序。该程序执行后产生具现的代码，和正常代码一并加入编译。也就说元编程可以做到用代码去生成代码。\n\n 2. tmp 伟大之处在于，由于 template metaprograms 执行于 cpp 编译期，因此可以将很多工作从运行期转移到编译期。例如：\n    \n    * 某些错误原本通常在运行期才能检测到，现在可在编译器找出来。\n    \n    * 使用 tmp 的 cpp 程序可能在每一方面都更加高效：比如较小的可执行文件，较短的运行期，较少的内存需求。\n\n 3. 在条款 47 我们曾提到如何实现一个 move 函数：\n    \n    template <typename iteratortype>\n    void move(iteratortype& iterator, int distance) {\n        // 使用类型信息\n        if (typeid(iteratortraits<iteratortype>::iteratortag) == typeid(randomaccessiteratortag)) {   \n            iterator += distance;\n        }\n        else {\n            if (distance >= 0) {\n                while (distance--)++iterator;\n            }\n            else {\n                while (distance++)--iterator;\n            }\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n    \n    并且我们曾描述这可能存在编译问题，现在就让我们看看是什么：虽然我们这里根据迭代器类型进行不同的操作，或 +=，或 ++，–，我们知道只有 random access iterator 可以有 += 运算，但是 cpp 要求：编译器必须确保所有源码都有效，即使是不会执行的源码。也就是说编译器会拿着其他不支持 += 的迭代器，进入 if 语句先测试是否支持 += 运算，无效则会报错。\n    \n    所以相比于要支持所有操作，traits class 针对不同类型进行函数重载的做法显然更好。\n\n 4. 我们先简单了解一下 tmp 编程。tmp 已被证明是一个图灵完备（turing-complete）机器，这意味着它可以计算任何事物，使用 tmp 你可以声明变量，执行循环，编写及调用函数…但这些相对于正常的 cpp 的实现会有很大的不同。比如：tmp 并没有循环部件，所有的循环效果都由递归完成。如果你不了解递归，恐怕必须先解决这个问题。\n\n 5. 一个经典的入门案例是使用 tmp 计算阶乘：\n    \n    template <unsigned n>\n    struct factorial {\n        static const int value = n * factorial<n - 1>::value;\n    };\n    \n    template <>\n    struct factorial<0> {\n        static const int value = 1;\n    };\n    \n    inline void trywithfactorial() {\n        std::cout << factorial<10>::value << "\\n";\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    \n    和所有递归行为一样，我们需要一个特殊情况来结束递归。对于 tmp 而言就是使用 template 的特化版本。\n    \n    正如 trywithfactorial 函数所使用的，只要你声明factorial<n>::value 就可以得到 n 阶乘值。当然这里存在值溢出的问题。\n\n 6. tmp 目前是一个新生的技术，语法不直观，也缺少 template 相关的调试器，但它将运行期工作移至编译期所带来的效率提升还是很令人印象深刻。\n\n\n# 2、 总结\n\n==请记住：==\n\n * ==template metaprogramming（tmp，模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率。==\n * ==tmp 可被用来生成基于政策选择组合（based on combination of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不合适的代码。==',charsets:{cjk:!0}},{title:"第4章 Cpp多线程系统编程精要",frontmatter:{title:"第4章 Cpp多线程系统编程精要",date:"2023-12-01T17:22:20.000Z",permalink:"/pages/6b2468/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/40.muduo%E7%BD%91%E7%BB%9C%E5%BA%93/01.%E7%AC%AC4%E7%AB%A0%20C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%B2%BE%E8%A6%81.html",relativePath:"01.CPP语言/40.muduo网络库/01.第4章 C++多线程系统编程精要.md",key:"v-53af30f2",path:"/pages/6b2468/",lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.47,time:148200.00000000003,words:494},headersStr:null,content:'# 第4章 Cpp多线程系统编程精要\n\n\n# 4.1 引言\n\n学习多线程编程面临的最大的思维方式的转变有以下两点：\n\n * 当前线程可能随时会被切换出去，或者说被抢占（preempt）了\n * 多线程程序中事件的发生顺序不再有全局统一的先后关系\n\n多线程程序的正确性不能依赖于任何一个线程的执行速度，不能通过原地等待 sleep() 来假定其他线程的事件已经发生，而必须通过适当的同步来让当前线程能看到其他线程的事件的结果。无论线程执行得快与慢（被操作系统切换出去得越多，执行越慢），程序都应该能正常工作。\n\n例如下面这段代码就有这方面的问题。\n\nbool running = false;//全局标志\nvoid threadFunc() {\n    while(running){\n        //get task from queue\n    }\n}\nvoid start() {\n\tmuduo::Thread t(threadFunc);\n    t.start();\n    running = true;//应该放到t.start()之前\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 这段代码暗中假定线程函数的启动慢于running变量的赋值，因此线程函数能进入while循环执行我们想要的功能。\n * 但是，直到有一天，系统负载很高，Thread::start()调用pthread_create()陷入内核后返回时，内核决定换另外一个就绪任务来执行。于是running的赋值就推迟了，这时线程函数就可能不进入while循环而直接退出了。\n * 有人会认为在while之前加一小段延时（sleep）就能解决问题，但这是错的，无论加多大的延时，系统都有可能先执行while的条件判断，然后再执行running的赋值。\n * 正确的做法是把running的赋值放到t.start()之前，这样借助pthread_create()的happens-before语意来保证running的新值能被线程看到。\n\n\n# 4.2 基本线程原语的选用\n\n> POSIX threads的函数有110多个，真正常用的不过十几个。而且在 Cpp 程序中通常会有更为易用的 wrapper, 不会直接调用 Pthreads 函数。\n\n这11个最基本的Pthreads函数是：\n\n * 2个：线程的创建和等待结束（join）。封装为 muduo::Thread。\n * 4个：mutex的创建、销毁、加锁、解锁。封装为 muduo::MutexLock。\n * 5个：条件变量的创建、销毁、等待、通知、广播。封装为 muduo::Condition。\n\n用这三样东西（thread、mutex、condition）可以完成任何多线程编程任务。当然我们一般也不会直接使用它们（mutex除外），而是使用更高层的封装，例如 mutex::ThreadPool 和 mutex::CountDownLatch 等。\n\n除此之外，Pthreads 还提供了其他一些原语，有些是可以酌情使用的，有些则是不推荐使用的。\n\n可以酌情使用的有:\n\n * pthread_once, 封装为 muduo::Singleton<T>。其实不如直接用全局变量。\n * pthread_key*, 封装为 muduo::ThreadLocal<T>。可以考虑用 __thread 替换之。\n\n不建议使用:\n\n * pthread_rwlock，读写锁通常应慎用。muduo没有封装读写锁，这是有意的。\n * sem_*，避免用信号量（semaphore）。它的功能与条件变量重合，但容易用错。\n * pthread_{cancel, kill}。程序中出现了它们，则通常意味着设计出了问题。\n\n> 不推荐使用读写锁的原因是它往往造成提高性能的错觉（允许多个线程并发读），实际上在很多情况下，与使用最简单的mutex相比，它实际上降低了性能。另外，写操作会阻塞读操作，如果要求优化读操作的延迟，用读写锁是不合适的。\n\n多线程系统编程的难点不在于学习线程原语（primitives），而在于理解多线程与现有的C/Cpp库函数和系统调用的交互关系，以进一步学习如何设计并实现线程安全且高效的程序。\n\n\n# 4.3 C/Cpp系统库的线程安全性\n\n> 现行的C/Cpp标准（C89/C99/Cpp03）并没有涉及线程。\n> \n> 新版的C/Cpp标准（C11和Cpp11）规定了程序在多线程下的语意，Cpp11还定义了一个线程库（std::thread）。\n\n对于标准而言，关键的不是定义线程库，而是规定内存模型（memory model）。特别是规定一个线程对某个共享变量的修改何时能被其他线程看到，这称为内存序（memory ordering）或者内存能见度（memory visibility）。\n\n线程的出现给出现在20世纪90年代Unix操作系统的系统函数库带来了冲击，破坏了20年来一贯的编程传统和假定。\n\n例如：\n\n * errno不再是一个全局变量，因为每个线程可能会执行不同的系统库函数。\n * 有些“纯函数”不受影响，例如memset/strcpy/snprintf等等。\n * 有些影响全局状态或者有副作用的函数可以通过加锁来实现线程安全，例如malloc/free、printf、fread/fseek等等。\n * 有些返回或使用静态空间的函数不可能做到线程安全，因此要提供另外的版本，例如asctime_r/ctime_r/gmtime_r、stderror_r、strtok_r等等。\n * 传统的 fork() 并发模型不再适用于多线程程序\n\n现在 Linux glibc 把 errno 定义为一个宏，注意 errno 是一个 lvalue，因此不能简单定义为某个函数的返回值，而必须定义为对函数返回指针的 dereference。\n\nextern int *__errno_location(void);\n#define errno (*__errno_location())\n\n\n1\n2\n\n\n现在 glibc 库函数大部分都是线程安全的。特别是 FILE* 系列函数是安全的，glibc 甚至提供了非线程安全的版本以应对某些特殊场合的性能需求。\n\n尽管单个函数是线程安全的，但两个或多个函数放到一起就不再安全了。\n\n> 例如 fseek() 和 fread() 都是安全的\n\n * 但是对某个文件“先seek再read”这两步操作中间有可能会被打断，其他线程有可能趁机修改了文件的当前位置，让程序逻辑无法正确执行。\n * 在这种情况下，我们可以用flockfile(FILE*)和funlockfile(FILE*)函数来显式地加锁。并且由于FILE*的锁是可重入的，加锁之后再调用fread()不会造成死锁。\n\n如果程序直接使用 lseek 和 read 这两个系统调用来随机读取文件，也存在 “先 seek 再 read” 这种race condition，但是似乎我们无法高效地对系统调用加锁。解决办法是改用pread系统调用，它不会改变文件的当前位置。\n\n由此可见，编写线程安全程序的一个难点在于线程安全是不可组合的（composable），一个函数foo()调用了两个线程安全的函数，而这个foo()函数本身很可能不是线程安全的。即便现在大多数glibc库函数是线程安全的，我们也不能像写单线程程序那样编写代码。\n\n例如，在单线程程序中，如果我们要临时转换时区，可以用tzset()函数，这个函数会改变程序全局的“当前时区”。\n\n// 保存当前的时区设置\nstring oldTz = getenv("TZ");\n// 设置时区为欧洲伦敦 (Europe/London)\nputenv("TZ=Europe/London");\n// 更新时区设置\ntzset();\n\n// 定义一个结构体用于存储伦敦的本地时间\nstruct tm localTimeInLN;\n// 获取当前时间戳\ntime_t now = time(NULL);\n// 将当前时间戳转换为伦敦时区的本地时间，并存储在localTimeInLN 中\nlocaltime_r(&now, &localTimeInLN);\n// 恢复之前保存的时区设置\nsetenv("TZ", oldTz.c_str(), 1);\n// 更新时区设置，使其回到之前的设置\ntzset();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n但是在多线程程序中，这么做不是线程安全的，即便tzset()本身是线程安全的。\n\n因为它改变了全局状态（当前时区），这有可能影响其他线程转换当前时间，或者被其他进行类似操作的线程影响。\n\n解决办法是使用 muduo::TimeZone class ，每个 immutable instance 对应一个时区，这样时间转换就不需要修改全局状态了。\n\n例如：\n\n// 自定义 TimeZone 类\nclass TimeZone {\npublic:\n    // 构造函数，接受时区文件路径\n    explicit TimeZone(const char* zonefile);\n    // 将时间戳转换为特定时区的本地时间\n    struct tm toLocalTime(time_t secondsSinceEpoch) const;\n    // 将特定时区的本地时间转换为时间戳\n    time_t fromLocalTime(const struct tm&) const;\n    // 其他可能的成员函数...\n};\n\n// 定义常量表示纽约时区和伦敦时区\nconst TimeZone kNewYorkTz("/usr/share/zoneinfo/America/New_York");\nconst TimeZone kLondonTz("/usr/share/zoneinfo/Europe/London");\n\n// 获取当前时间戳\ntime_t now = time(NULL);\n// 将当前时间戳转换为纽约时区的本地时间\nstruct tm localTimeInNY = kNewYorkTz.toLocalTime(now);\n// 将当前时间戳转换为伦敦时区的本地时间\nstruct tm localTimeInLN = kLondonTz.toLocalTime(now);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n一个基本思路是尽量把 class 设计成 immutable 的,这样用起来就不必为线程安全操心了。\n\n尽管Cpp03标准没有明说标准库的线程安全性，但我们可以遵循。\n\n- 一个基本原则：凡是非共享的对象都是彼此独立的,如果一个对象从始至终只被一个线程用到，那么它就是安全的。\n\n- 一个事实标准：共享的对象的 read-only 操作是安全的,前提是不能有并发的写操作。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n例如\n\n * 两个线程各自访问自己的局部 vector 对象是安全的；\n * 同时访问共享的 const vector 对象也是安全的，但是这个 vector 不能被第三个线程修改。一旦有 writer，那么 read-only 操作也必须加锁，例如 vector::size()。\n\nCpp 的标准库容器和 std::string 都不是线程安全的，只有 td::allocator 保证是线程安全的。一方面的原因是为了避免不必要的性能开销，另一方面的原因是单个成员函数的线程安全并不具备可组合性（composable）。\n\n假设有safe_vector<T>class，它的接口与std::vector相同，不过每个成员函数都是线程安全的（类似 Javasynchronized 方法）。但是用 safe_vector<T> 并不一定能写出线程安全的代码。\n\n例如：\n\nsafe_vector<int> vec;//全局可见\nif(!vec.empty()) { //没有加锁保护\n    int x = vec[0];//这两步在多线程下是不安全的\n}\n\n\n1\n2\n3\n4\n\n\n在if语句判断vec非空之后，别的线程可能清空其元素，从而造成vec[0]失效。\n\nCpp 标准库中的绝大多数泛型算法是线程安全的，因为这些都是无状态纯函数。只要输入区间是线程安全的，那么泛型函数就是线程安全的。\n\nCpp 的 iostream 不是线程安全的，因为流式输出\n\nstd::cout << "Now is " << time(NULL);\n\n\n1\n\n\n等价于两个函数调用\n\nstd::cout.operator<<("Now is ").operator<<(time(NULL));\n\n\n1\n\n\n即便 ostream::operator<<() 做到了线程安全，也不能保证其他线程不会在两次函数调用之前向 stdout 输出其他字符。\n\n对于“线程安全的 stdout 输出”这个需求，我们可以改用 printf，以达到安全性和输出的原子性。但是这等于用了全局锁，任何时刻只能有一个线程调用 printf，恐怕不见得高效。\n\n\n# 4.4 Linux上的线程标识\n\nPOSIX threads 库提供了 pthread_self 函数用于返回当前进程的标识符，其类型为 pthread_t。pthread_t 不一定是一个数值类型（整数或指针），也有可能是一个结构体，因此 Pthreads 专门提供了pthread_equal 函数用于对比两个线程标识符是否相等。\n\n这就带来一系列问题，包括：\n\n * 无法打印输出 pthread_t ，因为不知道其确切类型。也就没法在日志中用它表示当前线程的 id。\n * 无法比较 pthread_t 的大小或计算其 hash 值，因此无法用作关联容器的 key。\n * 无法定义一个非法的 pthread_t 值，用来表示绝对不可能存在的线程id，因此 MutexLock class 没有办法有效判断当前线程是否已经持有本锁。\n * pthread_t 值只在进程内有意义，与操作系统的任务调度之间无法建立有效关联。比方说在/proc文件系统中找不到 pthread_t 对应的 task。\n\nglibc的Pthreads实现实际上把 pthread_t 用作一个结构体指针（它的类型是unsigned long），指向一块动态分配的内存，而且这块内存是反复使用的。\n\n这就造成 pthread_t 的值很容易重复。Pthreads 只保证同一进程之内，同一时刻的各个线程的 id 不同；不能保证同一进程先后多个线程具有不同的 id，更不要说一台机器上多个进程之间的 id 唯一性了。\n\n例如下面这段代码中先后两个线程的标识符是相同的：\n\nint main(){\n    pthread_t t1,t2;\n    pthread_create(&t1,NULL,threadFunc,NULL);\n    printf("%lx\\n",t1);\n    pthread_join(t1,NULL);\n    pthread_create(&t2,NULL,threadFunc,NULL);\n    printf("%lx\\n",t2);\n    pthread_join(t2,NULL);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n$ ./a.out\n7fad11787700\n7fad11787700\n\n\n1\n2\n3\n\n\n因此，pthread_t 并不适合用作程序中对线程的标识符。\n\n在Linux上，作者建议使用gettid系统调用的返回值作为线程id，这么做的好处有：\n\n * 它的类型是 pid_t，其值通常是一个小整数 13，便于在日志中输出。\n * 在现代 Linux 中，它直接表示内核的任务调度id，因此在 /proc 文件系统中可以轻易找到对应项：/proc/tid或 /prod/pid/task/tid。\n * 在其他系统工具中也容易定位到具体某一个线程，例如在top中我们可以按线程列出任务，然后找出CPU 使用率最高的线程 id，再根据程序日志判断到底哪一个线程在耗用 CPU。\n * 任何时刻都是全局唯一的，并且由于 Linux 分配新 pid 采用递增轮回办法，短时间内启动的多个线程也会具有不同的线程 id。\n * 0 是非法值，因为操作系统第一个进程 init 的 pid 是 1。\n\n但是 glibc 并没有封装这个系统调用，需要我们自己实现。\n\n作者封装的 gettid 的方法如下：\n\nmuduo::CurrentThread::tid() 采取的办法是用 __thread 变量来缓存 gettid 的返回值，这样只有在本线程第一次调用的时候才进行系统调用，以后都是直接从 thread local 缓存的线程 id 拿到结果，效率无忧。\n\n未完待续。。。',normalizedContent:'# 第4章 cpp多线程系统编程精要\n\n\n# 4.1 引言\n\n学习多线程编程面临的最大的思维方式的转变有以下两点：\n\n * 当前线程可能随时会被切换出去，或者说被抢占（preempt）了\n * 多线程程序中事件的发生顺序不再有全局统一的先后关系\n\n多线程程序的正确性不能依赖于任何一个线程的执行速度，不能通过原地等待 sleep() 来假定其他线程的事件已经发生，而必须通过适当的同步来让当前线程能看到其他线程的事件的结果。无论线程执行得快与慢（被操作系统切换出去得越多，执行越慢），程序都应该能正常工作。\n\n例如下面这段代码就有这方面的问题。\n\nbool running = false;//全局标志\nvoid threadfunc() {\n    while(running){\n        //get task from queue\n    }\n}\nvoid start() {\n\tmuduo::thread t(threadfunc);\n    t.start();\n    running = true;//应该放到t.start()之前\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 这段代码暗中假定线程函数的启动慢于running变量的赋值，因此线程函数能进入while循环执行我们想要的功能。\n * 但是，直到有一天，系统负载很高，thread::start()调用pthread_create()陷入内核后返回时，内核决定换另外一个就绪任务来执行。于是running的赋值就推迟了，这时线程函数就可能不进入while循环而直接退出了。\n * 有人会认为在while之前加一小段延时（sleep）就能解决问题，但这是错的，无论加多大的延时，系统都有可能先执行while的条件判断，然后再执行running的赋值。\n * 正确的做法是把running的赋值放到t.start()之前，这样借助pthread_create()的happens-before语意来保证running的新值能被线程看到。\n\n\n# 4.2 基本线程原语的选用\n\n> posix threads的函数有110多个，真正常用的不过十几个。而且在 cpp 程序中通常会有更为易用的 wrapper, 不会直接调用 pthreads 函数。\n\n这11个最基本的pthreads函数是：\n\n * 2个：线程的创建和等待结束（join）。封装为 muduo::thread。\n * 4个：mutex的创建、销毁、加锁、解锁。封装为 muduo::mutexlock。\n * 5个：条件变量的创建、销毁、等待、通知、广播。封装为 muduo::condition。\n\n用这三样东西（thread、mutex、condition）可以完成任何多线程编程任务。当然我们一般也不会直接使用它们（mutex除外），而是使用更高层的封装，例如 mutex::threadpool 和 mutex::countdownlatch 等。\n\n除此之外，pthreads 还提供了其他一些原语，有些是可以酌情使用的，有些则是不推荐使用的。\n\n可以酌情使用的有:\n\n * pthread_once, 封装为 muduo::singleton<t>。其实不如直接用全局变量。\n * pthread_key*, 封装为 muduo::threadlocal<t>。可以考虑用 __thread 替换之。\n\n不建议使用:\n\n * pthread_rwlock，读写锁通常应慎用。muduo没有封装读写锁，这是有意的。\n * sem_*，避免用信号量（semaphore）。它的功能与条件变量重合，但容易用错。\n * pthread_{cancel, kill}。程序中出现了它们，则通常意味着设计出了问题。\n\n> 不推荐使用读写锁的原因是它往往造成提高性能的错觉（允许多个线程并发读），实际上在很多情况下，与使用最简单的mutex相比，它实际上降低了性能。另外，写操作会阻塞读操作，如果要求优化读操作的延迟，用读写锁是不合适的。\n\n多线程系统编程的难点不在于学习线程原语（primitives），而在于理解多线程与现有的c/cpp库函数和系统调用的交互关系，以进一步学习如何设计并实现线程安全且高效的程序。\n\n\n# 4.3 c/cpp系统库的线程安全性\n\n> 现行的c/cpp标准（c89/c99/cpp03）并没有涉及线程。\n> \n> 新版的c/cpp标准（c11和cpp11）规定了程序在多线程下的语意，cpp11还定义了一个线程库（std::thread）。\n\n对于标准而言，关键的不是定义线程库，而是规定内存模型（memory model）。特别是规定一个线程对某个共享变量的修改何时能被其他线程看到，这称为内存序（memory ordering）或者内存能见度（memory visibility）。\n\n线程的出现给出现在20世纪90年代unix操作系统的系统函数库带来了冲击，破坏了20年来一贯的编程传统和假定。\n\n例如：\n\n * errno不再是一个全局变量，因为每个线程可能会执行不同的系统库函数。\n * 有些“纯函数”不受影响，例如memset/strcpy/snprintf等等。\n * 有些影响全局状态或者有副作用的函数可以通过加锁来实现线程安全，例如malloc/free、printf、fread/fseek等等。\n * 有些返回或使用静态空间的函数不可能做到线程安全，因此要提供另外的版本，例如asctime_r/ctime_r/gmtime_r、stderror_r、strtok_r等等。\n * 传统的 fork() 并发模型不再适用于多线程程序\n\n现在 linux glibc 把 errno 定义为一个宏，注意 errno 是一个 lvalue，因此不能简单定义为某个函数的返回值，而必须定义为对函数返回指针的 dereference。\n\nextern int *__errno_location(void);\n#define errno (*__errno_location())\n\n\n1\n2\n\n\n现在 glibc 库函数大部分都是线程安全的。特别是 file* 系列函数是安全的，glibc 甚至提供了非线程安全的版本以应对某些特殊场合的性能需求。\n\n尽管单个函数是线程安全的，但两个或多个函数放到一起就不再安全了。\n\n> 例如 fseek() 和 fread() 都是安全的\n\n * 但是对某个文件“先seek再read”这两步操作中间有可能会被打断，其他线程有可能趁机修改了文件的当前位置，让程序逻辑无法正确执行。\n * 在这种情况下，我们可以用flockfile(file*)和funlockfile(file*)函数来显式地加锁。并且由于file*的锁是可重入的，加锁之后再调用fread()不会造成死锁。\n\n如果程序直接使用 lseek 和 read 这两个系统调用来随机读取文件，也存在 “先 seek 再 read” 这种race condition，但是似乎我们无法高效地对系统调用加锁。解决办法是改用pread系统调用，它不会改变文件的当前位置。\n\n由此可见，编写线程安全程序的一个难点在于线程安全是不可组合的（composable），一个函数foo()调用了两个线程安全的函数，而这个foo()函数本身很可能不是线程安全的。即便现在大多数glibc库函数是线程安全的，我们也不能像写单线程程序那样编写代码。\n\n例如，在单线程程序中，如果我们要临时转换时区，可以用tzset()函数，这个函数会改变程序全局的“当前时区”。\n\n// 保存当前的时区设置\nstring oldtz = getenv("tz");\n// 设置时区为欧洲伦敦 (europe/london)\nputenv("tz=europe/london");\n// 更新时区设置\ntzset();\n\n// 定义一个结构体用于存储伦敦的本地时间\nstruct tm localtimeinln;\n// 获取当前时间戳\ntime_t now = time(null);\n// 将当前时间戳转换为伦敦时区的本地时间，并存储在localtimeinln 中\nlocaltime_r(&now, &localtimeinln);\n// 恢复之前保存的时区设置\nsetenv("tz", oldtz.c_str(), 1);\n// 更新时区设置，使其回到之前的设置\ntzset();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n但是在多线程程序中，这么做不是线程安全的，即便tzset()本身是线程安全的。\n\n因为它改变了全局状态（当前时区），这有可能影响其他线程转换当前时间，或者被其他进行类似操作的线程影响。\n\n解决办法是使用 muduo::timezone class ，每个 immutable instance 对应一个时区，这样时间转换就不需要修改全局状态了。\n\n例如：\n\n// 自定义 timezone 类\nclass timezone {\npublic:\n    // 构造函数，接受时区文件路径\n    explicit timezone(const char* zonefile);\n    // 将时间戳转换为特定时区的本地时间\n    struct tm tolocaltime(time_t secondssinceepoch) const;\n    // 将特定时区的本地时间转换为时间戳\n    time_t fromlocaltime(const struct tm&) const;\n    // 其他可能的成员函数...\n};\n\n// 定义常量表示纽约时区和伦敦时区\nconst timezone knewyorktz("/usr/share/zoneinfo/america/new_york");\nconst timezone klondontz("/usr/share/zoneinfo/europe/london");\n\n// 获取当前时间戳\ntime_t now = time(null);\n// 将当前时间戳转换为纽约时区的本地时间\nstruct tm localtimeinny = knewyorktz.tolocaltime(now);\n// 将当前时间戳转换为伦敦时区的本地时间\nstruct tm localtimeinln = klondontz.tolocaltime(now);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n一个基本思路是尽量把 class 设计成 immutable 的,这样用起来就不必为线程安全操心了。\n\n尽管cpp03标准没有明说标准库的线程安全性，但我们可以遵循。\n\n- 一个基本原则：凡是非共享的对象都是彼此独立的,如果一个对象从始至终只被一个线程用到，那么它就是安全的。\n\n- 一个事实标准：共享的对象的 read-only 操作是安全的,前提是不能有并发的写操作。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n例如\n\n * 两个线程各自访问自己的局部 vector 对象是安全的；\n * 同时访问共享的 const vector 对象也是安全的，但是这个 vector 不能被第三个线程修改。一旦有 writer，那么 read-only 操作也必须加锁，例如 vector::size()。\n\ncpp 的标准库容器和 std::string 都不是线程安全的，只有 td::allocator 保证是线程安全的。一方面的原因是为了避免不必要的性能开销，另一方面的原因是单个成员函数的线程安全并不具备可组合性（composable）。\n\n假设有safe_vector<t>class，它的接口与std::vector相同，不过每个成员函数都是线程安全的（类似 javasynchronized 方法）。但是用 safe_vector<t> 并不一定能写出线程安全的代码。\n\n例如：\n\nsafe_vector<int> vec;//全局可见\nif(!vec.empty()) { //没有加锁保护\n    int x = vec[0];//这两步在多线程下是不安全的\n}\n\n\n1\n2\n3\n4\n\n\n在if语句判断vec非空之后，别的线程可能清空其元素，从而造成vec[0]失效。\n\ncpp 标准库中的绝大多数泛型算法是线程安全的，因为这些都是无状态纯函数。只要输入区间是线程安全的，那么泛型函数就是线程安全的。\n\ncpp 的 iostream 不是线程安全的，因为流式输出\n\nstd::cout << "now is " << time(null);\n\n\n1\n\n\n等价于两个函数调用\n\nstd::cout.operator<<("now is ").operator<<(time(null));\n\n\n1\n\n\n即便 ostream::operator<<() 做到了线程安全，也不能保证其他线程不会在两次函数调用之前向 stdout 输出其他字符。\n\n对于“线程安全的 stdout 输出”这个需求，我们可以改用 printf，以达到安全性和输出的原子性。但是这等于用了全局锁，任何时刻只能有一个线程调用 printf，恐怕不见得高效。\n\n\n# 4.4 linux上的线程标识\n\nposix threads 库提供了 pthread_self 函数用于返回当前进程的标识符，其类型为 pthread_t。pthread_t 不一定是一个数值类型（整数或指针），也有可能是一个结构体，因此 pthreads 专门提供了pthread_equal 函数用于对比两个线程标识符是否相等。\n\n这就带来一系列问题，包括：\n\n * 无法打印输出 pthread_t ，因为不知道其确切类型。也就没法在日志中用它表示当前线程的 id。\n * 无法比较 pthread_t 的大小或计算其 hash 值，因此无法用作关联容器的 key。\n * 无法定义一个非法的 pthread_t 值，用来表示绝对不可能存在的线程id，因此 mutexlock class 没有办法有效判断当前线程是否已经持有本锁。\n * pthread_t 值只在进程内有意义，与操作系统的任务调度之间无法建立有效关联。比方说在/proc文件系统中找不到 pthread_t 对应的 task。\n\nglibc的pthreads实现实际上把 pthread_t 用作一个结构体指针（它的类型是unsigned long），指向一块动态分配的内存，而且这块内存是反复使用的。\n\n这就造成 pthread_t 的值很容易重复。pthreads 只保证同一进程之内，同一时刻的各个线程的 id 不同；不能保证同一进程先后多个线程具有不同的 id，更不要说一台机器上多个进程之间的 id 唯一性了。\n\n例如下面这段代码中先后两个线程的标识符是相同的：\n\nint main(){\n    pthread_t t1,t2;\n    pthread_create(&t1,null,threadfunc,null);\n    printf("%lx\\n",t1);\n    pthread_join(t1,null);\n    pthread_create(&t2,null,threadfunc,null);\n    printf("%lx\\n",t2);\n    pthread_join(t2,null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n$ ./a.out\n7fad11787700\n7fad11787700\n\n\n1\n2\n3\n\n\n因此，pthread_t 并不适合用作程序中对线程的标识符。\n\n在linux上，作者建议使用gettid系统调用的返回值作为线程id，这么做的好处有：\n\n * 它的类型是 pid_t，其值通常是一个小整数 13，便于在日志中输出。\n * 在现代 linux 中，它直接表示内核的任务调度id，因此在 /proc 文件系统中可以轻易找到对应项：/proc/tid或 /prod/pid/task/tid。\n * 在其他系统工具中也容易定位到具体某一个线程，例如在top中我们可以按线程列出任务，然后找出cpu 使用率最高的线程 id，再根据程序日志判断到底哪一个线程在耗用 cpu。\n * 任何时刻都是全局唯一的，并且由于 linux 分配新 pid 采用递增轮回办法，短时间内启动的多个线程也会具有不同的线程 id。\n * 0 是非法值，因为操作系统第一个进程 init 的 pid 是 1。\n\n但是 glibc 并没有封装这个系统调用，需要我们自己实现。\n\n作者封装的 gettid 的方法如下：\n\nmuduo::currentthread::tid() 采取的办法是用 __thread 变量来缓存 gettid 的返回值，这样只有在本线程第一次调用的时候才进行系统调用，以后都是直接从 thread local 缓存的线程 id 拿到结果，效率无忧。\n\n未完待续。。。',charsets:{cjk:!0}},{title:"第11章 线程同步",frontmatter:{title:"第11章 线程同步",date:"2023-12-01T17:22:47.000Z",permalink:"/pages/5f8c9f/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/50.Unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/11.%E7%AC%AC11%E7%AB%A0%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5.html",relativePath:"01.CPP语言/50.Unix环境高级编程/11.第11章 线程同步.md",key:"v-55759766",path:"/pages/5f8c9f/",headers:[{level:2,title:"1.1 举个栗子",slug:"_1-1-举个栗子",normalizedTitle:"1.1 举个栗子",charIndex:218},{level:2,title:"1.2 再举个栗子",slug:"_1-2-再举个栗子",normalizedTitle:"1.2 再举个栗子",charIndex:409},{level:2,title:"1.3 再再举个栗子",slug:"_1-3-再再举个栗子",normalizedTitle:"1.3 再再举个栗子",charIndex:558},{level:2,title:"1.4 其他情况",slug:"_1-4-其他情况",normalizedTitle:"1.4 其他情况",charIndex:1256},{level:2,title:"3.1 理解",slug:"_3-1-理解",normalizedTitle:"3.1 理解",charIndex:1402},{level:2,title:"3.2 函数",slug:"_3-2-函数",normalizedTitle:"3.2 函数",charIndex:1624},{level:3,title:"初始化",slug:"初始化",normalizedTitle:"初始化",charIndex:1668},{level:3,title:"加锁、解锁",slug:"加锁、解锁",normalizedTitle:"加锁、解锁",charIndex:2075},{level:2,title:"3.3 来个栗子",slug:"_3-3-来个栗子",normalizedTitle:"3.3 来个栗子",charIndex:2490},{level:2,title:"4.1 理解",slug:"_4-1-理解",normalizedTitle:"4.1 理解",charIndex:4531},{level:2,title:"4.2 函数",slug:"_4-2-函数",normalizedTitle:"4.2 函数",charIndex:4694},{level:3,title:"初始化",slug:"初始化-2",normalizedTitle:"初始化",charIndex:1668},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:5508},{level:2,title:"4.3 举个例子",slug:"_4-3-举个例子",normalizedTitle:"4.3 举个例子",charIndex:6845},{level:2,title:"5.1 引言",slug:"_5-1-引言",normalizedTitle:"5.1 引言",charIndex:8143},{level:2,title:"5.2 函数",slug:"_5-2-函数",normalizedTitle:"5.2 函数",charIndex:8602},{level:3,title:"初始化",slug:"初始化-3",normalizedTitle:"初始化",charIndex:1668},{level:3,title:"加锁、解锁",slug:"加锁、解锁-2",normalizedTitle:"加锁、解锁",charIndex:2075},{level:2,title:"5.3 举个栗子",slug:"_5-3-举个栗子",normalizedTitle:"5.3 举个栗子",charIndex:9628},{level:2,title:"6.1 理解",slug:"_6-1-理解",normalizedTitle:"6.1 理解",charIndex:12874},{level:2,title:"6.2 函数",slug:"_6-2-函数",normalizedTitle:"6.2 函数",charIndex:13158},{level:3,title:"初始化",slug:"初始化-4",normalizedTitle:"初始化",charIndex:1668},{level:3,title:"加锁、解锁",slug:"加锁、解锁-3",normalizedTitle:"加锁、解锁",charIndex:2075},{level:2,title:"7.1 引言",slug:"_7-1-引言",normalizedTitle:"7.1 引言",charIndex:14073},{level:2,title:"7.2 函数",slug:"_7-2-函数",normalizedTitle:"7.2 函数",charIndex:14262},{level:3,title:"初始化",slug:"初始化-5",normalizedTitle:"初始化",charIndex:1668},{level:2,title:"7.3 举个例子",slug:"_7-3-举个例子",normalizedTitle:"7.3 举个例子",charIndex:15146}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"8 min read",minutes:7.12,time:427200,words:1424},headersStr:"1.1 举个栗子 1.2 再举个栗子 1.3 再再举个栗子 1.4 其他情况 3.1 理解 3.2 函数 初始化 加锁、解锁 3.3 来个栗子 4.1 理解 4.2 函数 初始化 注意事项 4.3 举个例子 5.1 引言 5.2 函数 初始化 加锁、解锁 5.3 举个栗子 6.1 理解 6.2 函数 初始化 加锁、解锁 7.1 引言 7.2 函数 初始化 7.3 举个例子",content:'# 第11章 线程同步\n\n\n# 1、引言\n\n * 当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。\n * 如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。\n * 同样，如果变量是只读的，多个线程同时读取该变量也不会有一致性问题。\n\n但是，当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。\n\n\n# 1.1 举个栗子\n\n> 在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。\n\n\n\n图 11-7 描述了两个线程读写相同变量的假设例子。\n\n * 在这个例子中，线程 A读取变量然后给这个变量赋予一个新的数值，但写操作需要两个存储器周期。\n * 当线程B在这两个存储器写周期中间读取这个变量时，它就会得到不一致的值。\n\n\n# 1.2 再举个栗子\n\n为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。\n\n\n\n图11-8描述了这种同步。\n\n * 如果线程B希望读取变量，它首先要获取锁。\n * 同样，当线程A更新变量时，也需要获取同样的这把锁。\n * 这样，线程B在线程A释放锁以前就不能读取变量。\n\n\n# 1.3 再再举个栗子\n\n两个或多个线程试图在同一时间修改同一变量时，也需要进行同步。考虑 变量增量操作的情况（图11-9）\n\n增量操作通常分解为以下3步：\n\n 1. 从内存单元读入寄存器。\n 2. 在寄存器中对变量做增量操作。\n 3. 把新的值写回内存单元。\n\n\n\n如果两个线程试图几乎在同一时间对同一个变量做增量操作而不进行同步的话，结果就可能出现不一致。\n\n * 变量可能比原来增加了1，也有可能比原来增加了2，具体增加了1还是2要取决于第二个线程开始操作时获取的数值。\n * 如果第二个线程执行第1步要比第一个线程执行第3步要早，第二个线程读到的值与第一个线程一样，为变量加1，然后写回去，事实上没有实际的效果，总的来说变量只增加了1。\n\n如果修改操作是原子操作，那么就不存在竞争。\n\n在图 11-9 例子中，如果增加1只需要一个存储器周期，那么就没有竞争存在。\n\n * 如果数据总是以顺序一致出现的，就不需要额外的同步。\n * 当多个线程观察不到数据的不一致时，那么操作就是顺序一致的。\n\n> 但是，在现代计算机系统中，存储访问需要多个总线周期，多处理器的总线周期通常在多个处理器上是交叉的，所以我们并不能保证数据是顺序一致的。\n\n * 在顺序一致环境中，可以把数据修改操作解释为运行线程的顺序操作步骤。\n * 可以把这样的操作描述为“线程A对变量增加了1，然后线程B对变量增加了1，所以变量的值就比原来的大2”，或者描述为“线程B对变量增加了1，然后线程A对变量增加了1，所以变量的值就比原来的大2”。\n * 这两个线程的任何操作顺序都不可能让变量出现除了上述值以外的其他值。\n\n\n# 1.4 其他情况\n\n> 程序使用变量的方式也会引起竞争，也会导致不一致的情况发生。\n\n例如，我们可能对某个变量加 1，然后基于这个值做出某种决定。因为这个增量操作步骤和这个决定步骤的组合并非原子操作，所以就给不一致情况的出现提供了可能。\n\n\n# 2、线程同步方法\n\n\n# 3、互斥量\n\n\n# 3.1 理解\n\n * 互斥量（mutex）从本质上说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。\n * 对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。\n * 如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。\n\n\n# 3.2 函数\n\n> 互斥量是用pthread_mutex_t数据类型表示的。使用前必须先初始化\n\n\n# 初始化\n\n两种初始化方式：\n\n 1. 设置为常量：PTHREAD_MUTEX_INITIALIZER（只适用于静态分配）\n 2. 调用函数初始化：调用pthread_mutex_init函数初始化，如果动态分配互斥量（例如：通过调用malloc函数）在释放内存前需要调用pthread_mutex_destroy。\n\n#include <pthread.h>\nint pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexarrt_t *restrict attr);\n\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n\n\n1\n2\n3\n4\n\n * 返回值：成功返回0，失败返回错误编号。\n * 若使用默认属性初始化互斥量，attr设为NULL即可。\n\n\n# 加锁、解锁\n\n#include <pthread.h>\n//加锁\nint pthread_mutex_lock(pthread_mutex_t *mutex);\n//尝试加锁\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\n//解锁（上述两种加锁都用这个解锁）\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 返回值：成功为0，失败为错误编号。\n * 若线程不希望被阻塞，可用pthread_mutex_trylock尝试对互斥量加锁。\n   * 互斥量处于未锁住状态，那么pthread_mutex_trylock将锁住互斥量，不会出现阻塞直接返回0。\n   * 互斥量处于锁住状态，那么pthread_mutex_trylock将会失败，不能锁住互斥量，返回ebusy。\n\n\n# 3.3 来个栗子\n\n目的：使用互斥量保护数据结构\n\n当一个以上的线程需要访问动态分配的对象时，我们可以在对象中嵌入引用计数，确保在所有使用该对象的线程完成数据访问之前，该对象内存空间不会被释放。\n\n * 在对引用计数加 1、减 1、检查引用计数是否到达 0 这些操作之前需要锁住互斥量。\n * 在foo_alloc 函数中将引用计数初始化为 1 时没必要加锁，因为在这个操作之前分配线程是唯一引用该对象的线程。\n * 但是在这之后如果要将该对象放到一个列表中，那么它就有可能被别的线程发现，这时候需要首先对它加锁。\n * 在使用该对象前，线程需要调用foo_hold对这个对象的引用计数加1。\n * 当对象使用完毕时，必须调用foo_rele释放引用。最后一个引用被释放时，对象所占的内存空间就被释放。\n * 在这个例子中，我们忽略了线程在调用foo_hold之前是如何找到对象的。如果有另一个线程在调用foo_hold时阻塞等待互斥锁，这时即使该对象引用计数为0，foo_rele释放该对象的内存仍然是不对的。可以通过确保对象在释放内存前不会被找到这种方式来避免上述问题。可以通过下面的例子来看看如何做到这一点。\n\n#include <stdlib.h>        // 包含标准库，用于内存管理函数。\n#include <pthread.h>       // 包含pthread库，用于多线程支持。\n\nstruct foo {\n    int \t\t\tf_count;  // 一个整数字段，用于存储结构体的引用计数。\n    pthread_mutex_t f_lock;   // 用于控制对结构体的访问的互斥锁。\n    int \t\t\tf_id;     // 一个整数字段，用于存储结构体的标识符。\n};\n// 分配并初始化“foo”结构体的函数\nstruct foo* foo_alloc(int id) { \n    struct foo* fp;           \t// 声明一个指向“foo”结构体的指针。\n    if((fp = malloc(sizeof(struct foo))) != NULL) { // 为结构体分配内存。\n        fp->f_count = 1;       \t\t\t\t\t\t// 将引用计数初始化为1。\n        fp->f_id = id;         \t\t\t\t\t\t// 使用提供的ID初始化结构体的ID。\n        if(pthread_mutex_init(&fp->f_lock, NULL) != 0) { // 初始化互斥锁。\n            free(fp);           \t\t\t\t\t// 如果互斥锁初始化失败，释放内存。\n            return(NULL);       \t\t\t\t\t// 返回NULL以指示失败。\n        }\n    }\n    return(fp);                // 返回初始化的“foo”结构体。\n}\n// 增加“foo”结构体的引用计数的函数\nvoid foo_hold(struct foo* fp) {  \n    pthread_mutex_lock(&fp->f_lock); \t// 获取互斥锁以确保独占访问。\n    fp->f_count++;            \t\t\t// 增加引用计数。\n    pthread_mutex_unlock(&fp->f_lock); \t// 释放互斥锁。\n}\n// 释放“foo”结构体并可能释放其内存的函数\nvoid foo_rele(struct foo* fp) {  \n    pthread_mutex_lock(&fp->f_lock); \t\t// 获取互斥锁以确保独占访问。\n    if (--fp->f_count == 0) { \t\t\t\t// 如果引用计数减为0，则可以安全地释放结构体。\n        pthread_mutex_unlock(&fp->f_lock); \t// 释放互斥锁。\n        pthread_mutex_destory(&fp->f_lock); // 销毁互斥锁。\n        free(fp);           \t\t\t\t// 释放与“foo”结构体关联的内存。\n    } else {\n        pthread_mutex_unlock(&fp->f_lock);  // 如果引用计数不为零，释放互斥锁。\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 4、 条件变量\n\n\n# 4.1 理解\n\n条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。\n\n条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。\n\n\n# 4.2 函数\n\n\n# 初始化\n\n由pthread_cond_t数据类型表示\n\n两种初始化方式：\n\n * 静态分配：把常量PTHREAD_COND_INITIALIZER赋给静态分配的条件变量\n * 动态分配：需要使用pthread_cond_init函数对它进行初始化\n\n在释放条件变量底层的内存空间之前，可以使用pthread_cond_destroy函数对条件变量进行反初始化（deinitialize）\n\n#include <pthread.h>\nint pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);\nint pthread_cond_destroy(pthread_cond_t *cond);\n\n\n1\n2\n3\n\n\n两个函数的返回值：若成功，返回0；否则，返回错误编号\n\n除非需要创建一个具有非默认属性的条件变量，否则pthread_cond_init函数的attr参数可以设置为NULL。\n\n我们使用pthread_cond_wait等待条件变量变为真。如果在给定的时间内条件不能满足，那么会生成一个返回错误码的变量。\n\n#include <pthread.h>\nint pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);\nint pthread_cond_timedwait(pthread_cond_t * restrict cond,pthread_mutex_t *restrict mutex,const struct timespaec *restrict tsptr);\n\n\n1\n2\n3\n\n\n两个函数的返回值：若成功，返回0；否则，返回错误编号\n\n\n# 注意事项\n\n * 传递给pthread_cond_wait的互斥量对条件进行保护。\n * 调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。\n * pthread_cond_wait返回时，互斥量再次被锁住。\n * pthread_cond_timedwait函数的功能与pthread_cond_wait函数相似，只是多了一个超时（tsptr）。超时值指定了我们愿意等待多长时间，它是通过timespec结构指定的。这个时间值是一个绝对数而不是相对数。\n * 例如，假设愿意等待3分钟。那么，并不是把3分钟转换成timespec结构，而是需要把当前时间加上3分钟再转换成timespec结构。\n * 可以使用clock_gettime函数（见6.10节）获取timespec结构表示的当前时间。但是目前并不是所有的平台都支持这个函数，因此，也可以用另一个函数gettimeofday 获取timeval结构表示的当前时间，然后把这个时间转换成timespec结构。\n\n#include <sys/time.h>\n#include <stdlib.h>\nvoid maketimeout(struct timespec *tsp, long minutes) {\n    struct timeval now;\n    gettimeofday(&now,NULL);\n    tsp->tv_sec = now.tv_sec;\n    tsp->tv_nsec = now.tv_usec*1000;\n    tsp->tv_sec += minutes*60;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果超时到期时条件还是没有出现，pthread_cond_timewait 将重新获取互斥量，然后返回错误ETIMEDOUT。从pthread_cond_wait或者pthread_cond_timedwait调用成功返回时，线程需要重新计算条件，因为另一个线程可能已经在运行并改变了条件。\n\n有两个函数可以用于通知线程条件已经满足。pthread_cond_signal函数至少能唤醒一个等待该条件的线程，而pthread_cond_broadcast函数则能唤醒等待该条件的所有线程。\n\nPOSIX 规范为了简化 pthread_cond_signal 的实现，允许它在实现的时候唤醒一个以上的线程。\n\n#include <pthread.h>\nint pthread_cond_signal(pthread_cond_t *cond);\nint pthread_cond_broadcast(pthread_cond_t *cond);\n\n\n1\n2\n3\n\n\n两个函数的返回值：若成功，返回0；否则，返回错误编号\n\n在调用pthread_cond_signal或者pthread_cond_broadcast时，我们说这是在给线程或者条件发信号。必须注意，一定要在改变条件状态以后再给线程发信号。\n\n\n# 4.3 举个例子\n\n以下例子给出了如何结合使用条件变量和互斥量对线程进行同步。\n\n#include <pthread.h>\n\n// 定义消息结构体\nstruct msg {\n    struct msg* m_next;\n};\n\nstruct msg* workq; // 全局消息队列指针\n\npthread_cond_t qready = PTHREAD_COND_INITIALIZER; // 条件变量，用于通知等待中的线程\npthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER; // 互斥锁，用于保护消息队列\n\nvoid process_msg(void) {\n    struct msg* mp;\n    for (;;) {\n        pthread_mutex_lock(&qlock); // 获取互斥锁，保护对消息队列的访问\n        // 如果消息队列为空，等待条件变量\n        while (workq == NULL) {\n            pthread_cond_wait(&qready, &qlock);\n        }\n        mp = workq; // 获取队列头部的消息\n        workq = mp->m_next; // 更新队列头部指针，将头部消息出队\n        pthread_mutex_unlock(&qlock); // 释放互斥锁，允许其他线程访问消息队列\n    }\n}\n\nvoid enqueue_msg(struct msg* mp) {\n    pthread_mutex_lock(&qlock); // 获取互斥锁，保护对消息队列的访问\n    mp->m_next = workq; // 将新消息插入到队列头部\n    workq = mp; // 更新队列头部指针，将新消息设置为队列头部\n    pthread_mutex_unlock(&qlock); // 释放互斥锁，允许其他线程访问消息队列\n    pthread_cond_signal(&qready); // 发送信号，通知等待中的消费者线程有新消息可处理\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n * 条件是工作队列的状态。我们用互斥量保护条件，在 while 循环中判断条件。\n * 把消息放到工作队列时，需要占有互斥量，但在给等待线程发信号时，不需要占有互斥量。\n * 只要线程在调用pthread_cond_signal之前把消息从队列中拖出了，就可以在释放互斥量以后完成这部分工作。\n * 因为我们是在 while 循环中检查条件，所以不存在这样的问题：线程醒来，发现队列仍为空，然后返回继续等待。如果代码不能容忍这种竞争，就需要在给线程发信号的时候占有互斥量。\n\n\n# 5、 读写锁\n\n\n# 5.1 引言\n\n读写锁（reader-writer lock）与互斥量类似，不过读写锁允许更高的并行性。\n\n互斥锁只有两个状态：（一次只能由一个线程可以对其加锁）\n\n * 锁住状态\n * 不加锁状态\n\n读写锁可以有3中状态：（一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁）\n\n * 读模式的加锁状态\n * 写模式的加锁状态\n * 不加锁状态\n\n注意：\n\n 1. 写加锁状态：解锁前，所有试图加锁的线程都会被阻塞。\n 2. 读加锁状态：所有试图以读模式加锁的线程都可以得到访问权，但是，试图以写模式加锁的线程都会被阻塞，直到所有的线程释放它们的读锁为止。\n 3. 读写锁非常适合于对数据结构读的次数远大于写的情况。\n\n读写锁也叫做共享互斥锁（shared-exclusive lock）。当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住的时候，就可以说成是以互斥模式锁住的。\n\n与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁。\n\n\n# 5.2 函数\n\n#include <pthread.h>\nint pthread_rwlock_init(pthread_rwlock_t* restrict rwlock, const pthread_rwlockattr_t* restrict attr);\nint pthread_rwlock_destroy(pthread_rwlock_t* rwlock);\n\n\n1\n2\n3\n\n * 返回值：成功为0，失败为错误编号\n * 若使用读写锁默认属性，传一个NULL指针给attr\n\n\n# 初始化\n\n两种初始化：\n\n * 设置为常量：如果默认属性够用，可用静态分配的读写锁进行初始化。PTHREAD_RWLOCK_INITIALIZER常量\n * 调用函数：pthread_rwlock_init\n\n如果pthread_rwlock_init为读写锁分配了资源，pthread_rwlock_destroy将释放这些资源。\n\n在释放读写锁占用的内存之前，需要调用pthread_rwlock_destroy做清理工作。如果在调用pthread_rwlock_destroy之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失。\n\n\n# 加锁、解锁\n\n#include <pthread.h>\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_unlock(pthradd_rwlock_t *rwlock);\n\n\n1\n2\n3\n4\n\n * 返回值：成功为0，失败为错误编号\n * 各种实现可能会对共享模式下可获取的读写锁的次数进行限制，所以需要检查pthread_rwlock_rdlock的返回值。\n\n==Single UNIX Specification还定义了读写锁原语的条件版本。==\n\n#include <pthread.h>\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n\n\n1\n2\n3\n\n\n返回值：成功为0，失败返回错误编号EBUSY\n\n\n# 5.3 举个栗子\n\n目的：解释读写锁的使用。作业请求队列由单个读写锁保护。这个例子给出了多个工作线程获取单个主线程分配给它们的作业。\n\n#include <stdlib.h>\n#include <pthread.h>\n// 定义任务结构体\nstruct job { \n    struct job *j_next; \t// 指向下一个任务\n    struct job *j_prev; \t// 指向前一个任务\n    pthread_t \tj_id; \t\t// 任务的线程ID\n};\n// 定义队列结构体\nstruct queue { \n    struct job *q_head; \t\t// 指向队列头部的任务\n    struct job *q_tail; \t\t// 指向队列尾部的任务\n    pthread_rwlock_t q_lock;\t// 读写锁\n};\n// 初始化队列\nint queue_init(struct queue *qp) {\n    int err; // 错误码\n    qp->q_head = NULL;  // 队列头部置空\n    qp->q_tail = NULL;  // 队列尾部置空\n    err = pthread_rwlock_init(&qp->q_lock,NULL); // 初始化读写锁\n    if(err != 0) \t\t// 如果出现错误\n        return (err); \t// 返回错误码\n    return(0); // 返回成功\n}\n// 向队列头部插入任务(头插法)\nvoid job_insert(struct queue *qp,struct job *jp) {\n    pthread_rwlock_wrlock(&qp->q_lock); // 写锁定\n    jp->j_next = qp->q_head; // 新任务的下一个指向当前头部任务\n    jp->j_prev = NULL;\t\t // 新任务的前一个置空\n    if(qp->q_head != NULL) \t // 如果队列不为空\n        qp->q_head->j_prev = jp; // 当前头部任务的前一个指向新任务\n    else \t\t\t\t\t // 如果队列为空\n        qp->q_tail = jp; \t // 队列尾部指向新任务\n    qp->q_head = jp; \t\t // 队列头部指向新任务\n    pthread_rwlock_unlock(&qp->q_lock); // 解锁\n}\n// 向队列尾部追加任务\nvoid job_append(struct queue *qp, struct job *jp) {\n    pthread_rwlock_wrlock(&qp->q_lock); // 写锁定\n    jp->j_next = NULL; \t\t\t\t\t// 新任务的下一个置空\n    jp->j_prev = qp->q_tail; \t\t\t// 新任务的前一个指向当前尾部任务\n    if(qp->q_tail != NULL) \t\t\t\t// 如果队列尾部不为空\n        qp->q_tail->j_next = jp; \t\t// 当前尾部任务的下一个指向新任务\n    else \t\t\t\t\t\t\t\t// 如果队列尾部为空\n        qp->q_head = jp; \t\t\t\t// 队列头部指向新任务\n    qp->q_tail = jp; \t\t\t\t\t// 队列尾部指向新任务\n    pthread_rwlock_unlock(&qp->q_lock); // 解锁\n}\n// 从队列中移除任务\nvoid job_remove(struct queue *qp, struct job *jp) {\n    pthread_rwlock_wrlock(&qp->q_lock); // 写锁定\n    if(jp == qp->q_head) { \t\t\t\t// 如果要移除的任务是队列头部任务\n        qp->q_head = jp->j_next; \t\t// 队列头部指向下一个任务\n        if(qp->q_tail == jp) \t\t\t// 如果队列尾部也是要移除的任务\n            qp->q_tail = NULL; \t\t\t// 队列尾部置空\n        else \t\t\t\t\t\t\t// 如果队列尾部不是要移除的任务\n            jp->j_next->j_prev = jp->j_prev; // 下一个任务的前一个指向要移除任务的前一个\n    } else if(jp == qp->q_tail) { \t\t// 如果要移除的任务是队列尾部任务\n        qp->q_tail = jp->j_prev; \t\t// 队列尾部指向前一个任务\n        jp->j_prev->j_next = jp->j_next;// 前一个任务的下一个指向要移除任务的下一个\n    } else { // 如果要移除的任务在队列中间\n        jp->j_prev->j_next = jp->j_next;// 前一个任务的下一个指向要移除任务的下一个\n        jp->j_next->j_prev = jp->j_prev;// 下一个任务的前一个指向要移除任务的前一个\n    }\n    pthread_rwlock_unlock(&qp->q_lock); // 解锁\n}\n// 查找队列中的任务\nstruct job *job_find(struct queue *qp, pthread_t id) {\n\tstruct job* jp; \t\t\t\t\t\t\t// 任务指针\n    if(pthread_rwlock_rdlock(&qp->q_lock) != 0) // 读锁定\n        return(NULL); \t\t\t\t\t\t\t// 如果出现错误，返回空\n    for(jp = qp->q_head; jp != NULL; jp = jp->j_next) // 遍历队列中的任务\n        if(pthread_equal(jp->j_id, id)) \t\t// 如果找到了目标任务\n            break; \t\t\t\t\t\t\t\t// 退出循环\n    pthread_rwlock_unlock(&qp->q_lock); \t\t// 解锁\n    return(jp); \t\t\t\t\t\t\t\t// 返回找到的任务\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n * 在这个例子中，凡是需要向队列中增加作业或者从队列中删除作业的时候，都采用了写模式来锁住队列的读写锁。\n * 不管何时搜索队列，都需要获取读模式下的锁，允许所有的工作线程并发地搜索队列。\n * 在这种情况下，只有在线程搜索作业的频率远远高于增加或删除作业时，使用读写锁才可能改善性能。\n * 工作线程只能从队列中读取与它们的线程 ID 匹配的作业。由于作业结构同一时间只能由一个线程使用，所以不需要额外的加锁。\n\n\n# 6、自旋锁\n\n\n# 6.1 理解\n\n自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前 一直处于忙等（自旋）阻塞状态。所以当线程自旋等待锁变为可用时，CPU不能做其他的事情。这也是自旋锁只能够被持有一小段时间的原因。\n\n可用于以下情况：\n\n * 锁被持有时间短，线程不希望再重新调度上花费太多的成本。\n * 自旋锁用在非抢占式内核中时是非常有用的：除了提供互斥机制以外，它们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为它需要获取已被加锁的自选锁（把中断想成是另一种抢占）。在这种类型的内核中，中断处理程序不能休眠，因此它们能用的同步原语只能是自旋锁。\n\n\n# 6.2 函数\n\n\n# 初始化\n\n#include <pthread.h>\n//对自旋锁进行初始化\nint pthread_spin_init(pthread_spinlock_t* lock, int pshared);\n//销毁自旋锁\nint pthread_spin_destory(pthread_spinlock_t *lock);\n\n\n1\n2\n3\n4\n5\n\n\n返回值：成功为0，失败为错误编号\n\n参数：\n\n * pshared参数表示进程共享属性，表明自旋锁是如何获取的。\n   * PTHREAD_PROCESS_SHARED，则自旋锁能被可用访问锁底层内存的线程所获取，即便那些线程属于不同的进程。\n   * 如果设为PTHREAD_PROCESS_PRIVATE，自旋锁就只能被初始化该锁的进程内部的线程所访问。\n\n\n# 加锁、解锁\n\n#include <pthread.h>\n//加锁，获取锁之前一直自旋\nint pthread_spin_lock(pthread_spinlock_t *lock);\n//尝试加锁，不能获取锁返回EBUSY错误（不能自旋）\nint pthread_spin_trylock(pthread_spinlock_t *lock);\n//解锁\nint pthread_spin_unlock(pthread_spinlock_t *lock);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n返回值：成功为0，失败为错误编号\n\n注意：\n\n * 如果自旋锁当前在解锁状态的话，pthread_spin_lock函数不要自旋就可以对它加锁。如果线程已经对它加锁了，结果就是未定义的。\n * 调用pthread_spin_lock会返回EDEADLK错误（或其他错误），或者调用可能会永久自旋。\n * 不管是pthread_spin_lock还是pthread_spin_trylock，返回值为0的话就表示自旋锁被加锁。\n * 不要调用在持有自旋锁情况下可能会进入休眠状态的函数。如果调用了这些函数，会浪费CPU资源，因为其他线程需要获取自旋锁需要等待的时间就延长了。\n\n\n# 7、屏障\n\n\n# 7.1 引言\n\n屏障（barrier）是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。\n\npthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。\n\n但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作。\n\n\n# 7.2 函数\n\n\n# 初始化\n\n#include <pthread.h>\nint pthread_barrier_init(pthread_barrier_t* restrict barrier, const pthread_barrierattr_t* restrict attr, unsigned int count);\nint pthread_barrier_destory(pthread_barrier_t *barrier);\n\n\n1\n2\n3\n\n\n返回值：成功为0，失败为错误编号\n\n参数：\n\n * count：在允许所有线程继续运行之前，必须到达屏障的线程数目。\n * attr：设置为NULL，用默认属性初始化屏障\n\n可以使用pthread_barrier_wait函数表明，线程已完成工作，准备等所有其他线程赶上来。\n\n#include <pthread.h>\nint pthread_barrier_wait(pthread_barrier_t *barrier);\n\n\n1\n2\n\n\n返回值：\n\n * 成功为0或者PTHREAD_BARRIER_SERIAL_THREAD\n * 失败返回错误编号\n\n调用pthread_barrier_wait的线程在屏障计数（调用pthread_barrier_init时设定）未满足条件时，会进入休眠状态。\n\n如果该线程是最后一个调用pthread_barrier_wait的线程，就满足了屏障计数，所有的线程都被唤醒。\n\n对于一个任意线程，pthread_barrier_wait函数返回了PTHREAD_BARRIER_SERIAL_THREAD。剩下的线程看到的返回值是0。这使得一个线程可以作为主线程，它可以工作在其他所有线程已完成的工作结果上。\n\n一旦达到屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。\n\n但是除非在调用了pthread_barrier_destroy函数之后，又调用了pthread_barrier_init函数对计数用另外的数进行初始化，否则屏障计数不会改变。\n\n\n# 7.3 举个例子\n\n以下例子给出了在一个任务上合作的多个线程之间如何用屏障进行同步。\n\n#include "apue.h"        \n#include <pthread.h>     \n#include <limits.h>      // 包含限制常量\n#include <sys/time.h>    \n#define NTHR 8           // 定义线程数\n#define NUMNUM 8000000L  // 定义总元素数\n#define TNUM (NUMNUM/NTHR)  // 每个线程的元素数\n\nlong nums[NUMNUM];         // 存储随机数的数组\nlong snums[NUMNUM];        // 存储排序后的数值的数组\n\npthread_barrier_t b;      // 声明一个 pthread 屏障变量\n\n#ifdef SOLARIS\n#define headpsort qsort   // 在 Solaris 平台上使用 qsort\n#else\nextern int heapsort(void*, size_t, size_t, int(*)(const void*, const void*)); // 在其他平台上使用 heapsort\n#endif\n\n//比较两个元素的大小\nint complong(const void* arg1, const void* arg2) {\n    long l1 = *(long*)arg1; // 强制转换参数类型为 long\n    long l2 = *(long*)arg2;\n    if (l1 == l2)\n        return 0;\n    else if (l1 < l2)\n        return -1;\n    else\n        return 1;\n}\n//线程的执行函数，使用heapsort算法对一部分数组进行排序，并在完成后等待其他线程\nvoid* thr_fn(void* arg) {\n    long idx = (long)arg;  // 强制转换参数类型为 long\n    heapsort(&nums[idx], TNUM, sizeof(long), complong); // 使用 heapsort 进行排序\n    pthread_barrier_wait(&b);  // 等待其他线程到达屏障\n    return ((void*)0);\n}\n//合并各个线程排序后的子数组，生成最终的有序数组\nvoid merge() {\n    long idx[NTHR]; // 存储每个线程当前处理的索引\n    long i, minidx, sidx, num;\n    for (i = 0; i < NTHR; ++i)\n        idx[i] = i * TNUM;\n    for (sidx = 0; sidx < NUMNUM; sidx++) {\n        num = LONG_MAX;\n        for (i = 0; i < NTHR; ++i) {\n            if ((idx[i] < (i + 1) * TNUM) && (nums[idx[i]] < num)) {\n                num = nums[idx[i]];\n                minidx = i;\n            }\n        }\n        snums[sidx] = nums[idx[minidx]];\n        idx[minidx]++;\n    }\n}\n\nint main() {\n    unsigned long i;\n    struct timeval start, end;\n    long long startusec, endusec;//记录开始时间、结束时间\n    double elapsed;//计算经过的时间\n    int err;\n    pthread_t tid;\n\n    srandom(1);  // 初始化随机数生成器\n    for (i = 0; i < NUMNUM; ++i) {\n        nums[i] = random();  // 生成随机数并存储在 nums 数组中\n    }\n    gettimeofday(&start, NULL);  // 获取开始时间\n    pthread_barrier_init(&b, NULL, NTHR + 1);  // 初始化 pthread 屏障\n    for (i = 0; i < NTHR; ++i) {\n        err = pthread_create(&tid, NULL, thr_fn, (void*)(i * TNUM)); // 创建线程\n        if (err != 0)\n            err_exit(err, "can\'t create thread"); // 处理线程创建错误\n    }\n    pthread_barrier_wait(&b);  // 主线程等待所有线程到达屏障\n    merge();  // 合并排序后的子数组\n    gettimeofday(&end, NULL);  // 获取结束时间\n\n    startusec = start.tv_sec * 1000000 + start.tv_usec;\n    endusec = end.tv_sec * 1000000 + end.tv_usec;\n    elapsed = (double)(endusec - startusec) / 1000000.0; // 计算经过的时间\n    printf("sort took %.4f seconds\\n", elapsed); // 打印排序花费的时间\n    for (i = 0; i < NUMNUM; ++i)\n        printf("%ld\\n", snums[i]);  // 打印排序后的数值\n    exit(0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n * 这个例子给出了多个线程只执行一个任务时，使用屏障的简单情况。\n * 在更加实际的情况下，工作线程在调用pthread_barrier_wait函数返回后会接着执行其他的活动。\n * 在这个实例中，使用8个线程分解了800万个数的排序工作。每个线程用堆排序算法对100万个数进行排序。然后主线程调用一个函数对这些结果进行合并。\n * 并不需要使用 pthread_barrier_wait 函数中的返回值PTHREAD_BARRIER_SERIAL_THREAD 来决定哪个线程执行结果合并操作，因为我们使用了主线程来完成这个任务。\n * 这也是把屏障计数值设为工作线程数加1的原因，主线程也作为其中的一个候选线程。',normalizedContent:'# 第11章 线程同步\n\n\n# 1、引言\n\n * 当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。\n * 如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。\n * 同样，如果变量是只读的，多个线程同时读取该变量也不会有一致性问题。\n\n但是，当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。\n\n\n# 1.1 举个栗子\n\n> 在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。\n\n\n\n图 11-7 描述了两个线程读写相同变量的假设例子。\n\n * 在这个例子中，线程 a读取变量然后给这个变量赋予一个新的数值，但写操作需要两个存储器周期。\n * 当线程b在这两个存储器写周期中间读取这个变量时，它就会得到不一致的值。\n\n\n# 1.2 再举个栗子\n\n为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。\n\n\n\n图11-8描述了这种同步。\n\n * 如果线程b希望读取变量，它首先要获取锁。\n * 同样，当线程a更新变量时，也需要获取同样的这把锁。\n * 这样，线程b在线程a释放锁以前就不能读取变量。\n\n\n# 1.3 再再举个栗子\n\n两个或多个线程试图在同一时间修改同一变量时，也需要进行同步。考虑 变量增量操作的情况（图11-9）\n\n增量操作通常分解为以下3步：\n\n 1. 从内存单元读入寄存器。\n 2. 在寄存器中对变量做增量操作。\n 3. 把新的值写回内存单元。\n\n\n\n如果两个线程试图几乎在同一时间对同一个变量做增量操作而不进行同步的话，结果就可能出现不一致。\n\n * 变量可能比原来增加了1，也有可能比原来增加了2，具体增加了1还是2要取决于第二个线程开始操作时获取的数值。\n * 如果第二个线程执行第1步要比第一个线程执行第3步要早，第二个线程读到的值与第一个线程一样，为变量加1，然后写回去，事实上没有实际的效果，总的来说变量只增加了1。\n\n如果修改操作是原子操作，那么就不存在竞争。\n\n在图 11-9 例子中，如果增加1只需要一个存储器周期，那么就没有竞争存在。\n\n * 如果数据总是以顺序一致出现的，就不需要额外的同步。\n * 当多个线程观察不到数据的不一致时，那么操作就是顺序一致的。\n\n> 但是，在现代计算机系统中，存储访问需要多个总线周期，多处理器的总线周期通常在多个处理器上是交叉的，所以我们并不能保证数据是顺序一致的。\n\n * 在顺序一致环境中，可以把数据修改操作解释为运行线程的顺序操作步骤。\n * 可以把这样的操作描述为“线程a对变量增加了1，然后线程b对变量增加了1，所以变量的值就比原来的大2”，或者描述为“线程b对变量增加了1，然后线程a对变量增加了1，所以变量的值就比原来的大2”。\n * 这两个线程的任何操作顺序都不可能让变量出现除了上述值以外的其他值。\n\n\n# 1.4 其他情况\n\n> 程序使用变量的方式也会引起竞争，也会导致不一致的情况发生。\n\n例如，我们可能对某个变量加 1，然后基于这个值做出某种决定。因为这个增量操作步骤和这个决定步骤的组合并非原子操作，所以就给不一致情况的出现提供了可能。\n\n\n# 2、线程同步方法\n\n\n# 3、互斥量\n\n\n# 3.1 理解\n\n * 互斥量（mutex）从本质上说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。\n * 对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。\n * 如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。\n\n\n# 3.2 函数\n\n> 互斥量是用pthread_mutex_t数据类型表示的。使用前必须先初始化\n\n\n# 初始化\n\n两种初始化方式：\n\n 1. 设置为常量：pthread_mutex_initializer（只适用于静态分配）\n 2. 调用函数初始化：调用pthread_mutex_init函数初始化，如果动态分配互斥量（例如：通过调用malloc函数）在释放内存前需要调用pthread_mutex_destroy。\n\n#include <pthread.h>\nint pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexarrt_t *restrict attr);\n\nint pthread_mutex_destroy(pthread_mutex_t *mutex);\n\n\n1\n2\n3\n4\n\n * 返回值：成功返回0，失败返回错误编号。\n * 若使用默认属性初始化互斥量，attr设为null即可。\n\n\n# 加锁、解锁\n\n#include <pthread.h>\n//加锁\nint pthread_mutex_lock(pthread_mutex_t *mutex);\n//尝试加锁\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\n//解锁（上述两种加锁都用这个解锁）\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 返回值：成功为0，失败为错误编号。\n * 若线程不希望被阻塞，可用pthread_mutex_trylock尝试对互斥量加锁。\n   * 互斥量处于未锁住状态，那么pthread_mutex_trylock将锁住互斥量，不会出现阻塞直接返回0。\n   * 互斥量处于锁住状态，那么pthread_mutex_trylock将会失败，不能锁住互斥量，返回ebusy。\n\n\n# 3.3 来个栗子\n\n目的：使用互斥量保护数据结构\n\n当一个以上的线程需要访问动态分配的对象时，我们可以在对象中嵌入引用计数，确保在所有使用该对象的线程完成数据访问之前，该对象内存空间不会被释放。\n\n * 在对引用计数加 1、减 1、检查引用计数是否到达 0 这些操作之前需要锁住互斥量。\n * 在foo_alloc 函数中将引用计数初始化为 1 时没必要加锁，因为在这个操作之前分配线程是唯一引用该对象的线程。\n * 但是在这之后如果要将该对象放到一个列表中，那么它就有可能被别的线程发现，这时候需要首先对它加锁。\n * 在使用该对象前，线程需要调用foo_hold对这个对象的引用计数加1。\n * 当对象使用完毕时，必须调用foo_rele释放引用。最后一个引用被释放时，对象所占的内存空间就被释放。\n * 在这个例子中，我们忽略了线程在调用foo_hold之前是如何找到对象的。如果有另一个线程在调用foo_hold时阻塞等待互斥锁，这时即使该对象引用计数为0，foo_rele释放该对象的内存仍然是不对的。可以通过确保对象在释放内存前不会被找到这种方式来避免上述问题。可以通过下面的例子来看看如何做到这一点。\n\n#include <stdlib.h>        // 包含标准库，用于内存管理函数。\n#include <pthread.h>       // 包含pthread库，用于多线程支持。\n\nstruct foo {\n    int \t\t\tf_count;  // 一个整数字段，用于存储结构体的引用计数。\n    pthread_mutex_t f_lock;   // 用于控制对结构体的访问的互斥锁。\n    int \t\t\tf_id;     // 一个整数字段，用于存储结构体的标识符。\n};\n// 分配并初始化“foo”结构体的函数\nstruct foo* foo_alloc(int id) { \n    struct foo* fp;           \t// 声明一个指向“foo”结构体的指针。\n    if((fp = malloc(sizeof(struct foo))) != null) { // 为结构体分配内存。\n        fp->f_count = 1;       \t\t\t\t\t\t// 将引用计数初始化为1。\n        fp->f_id = id;         \t\t\t\t\t\t// 使用提供的id初始化结构体的id。\n        if(pthread_mutex_init(&fp->f_lock, null) != 0) { // 初始化互斥锁。\n            free(fp);           \t\t\t\t\t// 如果互斥锁初始化失败，释放内存。\n            return(null);       \t\t\t\t\t// 返回null以指示失败。\n        }\n    }\n    return(fp);                // 返回初始化的“foo”结构体。\n}\n// 增加“foo”结构体的引用计数的函数\nvoid foo_hold(struct foo* fp) {  \n    pthread_mutex_lock(&fp->f_lock); \t// 获取互斥锁以确保独占访问。\n    fp->f_count++;            \t\t\t// 增加引用计数。\n    pthread_mutex_unlock(&fp->f_lock); \t// 释放互斥锁。\n}\n// 释放“foo”结构体并可能释放其内存的函数\nvoid foo_rele(struct foo* fp) {  \n    pthread_mutex_lock(&fp->f_lock); \t\t// 获取互斥锁以确保独占访问。\n    if (--fp->f_count == 0) { \t\t\t\t// 如果引用计数减为0，则可以安全地释放结构体。\n        pthread_mutex_unlock(&fp->f_lock); \t// 释放互斥锁。\n        pthread_mutex_destory(&fp->f_lock); // 销毁互斥锁。\n        free(fp);           \t\t\t\t// 释放与“foo”结构体关联的内存。\n    } else {\n        pthread_mutex_unlock(&fp->f_lock);  // 如果引用计数不为零，释放互斥锁。\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 4、 条件变量\n\n\n# 4.1 理解\n\n条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。\n\n条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。\n\n\n# 4.2 函数\n\n\n# 初始化\n\n由pthread_cond_t数据类型表示\n\n两种初始化方式：\n\n * 静态分配：把常量pthread_cond_initializer赋给静态分配的条件变量\n * 动态分配：需要使用pthread_cond_init函数对它进行初始化\n\n在释放条件变量底层的内存空间之前，可以使用pthread_cond_destroy函数对条件变量进行反初始化（deinitialize）\n\n#include <pthread.h>\nint pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);\nint pthread_cond_destroy(pthread_cond_t *cond);\n\n\n1\n2\n3\n\n\n两个函数的返回值：若成功，返回0；否则，返回错误编号\n\n除非需要创建一个具有非默认属性的条件变量，否则pthread_cond_init函数的attr参数可以设置为null。\n\n我们使用pthread_cond_wait等待条件变量变为真。如果在给定的时间内条件不能满足，那么会生成一个返回错误码的变量。\n\n#include <pthread.h>\nint pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);\nint pthread_cond_timedwait(pthread_cond_t * restrict cond,pthread_mutex_t *restrict mutex,const struct timespaec *restrict tsptr);\n\n\n1\n2\n3\n\n\n两个函数的返回值：若成功，返回0；否则，返回错误编号\n\n\n# 注意事项\n\n * 传递给pthread_cond_wait的互斥量对条件进行保护。\n * 调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。\n * pthread_cond_wait返回时，互斥量再次被锁住。\n * pthread_cond_timedwait函数的功能与pthread_cond_wait函数相似，只是多了一个超时（tsptr）。超时值指定了我们愿意等待多长时间，它是通过timespec结构指定的。这个时间值是一个绝对数而不是相对数。\n * 例如，假设愿意等待3分钟。那么，并不是把3分钟转换成timespec结构，而是需要把当前时间加上3分钟再转换成timespec结构。\n * 可以使用clock_gettime函数（见6.10节）获取timespec结构表示的当前时间。但是目前并不是所有的平台都支持这个函数，因此，也可以用另一个函数gettimeofday 获取timeval结构表示的当前时间，然后把这个时间转换成timespec结构。\n\n#include <sys/time.h>\n#include <stdlib.h>\nvoid maketimeout(struct timespec *tsp, long minutes) {\n    struct timeval now;\n    gettimeofday(&now,null);\n    tsp->tv_sec = now.tv_sec;\n    tsp->tv_nsec = now.tv_usec*1000;\n    tsp->tv_sec += minutes*60;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果超时到期时条件还是没有出现，pthread_cond_timewait 将重新获取互斥量，然后返回错误etimedout。从pthread_cond_wait或者pthread_cond_timedwait调用成功返回时，线程需要重新计算条件，因为另一个线程可能已经在运行并改变了条件。\n\n有两个函数可以用于通知线程条件已经满足。pthread_cond_signal函数至少能唤醒一个等待该条件的线程，而pthread_cond_broadcast函数则能唤醒等待该条件的所有线程。\n\nposix 规范为了简化 pthread_cond_signal 的实现，允许它在实现的时候唤醒一个以上的线程。\n\n#include <pthread.h>\nint pthread_cond_signal(pthread_cond_t *cond);\nint pthread_cond_broadcast(pthread_cond_t *cond);\n\n\n1\n2\n3\n\n\n两个函数的返回值：若成功，返回0；否则，返回错误编号\n\n在调用pthread_cond_signal或者pthread_cond_broadcast时，我们说这是在给线程或者条件发信号。必须注意，一定要在改变条件状态以后再给线程发信号。\n\n\n# 4.3 举个例子\n\n以下例子给出了如何结合使用条件变量和互斥量对线程进行同步。\n\n#include <pthread.h>\n\n// 定义消息结构体\nstruct msg {\n    struct msg* m_next;\n};\n\nstruct msg* workq; // 全局消息队列指针\n\npthread_cond_t qready = pthread_cond_initializer; // 条件变量，用于通知等待中的线程\npthread_mutex_t qlock = pthread_mutex_initializer; // 互斥锁，用于保护消息队列\n\nvoid process_msg(void) {\n    struct msg* mp;\n    for (;;) {\n        pthread_mutex_lock(&qlock); // 获取互斥锁，保护对消息队列的访问\n        // 如果消息队列为空，等待条件变量\n        while (workq == null) {\n            pthread_cond_wait(&qready, &qlock);\n        }\n        mp = workq; // 获取队列头部的消息\n        workq = mp->m_next; // 更新队列头部指针，将头部消息出队\n        pthread_mutex_unlock(&qlock); // 释放互斥锁，允许其他线程访问消息队列\n    }\n}\n\nvoid enqueue_msg(struct msg* mp) {\n    pthread_mutex_lock(&qlock); // 获取互斥锁，保护对消息队列的访问\n    mp->m_next = workq; // 将新消息插入到队列头部\n    workq = mp; // 更新队列头部指针，将新消息设置为队列头部\n    pthread_mutex_unlock(&qlock); // 释放互斥锁，允许其他线程访问消息队列\n    pthread_cond_signal(&qready); // 发送信号，通知等待中的消费者线程有新消息可处理\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n * 条件是工作队列的状态。我们用互斥量保护条件，在 while 循环中判断条件。\n * 把消息放到工作队列时，需要占有互斥量，但在给等待线程发信号时，不需要占有互斥量。\n * 只要线程在调用pthread_cond_signal之前把消息从队列中拖出了，就可以在释放互斥量以后完成这部分工作。\n * 因为我们是在 while 循环中检查条件，所以不存在这样的问题：线程醒来，发现队列仍为空，然后返回继续等待。如果代码不能容忍这种竞争，就需要在给线程发信号的时候占有互斥量。\n\n\n# 5、 读写锁\n\n\n# 5.1 引言\n\n读写锁（reader-writer lock）与互斥量类似，不过读写锁允许更高的并行性。\n\n互斥锁只有两个状态：（一次只能由一个线程可以对其加锁）\n\n * 锁住状态\n * 不加锁状态\n\n读写锁可以有3中状态：（一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁）\n\n * 读模式的加锁状态\n * 写模式的加锁状态\n * 不加锁状态\n\n注意：\n\n 1. 写加锁状态：解锁前，所有试图加锁的线程都会被阻塞。\n 2. 读加锁状态：所有试图以读模式加锁的线程都可以得到访问权，但是，试图以写模式加锁的线程都会被阻塞，直到所有的线程释放它们的读锁为止。\n 3. 读写锁非常适合于对数据结构读的次数远大于写的情况。\n\n读写锁也叫做共享互斥锁（shared-exclusive lock）。当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住的时候，就可以说成是以互斥模式锁住的。\n\n与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁。\n\n\n# 5.2 函数\n\n#include <pthread.h>\nint pthread_rwlock_init(pthread_rwlock_t* restrict rwlock, const pthread_rwlockattr_t* restrict attr);\nint pthread_rwlock_destroy(pthread_rwlock_t* rwlock);\n\n\n1\n2\n3\n\n * 返回值：成功为0，失败为错误编号\n * 若使用读写锁默认属性，传一个null指针给attr\n\n\n# 初始化\n\n两种初始化：\n\n * 设置为常量：如果默认属性够用，可用静态分配的读写锁进行初始化。pthread_rwlock_initializer常量\n * 调用函数：pthread_rwlock_init\n\n如果pthread_rwlock_init为读写锁分配了资源，pthread_rwlock_destroy将释放这些资源。\n\n在释放读写锁占用的内存之前，需要调用pthread_rwlock_destroy做清理工作。如果在调用pthread_rwlock_destroy之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失。\n\n\n# 加锁、解锁\n\n#include <pthread.h>\nint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_unlock(pthradd_rwlock_t *rwlock);\n\n\n1\n2\n3\n4\n\n * 返回值：成功为0，失败为错误编号\n * 各种实现可能会对共享模式下可获取的读写锁的次数进行限制，所以需要检查pthread_rwlock_rdlock的返回值。\n\n==single unix specification还定义了读写锁原语的条件版本。==\n\n#include <pthread.h>\nint pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\nint pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n\n\n1\n2\n3\n\n\n返回值：成功为0，失败返回错误编号ebusy\n\n\n# 5.3 举个栗子\n\n目的：解释读写锁的使用。作业请求队列由单个读写锁保护。这个例子给出了多个工作线程获取单个主线程分配给它们的作业。\n\n#include <stdlib.h>\n#include <pthread.h>\n// 定义任务结构体\nstruct job { \n    struct job *j_next; \t// 指向下一个任务\n    struct job *j_prev; \t// 指向前一个任务\n    pthread_t \tj_id; \t\t// 任务的线程id\n};\n// 定义队列结构体\nstruct queue { \n    struct job *q_head; \t\t// 指向队列头部的任务\n    struct job *q_tail; \t\t// 指向队列尾部的任务\n    pthread_rwlock_t q_lock;\t// 读写锁\n};\n// 初始化队列\nint queue_init(struct queue *qp) {\n    int err; // 错误码\n    qp->q_head = null;  // 队列头部置空\n    qp->q_tail = null;  // 队列尾部置空\n    err = pthread_rwlock_init(&qp->q_lock,null); // 初始化读写锁\n    if(err != 0) \t\t// 如果出现错误\n        return (err); \t// 返回错误码\n    return(0); // 返回成功\n}\n// 向队列头部插入任务(头插法)\nvoid job_insert(struct queue *qp,struct job *jp) {\n    pthread_rwlock_wrlock(&qp->q_lock); // 写锁定\n    jp->j_next = qp->q_head; // 新任务的下一个指向当前头部任务\n    jp->j_prev = null;\t\t // 新任务的前一个置空\n    if(qp->q_head != null) \t // 如果队列不为空\n        qp->q_head->j_prev = jp; // 当前头部任务的前一个指向新任务\n    else \t\t\t\t\t // 如果队列为空\n        qp->q_tail = jp; \t // 队列尾部指向新任务\n    qp->q_head = jp; \t\t // 队列头部指向新任务\n    pthread_rwlock_unlock(&qp->q_lock); // 解锁\n}\n// 向队列尾部追加任务\nvoid job_append(struct queue *qp, struct job *jp) {\n    pthread_rwlock_wrlock(&qp->q_lock); // 写锁定\n    jp->j_next = null; \t\t\t\t\t// 新任务的下一个置空\n    jp->j_prev = qp->q_tail; \t\t\t// 新任务的前一个指向当前尾部任务\n    if(qp->q_tail != null) \t\t\t\t// 如果队列尾部不为空\n        qp->q_tail->j_next = jp; \t\t// 当前尾部任务的下一个指向新任务\n    else \t\t\t\t\t\t\t\t// 如果队列尾部为空\n        qp->q_head = jp; \t\t\t\t// 队列头部指向新任务\n    qp->q_tail = jp; \t\t\t\t\t// 队列尾部指向新任务\n    pthread_rwlock_unlock(&qp->q_lock); // 解锁\n}\n// 从队列中移除任务\nvoid job_remove(struct queue *qp, struct job *jp) {\n    pthread_rwlock_wrlock(&qp->q_lock); // 写锁定\n    if(jp == qp->q_head) { \t\t\t\t// 如果要移除的任务是队列头部任务\n        qp->q_head = jp->j_next; \t\t// 队列头部指向下一个任务\n        if(qp->q_tail == jp) \t\t\t// 如果队列尾部也是要移除的任务\n            qp->q_tail = null; \t\t\t// 队列尾部置空\n        else \t\t\t\t\t\t\t// 如果队列尾部不是要移除的任务\n            jp->j_next->j_prev = jp->j_prev; // 下一个任务的前一个指向要移除任务的前一个\n    } else if(jp == qp->q_tail) { \t\t// 如果要移除的任务是队列尾部任务\n        qp->q_tail = jp->j_prev; \t\t// 队列尾部指向前一个任务\n        jp->j_prev->j_next = jp->j_next;// 前一个任务的下一个指向要移除任务的下一个\n    } else { // 如果要移除的任务在队列中间\n        jp->j_prev->j_next = jp->j_next;// 前一个任务的下一个指向要移除任务的下一个\n        jp->j_next->j_prev = jp->j_prev;// 下一个任务的前一个指向要移除任务的前一个\n    }\n    pthread_rwlock_unlock(&qp->q_lock); // 解锁\n}\n// 查找队列中的任务\nstruct job *job_find(struct queue *qp, pthread_t id) {\n\tstruct job* jp; \t\t\t\t\t\t\t// 任务指针\n    if(pthread_rwlock_rdlock(&qp->q_lock) != 0) // 读锁定\n        return(null); \t\t\t\t\t\t\t// 如果出现错误，返回空\n    for(jp = qp->q_head; jp != null; jp = jp->j_next) // 遍历队列中的任务\n        if(pthread_equal(jp->j_id, id)) \t\t// 如果找到了目标任务\n            break; \t\t\t\t\t\t\t\t// 退出循环\n    pthread_rwlock_unlock(&qp->q_lock); \t\t// 解锁\n    return(jp); \t\t\t\t\t\t\t\t// 返回找到的任务\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n * 在这个例子中，凡是需要向队列中增加作业或者从队列中删除作业的时候，都采用了写模式来锁住队列的读写锁。\n * 不管何时搜索队列，都需要获取读模式下的锁，允许所有的工作线程并发地搜索队列。\n * 在这种情况下，只有在线程搜索作业的频率远远高于增加或删除作业时，使用读写锁才可能改善性能。\n * 工作线程只能从队列中读取与它们的线程 id 匹配的作业。由于作业结构同一时间只能由一个线程使用，所以不需要额外的加锁。\n\n\n# 6、自旋锁\n\n\n# 6.1 理解\n\n自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前 一直处于忙等（自旋）阻塞状态。所以当线程自旋等待锁变为可用时，cpu不能做其他的事情。这也是自旋锁只能够被持有一小段时间的原因。\n\n可用于以下情况：\n\n * 锁被持有时间短，线程不希望再重新调度上花费太多的成本。\n * 自旋锁用在非抢占式内核中时是非常有用的：除了提供互斥机制以外，它们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为它需要获取已被加锁的自选锁（把中断想成是另一种抢占）。在这种类型的内核中，中断处理程序不能休眠，因此它们能用的同步原语只能是自旋锁。\n\n\n# 6.2 函数\n\n\n# 初始化\n\n#include <pthread.h>\n//对自旋锁进行初始化\nint pthread_spin_init(pthread_spinlock_t* lock, int pshared);\n//销毁自旋锁\nint pthread_spin_destory(pthread_spinlock_t *lock);\n\n\n1\n2\n3\n4\n5\n\n\n返回值：成功为0，失败为错误编号\n\n参数：\n\n * pshared参数表示进程共享属性，表明自旋锁是如何获取的。\n   * pthread_process_shared，则自旋锁能被可用访问锁底层内存的线程所获取，即便那些线程属于不同的进程。\n   * 如果设为pthread_process_private，自旋锁就只能被初始化该锁的进程内部的线程所访问。\n\n\n# 加锁、解锁\n\n#include <pthread.h>\n//加锁，获取锁之前一直自旋\nint pthread_spin_lock(pthread_spinlock_t *lock);\n//尝试加锁，不能获取锁返回ebusy错误（不能自旋）\nint pthread_spin_trylock(pthread_spinlock_t *lock);\n//解锁\nint pthread_spin_unlock(pthread_spinlock_t *lock);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n返回值：成功为0，失败为错误编号\n\n注意：\n\n * 如果自旋锁当前在解锁状态的话，pthread_spin_lock函数不要自旋就可以对它加锁。如果线程已经对它加锁了，结果就是未定义的。\n * 调用pthread_spin_lock会返回edeadlk错误（或其他错误），或者调用可能会永久自旋。\n * 不管是pthread_spin_lock还是pthread_spin_trylock，返回值为0的话就表示自旋锁被加锁。\n * 不要调用在持有自旋锁情况下可能会进入休眠状态的函数。如果调用了这些函数，会浪费cpu资源，因为其他线程需要获取自旋锁需要等待的时间就延长了。\n\n\n# 7、屏障\n\n\n# 7.1 引言\n\n屏障（barrier）是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。\n\npthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。\n\n但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作。\n\n\n# 7.2 函数\n\n\n# 初始化\n\n#include <pthread.h>\nint pthread_barrier_init(pthread_barrier_t* restrict barrier, const pthread_barrierattr_t* restrict attr, unsigned int count);\nint pthread_barrier_destory(pthread_barrier_t *barrier);\n\n\n1\n2\n3\n\n\n返回值：成功为0，失败为错误编号\n\n参数：\n\n * count：在允许所有线程继续运行之前，必须到达屏障的线程数目。\n * attr：设置为null，用默认属性初始化屏障\n\n可以使用pthread_barrier_wait函数表明，线程已完成工作，准备等所有其他线程赶上来。\n\n#include <pthread.h>\nint pthread_barrier_wait(pthread_barrier_t *barrier);\n\n\n1\n2\n\n\n返回值：\n\n * 成功为0或者pthread_barrier_serial_thread\n * 失败返回错误编号\n\n调用pthread_barrier_wait的线程在屏障计数（调用pthread_barrier_init时设定）未满足条件时，会进入休眠状态。\n\n如果该线程是最后一个调用pthread_barrier_wait的线程，就满足了屏障计数，所有的线程都被唤醒。\n\n对于一个任意线程，pthread_barrier_wait函数返回了pthread_barrier_serial_thread。剩下的线程看到的返回值是0。这使得一个线程可以作为主线程，它可以工作在其他所有线程已完成的工作结果上。\n\n一旦达到屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。\n\n但是除非在调用了pthread_barrier_destroy函数之后，又调用了pthread_barrier_init函数对计数用另外的数进行初始化，否则屏障计数不会改变。\n\n\n# 7.3 举个例子\n\n以下例子给出了在一个任务上合作的多个线程之间如何用屏障进行同步。\n\n#include "apue.h"        \n#include <pthread.h>     \n#include <limits.h>      // 包含限制常量\n#include <sys/time.h>    \n#define nthr 8           // 定义线程数\n#define numnum 8000000l  // 定义总元素数\n#define tnum (numnum/nthr)  // 每个线程的元素数\n\nlong nums[numnum];         // 存储随机数的数组\nlong snums[numnum];        // 存储排序后的数值的数组\n\npthread_barrier_t b;      // 声明一个 pthread 屏障变量\n\n#ifdef solaris\n#define headpsort qsort   // 在 solaris 平台上使用 qsort\n#else\nextern int heapsort(void*, size_t, size_t, int(*)(const void*, const void*)); // 在其他平台上使用 heapsort\n#endif\n\n//比较两个元素的大小\nint complong(const void* arg1, const void* arg2) {\n    long l1 = *(long*)arg1; // 强制转换参数类型为 long\n    long l2 = *(long*)arg2;\n    if (l1 == l2)\n        return 0;\n    else if (l1 < l2)\n        return -1;\n    else\n        return 1;\n}\n//线程的执行函数，使用heapsort算法对一部分数组进行排序，并在完成后等待其他线程\nvoid* thr_fn(void* arg) {\n    long idx = (long)arg;  // 强制转换参数类型为 long\n    heapsort(&nums[idx], tnum, sizeof(long), complong); // 使用 heapsort 进行排序\n    pthread_barrier_wait(&b);  // 等待其他线程到达屏障\n    return ((void*)0);\n}\n//合并各个线程排序后的子数组，生成最终的有序数组\nvoid merge() {\n    long idx[nthr]; // 存储每个线程当前处理的索引\n    long i, minidx, sidx, num;\n    for (i = 0; i < nthr; ++i)\n        idx[i] = i * tnum;\n    for (sidx = 0; sidx < numnum; sidx++) {\n        num = long_max;\n        for (i = 0; i < nthr; ++i) {\n            if ((idx[i] < (i + 1) * tnum) && (nums[idx[i]] < num)) {\n                num = nums[idx[i]];\n                minidx = i;\n            }\n        }\n        snums[sidx] = nums[idx[minidx]];\n        idx[minidx]++;\n    }\n}\n\nint main() {\n    unsigned long i;\n    struct timeval start, end;\n    long long startusec, endusec;//记录开始时间、结束时间\n    double elapsed;//计算经过的时间\n    int err;\n    pthread_t tid;\n\n    srandom(1);  // 初始化随机数生成器\n    for (i = 0; i < numnum; ++i) {\n        nums[i] = random();  // 生成随机数并存储在 nums 数组中\n    }\n    gettimeofday(&start, null);  // 获取开始时间\n    pthread_barrier_init(&b, null, nthr + 1);  // 初始化 pthread 屏障\n    for (i = 0; i < nthr; ++i) {\n        err = pthread_create(&tid, null, thr_fn, (void*)(i * tnum)); // 创建线程\n        if (err != 0)\n            err_exit(err, "can\'t create thread"); // 处理线程创建错误\n    }\n    pthread_barrier_wait(&b);  // 主线程等待所有线程到达屏障\n    merge();  // 合并排序后的子数组\n    gettimeofday(&end, null);  // 获取结束时间\n\n    startusec = start.tv_sec * 1000000 + start.tv_usec;\n    endusec = end.tv_sec * 1000000 + end.tv_usec;\n    elapsed = (double)(endusec - startusec) / 1000000.0; // 计算经过的时间\n    printf("sort took %.4f seconds\\n", elapsed); // 打印排序花费的时间\n    for (i = 0; i < numnum; ++i)\n        printf("%ld\\n", snums[i]);  // 打印排序后的数值\n    exit(0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n * 这个例子给出了多个线程只执行一个任务时，使用屏障的简单情况。\n * 在更加实际的情况下，工作线程在调用pthread_barrier_wait函数返回后会接着执行其他的活动。\n * 在这个实例中，使用8个线程分解了800万个数的排序工作。每个线程用堆排序算法对100万个数进行排序。然后主线程调用一个函数对这些结果进行合并。\n * 并不需要使用 pthread_barrier_wait 函数中的返回值pthread_barrier_serial_thread 来决定哪个线程执行结果合并操作，因为我们使用了主线程来完成这个任务。\n * 这也是把屏障计数值设为工作线程数加1的原因，主线程也作为其中的一个候选线程。',charsets:{cjk:!0}},{title:"函数模板",frontmatter:{title:"函数模板",date:"2023-12-15T09:54:13.000Z",permalink:"/pages/3f1d21/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/60.Cpp%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/01.%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF.html",relativePath:"01.CPP语言/60.Cpp提高编程/01.函数模板.md",key:"v-f0cc61b6",path:"/pages/3f1d21/",headers:[{level:2,title:"一、函数模板",slug:"一、函数模板",normalizedTitle:"一、函数模板",charIndex:2},{level:3,title:"1.1 函数模板",slug:"_1-1-函数模板",normalizedTitle:"1.1 函数模板",charIndex:13},{level:3,title:"1.2 函数模板语法",slug:"_1-2-函数模板语法",normalizedTitle:"1.2 函数模板语法",charIndex:51},{level:3,title:"1.3 函数模板示例",slug:"_1-3-函数模板示例",normalizedTitle:"1.3 函数模板示例",charIndex:237},{level:3,title:"1.4 总结：",slug:"_1-4-总结",normalizedTitle:"1.4 总结：",charIndex:927},{level:3,title:"1.5 函数模板注意事项",slug:"_1-5-函数模板注意事项",normalizedTitle:"1.5 函数模板注意事项",charIndex:1015},{level:3,title:"1.6 函数模板案例",slug:"_1-6-函数模板案例",normalizedTitle:"1.6 函数模板案例",charIndex:1719},{level:3,title:"1.7 普通函数与函数模板的区别",slug:"_1-7-普通函数与函数模板的区别",normalizedTitle:"1.7 普通函数与函数模板的区别",charIndex:3300},{level:3,title:"1.8 普通函数和函数模板的调用规则",slug:"_1-8-普通函数和函数模板的调用规则",normalizedTitle:"1.8 普通函数和函数模板的调用规则",charIndex:3956},{level:3,title:"1.9 模板的局限性",slug:"_1-9-模板的局限性",normalizedTitle:"1.9 模板的局限性",charIndex:4939},{level:4,title:"1.9.1 传入数组可能失效",slug:"_1-9-1-传入数组可能失效",normalizedTitle:"1.9.1 传入数组可能失效",charIndex:4953},{level:4,title:"1.9.2 传入自定义数据类型可能失效",slug:"_1-9-2-传入自定义数据类型可能失效",normalizedTitle:"1.9.2 传入自定义数据类型可能失效",charIndex:5072},{level:3,title:"1.10 具体化的模板示例",slug:"_1-10-具体化的模板示例",normalizedTitle:"1.10 具体化的模板示例",charIndex:5256}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"5 min read",minutes:4.135,time:248100,words:827},headersStr:"一、函数模板 1.1 函数模板 1.2 函数模板语法 1.3 函数模板示例 1.4 总结： 1.5 函数模板注意事项 1.6 函数模板案例 1.7 普通函数与函数模板的区别 1.8 普通函数和函数模板的调用规则 1.9 模板的局限性 1.9.1 传入数组可能失效 1.9.2 传入自定义数据类型可能失效 1.10 具体化的模板示例",content:'# 一、函数模板\n\n\n# 1.1 函数模板\n\n> C++ 提供两种模板机制：函数模板和类模板\n\n\n# 1.2 函数模板语法\n\n建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n\ntemplate<typename T>\n// 函数声明或定义\n\n\n1\n2\n\n * template：声明创建模板\n * typename：表名其后面的符号是一种数据类型，可用 class 代替\n * T：通用的数据类型，名称可以替换，通常为大写字母\n\n\n# 1.3 函数模板示例\n\n// 交换整形函数\nvoid swapInt(int &a,int &b){\n    int temp = a;\n    a = b;\n    b = temp;\n}\n// 交换浮点型函数\nvoid swapDouble(double &a,double &b){\n    double temp = b;\n    a = b;\n    b = temp;\n}\n// 利用模板提供通用的交换函数\ntemplate<typename T>\nvoid mySwap(T &a,T &b){\n    T temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid test01(){\n    int a = 10;\n    int b = 20;\n    // 利用模板实现交换\n    // 1、自动类型推导\n    mySwap(a,b);\n    \n    // 2、显示指定类型\n    mySwap<int>(a,b);\n    \n    cout << "a = " << a << endl;\n    cout << "b = " << b << endl;\n}\n\nint main(){\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 1.4 总结：\n\n * 模板函数利用关键字 template\n * 使用模板函数有两种方式：自动类型推导、显示指定类型\n * 模板的目的是为了提高复用性、将类型参数化\n\n\n# 1.5 函数模板注意事项\n\n * 自动类型推导，必须推导出一致的数据类型T，才可以使用\n * 模板必须要确定出T的数据类型，才可以使用\n\n// 利用模板提供通用的交换函数\ntemplate<class T>\nvoid mySwap(T& a,T& b){\n    T temp = a;\n    a = b;\n    b = temp;\n}\n// 1、自动类型推导，必须推导出一致的数据类型 T,才可以使用\nvoid test01(){\n    int a = 10;\n    int b = 20;\n    char c = \'c\';\n    mySwap(a,b);\t// 正确：可以推导出一致的T\n    mySwap(a,c);\t// 错误：推导不出一致的T类型\n}\n// 2、模板必须要确定出 T 的数据类型，才可以使用\ntemplate<class T>\nvoid func(){\n    cout << "func 调用" << endl;\n}\nvoid test02(){\n    //func();\t\t// 错误：模板不能独立使用，必须确定出 T 的类型\n    func<int>();\t// 利用显示指定类型的方式，给 T 一个类型，才可以使用该模板\n}\nint main(){\n    test01();\n    test02();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 1.6 函数模板案例\n\n> 案例描述：\n> \n> 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序\n> \n> 排序规则从大到小，排序算法为选择排序\n> \n> 分别利用 char 数组和 int 数组进行测试\n\n#include <iostream>\nusing namespace std;\n\n// 交换模板函数\ntemplate<typename T>\nvoid mySwap(T& a, T& b) {\n    T temp = a;\n    a = b;\n    b = temp;\n}\n\n// 利用选择排序的模板函数，对数组进行从大到小的排序\ntemplate<typename T>\nvoid selectionSort(T arr[],int len) {\n    int minIndex;\n    for (int i = 0; i < len; ++i) {\n        minIndex = i;\n        for (int j = i + 1; j < len; ++j) {\n            if (arr[minIndex] < arr[j]) {\n                minIndex = j;\n            }\n            mySwap(arr[i], arr[minIndex]);\n        }\n    }\n}\ntemplate<typename T>\nvoid Print(T arr[],int len) {\n    for (int i = 0; i < len; ++i) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\n\n// 测试int类型数组\nvoid test01() {\n    int intArr[] = { 1,2,3,4,5,6,7,8,9 };\n    int num = sizeof(intArr) / sizeof(int);\n    cout << "对数组进行选择排序  前：";\n    Print(intArr, num);\n    selectionSort(intArr, num);\n    cout << "对数组进行选择排序  后：";\n    Print(intArr, num);\n    cout << "-------------------------------" << endl;\n}\n\n// 测试char类型数组\nvoid test02() {\n    char charArr[] = "abcdefghi";\n    int num = sizeof(charArr) / sizeof(char);\n    cout << "对数组进行选择排序  前：";\n    Print(charArr, num);\n    selectionSort(charArr, num);\n    cout << "对数组进行选择排序  后：";\n    Print(charArr, num);\n}\nint main() {\n    test01();\n    test02();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 1.7 普通函数与函数模板的区别\n\n * 普通函数调用时可以发生自动类型转换（隐式类型转换）\n * 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换\n * 如果利用显示指定类型的方式，可以发生隐式类型转换\n\n// 普通函数\nint myAdd01(int a,int b){\n    return a+b;\n}\n\n// 函数模板\ntemplate<typename T>\nT myAdd02(T a,T b){\n    return a+b;\n}\n\nvoid test01() {\n    int a = 10;\n    int b = 20;\n    char c = \'c\';\n    cout << myAdd01(a,c) << endl;\t// 正确：将char类型的\'c\'隐式转换为int类型 \'c\'对应 ASCII码 99\n    // myAdd02(a,c);\t\t\t\t// 错误：使用自动类型推导时，不会发生隐式类型转换\n    myAdd02<int>(a,c);\t\t\t\t// 正确：如果用显示指定类型，可以发生隐式类型转换\n}\n\nint main(){\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T\n\n\n# 1.8 普通函数和函数模板的调用规则\n\n * 如果函数模板和普通函数都可以实现，优先调用普通函数\n * 可以通过空模板参数列表来强制调用函数模板\n * 函数模板也可以发生重载\n * 如果函数模板可以产生更好的匹配，优先调用函数模板\n\n> 总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n\n// 普通函数与函数模板调用规则\nvoid Print(int a,int b) {\n    cout << "调用的普通函数" << endl;\n}\n\ntemplate<class T>\nvoid Print(T a, T b){\n    cout << "调用的函数模板" << endl;\n}\n\ntemplate<class T>\nvoid Print(T a, T b, T c){\n    cout << "调用的重载函数模板" << endl;\n}\n\nvoid test01(){\n    // 1、如果函数模板和普通函数都可以实现，优先调用普通函数\n    // 注意：如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到.\n    int a = 10;\n    int b = 20;\n    Print(a,b);\t\t\t// 调用普通函数\n    \n    // 2、可以通过空模板参数列表来强制调用函数模板\n    Print<>(a,b);\t\t// 调用函数模板\n    \n    // 3、函数模板也可以发生重载\n    int c = 30;\n    Print(a,b,c);\t\t//调用重载的函数模板\n    \n    // 4、 如果函数模板可以产生更好的匹配,优先调用函数模板\n    char c1 = \'a\';\n    char c2 = \'b\';\n    Print(c1,c2);\t\t// 调用函数模板\n}\n\nint main() {\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 1.9 模板的局限性\n\n# 1.9.1 传入数组可能失效\n\ntemplate<class T>\nvoid f(T a, T b){\n    a = b;\n}\n\n\n1\n2\n3\n4\n\n\n在上述代码中提供的赋值操作，如果传入的 a 和 b 是一个数组，就无法实现了\n\n# 1.9.2 传入自定义数据类型可能失效\n\ntemplate<class T>\nvoid f(T a, T b){\n    if(a > b) {...}\n}\n\n\n1\n2\n3\n4\n\n\n在上述代码中，如果T的数据类型传入的是像 Person 这样的自定义数据类型，也无法正常运行\n\n> 因此，为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n\n\n# 1.10 具体化的模板示例\n\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Person {\n  public:\n    Person(string name,int age) {\n        this->m_Name = name;\n        this->m_Age = age;\n    }\n  private:\n    string m_Name;\n    int m_Age;\n};\n\n// 普通函数模板\ntemplate<class T>\nbool myCompare(T &a,T &b){\n    if(a == b) {\n        return true;\n    } else {\n        return false;\n    }\n}\n// 具体化：显示 具体化的原型和定义是以template<>开头，并通过名称来指出类型\n// 具体化优先于常规模板\ntemplate<>bool myCompare(Person &p1,Person &2){\n    if(p1.m_Name == p2.m_Name && p1.m_Age == p2.m_Age) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid test01(){\n    int a = 10;\n    int b = 20;\n    // 内置数据类型可以直接使用通用的函数模板\n    bool ret = myCompare(a , b);\n    if(ret) {\n        cout << "a == b" << endl;\n    } else {\n        cout << "a != b" << endl;\n    }\n}\n\nvoid test02() {\n    Person p1("Tom", 10);\n    Person p2("Tom", 10);\n    // 自定义数据类型，不会调用普通的函数模板\n    // 可以创建具体化的Person数据类型的模板，用于特殊处理这个类型\n    bool ret = myCompare(p1,p2);\n    if(ret) {\n        cout << "p1 == p2" << endl;\n    } else {\n        cout << "p1 != p2" << endl;\n    }\n}\n\nint main() {\n    test01();\n    test02();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n总结：\n\n * 利用具体化的模板，可以解决自定义类型的通用化\n * 学习模板并不是为了写模板，而是在 STL 能够运用系统提供的模板',normalizedContent:'# 一、函数模板\n\n\n# 1.1 函数模板\n\n> c++ 提供两种模板机制：函数模板和类模板\n\n\n# 1.2 函数模板语法\n\n建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。\n\ntemplate<typename t>\n// 函数声明或定义\n\n\n1\n2\n\n * template：声明创建模板\n * typename：表名其后面的符号是一种数据类型，可用 class 代替\n * t：通用的数据类型，名称可以替换，通常为大写字母\n\n\n# 1.3 函数模板示例\n\n// 交换整形函数\nvoid swapint(int &a,int &b){\n    int temp = a;\n    a = b;\n    b = temp;\n}\n// 交换浮点型函数\nvoid swapdouble(double &a,double &b){\n    double temp = b;\n    a = b;\n    b = temp;\n}\n// 利用模板提供通用的交换函数\ntemplate<typename t>\nvoid myswap(t &a,t &b){\n    t temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid test01(){\n    int a = 10;\n    int b = 20;\n    // 利用模板实现交换\n    // 1、自动类型推导\n    myswap(a,b);\n    \n    // 2、显示指定类型\n    myswap<int>(a,b);\n    \n    cout << "a = " << a << endl;\n    cout << "b = " << b << endl;\n}\n\nint main(){\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 1.4 总结：\n\n * 模板函数利用关键字 template\n * 使用模板函数有两种方式：自动类型推导、显示指定类型\n * 模板的目的是为了提高复用性、将类型参数化\n\n\n# 1.5 函数模板注意事项\n\n * 自动类型推导，必须推导出一致的数据类型t，才可以使用\n * 模板必须要确定出t的数据类型，才可以使用\n\n// 利用模板提供通用的交换函数\ntemplate<class t>\nvoid myswap(t& a,t& b){\n    t temp = a;\n    a = b;\n    b = temp;\n}\n// 1、自动类型推导，必须推导出一致的数据类型 t,才可以使用\nvoid test01(){\n    int a = 10;\n    int b = 20;\n    char c = \'c\';\n    myswap(a,b);\t// 正确：可以推导出一致的t\n    myswap(a,c);\t// 错误：推导不出一致的t类型\n}\n// 2、模板必须要确定出 t 的数据类型，才可以使用\ntemplate<class t>\nvoid func(){\n    cout << "func 调用" << endl;\n}\nvoid test02(){\n    //func();\t\t// 错误：模板不能独立使用，必须确定出 t 的类型\n    func<int>();\t// 利用显示指定类型的方式，给 t 一个类型，才可以使用该模板\n}\nint main(){\n    test01();\n    test02();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 1.6 函数模板案例\n\n> 案例描述：\n> \n> 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序\n> \n> 排序规则从大到小，排序算法为选择排序\n> \n> 分别利用 char 数组和 int 数组进行测试\n\n#include <iostream>\nusing namespace std;\n\n// 交换模板函数\ntemplate<typename t>\nvoid myswap(t& a, t& b) {\n    t temp = a;\n    a = b;\n    b = temp;\n}\n\n// 利用选择排序的模板函数，对数组进行从大到小的排序\ntemplate<typename t>\nvoid selectionsort(t arr[],int len) {\n    int minindex;\n    for (int i = 0; i < len; ++i) {\n        minindex = i;\n        for (int j = i + 1; j < len; ++j) {\n            if (arr[minindex] < arr[j]) {\n                minindex = j;\n            }\n            myswap(arr[i], arr[minindex]);\n        }\n    }\n}\ntemplate<typename t>\nvoid print(t arr[],int len) {\n    for (int i = 0; i < len; ++i) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\n\n// 测试int类型数组\nvoid test01() {\n    int intarr[] = { 1,2,3,4,5,6,7,8,9 };\n    int num = sizeof(intarr) / sizeof(int);\n    cout << "对数组进行选择排序  前：";\n    print(intarr, num);\n    selectionsort(intarr, num);\n    cout << "对数组进行选择排序  后：";\n    print(intarr, num);\n    cout << "-------------------------------" << endl;\n}\n\n// 测试char类型数组\nvoid test02() {\n    char chararr[] = "abcdefghi";\n    int num = sizeof(chararr) / sizeof(char);\n    cout << "对数组进行选择排序  前：";\n    print(chararr, num);\n    selectionsort(chararr, num);\n    cout << "对数组进行选择排序  后：";\n    print(chararr, num);\n}\nint main() {\n    test01();\n    test02();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 1.7 普通函数与函数模板的区别\n\n * 普通函数调用时可以发生自动类型转换（隐式类型转换）\n * 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换\n * 如果利用显示指定类型的方式，可以发生隐式类型转换\n\n// 普通函数\nint myadd01(int a,int b){\n    return a+b;\n}\n\n// 函数模板\ntemplate<typename t>\nt myadd02(t a,t b){\n    return a+b;\n}\n\nvoid test01() {\n    int a = 10;\n    int b = 20;\n    char c = \'c\';\n    cout << myadd01(a,c) << endl;\t// 正确：将char类型的\'c\'隐式转换为int类型 \'c\'对应 ascii码 99\n    // myadd02(a,c);\t\t\t\t// 错误：使用自动类型推导时，不会发生隐式类型转换\n    myadd02<int>(a,c);\t\t\t\t// 正确：如果用显示指定类型，可以发生隐式类型转换\n}\n\nint main(){\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型t\n\n\n# 1.8 普通函数和函数模板的调用规则\n\n * 如果函数模板和普通函数都可以实现，优先调用普通函数\n * 可以通过空模板参数列表来强制调用函数模板\n * 函数模板也可以发生重载\n * 如果函数模板可以产生更好的匹配，优先调用函数模板\n\n> 总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性\n\n// 普通函数与函数模板调用规则\nvoid print(int a,int b) {\n    cout << "调用的普通函数" << endl;\n}\n\ntemplate<class t>\nvoid print(t a, t b){\n    cout << "调用的函数模板" << endl;\n}\n\ntemplate<class t>\nvoid print(t a, t b, t c){\n    cout << "调用的重载函数模板" << endl;\n}\n\nvoid test01(){\n    // 1、如果函数模板和普通函数都可以实现，优先调用普通函数\n    // 注意：如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到.\n    int a = 10;\n    int b = 20;\n    print(a,b);\t\t\t// 调用普通函数\n    \n    // 2、可以通过空模板参数列表来强制调用函数模板\n    print<>(a,b);\t\t// 调用函数模板\n    \n    // 3、函数模板也可以发生重载\n    int c = 30;\n    print(a,b,c);\t\t//调用重载的函数模板\n    \n    // 4、 如果函数模板可以产生更好的匹配,优先调用函数模板\n    char c1 = \'a\';\n    char c2 = \'b\';\n    print(c1,c2);\t\t// 调用函数模板\n}\n\nint main() {\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 1.9 模板的局限性\n\n# 1.9.1 传入数组可能失效\n\ntemplate<class t>\nvoid f(t a, t b){\n    a = b;\n}\n\n\n1\n2\n3\n4\n\n\n在上述代码中提供的赋值操作，如果传入的 a 和 b 是一个数组，就无法实现了\n\n# 1.9.2 传入自定义数据类型可能失效\n\ntemplate<class t>\nvoid f(t a, t b){\n    if(a > b) {...}\n}\n\n\n1\n2\n3\n4\n\n\n在上述代码中，如果t的数据类型传入的是像 person 这样的自定义数据类型，也无法正常运行\n\n> 因此，为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板\n\n\n# 1.10 具体化的模板示例\n\n#include <iostream>\n#include <string>\nusing namespace std;\nclass person {\n  public:\n    person(string name,int age) {\n        this->m_name = name;\n        this->m_age = age;\n    }\n  private:\n    string m_name;\n    int m_age;\n};\n\n// 普通函数模板\ntemplate<class t>\nbool mycompare(t &a,t &b){\n    if(a == b) {\n        return true;\n    } else {\n        return false;\n    }\n}\n// 具体化：显示 具体化的原型和定义是以template<>开头，并通过名称来指出类型\n// 具体化优先于常规模板\ntemplate<>bool mycompare(person &p1,person &2){\n    if(p1.m_name == p2.m_name && p1.m_age == p2.m_age) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid test01(){\n    int a = 10;\n    int b = 20;\n    // 内置数据类型可以直接使用通用的函数模板\n    bool ret = mycompare(a , b);\n    if(ret) {\n        cout << "a == b" << endl;\n    } else {\n        cout << "a != b" << endl;\n    }\n}\n\nvoid test02() {\n    person p1("tom", 10);\n    person p2("tom", 10);\n    // 自定义数据类型，不会调用普通的函数模板\n    // 可以创建具体化的person数据类型的模板，用于特殊处理这个类型\n    bool ret = mycompare(p1,p2);\n    if(ret) {\n        cout << "p1 == p2" << endl;\n    } else {\n        cout << "p1 != p2" << endl;\n    }\n}\n\nint main() {\n    test01();\n    test02();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n总结：\n\n * 利用具体化的模板，可以解决自定义类型的通用化\n * 学习模板并不是为了写模板，而是在 stl 能够运用系统提供的模板',charsets:{cjk:!0}},{title:"类模板",frontmatter:{title:"类模板",date:"2023-12-15T09:54:13.000Z",permalink:"/pages/db4e3c/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/60.Cpp%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/02.%E7%B1%BB%E6%A8%A1%E6%9D%BF.html",relativePath:"01.CPP语言/60.Cpp提高编程/02.类模板.md",key:"v-13ee8c1e",path:"/pages/db4e3c/",headers:[{level:2,title:"2、类模板",slug:"_2、类模板",normalizedTitle:"2、类模板",charIndex:2},{level:3,title:"2.1 类模板语法",slug:"_2-1-类模板语法",normalizedTitle:"2.1 类模板语法",charIndex:12},{level:3,title:"2.2 类模板和函数模板的区别",slug:"_2-2-类模板和函数模板的区别",normalizedTitle:"2.2 类模板和函数模板的区别",charIndex:881},{level:3,title:"2.3 类模板中成员函数创建时机",slug:"_2-3-类模板中成员函数创建时机",normalizedTitle:"2.3 类模板中成员函数创建时机",charIndex:1867},{level:3,title:"2.4 类模板对象做函数参数",slug:"_2-4-类模板对象做函数参数",normalizedTitle:"2.4 类模板对象做函数参数",charIndex:2709},{level:3,title:"2.5 类模板与继承",slug:"_2-5-类模板与继承",normalizedTitle:"2.5 类模板与继承",charIndex:4137},{level:3,title:"2.6 类模板成员函数类外实现",slug:"_2-6-类模板成员函数类外实现",normalizedTitle:"2.6 类模板成员函数类外实现",charIndex:4267},{level:3,title:"2.7 类模板和友元",slug:"_2-7-类模板和友元",normalizedTitle:"2.7 类模板和友元",charIndex:5032},{level:3,title:"2.8 类模板案例",slug:"_2-8-类模板案例",normalizedTitle:"2.8 类模板案例",charIndex:6296}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"6 min read",minutes:5.78,time:346800,words:1156},headersStr:"2、类模板 2.1 类模板语法 2.2 类模板和函数模板的区别 2.3 类模板中成员函数创建时机 2.4 类模板对象做函数参数 2.5 类模板与继承 2.6 类模板成员函数类外实现 2.7 类模板和友元 2.8 类模板案例",content:'# 2、类模板\n\n\n# 2.1 类模板语法\n\n> 建立一个通用类，类中的成员、数据类型可以不具体制定，用一个虚拟的类型来代表。\n\ntemplate<typename T>\n// 类\n\n\n1\n2\n\n * template：声明创建模板\n * typename：表名其后面的符号是一种数据类型，可以用 class 代替\n * T：通用的数据类型，名称可以替换，通常为大写字母\n\n#include <iostream>\nusing namespace std;\n// 类模板\ntemplate<class NameType, class AgeType>\nclass Person {\n  public:\n  \tPerson(NameType name, AgeType age){\n        this->mName = name;\n        this->mAge = age;\n    }  \n    void showPerson() {\n        cout << "name: " << this->mName << "age: " << this->mAge << endl;\n    }\n  public:\n    NameType mName;\n    AgeTyep mAge;\n};\n\nvoid test01() {\n    // 指定 NameType 为 string 类型，AgeType 为 int 类型\n    Person<string,int>P1("孙悟空",999);\n    P1.showPerson();\n}\n\nint main() {\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n总结：\n\n * 类模板和函数模板语法类似，在声明模板 template 后面加类，此类称为类模板\n\n\n# 2.2 类模板和函数模板的区别\n\n * 类模板没有自动类型推导的使用方式\n * 类模板在模板参数列表中可以有默认参数\n\n#include <iostream>\nusing namespace std;\n// 类模板\ntemplate<class NameType, class AgeType = int>\nclass Person {\n  public:\n    Person(nameType name, AgeType age) {\n        this->mName = name;\n        this->mAge = age;\n    }\n    void showPerson() {\n        cout << "name: " << this->mName << "age: " << this->mAge << endl;\n    }\n  public:\n    NameType mName;\n    AgeType mAge;\n};\n\n//1、类模板没有自动类型推导的使用方式\n//1、类模板没有自动类型推导的使用方式\nvoid test01()\n{\n\t// Person p("孙悟空", 1000); \t\t\t// 错误 类模板使用时候，不可以用自动类型推导\n\tPerson <string ,int>p("孙悟空", 1000); // 必须使用显示指定类型的方式，使用类模板\n\tp.showPerson();\n}\n\n//2、类模板在模板参数列表中可以有默认参数\nvoid test02() {\n\tPerson<string>p("猪八戒",999);\t\t\t// 类模板中的模板参数列表，库指定默认参数\n    p.showPerson();\n}\n\nint main() {\n    test01();\n    test02();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n总结：\n\n * 类模板使用只能用显示指定类型方式\n * 类模板中的模板参数列表可以有默认参数\n\n\n# 2.3 类模板中成员函数创建时机\n\n类模板中成员函数和普通类中成员函数创建时机是有区别的：\n\n * 普通类中的成员函数一开始就可以创建\n * 类模板中的成员函数在调用时才创建\n\n#include <iostream>\nusing namespace std;\nclass Person1 {\n    public:\n    void showPerson1() {\n        cout << "Person1 show" << endl;\n    }\n};\nclass Person2 {\n    public:\n    void showPerson2() {\n        cout << "Person2 show" << endl;\n    }\n};\n\ntemplate<class T>\n    class MyClass {\n        public:\n        T obj;\n        // 类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成\n        void fun1() { obj.showPerson1(); }\n        void fun2() { obj.showPerson2(); }\n    };\nvoid test01()\n{\n    MyClass<Person1> m;\n    m.fun1();\n    // m.fun2();\t\t// 编译会出错，说明函数调用才会去创建成员函数\n}\nint main() {\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n总结：\n\n * 类模板中的成员函数并不是一开始就创建的，在调用时才去创建\n\n\n# 2.4 类模板对象做函数参数\n\n * 类模板实例化出的对象，向函数传参的方式\n\n共三种传入方式：\n\n 1. 指定传入的类型：直接显示对象的数据类型\n 2. 参数模板化：将对象中的参数变为模板进行传递\n 3. 整个类模板化：将这个对象类型模板化进行传递\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// 类模板\ntemplate<class NameType, class AgeType = int>\nclass Person {\npublic:\n\tPerson(NameType name, AgeType age) {\n\t\tthis->mName = name;\n\t\tthis->mAge = age;\n\t}\n\tvoid showPerson() {\n\t\tcout << "name: " << this->mName << " age: " << this->mAge << endl;\n\t}\n\npublic:\n\tNameType mName;\n\tAgeType mAge;\n};\n\n// 1、类模板对象作为函数参数，方式一：指定传入的类型\nvoid printPerson1(Person<string, int>& p) {\n\tp.showPerson();\n}\nvoid test01() {\n\tPerson<string, int>p("孙悟空", 100);\n\tprintPerson1(p);\n}\n\n// 2、参数模板化\ntemplate<class T1, class T2>\nvoid printPerson2(Person<T1, T2>& p) {\n\tp.showPerson();\n\tcout << "T1的类型为： " << typeid(T1).name() << endl;\n\tcout << "T2的类型为： " << typeid(T2).name() << endl;\n}\nvoid test02() {\n\tPerson<string, int>p("猪八戒", 90);\n\tprintPerson2(p);\n}\n\n// 3、整个类模板化\ntemplate<class T>\nvoid printPerson3(T& p) {\n\tcout << "T的类型为： " << typeid(T).name() << endl;\n\tp.showPerson();\n}\nvoid test03() {\n\tPerson<string, int>p("唐僧", 30);\n\tprintPerson3(p);\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\ttest03();\n\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n总结：\n\n * 通过类模板创建的对象，可以有三种方式向函数中进行传参\n * 使用比较广泛的是第一种：指定传入的类型\n\n\n# 2.5 类模板与继承\n\n当类模板碰到继承时，需要注意以下几点：\n\n * 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中 T 的类型\n * 如果不指定，编译器无法给子类分配内存\n * 如果想灵活指定出父类中T的类型，子类也需变为类模板\n\n\n# 2.6 类模板成员函数类外实现\n\n#include <iostream>\nusing namespace std;\n\n// 类模板中成员函数类外实现\ntemplate<class T1,class T2>\nclass Person {\npublic:\n\t// 成员函数类内声明\n\tPerson(T1 name, T2 age);\n\tvoid showPerson();\n\npublic:\n\tT1 m_Name;\n\tT2 m_Age;\n};\n\n// 构造函数 类外实现\ntemplate<class T1, class T2>\nPerson<T1, T2>::Person(T1 name, T2 age) {\n\tthis->m_Name = name;\n\tthis->m_Age = age;\n}\n\n// 成员函数 类外实现\ntemplate<class T1,class T2>\nvoid Person<T1, T2>::showPerson() {\n\tcout << "姓名：" << this->m_Name << " 年龄：" << this->m_Age << endl;\n}\n\nvoid test01() {\n\tPerson<string, int>p("Tom", 20);\n\tp.showPerson();\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n总结：\n\n * 类模板中成员函数类外实现时，需要加上模板参数列表\n\n\n# 2.7 类模板和友元\n\n * 全局函数类内实现：直接在类内声明友元即可\n * 全局函数类外实现：需要提前让编译器知道全局函数的存在\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// 2、全局函数配合友元 类外实现：先做函数模板声明，下方在做函数模板定义，在做友元\ntemplate<class T1, class T2>class Person;\n\n// 如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到\ntemplate<class T1, class T2> void printPerson2(Person<T1, T2>& p);\n\ntemplate<class T1,class T2>\nclass Person {\n\t// 1、全局函数配合友元   类内实现\n\tfriend void printPerson(Person<T1, T2>& p) {\n\t\tcout << "姓名：" << p.m_Name << "年龄：" << p.m_Age << endl;\n\t}\n\n\t//   全局函数配合友元   类外实现\n\tfriend void printPerson2<>(Person<T1, T2>& p);\n\npublic:\n\tPerson(T1 name, T2 age) {\n\t\tthis->m_Name = name;\n\t\tthis->m_Age = age;\n\t}\n\nprivate:\n\tT1 m_Name;\n\tT2 m_Age;\n};\n\n// 1、全局函数在类内实现\nvoid test01() {\n\tPerson <string, int>p("Tom", 20);\n\tprintPerson(p);\n}\n\n// 2、全局函数在类外实现\nvoid test02() {\n\tPerson<string, int>p("Jerry", 30);\n\tprintPerson2(p);\n}\n\ntemplate<class T1, class T2>\nvoid printPerson2(Person<T1, T2>& p) {\n\tcout << "类外实现 --- 姓名：" << p.m_Name << "年龄：" << p.m_Age << endl;\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n总结：\n\n * 建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n\n\n# 2.8 类模板案例\n\n> 案例描述：实现一个通用的数组类，要求如下：\n> \n>  * 可以对内置数据类型以及自定义数据类型的数据进行存储\n>  * 将数组中的数据存储到堆区\n>  * 构造函数中可以传入数组的容量\n>  * 提供对应的拷贝构造函数以及operator=防止浅拷贝问题\n>  * 提供尾插法和尾删法对数组中的数据进行增加和删除\n>  * 可以通过下标的方式访问数组中的元素\n>  * 可以获取数组中当前元素个数和数组的容量\n\nmyArray.hpp文件\n\n#pragma\n#include <iostream>\n#include <string>\nusing namespace std;\n\ntemplate<class T>\nclass MyArray {\npublic:\n\t// 构造函数\n\tMyArray(int capatity) {\n\t\tthis->m_Capacity = capatity;\n\t\tthis->m_Size = 0;\n\t\tpAddress = new T[this->m_Capacity];\n\t}\n\t// 拷贝函数\n\tMyArray(const MyArray& arr) {\n\t\tthis->m_Capacity = arr.m_Capacity;\n\t\tthis->m_Size = arr.m_Size;\n\t\tthis->pAddress = new T[this->m_Capacity];\n\t\tfor (int i = 0; i < this->m_Size; ++i) {\n\t\t\t// 如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是构造 而是赋值，\n\t\t\t// 普通类型可以直接 = 但是指针类型需要深拷贝\n\t\t\tthis->pAddress[i] = arr.pAddress[i];\n\t\t}\n\t}\n\t// 重载 = 操作符 防止浅拷贝问题\n\tMyArray& operator=(const MyArray& myarray) {\n\t\tif (this->pAddress != nullptr) {\n\t\t\tdelete[] this->pAddress;\n\t\t\tthis->m_Capacity = 0;\n\t\t\tthis->m_Size = 0;\n\t\t}\n\n\t\tthis->m_Capacity = myarray.m_Capacity;\n\t\tthis->m_Size = myarray.m_Size;\n\t\tthis->pAddress = new T[this->m_Capacity];\n\t\tfor (int i = 0; i < this->m_Size; ++i) {\n\t\t\tthis->pAddress[i] = myarray[i];\n\t\t}\n\t\treturn *this;\n\t}\n\t// 重载 [] 操作符 arr[0]\n\tT& operator[](int index) {\n\t\treturn this->pAddress[index];//不考虑越界，用户自己去处理\n\t}\n\t\n\t// 尾插法\n\tvoid push_back(const T& val) {\n\t\tif (this->m_Capacity == this->m_Size) {\n\t\t\treturn;\n\t\t}\n\t\tthis->pAddress[this->m_Size] = val;\n\t\tthis->m_Size++;\n\t}\n\n\t// 尾删法\n\tvoid pop_back() {\n\t\tif (this->m_Size == 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis->m_Size--;\n\t}\n\n\t//获取数组容量\n\tint getCapacity() {\n\t\treturn this->m_Capacity;\n\t}\n\n\t// 获取数组大小\n\tint getSize() {\n\t\treturn this->m_Size;\n\t}\n\n\t~MyArray() {\n\t\tif (this->pAddress != nullptr) {\n\t\t\tdelete[] this->pAddress;\n\t\t\tthis->pAddress = nullptr;\n\t\t\tthis->m_Capacity = 0;\n\t\t\tthis->m_Size = 0;\n\t\t}\n\t}\nprivate:\n\tT* pAddress;\t// 指向一个堆空间，这个空间存储真正的数据\n\tint m_Capacity; // 容量\n\tint m_Size;\t\t// 大小\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\nmyArray.cpp文件\n\n#include "myArray.hpp"\n\nvoid printIntArray(MyArray<int>& arr) {\n\tfor (int i = 0; i < arr.getSize(); ++i) {\n\t\tcout << arr[i] << " ";\n\t}\n\tcout << endl;\n}\n\n// 测试内置数据类型\nvoid test01() {\n\tMyArray<int> array1(10);\n\tfor (int i = 0; i < 10; ++i) {\n\t\tarray1.push_back(i);\n\t}\n\tcout << "array1打印输出：" << endl;\n\tprintIntArray(array1);\n\tcout << "array1的大小：" << array1.getSize() << endl;\n\tcout << "array1的容量：" << array1.getCapacity() << endl;\n\tcout <<-----------------------------------" << endl;\n\n\tMyArray<int> array2(array1);\n\tarray2.pop_back();\n\tcout << "array2打印输出：" << endl;\n\tprintIntArray(array2);\n\tcout << "array2的大小：" << array2.getSize() << endl;\n\tcout << "array2的容量：" << array2.getCapacity() << endl;\n}\n\n// 测试自定义数据类型\nclass Person {\npublic:\n\tPerson() {}\n\tPerson(string name, int age) {\n\t\tthis->m_Name = name;\n\t\tthis->m_Age = age;\n\t}\n\npublic:\n\tstring m_Name;\n\tint m_Age;\n};\nvoid printPersonArray(MyArray<Person>& personArr) {\n\tfor (int i = 0; i < personArr.getSize(); ++i) {\n\t\tcout << "姓名：" << personArr[i].m_Name << " 年龄：" << personArr[i].m_Age << endl;\n\t}\n}\n\nvoid test02() {\n\t// 创建数组\n\tMyArray<Person>pArray(10);\n\tPerson p1("孙悟空", 999);\n\tPerson p2("韩信", 20);\n\tPerson p3("妲己", 18);\n\tPerson p4("王昭君", 15);\n\tPerson p5("赵云", 24);\n\t// 插入数据\n\tpArray.push_back(p1);\n\tpArray.push_back(p2);\n\tpArray.push_back(p3);\n\tpArray.push_back(p4);\n\tpArray.push_back(p5);\n\tprintPersonArray(pArray);\n\n\tcout << "pArray的大小：" << pArray.getSize() << endl;\n\tcout << "pArray的容量：" << pArray.getCapacity() << endl;\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n',normalizedContent:'# 2、类模板\n\n\n# 2.1 类模板语法\n\n> 建立一个通用类，类中的成员、数据类型可以不具体制定，用一个虚拟的类型来代表。\n\ntemplate<typename t>\n// 类\n\n\n1\n2\n\n * template：声明创建模板\n * typename：表名其后面的符号是一种数据类型，可以用 class 代替\n * t：通用的数据类型，名称可以替换，通常为大写字母\n\n#include <iostream>\nusing namespace std;\n// 类模板\ntemplate<class nametype, class agetype>\nclass person {\n  public:\n  \tperson(nametype name, agetype age){\n        this->mname = name;\n        this->mage = age;\n    }  \n    void showperson() {\n        cout << "name: " << this->mname << "age: " << this->mage << endl;\n    }\n  public:\n    nametype mname;\n    agetyep mage;\n};\n\nvoid test01() {\n    // 指定 nametype 为 string 类型，agetype 为 int 类型\n    person<string,int>p1("孙悟空",999);\n    p1.showperson();\n}\n\nint main() {\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n总结：\n\n * 类模板和函数模板语法类似，在声明模板 template 后面加类，此类称为类模板\n\n\n# 2.2 类模板和函数模板的区别\n\n * 类模板没有自动类型推导的使用方式\n * 类模板在模板参数列表中可以有默认参数\n\n#include <iostream>\nusing namespace std;\n// 类模板\ntemplate<class nametype, class agetype = int>\nclass person {\n  public:\n    person(nametype name, agetype age) {\n        this->mname = name;\n        this->mage = age;\n    }\n    void showperson() {\n        cout << "name: " << this->mname << "age: " << this->mage << endl;\n    }\n  public:\n    nametype mname;\n    agetype mage;\n};\n\n//1、类模板没有自动类型推导的使用方式\n//1、类模板没有自动类型推导的使用方式\nvoid test01()\n{\n\t// person p("孙悟空", 1000); \t\t\t// 错误 类模板使用时候，不可以用自动类型推导\n\tperson <string ,int>p("孙悟空", 1000); // 必须使用显示指定类型的方式，使用类模板\n\tp.showperson();\n}\n\n//2、类模板在模板参数列表中可以有默认参数\nvoid test02() {\n\tperson<string>p("猪八戒",999);\t\t\t// 类模板中的模板参数列表，库指定默认参数\n    p.showperson();\n}\n\nint main() {\n    test01();\n    test02();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n总结：\n\n * 类模板使用只能用显示指定类型方式\n * 类模板中的模板参数列表可以有默认参数\n\n\n# 2.3 类模板中成员函数创建时机\n\n类模板中成员函数和普通类中成员函数创建时机是有区别的：\n\n * 普通类中的成员函数一开始就可以创建\n * 类模板中的成员函数在调用时才创建\n\n#include <iostream>\nusing namespace std;\nclass person1 {\n    public:\n    void showperson1() {\n        cout << "person1 show" << endl;\n    }\n};\nclass person2 {\n    public:\n    void showperson2() {\n        cout << "person2 show" << endl;\n    }\n};\n\ntemplate<class t>\n    class myclass {\n        public:\n        t obj;\n        // 类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成\n        void fun1() { obj.showperson1(); }\n        void fun2() { obj.showperson2(); }\n    };\nvoid test01()\n{\n    myclass<person1> m;\n    m.fun1();\n    // m.fun2();\t\t// 编译会出错，说明函数调用才会去创建成员函数\n}\nint main() {\n    test01();\n    system("pause");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n总结：\n\n * 类模板中的成员函数并不是一开始就创建的，在调用时才去创建\n\n\n# 2.4 类模板对象做函数参数\n\n * 类模板实例化出的对象，向函数传参的方式\n\n共三种传入方式：\n\n 1. 指定传入的类型：直接显示对象的数据类型\n 2. 参数模板化：将对象中的参数变为模板进行传递\n 3. 整个类模板化：将这个对象类型模板化进行传递\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// 类模板\ntemplate<class nametype, class agetype = int>\nclass person {\npublic:\n\tperson(nametype name, agetype age) {\n\t\tthis->mname = name;\n\t\tthis->mage = age;\n\t}\n\tvoid showperson() {\n\t\tcout << "name: " << this->mname << " age: " << this->mage << endl;\n\t}\n\npublic:\n\tnametype mname;\n\tagetype mage;\n};\n\n// 1、类模板对象作为函数参数，方式一：指定传入的类型\nvoid printperson1(person<string, int>& p) {\n\tp.showperson();\n}\nvoid test01() {\n\tperson<string, int>p("孙悟空", 100);\n\tprintperson1(p);\n}\n\n// 2、参数模板化\ntemplate<class t1, class t2>\nvoid printperson2(person<t1, t2>& p) {\n\tp.showperson();\n\tcout << "t1的类型为： " << typeid(t1).name() << endl;\n\tcout << "t2的类型为： " << typeid(t2).name() << endl;\n}\nvoid test02() {\n\tperson<string, int>p("猪八戒", 90);\n\tprintperson2(p);\n}\n\n// 3、整个类模板化\ntemplate<class t>\nvoid printperson3(t& p) {\n\tcout << "t的类型为： " << typeid(t).name() << endl;\n\tp.showperson();\n}\nvoid test03() {\n\tperson<string, int>p("唐僧", 30);\n\tprintperson3(p);\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\ttest03();\n\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n总结：\n\n * 通过类模板创建的对象，可以有三种方式向函数中进行传参\n * 使用比较广泛的是第一种：指定传入的类型\n\n\n# 2.5 类模板与继承\n\n当类模板碰到继承时，需要注意以下几点：\n\n * 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中 t 的类型\n * 如果不指定，编译器无法给子类分配内存\n * 如果想灵活指定出父类中t的类型，子类也需变为类模板\n\n\n# 2.6 类模板成员函数类外实现\n\n#include <iostream>\nusing namespace std;\n\n// 类模板中成员函数类外实现\ntemplate<class t1,class t2>\nclass person {\npublic:\n\t// 成员函数类内声明\n\tperson(t1 name, t2 age);\n\tvoid showperson();\n\npublic:\n\tt1 m_name;\n\tt2 m_age;\n};\n\n// 构造函数 类外实现\ntemplate<class t1, class t2>\nperson<t1, t2>::person(t1 name, t2 age) {\n\tthis->m_name = name;\n\tthis->m_age = age;\n}\n\n// 成员函数 类外实现\ntemplate<class t1,class t2>\nvoid person<t1, t2>::showperson() {\n\tcout << "姓名：" << this->m_name << " 年龄：" << this->m_age << endl;\n}\n\nvoid test01() {\n\tperson<string, int>p("tom", 20);\n\tp.showperson();\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n总结：\n\n * 类模板中成员函数类外实现时，需要加上模板参数列表\n\n\n# 2.7 类模板和友元\n\n * 全局函数类内实现：直接在类内声明友元即可\n * 全局函数类外实现：需要提前让编译器知道全局函数的存在\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// 2、全局函数配合友元 类外实现：先做函数模板声明，下方在做函数模板定义，在做友元\ntemplate<class t1, class t2>class person;\n\n// 如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到\ntemplate<class t1, class t2> void printperson2(person<t1, t2>& p);\n\ntemplate<class t1,class t2>\nclass person {\n\t// 1、全局函数配合友元   类内实现\n\tfriend void printperson(person<t1, t2>& p) {\n\t\tcout << "姓名：" << p.m_name << "年龄：" << p.m_age << endl;\n\t}\n\n\t//   全局函数配合友元   类外实现\n\tfriend void printperson2<>(person<t1, t2>& p);\n\npublic:\n\tperson(t1 name, t2 age) {\n\t\tthis->m_name = name;\n\t\tthis->m_age = age;\n\t}\n\nprivate:\n\tt1 m_name;\n\tt2 m_age;\n};\n\n// 1、全局函数在类内实现\nvoid test01() {\n\tperson <string, int>p("tom", 20);\n\tprintperson(p);\n}\n\n// 2、全局函数在类外实现\nvoid test02() {\n\tperson<string, int>p("jerry", 30);\n\tprintperson2(p);\n}\n\ntemplate<class t1, class t2>\nvoid printperson2(person<t1, t2>& p) {\n\tcout << "类外实现 --- 姓名：" << p.m_name << "年龄：" << p.m_age << endl;\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n总结：\n\n * 建议全局函数做类内实现，用法简单，而且编译器可以直接识别\n\n\n# 2.8 类模板案例\n\n> 案例描述：实现一个通用的数组类，要求如下：\n> \n>  * 可以对内置数据类型以及自定义数据类型的数据进行存储\n>  * 将数组中的数据存储到堆区\n>  * 构造函数中可以传入数组的容量\n>  * 提供对应的拷贝构造函数以及operator=防止浅拷贝问题\n>  * 提供尾插法和尾删法对数组中的数据进行增加和删除\n>  * 可以通过下标的方式访问数组中的元素\n>  * 可以获取数组中当前元素个数和数组的容量\n\nmyarray.hpp文件\n\n#pragma\n#include <iostream>\n#include <string>\nusing namespace std;\n\ntemplate<class t>\nclass myarray {\npublic:\n\t// 构造函数\n\tmyarray(int capatity) {\n\t\tthis->m_capacity = capatity;\n\t\tthis->m_size = 0;\n\t\tpaddress = new t[this->m_capacity];\n\t}\n\t// 拷贝函数\n\tmyarray(const myarray& arr) {\n\t\tthis->m_capacity = arr.m_capacity;\n\t\tthis->m_size = arr.m_size;\n\t\tthis->paddress = new t[this->m_capacity];\n\t\tfor (int i = 0; i < this->m_size; ++i) {\n\t\t\t// 如果t为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是构造 而是赋值，\n\t\t\t// 普通类型可以直接 = 但是指针类型需要深拷贝\n\t\t\tthis->paddress[i] = arr.paddress[i];\n\t\t}\n\t}\n\t// 重载 = 操作符 防止浅拷贝问题\n\tmyarray& operator=(const myarray& myarray) {\n\t\tif (this->paddress != nullptr) {\n\t\t\tdelete[] this->paddress;\n\t\t\tthis->m_capacity = 0;\n\t\t\tthis->m_size = 0;\n\t\t}\n\n\t\tthis->m_capacity = myarray.m_capacity;\n\t\tthis->m_size = myarray.m_size;\n\t\tthis->paddress = new t[this->m_capacity];\n\t\tfor (int i = 0; i < this->m_size; ++i) {\n\t\t\tthis->paddress[i] = myarray[i];\n\t\t}\n\t\treturn *this;\n\t}\n\t// 重载 [] 操作符 arr[0]\n\tt& operator[](int index) {\n\t\treturn this->paddress[index];//不考虑越界，用户自己去处理\n\t}\n\t\n\t// 尾插法\n\tvoid push_back(const t& val) {\n\t\tif (this->m_capacity == this->m_size) {\n\t\t\treturn;\n\t\t}\n\t\tthis->paddress[this->m_size] = val;\n\t\tthis->m_size++;\n\t}\n\n\t// 尾删法\n\tvoid pop_back() {\n\t\tif (this->m_size == 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis->m_size--;\n\t}\n\n\t//获取数组容量\n\tint getcapacity() {\n\t\treturn this->m_capacity;\n\t}\n\n\t// 获取数组大小\n\tint getsize() {\n\t\treturn this->m_size;\n\t}\n\n\t~myarray() {\n\t\tif (this->paddress != nullptr) {\n\t\t\tdelete[] this->paddress;\n\t\t\tthis->paddress = nullptr;\n\t\t\tthis->m_capacity = 0;\n\t\t\tthis->m_size = 0;\n\t\t}\n\t}\nprivate:\n\tt* paddress;\t// 指向一个堆空间，这个空间存储真正的数据\n\tint m_capacity; // 容量\n\tint m_size;\t\t// 大小\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n\nmyarray.cpp文件\n\n#include "myarray.hpp"\n\nvoid printintarray(myarray<int>& arr) {\n\tfor (int i = 0; i < arr.getsize(); ++i) {\n\t\tcout << arr[i] << " ";\n\t}\n\tcout << endl;\n}\n\n// 测试内置数据类型\nvoid test01() {\n\tmyarray<int> array1(10);\n\tfor (int i = 0; i < 10; ++i) {\n\t\tarray1.push_back(i);\n\t}\n\tcout << "array1打印输出：" << endl;\n\tprintintarray(array1);\n\tcout << "array1的大小：" << array1.getsize() << endl;\n\tcout << "array1的容量：" << array1.getcapacity() << endl;\n\tcout <<-----------------------------------" << endl;\n\n\tmyarray<int> array2(array1);\n\tarray2.pop_back();\n\tcout << "array2打印输出：" << endl;\n\tprintintarray(array2);\n\tcout << "array2的大小：" << array2.getsize() << endl;\n\tcout << "array2的容量：" << array2.getcapacity() << endl;\n}\n\n// 测试自定义数据类型\nclass person {\npublic:\n\tperson() {}\n\tperson(string name, int age) {\n\t\tthis->m_name = name;\n\t\tthis->m_age = age;\n\t}\n\npublic:\n\tstring m_name;\n\tint m_age;\n};\nvoid printpersonarray(myarray<person>& personarr) {\n\tfor (int i = 0; i < personarr.getsize(); ++i) {\n\t\tcout << "姓名：" << personarr[i].m_name << " 年龄：" << personarr[i].m_age << endl;\n\t}\n}\n\nvoid test02() {\n\t// 创建数组\n\tmyarray<person>parray(10);\n\tperson p1("孙悟空", 999);\n\tperson p2("韩信", 20);\n\tperson p3("妲己", 18);\n\tperson p4("王昭君", 15);\n\tperson p5("赵云", 24);\n\t// 插入数据\n\tparray.push_back(p1);\n\tparray.push_back(p2);\n\tparray.push_back(p3);\n\tparray.push_back(p4);\n\tparray.push_back(p5);\n\tprintpersonarray(parray);\n\n\tcout << "parray的大小：" << parray.getsize() << endl;\n\tcout << "parray的容量：" << parray.getcapacity() << endl;\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n',charsets:{cjk:!0}},{title:"初识STL",frontmatter:{title:"初识STL",date:"2023-12-15T09:54:13.000Z",permalink:"/pages/a7c324/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/60.Cpp%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/03.%E5%88%9D%E8%AF%86STL.html",relativePath:"01.CPP语言/60.Cpp提高编程/03.初识STL.md",key:"v-65a3fd54",path:"/pages/a7c324/",headers:[{level:2,title:"3、初识STL",slug:"_3、初识stl",normalizedTitle:"3、初识stl",charIndex:2},{level:3,title:"3.1 vector 存放内置数据类型",slug:"_3-1-vector-存放内置数据类型",normalizedTitle:"3.1 vector 存放内置数据类型",charIndex:397},{level:3,title:"3.2 vector 存放自定义数据类型",slug:"_3-2-vector-存放自定义数据类型",normalizedTitle:"3.2 vector 存放自定义数据类型",charIndex:1657},{level:3,title:"3.3 vector容器嵌套容器",slug:"_3-3-vector容器嵌套容器",normalizedTitle:"3.3 vector容器嵌套容器",charIndex:2955}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.055,time:123300.00000000001,words:411},headersStr:"3、初识STL 3.1 vector 存放内置数据类型 3.2 vector 存放自定义数据类型 3.3 vector容器嵌套容器",content:'# 3、初识STL\n\n * STL（Standard Template Library，标准模板库）\n * STL从广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）\n * 容器和算法之间通过迭代器进行无缝连接\n * STL 几乎所有的代码都采用了模板类或者模板函数\n\nSTL六大组件：\n\n容器、算法、迭代器、仿函数、适配器（配接器）、空间置配器\n\n 1. 容器：各种数据结构，如 vector、list、deque、set、map 等，用来存放数据\n 2. 算法：各种常用算法，如 sort、find、copy、for_each 等\n 3. 迭代器：扮演了容器与算法之间的胶合剂\n 4. 仿函数：行为类似函数，可作为算法的某种策略。\n 5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。\n 6. 空间置配器：负责空间的配置与管理\n\n\n# 3.1 vector 存放内置数据类型\n\n * 容器：vector\n * 算法：for_each\n * 迭代器：vector<int>::iterator\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid printVal(int val) {\n\tcout << val << " ";\n}\n\nvoid test01() {\n\t// 创建 vector 容器对象，并且通过模板参数指定容器中存放的数据的类型\n\tvector<int> v;\n\t// 向容器中放数据\n\tv.push_back(10);\n\tv.push_back(20);\n\tv.push_back(30);\n\tv.push_back(40);\n\tv.push_back(50);\n\n\t// 每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素\n\t// v.begin() 返回迭代器，这个迭代器指向容器中第一个数据\n\t// v.end() 返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置\n\t// vector<int>::iterator 拿到 vector<int> 这种容器的迭代器类型\n\tvector<int>::iterator itbegin = v.begin();\n\tvector<int>::iterator itend = v.end();\n\n\t// 第一种遍历方式：\n\tcout << "while循环遍历方式：";\n\twhile (itbegin != itend) {\n\t\tcout << *itbegin << " ";\n\t\titbegin++;\n\t}\n\tcout << endl;\n\n\t// 第二种遍历方式：\n\tcout << "for循环遍历方式：";\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n\n\t// 第三种遍历方式：\n\t// 使用STL提供标准遍历算法 头文件 algorithm\n\tcout << "使用 STL 提供的遍历算法 for_each：";\n\tfor_each(v.begin(), v.end(), printVal);\n\tcout << endl;\n\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 3.2 vector 存放自定义数据类型\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Person {\npublic:\n\tPerson(string name,int age){\n\t\tm_name = name;\n\t\tm_age = age;\n\t}\n\t\npublic:\n\tstring m_name;\n\tint m_age;\n};\n\nvoid test01() {\n\tvector<Person>v;\n\tPerson p1("aaa", 10);\n\tPerson p2("bbb", 20);\n\tPerson p3("ccc", 30);\n\tPerson p4("ddd", 40);\n\tPerson p5("eee", 50);\n\tv.push_back(p1);\n\tv.push_back(p2);\n\tv.push_back(p3);\n\tv.push_back(p4);\n\tv.push_back(p5);\n\tfor (vector<Person>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << "姓名：" << (*it).m_name << " 年龄：" << (*it).m_age << endl;\n\t}\n\tcout << "----------------------" << endl;\n}\n\nvoid test02() {\n\tvector<Person*>v;\n\tPerson p1("aaa", 10);\n\tPerson p2("bbb", 20);\n\tPerson p3("ccc", 30);\n\tPerson p4("ddd", 40);\n\tPerson p5("eee", 50);\n\tv.push_back(&p1);\n\tv.push_back(&p2);\n\tv.push_back(&p3);\n\tv.push_back(&p4);\n\tv.push_back(&p5);\n\tfor (vector<Person*>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tPerson* p = (*it);\n\t\tcout << "姓名：" << p->m_name << " 年龄：" << p->m_age << endl;\n\t}\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 3.3 vector容器嵌套容器\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tvector<vector<int>>v;\n\tvector<int>v1;\n\tvector<int>v2;\n\tvector<int>v3;\n\tvector<int>v4;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tv1.push_back(i + 1);\n\t\tv2.push_back(i + 2);\n\t\tv3.push_back(i + 3);\n\t\tv4.push_back(i + 4);\n\t}\n\tv.push_back(v1);\n\tv.push_back(v2);\n\tv.push_back(v3);\n\tv.push_back(v4);\n\n\tfor (vector<vector<int>>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tfor (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); ++vit) {\n\t\t\tcout << *vit << " ";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n',normalizedContent:'# 3、初识stl\n\n * stl（standard template library，标准模板库）\n * stl从广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）\n * 容器和算法之间通过迭代器进行无缝连接\n * stl 几乎所有的代码都采用了模板类或者模板函数\n\nstl六大组件：\n\n容器、算法、迭代器、仿函数、适配器（配接器）、空间置配器\n\n 1. 容器：各种数据结构，如 vector、list、deque、set、map 等，用来存放数据\n 2. 算法：各种常用算法，如 sort、find、copy、for_each 等\n 3. 迭代器：扮演了容器与算法之间的胶合剂\n 4. 仿函数：行为类似函数，可作为算法的某种策略。\n 5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。\n 6. 空间置配器：负责空间的配置与管理\n\n\n# 3.1 vector 存放内置数据类型\n\n * 容器：vector\n * 算法：for_each\n * 迭代器：vector<int>::iterator\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid printval(int val) {\n\tcout << val << " ";\n}\n\nvoid test01() {\n\t// 创建 vector 容器对象，并且通过模板参数指定容器中存放的数据的类型\n\tvector<int> v;\n\t// 向容器中放数据\n\tv.push_back(10);\n\tv.push_back(20);\n\tv.push_back(30);\n\tv.push_back(40);\n\tv.push_back(50);\n\n\t// 每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素\n\t// v.begin() 返回迭代器，这个迭代器指向容器中第一个数据\n\t// v.end() 返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置\n\t// vector<int>::iterator 拿到 vector<int> 这种容器的迭代器类型\n\tvector<int>::iterator itbegin = v.begin();\n\tvector<int>::iterator itend = v.end();\n\n\t// 第一种遍历方式：\n\tcout << "while循环遍历方式：";\n\twhile (itbegin != itend) {\n\t\tcout << *itbegin << " ";\n\t\titbegin++;\n\t}\n\tcout << endl;\n\n\t// 第二种遍历方式：\n\tcout << "for循环遍历方式：";\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n\n\t// 第三种遍历方式：\n\t// 使用stl提供标准遍历算法 头文件 algorithm\n\tcout << "使用 stl 提供的遍历算法 for_each：";\n\tfor_each(v.begin(), v.end(), printval);\n\tcout << endl;\n\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 3.2 vector 存放自定义数据类型\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass person {\npublic:\n\tperson(string name,int age){\n\t\tm_name = name;\n\t\tm_age = age;\n\t}\n\t\npublic:\n\tstring m_name;\n\tint m_age;\n};\n\nvoid test01() {\n\tvector<person>v;\n\tperson p1("aaa", 10);\n\tperson p2("bbb", 20);\n\tperson p3("ccc", 30);\n\tperson p4("ddd", 40);\n\tperson p5("eee", 50);\n\tv.push_back(p1);\n\tv.push_back(p2);\n\tv.push_back(p3);\n\tv.push_back(p4);\n\tv.push_back(p5);\n\tfor (vector<person>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << "姓名：" << (*it).m_name << " 年龄：" << (*it).m_age << endl;\n\t}\n\tcout << "----------------------" << endl;\n}\n\nvoid test02() {\n\tvector<person*>v;\n\tperson p1("aaa", 10);\n\tperson p2("bbb", 20);\n\tperson p3("ccc", 30);\n\tperson p4("ddd", 40);\n\tperson p5("eee", 50);\n\tv.push_back(&p1);\n\tv.push_back(&p2);\n\tv.push_back(&p3);\n\tv.push_back(&p4);\n\tv.push_back(&p5);\n\tfor (vector<person*>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tperson* p = (*it);\n\t\tcout << "姓名：" << p->m_name << " 年龄：" << p->m_age << endl;\n\t}\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 3.3 vector容器嵌套容器\n\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tvector<vector<int>>v;\n\tvector<int>v1;\n\tvector<int>v2;\n\tvector<int>v3;\n\tvector<int>v4;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tv1.push_back(i + 1);\n\t\tv2.push_back(i + 2);\n\t\tv3.push_back(i + 3);\n\t\tv4.push_back(i + 4);\n\t}\n\tv.push_back(v1);\n\tv.push_back(v2);\n\tv.push_back(v3);\n\tv.push_back(v4);\n\n\tfor (vector<vector<int>>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tfor (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); ++vit) {\n\t\t\tcout << *vit << " ";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n',charsets:{cjk:!0}},{title:"string 容器",frontmatter:{title:"string 容器",date:"2023-12-15T09:54:13.000Z",permalink:"/pages/4906d0/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/60.Cpp%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/04.string%20%E5%AE%B9%E5%99%A8.html",relativePath:"01.CPP语言/60.Cpp提高编程/04.string 容器.md",key:"v-966b0b0c",path:"/pages/4906d0/",headers:[{level:2,title:"4、string 容器",slug:"_4、string-容器",normalizedTitle:"4、string 容器",charIndex:2},{level:3,title:"4.1 string 构造函数",slug:"_4-1-string-构造函数",normalizedTitle:"4.1 string 构造函数",charIndex:283},{level:3,title:"4.2 string 赋值操作",slug:"_4-2-string-赋值操作",normalizedTitle:"4.2 string 赋值操作",charIndex:987},{level:3,title:"4.3 string 字符串拼接",slug:"_4-3-string-字符串拼接",normalizedTitle:"4.3 string 字符串拼接",charIndex:2237},{level:3,title:"4.4 string 查找和替换",slug:"_4-4-string-查找和替换",normalizedTitle:"4.4 string 查找和替换",charIndex:3355},{level:3,title:"4.5 string字符串比较",slug:"_4-5-string字符串比较",normalizedTitle:"4.5 string字符串比较",charIndex:4375},{level:3,title:"4.6 string 字符存取",slug:"_4-6-string-字符存取",normalizedTitle:"4.6 string 字符存取",charIndex:5067},{level:3,title:"4.7 string 插入和删除",slug:"_4-7-string-插入和删除",normalizedTitle:"4.7 string 插入和删除",charIndex:5795},{level:3,title:"4.8 string 字串",slug:"_4-8-string-字串",normalizedTitle:"4.8 string 字串",charIndex:6426}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"6 min read",minutes:5.555,time:333299.99999999994,words:1111},headersStr:"4、string 容器 4.1 string 构造函数 4.2 string 赋值操作 4.3 string 字符串拼接 4.4 string 查找和替换 4.5 string字符串比较 4.6 string 字符存取 4.7 string 插入和删除 4.8 string 字串",content:'# 4、string 容器\n\n本质：\n\n * string 是 C++ 风格的字符串，而 string 本质上是一个类\n\nstring 和 char 的区别：*\n\n * char* 是一个指针\n\n * string 是一个类，类内部封装了char*，管理这个字符串，是一个char*类型的容器\n\n特点：\n\n * string 类内部封装了很多成员方法\n * 例如：查找 find、拷贝 copy、删除 delete、替换 replace、插入 insert\n * string 管理 char* 所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\n\n\n# 4.1 string 构造函数\n\n构造函数原型：\n\nstring();\t\t\t\t\t//创建一个空的字符串 例如：string str;\nstring(const char* s);\t\t//使用字符串 s 初始化\nstring(const string& str);\t//使用一个 string 对象初始化另一个 string 对象\nstring(int n, char c);\t\t//使用 n 个字符 c 初始化\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tstring s1;\t\t\t\t\t\t// 创建空字符串，调用无参构造函数\n\tcout << "s1 = " << s1 << endl;\n\n\tconst char* str = "hello world!";\n\tstring s2(str);\t\t\t\t\t// 把 c_string 转换成了 string\n\tcout << "s2 = " << s2 << endl;\n\n\tstring s3(s2);\n\tcout << "s3 = " << s3 << endl;\n\n\tstring s4(10, \'a\');\n\tcout << "s4 = " << s4 << endl;\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 4.2 string 赋值操作\n\n功能描述：\n\n * 给 string 字符串进行赋值\n\n赋值的函数原型：\n\nstring& operator=(const char* s);\t// char* 类型字符串赋值给当前的字符串\nstring& operator=(const string &s);\t// 把字符串 s 赋给当前的字符串\nstring& operator=(char c);\t\t\t// 字符赋值给当前的字符串\nstring& assign(const char *s);\t\t// 把字符串 s 赋给当前的字符串\nstring& assign(const char *s,int n);// 把字符串 s 的前 n 个字符赋给当前的字符串\nstring& assign(const string &s); \t// 把字符串 s 赋给当前字符串\nstring& assign(int n, char c); \t\t// 用 n 个字符 c 赋给当前字符串\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tstring str1;\n\tstr1 = "hello world!";\n\tcout << "str1 = " << str1 << endl;\n\n\tstring str2;\n\tstr2 = str1;\n\tcout << "str2 = " << str2 << endl;\n\n\tstring str3;\n\tstr3 = \'a\';\n\tcout << "str3 = " << str3 << endl;\n\n\tstring str4;\n\tstr4.assign("hello C++");\n\tcout << "str4 = " << str4 << endl;\n\n\tstring str5;\n\tstr5.assign("hello C++",5);\n\tcout << "str5 = " << str5 << endl;\n\n\tstring str6;\n\tstr6.assign(str5);\n\tcout << "str6 = " << str6 << endl;\n\n\tstring str7;\n\tstr7.assign(10, \'b\');\n\tcout << "str7 = " << str7 << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n总结：\n\n * string 的赋值方式很多，operator= 这种方式是比较实用的\n\n\n# 4.3 string 字符串拼接\n\n功能描述：\n\n * 实现在字符串末尾拼接字符串\n\n函数原型：\n\nstring& operator+=(const char* str); \t// 重载 += 操作符\nstring& operator+=(const char c); \t\t// 重载 += 操作符\nstring& operator+=(const string& str); \t// 重载 += 操作符\n\nstring& append(const char *s); \t\t\t// 把字符串 s 连接到当前字符串结尾\nstring& append(const char *s, int n); \t// 把字符串 s 的前 n 个字符连接到当前字符串结尾\nstring& append(const string &s); \t\t// 同 operator+=(const string& str)\nstring& append(const string &s, int pos, int n); // 字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tstring str1 = "我";\n\tstr1 += "爱学习";\n\tcout << "str1 = " << str1 << endl;\n\n\tstr1 += \':\';\n\tcout << "str1 = " << str1 << endl;\n\n\tstring str2 = "C++ Java";\n\tstr1 += str2;\n\tcout << "str1 = " << str1 << endl;\n\n\tstring str3 = "I";\n\tstr3.append(" love ");\n\tstr3.append("C++ Java ", 4);\n\tstr3.append(str2);\n\tstr3.append(str2, 3, 6);\t\t\t// 从下标 3 位置开始 ，截取 6 个字符，拼接到字符串末尾，空格也算\n\tcout << "str3 = " << str3 << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 4.4 string 查找和替换\n\n功能描述：\n\n * 查找：查找指定字符串是否存在\n * 替换：在指定的位置替换字符串\n\n函数原型：\n\n// 查找 str 第一次出现位置,从 pos 开始查找\nint find(const string& str, int pos = 0) const; \n\n// 查找 s 第一次出现位置,从 pos 开始查找\nint find(const char* s, int pos = 0) const; \n\n// 从 pos 位置查找 s 的前 n 个字符第一次位置\nint find(const char* s, int pos, int n) const;\n\n// 查找字符 c 第一次出现位置\nint find(const char c, int pos = 0) const; \n\n// 查找 str 最后一次位置,从 pos 开始查找\nint rfind(const string& str, int pos = npos) const; \n\n// 查找 s 最后一次出现位置,从 pos 开始查找\nint rfind(const char* s, int pos = npos) const; \n\n// 从 pos 查找 s 的前 n 个字符最后一次位置\nint rfind(const char* s, int pos, int n) const; \n\n// 查找字符 c 最后一次出现位置\nint rfind(const char c, int pos = 0) const; \n\n// 替换从 pos 开始 n 个字符为字符串 str\nstring& replace(int pos, int n, const string& str); \n\n// 替换从 pos 开始的 n 个字符为字符串 s\nstring& replace(int pos, int n, const char* s); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n总结：\n\n * find 查找是从左往右，rfind 从右往左\n * find 找到字符串后返回查找的第一个字符位置，找不到位置-1\n * replace 在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串\n\n\n# 4.5 string字符串比较\n\n功能描述：\n\n * 字符串之间的比较\n\n比较方式：\n\n * 字符串比较是按字符的ASCII码进行对比\n * =返回 0\n * >返回 1\n * <返回 -1\n\n函数原型：\n\nint compare(const string &s) const;\t//与字符串 s 比较\nint compare(const char *s) const;\t//与字符串 s 比较\n\n\n1\n2\n\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid test01() {\n\tstring str1 = "hello";\n\tstring str2 = "hello";\n\n\tint ret = str1.compare(str2);\n\n\tif (ret == 0) {\n\t\tcout << "s1 等于 s2" << endl;\n\t}\n\telse if (ret > 0) {\n\t\tcout << "s1 大于 s2" << endl;\n\t}\n\telse {\n\t\tcout << "s1 小于 s2" << endl;\n\t}\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n总结：\n\n * 字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大\n\n\n# 4.6 string 字符存取\n\nstring中单个字符存取方式有两种：\n\nchar& operator[](int n);//通过 [] 方式取字符\nchar& at(int n);\t\t//通过 at 方法获取字符\n\n\n1\n2\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid test01() {\n\tstring str = "hello world";\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tcout << str[i] << " ";\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tcout << str.at(i) << " ";\n\t}\n\tcout << endl;\n\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tcout << str.at(i) << " ";\n\t}\n\tcout << endl;\n\n\t// 字符修改\n\tstr[0] = \'x\';\n\tstr.at(1) = \'x\';\n\tcout << str << endl;\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n总结：\n\n * string 字符串中单个字符存取有两种方式，利用 [ ] 或 at\n\n\n# 4.7 string 插入和删除\n\n功能描述：\n\n * 对 string 字符串进行插入和删除字符操作\n\n函数原型：\n\nstring& insert(int pos, const char* s); \t// 插入字符串\nstring& insert(int pos, const string& str); // 插入字符串\nstring& insert(int pos, int n, char c); \t// 在指定位置插入 n 个字符 c\nstring& erase(int pos, int n = npos); \t\t// 删除从 Pos 开始的 n 个字符\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tstring str = "hello";\n\tstr.insert(1, "111");\n\tcout << str << endl;\n\tstr.erase(1, 3);\t//从 1 号位置开始 3 个字符\n\tcout << str << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n总结：\n\n * 插入和删除的起始下标都是从0开始\n\n\n# 4.8 string 字串\n\n功能描述：\n\n * 从字符串中获取想要的子串\n\n函数原型：\n\nstring substr(int pos = 0, int n = npos) const; // 返回由 pos 开始的 n 个字符组成的字符串\n\n\n1\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// 子串\nvoid test01() {\n\tstring str = "abcdefg";\n\tstring substr = str.substr(1, 3);\n\tcout << "substr = " << substr << endl;\n\n\tstring email = "hello@sina.com";\n\tint pos = email.find("@");\n\tstring username = email.substr(0, pos);\n\tcout << "username: " << username << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# 4、string 容器\n\n本质：\n\n * string 是 c++ 风格的字符串，而 string 本质上是一个类\n\nstring 和 char 的区别：*\n\n * char* 是一个指针\n\n * string 是一个类，类内部封装了char*，管理这个字符串，是一个char*类型的容器\n\n特点：\n\n * string 类内部封装了很多成员方法\n * 例如：查找 find、拷贝 copy、删除 delete、替换 replace、插入 insert\n * string 管理 char* 所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责\n\n\n# 4.1 string 构造函数\n\n构造函数原型：\n\nstring();\t\t\t\t\t//创建一个空的字符串 例如：string str;\nstring(const char* s);\t\t//使用字符串 s 初始化\nstring(const string& str);\t//使用一个 string 对象初始化另一个 string 对象\nstring(int n, char c);\t\t//使用 n 个字符 c 初始化\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tstring s1;\t\t\t\t\t\t// 创建空字符串，调用无参构造函数\n\tcout << "s1 = " << s1 << endl;\n\n\tconst char* str = "hello world!";\n\tstring s2(str);\t\t\t\t\t// 把 c_string 转换成了 string\n\tcout << "s2 = " << s2 << endl;\n\n\tstring s3(s2);\n\tcout << "s3 = " << s3 << endl;\n\n\tstring s4(10, \'a\');\n\tcout << "s4 = " << s4 << endl;\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 4.2 string 赋值操作\n\n功能描述：\n\n * 给 string 字符串进行赋值\n\n赋值的函数原型：\n\nstring& operator=(const char* s);\t// char* 类型字符串赋值给当前的字符串\nstring& operator=(const string &s);\t// 把字符串 s 赋给当前的字符串\nstring& operator=(char c);\t\t\t// 字符赋值给当前的字符串\nstring& assign(const char *s);\t\t// 把字符串 s 赋给当前的字符串\nstring& assign(const char *s,int n);// 把字符串 s 的前 n 个字符赋给当前的字符串\nstring& assign(const string &s); \t// 把字符串 s 赋给当前字符串\nstring& assign(int n, char c); \t\t// 用 n 个字符 c 赋给当前字符串\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tstring str1;\n\tstr1 = "hello world!";\n\tcout << "str1 = " << str1 << endl;\n\n\tstring str2;\n\tstr2 = str1;\n\tcout << "str2 = " << str2 << endl;\n\n\tstring str3;\n\tstr3 = \'a\';\n\tcout << "str3 = " << str3 << endl;\n\n\tstring str4;\n\tstr4.assign("hello c++");\n\tcout << "str4 = " << str4 << endl;\n\n\tstring str5;\n\tstr5.assign("hello c++",5);\n\tcout << "str5 = " << str5 << endl;\n\n\tstring str6;\n\tstr6.assign(str5);\n\tcout << "str6 = " << str6 << endl;\n\n\tstring str7;\n\tstr7.assign(10, \'b\');\n\tcout << "str7 = " << str7 << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n总结：\n\n * string 的赋值方式很多，operator= 这种方式是比较实用的\n\n\n# 4.3 string 字符串拼接\n\n功能描述：\n\n * 实现在字符串末尾拼接字符串\n\n函数原型：\n\nstring& operator+=(const char* str); \t// 重载 += 操作符\nstring& operator+=(const char c); \t\t// 重载 += 操作符\nstring& operator+=(const string& str); \t// 重载 += 操作符\n\nstring& append(const char *s); \t\t\t// 把字符串 s 连接到当前字符串结尾\nstring& append(const char *s, int n); \t// 把字符串 s 的前 n 个字符连接到当前字符串结尾\nstring& append(const string &s); \t\t// 同 operator+=(const string& str)\nstring& append(const string &s, int pos, int n); // 字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tstring str1 = "我";\n\tstr1 += "爱学习";\n\tcout << "str1 = " << str1 << endl;\n\n\tstr1 += \':\';\n\tcout << "str1 = " << str1 << endl;\n\n\tstring str2 = "c++ java";\n\tstr1 += str2;\n\tcout << "str1 = " << str1 << endl;\n\n\tstring str3 = "i";\n\tstr3.append(" love ");\n\tstr3.append("c++ java ", 4);\n\tstr3.append(str2);\n\tstr3.append(str2, 3, 6);\t\t\t// 从下标 3 位置开始 ，截取 6 个字符，拼接到字符串末尾，空格也算\n\tcout << "str3 = " << str3 << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 4.4 string 查找和替换\n\n功能描述：\n\n * 查找：查找指定字符串是否存在\n * 替换：在指定的位置替换字符串\n\n函数原型：\n\n// 查找 str 第一次出现位置,从 pos 开始查找\nint find(const string& str, int pos = 0) const; \n\n// 查找 s 第一次出现位置,从 pos 开始查找\nint find(const char* s, int pos = 0) const; \n\n// 从 pos 位置查找 s 的前 n 个字符第一次位置\nint find(const char* s, int pos, int n) const;\n\n// 查找字符 c 第一次出现位置\nint find(const char c, int pos = 0) const; \n\n// 查找 str 最后一次位置,从 pos 开始查找\nint rfind(const string& str, int pos = npos) const; \n\n// 查找 s 最后一次出现位置,从 pos 开始查找\nint rfind(const char* s, int pos = npos) const; \n\n// 从 pos 查找 s 的前 n 个字符最后一次位置\nint rfind(const char* s, int pos, int n) const; \n\n// 查找字符 c 最后一次出现位置\nint rfind(const char c, int pos = 0) const; \n\n// 替换从 pos 开始 n 个字符为字符串 str\nstring& replace(int pos, int n, const string& str); \n\n// 替换从 pos 开始的 n 个字符为字符串 s\nstring& replace(int pos, int n, const char* s); \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n总结：\n\n * find 查找是从左往右，rfind 从右往左\n * find 找到字符串后返回查找的第一个字符位置，找不到位置-1\n * replace 在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串\n\n\n# 4.5 string字符串比较\n\n功能描述：\n\n * 字符串之间的比较\n\n比较方式：\n\n * 字符串比较是按字符的ascii码进行对比\n * =返回 0\n * >返回 1\n * <返回 -1\n\n函数原型：\n\nint compare(const string &s) const;\t//与字符串 s 比较\nint compare(const char *s) const;\t//与字符串 s 比较\n\n\n1\n2\n\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid test01() {\n\tstring str1 = "hello";\n\tstring str2 = "hello";\n\n\tint ret = str1.compare(str2);\n\n\tif (ret == 0) {\n\t\tcout << "s1 等于 s2" << endl;\n\t}\n\telse if (ret > 0) {\n\t\tcout << "s1 大于 s2" << endl;\n\t}\n\telse {\n\t\tcout << "s1 小于 s2" << endl;\n\t}\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n总结：\n\n * 字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大\n\n\n# 4.6 string 字符存取\n\nstring中单个字符存取方式有两种：\n\nchar& operator[](int n);//通过 [] 方式取字符\nchar& at(int n);\t\t//通过 at 方法获取字符\n\n\n1\n2\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid test01() {\n\tstring str = "hello world";\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tcout << str[i] << " ";\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tcout << str.at(i) << " ";\n\t}\n\tcout << endl;\n\n\tfor (int i = 0; i < str.size(); ++i) {\n\t\tcout << str.at(i) << " ";\n\t}\n\tcout << endl;\n\n\t// 字符修改\n\tstr[0] = \'x\';\n\tstr.at(1) = \'x\';\n\tcout << str << endl;\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n总结：\n\n * string 字符串中单个字符存取有两种方式，利用 [ ] 或 at\n\n\n# 4.7 string 插入和删除\n\n功能描述：\n\n * 对 string 字符串进行插入和删除字符操作\n\n函数原型：\n\nstring& insert(int pos, const char* s); \t// 插入字符串\nstring& insert(int pos, const string& str); // 插入字符串\nstring& insert(int pos, int n, char c); \t// 在指定位置插入 n 个字符 c\nstring& erase(int pos, int n = npos); \t\t// 删除从 pos 开始的 n 个字符\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid test01() {\n\tstring str = "hello";\n\tstr.insert(1, "111");\n\tcout << str << endl;\n\tstr.erase(1, 3);\t//从 1 号位置开始 3 个字符\n\tcout << str << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n总结：\n\n * 插入和删除的起始下标都是从0开始\n\n\n# 4.8 string 字串\n\n功能描述：\n\n * 从字符串中获取想要的子串\n\n函数原型：\n\nstring substr(int pos = 0, int n = npos) const; // 返回由 pos 开始的 n 个字符组成的字符串\n\n\n1\n\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// 子串\nvoid test01() {\n\tstring str = "abcdefg";\n\tstring substr = str.substr(1, 3);\n\tcout << "substr = " << substr << endl;\n\n\tstring email = "hello@sina.com";\n\tint pos = email.find("@");\n\tstring username = email.substr(0, pos);\n\tcout << "username: " << username << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0}},{title:"deque 容器",frontmatter:{title:"deque 容器",date:"2023-12-21T09:59:01.000Z",permalink:"/pages/2a1016/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/60.Cpp%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/06.deque%20%E5%AE%B9%E5%99%A8.html",relativePath:"01.CPP语言/60.Cpp提高编程/06.deque 容器.md",key:"v-7784b32c",path:"/pages/2a1016/",headers:[{level:2,title:"6、deque 容器",slug:"_6、deque-容器",normalizedTitle:"6、deque 容器",charIndex:2},{level:3,title:"6.1 deque构造函数",slug:"_6-1-deque构造函数",normalizedTitle:"6.1 deque构造函数",charIndex:304},{level:3,title:"6.2 deque 赋值操作",slug:"_6-2-deque-赋值操作",normalizedTitle:"6.2 deque 赋值操作",charIndex:1173},{level:3,title:"6.3 deque 大小操作",slug:"_6-3-deque-大小操作",normalizedTitle:"6.3 deque 大小操作",charIndex:2037},{level:3,title:"6.4 deque 插入和删除",slug:"_6-4-deque-插入和删除",normalizedTitle:"6.4 deque 插入和删除",charIndex:3148},{level:3,title:"6.5 deque数据存取",slug:"_6-5-deque数据存取",normalizedTitle:"6.5 deque数据存取",charIndex:5075},{level:3,title:"6.6 deque 排序",slug:"_6-6-deque-排序",normalizedTitle:"6.6 deque 排序",charIndex:6049},{level:3,title:"6.7 案例——评委打分",slug:"_6-7-案例-评委打分",normalizedTitle:"6.7 案例——评委打分",charIndex:6750}],readingTime:{text:"6 min read",minutes:5.75,time:345e3,words:1150},headersStr:"6、deque 容器 6.1 deque构造函数 6.2 deque 赋值操作 6.3 deque 大小操作 6.4 deque 插入和删除 6.5 deque数据存取 6.6 deque 排序 6.7 案例——评委打分",content:'# 6、deque 容器\n\n功能：\n\n * 双端数组，可以对头端进行插入删除操作\n\ndeque 与 vector 区别：\n\n * vector 对于头部的插入删除效率低，数据量越大，效率越低\n * deque 相对而言，对头部的插入删除速度会比 vector 快\n * vector 访问元素时的速度会比 deque 快，这和两者内部实现有关\n\n\n\ndeque 内部工作原理:\n\n * deque 内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据\n * 中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间\n\n\n\n * deque 容器的迭代器也是支持随机访问的\n\n\n# 6.1 deque构造函数\n\n功能描述：\n\n * deque 容器构造\n\n函数原型：\n\ndeque<T>deqT;\t\t\t// 默认构造形式\ndeque(beg, end);\t\t// 构造函数将 [beg, end) 区间中的元素拷贝给本身。\ndeque(n, elem);\t\t\t// 构造函数将 n 个 elem 拷贝给本身\ndeque(const deque &deq);// 拷贝构造函数\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\nvoid printDeque(const deque<int>& d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tdeque<int>d1;\t\t\t\t\t// 无参构造函数\n\tfor (int i = 0; i < 10; ++i) {\n\t\td1.push_back(i);\n\t}\n\tprintDeque(d1);\n\n\tdeque<int>d2(d1.begin(), d1.end());\n\tprintDeque(d2);\n\n\tdeque<int>d3(10, 100);\n\tprintDeque(d3);\n\n\tdeque<int>d4 = d3;\n\tprintDeque(d4);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n总结：\n\n * deque 容器和 vector 容器的构造方式几乎一致，灵活使用即可\n\n\n# 6.2 deque 赋值操作\n\n功能描述：\n\n * 给 deque 容器进行赋值\n\n函数原型：\n\ndeque& operator=(const deque &deq);\t\t// 重载等号操作符\nassign(beg, end);\t\t\t\t\t\t// 将 [beg, end) 区间中的数据拷贝赋值给本身。\nassign(n, elem);\t\t\t\t\t\t// 将 n 个 elem 拷贝赋值给本身。\n\n\n1\n2\n3\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nvoid printDeque(const deque<int>& d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\n//赋值操作\nvoid test01() {\n\tdeque<int> d1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\td1.push_back(i);\n\t}\n\tprintDeque(d1);\n\n\tdeque<int> d2;\n\td2 = d1;\n\tprintDeque(d2);\n\n\tdeque<int> d3;\n\td3.assign(d1.begin(), d1.end());\n\tprintDeque(d3);\n\t\n\tdeque<int> d4;\n\td4.assign(10, 100);\n\tprintDeque(d4);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 6.3 deque 大小操作\n\n功能描述：\n\n * 对 deque 容器的大小进行操作\n\n函数原型：\n\ndeque.empty();\t\t// 判断容器是否为空\ndeque.size();\t\t// 返回容器中元素的个数\n\n// 重新指定容器的长度为 num,若容器变长，则以默认值填充新位\n// 如果容器变短，则末尾超出容器长度的元素被删除。\ndeque.resize(num);\n\n// 重新指定容器的长度为 num,若容器变长，则以 elem 值填充新位置。\n// 如果容器变短，则末尾超出容器长度的元素被删除。\ndeque.resize(num, elem);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nvoid printDeque(deque<int> &d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tdeque<int> d1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\td1.push_back(i);\n\t}\n\tprintDeque(d1);\n\n\t// 判断容器是否为空\n\tif (d1.empty()) {\n\t\tcout << "d1为空！" << endl;\n\t}\n\telse {\n\t\tcout << "d1不为空！" << endl;\n\t\t// 统计大小\n\t\tcout << "d1的大小为：" << d1.size() << endl;\n\t}\n\n\t// 重新指定大小\n\td1.resize(15, 1);\n\tprintDeque(d1);\n\td1.resize(5);\n\tprintDeque(d1);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n总结：\n\n * deque 没有容量的概念\n * 判断是否为空 --- empty\n * 返回元素个数 --- size\n * 重新指定个数 --- resize\n\n\n# 6.4 deque 插入和删除\n\n功能描述：\n\n * 向 deque 容器中插入和删除数据\n\n函数原型：\n\n * 两端插入操作：\n\npush_back(elem); // 在容器尾部添加一个数据\npush_front(elem);// 在容器头部插入一个数据\npop_back();\t\t // 删除容器最后一个数据\npop_front();\t // 删除容器第一个数据\n\n\n1\n2\n3\n4\n\n * 指定位置操作：\n\ninsert(pos, elem);\t\t// 在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。\ninsert(pos, n, elem);\t// 在 pos 位置插入 n 个 elem 数据，无返回值。\ninsert(pos, beg, end);\t// 在 pos 位置插入 [beg,end) 区间的数据，无返回值。\nclear();\t\t\t\t// 清空容器的所有数据\nerase(beg, end);\t\t// 删除 [beg,end) 区间的数据，返回下一个数据的位置。\nerase(pos);\t\t\t\t// 删除 pos 位置的数据，返回下一个数据的位置。\n\n\n1\n2\n3\n4\n5\n6\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nvoid printDeque(const deque<int>& d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\n// 两端操作\nvoid test01() {\n\tdeque<int> d;\n\t// 尾插\n\td.push_back(10);\n\td.push_back(20);\n\n\t// 头插\n\td.push_front(100);\n\td.push_front(200);\n\tprintDeque(d);\n\n\t// 尾插\n\td.pop_back();\n\td.pop_front();\n\tprintDeque(d);\n}\n\n//插入\nvoid test02() {\n\tdeque<int> d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tprintDeque(d);\n\n\td.insert(d.begin(), 1000);\n\tprintDeque(d);\n\n\td.insert(d.begin(), 2, 10000);\n\tprintDeque(d);\n\n\tdeque<int> d2;\n\td2.push_back(1);\n\td2.push_back(2);\n\td2.push_back(3);\n\n\td.insert(d.begin(), d2.begin(), d2.end());\n\tprintDeque(d);\n}\n\nvoid test03() {\n\tdeque<int> d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tprintDeque(d);\n\n\td.erase(d.begin());\n\tprintDeque(d);\n\n\td.erase(d.begin(), d.end());\n\td.clear();\n\tprintDeque(d);\n}\n\nint main() {\n\t//test01();\n\t//test02();\n\ttest03();\n\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n总结：\n\n * 插入和删除提供的位置是迭代器！\n * 尾插 --- push_back\n * 尾删 --- pop_back\n * 头插 --- push_front\n * 头删 --- pop_front\n\n\n# 6.5 deque数据存取\n\n功能描述：\n\n * 对 deque 中的数据的存取操作\n\n函数原型：\n\nat(int idx); //返回索引 idx 所指的数据\noperator[];  //返回索引 idx 所指的数据\nfront();\t //返回容器中第一个数据元素\nback();\t\t //返回容器中最后一个数据元素\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nvoid printDeque(deque<int> &d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tdeque<int> d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tfor (int i = 0; i < d.size(); ++i) {\n\t\tcout << d[i] << " ";\n\t}\n\tcout << endl;\n\n\tfor (int i = 0; i < d.size(); ++i) {\n\t\tcout << d.at(i) << " ";\n\t}\n\tcout << endl;\n\n\tcout << "front:" << d.front() << endl;\n\tcout << "back:" << d.back() << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n总结：\n\n * 除了用迭代器获取 deque 容器中元素，[ ] 和 at 也可以\n * front 返回容器第一个元素\n * back 返回容器最后一个元素\n\n\n# 6.6 deque 排序\n\n功能描述：\n\n * 利用算法实现对 deque 容器进行排序\n\n算法：\n\nsort(iterator beg,iterator end);// 对 beg 和 end 区间内元素进行排序\n\n\n1\n\n\n#include <iostream>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\nvoid printDeque(const deque<int> &d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tdeque<int> d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\n\tprintDeque(d);\n\tsort(d.begin(), d.end());\n\tprintDeque(d);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n总结：\n\n * sort 算法非常实用，使用时包含头文件 algorithm 即可\n\n\n# 6.7 案例——评委打分\n\n> 有5名选手：选手 ABCDE，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n\n实现步骤：\n\n 1. 创建五名选手，放到 vector 中\n 2. 遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评分打分存到 deque 容器中\n 3. sort 算法对 deque 容器中分数排序，去除最高和最低分\n 4. deque 容器遍历一遍，累加总分\n 5. 获取平均分\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\nclass Person {\npublic:\n\tPerson(string name, int num) {\n\t\tthis->m_name = name;\n\t\tthis->m_num = num;\n\t}\npublic:\n\tstring m_name;\n\tint m_num;\n};\n\n// 创建人数\nvoid createPerson(vector<Person>& v) {\n\tstring nameSeed = "ABCDE";\n\tfor (int i = 0; i < 5; ++i) {\n\t\tstring name = "选手";\n\t\tname += nameSeed[i];\n\t\tint num = 0;\n\t\tPerson p(name, num);\n\t\t// 将创建的Person对象 放入到容器中\n\t\tv.push_back(p);\n\t}\n}\n\nvoid setScore(vector<Person>& v) {\n\tfor (vector<Person>::iterator it = v.begin(); it != v.end(); it++) {\n\t\t// 将评委的分数 放入到deque容器中\n\t\tdeque<int> d;\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\tint score = rand() % 41 + 60;//60 ~ 100\n\t\t\td.push_back(score);\n\t\t}\n\t\t// 测试\n\t\t/*cout << "选手：" << it->m_name << " 打分：" << it->m_num << endl;\n\t\tfor (deque<int>::iterator dit = d.begin(); dit != d.end(); ++dit) {\n\t\t\tcout << *dit << " ";\n\t\t}\n\t\tcout << endl;\n\t\tcout << "-------------------------------------------------" << endl;*/\n\t\t// 排序\n\t\tsort(d.begin(), d.end());\n\t\t// 取出最高分和最低分\n\t\td.pop_back();\n\t\td.pop_front();\n\t\t// 取平均分\n\t\tint sum = 0;\n\t\tfor (deque<int>::iterator dit = d.begin(); dit != d.end(); ++dit) {\n\t\t\tsum += *dit;\n\t\t}\n\t\tint avg = sum / d.size();\n\t\t// 将平均分 赋值给选手身上\n\t\tit->m_num = avg;\n\t}\n}\n\nvoid showScore(vector<Person>& v) {\n\tfor (vector<Person>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << "姓名：" << it->m_name << " 平均分：" << it->m_num << endl;\n\t}\n\t/*cout << "-------------------------------------------------" << endl;*/\n}\n\nint main() {\n\tsrand((unsigned int)time(NULL));\n\n\t// 1、创建5名选手\n\tvector<Person> v;// 存放选手的容器\n\tcreatePerson(v);\n\t// 测试\n\t/*for (vector<Person>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << "姓名：" << (*it).m_name << " 分数：" << (*it).m_num << endl;\n\t}\n\tcout << "-------------------------------------------------" << endl;*/\n\t\n\t// 2、给5名选手打分\n\tsetScore(v);\n\n\t// 3、显示最后得分\n\tshowScore(v);\n\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n',normalizedContent:'# 6、deque 容器\n\n功能：\n\n * 双端数组，可以对头端进行插入删除操作\n\ndeque 与 vector 区别：\n\n * vector 对于头部的插入删除效率低，数据量越大，效率越低\n * deque 相对而言，对头部的插入删除速度会比 vector 快\n * vector 访问元素时的速度会比 deque 快，这和两者内部实现有关\n\n\n\ndeque 内部工作原理:\n\n * deque 内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据\n * 中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间\n\n\n\n * deque 容器的迭代器也是支持随机访问的\n\n\n# 6.1 deque构造函数\n\n功能描述：\n\n * deque 容器构造\n\n函数原型：\n\ndeque<t>deqt;\t\t\t// 默认构造形式\ndeque(beg, end);\t\t// 构造函数将 [beg, end) 区间中的元素拷贝给本身。\ndeque(n, elem);\t\t\t// 构造函数将 n 个 elem 拷贝给本身\ndeque(const deque &deq);// 拷贝构造函数\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\nvoid printdeque(const deque<int>& d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tdeque<int>d1;\t\t\t\t\t// 无参构造函数\n\tfor (int i = 0; i < 10; ++i) {\n\t\td1.push_back(i);\n\t}\n\tprintdeque(d1);\n\n\tdeque<int>d2(d1.begin(), d1.end());\n\tprintdeque(d2);\n\n\tdeque<int>d3(10, 100);\n\tprintdeque(d3);\n\n\tdeque<int>d4 = d3;\n\tprintdeque(d4);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n总结：\n\n * deque 容器和 vector 容器的构造方式几乎一致，灵活使用即可\n\n\n# 6.2 deque 赋值操作\n\n功能描述：\n\n * 给 deque 容器进行赋值\n\n函数原型：\n\ndeque& operator=(const deque &deq);\t\t// 重载等号操作符\nassign(beg, end);\t\t\t\t\t\t// 将 [beg, end) 区间中的数据拷贝赋值给本身。\nassign(n, elem);\t\t\t\t\t\t// 将 n 个 elem 拷贝赋值给本身。\n\n\n1\n2\n3\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nvoid printdeque(const deque<int>& d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\n//赋值操作\nvoid test01() {\n\tdeque<int> d1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\td1.push_back(i);\n\t}\n\tprintdeque(d1);\n\n\tdeque<int> d2;\n\td2 = d1;\n\tprintdeque(d2);\n\n\tdeque<int> d3;\n\td3.assign(d1.begin(), d1.end());\n\tprintdeque(d3);\n\t\n\tdeque<int> d4;\n\td4.assign(10, 100);\n\tprintdeque(d4);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 6.3 deque 大小操作\n\n功能描述：\n\n * 对 deque 容器的大小进行操作\n\n函数原型：\n\ndeque.empty();\t\t// 判断容器是否为空\ndeque.size();\t\t// 返回容器中元素的个数\n\n// 重新指定容器的长度为 num,若容器变长，则以默认值填充新位\n// 如果容器变短，则末尾超出容器长度的元素被删除。\ndeque.resize(num);\n\n// 重新指定容器的长度为 num,若容器变长，则以 elem 值填充新位置。\n// 如果容器变短，则末尾超出容器长度的元素被删除。\ndeque.resize(num, elem);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nvoid printdeque(deque<int> &d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tdeque<int> d1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\td1.push_back(i);\n\t}\n\tprintdeque(d1);\n\n\t// 判断容器是否为空\n\tif (d1.empty()) {\n\t\tcout << "d1为空！" << endl;\n\t}\n\telse {\n\t\tcout << "d1不为空！" << endl;\n\t\t// 统计大小\n\t\tcout << "d1的大小为：" << d1.size() << endl;\n\t}\n\n\t// 重新指定大小\n\td1.resize(15, 1);\n\tprintdeque(d1);\n\td1.resize(5);\n\tprintdeque(d1);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n总结：\n\n * deque 没有容量的概念\n * 判断是否为空 --- empty\n * 返回元素个数 --- size\n * 重新指定个数 --- resize\n\n\n# 6.4 deque 插入和删除\n\n功能描述：\n\n * 向 deque 容器中插入和删除数据\n\n函数原型：\n\n * 两端插入操作：\n\npush_back(elem); // 在容器尾部添加一个数据\npush_front(elem);// 在容器头部插入一个数据\npop_back();\t\t // 删除容器最后一个数据\npop_front();\t // 删除容器第一个数据\n\n\n1\n2\n3\n4\n\n * 指定位置操作：\n\ninsert(pos, elem);\t\t// 在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。\ninsert(pos, n, elem);\t// 在 pos 位置插入 n 个 elem 数据，无返回值。\ninsert(pos, beg, end);\t// 在 pos 位置插入 [beg,end) 区间的数据，无返回值。\nclear();\t\t\t\t// 清空容器的所有数据\nerase(beg, end);\t\t// 删除 [beg,end) 区间的数据，返回下一个数据的位置。\nerase(pos);\t\t\t\t// 删除 pos 位置的数据，返回下一个数据的位置。\n\n\n1\n2\n3\n4\n5\n6\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nvoid printdeque(const deque<int>& d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\n// 两端操作\nvoid test01() {\n\tdeque<int> d;\n\t// 尾插\n\td.push_back(10);\n\td.push_back(20);\n\n\t// 头插\n\td.push_front(100);\n\td.push_front(200);\n\tprintdeque(d);\n\n\t// 尾插\n\td.pop_back();\n\td.pop_front();\n\tprintdeque(d);\n}\n\n//插入\nvoid test02() {\n\tdeque<int> d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tprintdeque(d);\n\n\td.insert(d.begin(), 1000);\n\tprintdeque(d);\n\n\td.insert(d.begin(), 2, 10000);\n\tprintdeque(d);\n\n\tdeque<int> d2;\n\td2.push_back(1);\n\td2.push_back(2);\n\td2.push_back(3);\n\n\td.insert(d.begin(), d2.begin(), d2.end());\n\tprintdeque(d);\n}\n\nvoid test03() {\n\tdeque<int> d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tprintdeque(d);\n\n\td.erase(d.begin());\n\tprintdeque(d);\n\n\td.erase(d.begin(), d.end());\n\td.clear();\n\tprintdeque(d);\n}\n\nint main() {\n\t//test01();\n\t//test02();\n\ttest03();\n\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n总结：\n\n * 插入和删除提供的位置是迭代器！\n * 尾插 --- push_back\n * 尾删 --- pop_back\n * 头插 --- push_front\n * 头删 --- pop_front\n\n\n# 6.5 deque数据存取\n\n功能描述：\n\n * 对 deque 中的数据的存取操作\n\n函数原型：\n\nat(int idx); //返回索引 idx 所指的数据\noperator[];  //返回索引 idx 所指的数据\nfront();\t //返回容器中第一个数据元素\nback();\t\t //返回容器中最后一个数据元素\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <deque>\nusing namespace std;\n\nvoid printdeque(deque<int> &d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tdeque<int> d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\tfor (int i = 0; i < d.size(); ++i) {\n\t\tcout << d[i] << " ";\n\t}\n\tcout << endl;\n\n\tfor (int i = 0; i < d.size(); ++i) {\n\t\tcout << d.at(i) << " ";\n\t}\n\tcout << endl;\n\n\tcout << "front:" << d.front() << endl;\n\tcout << "back:" << d.back() << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n总结：\n\n * 除了用迭代器获取 deque 容器中元素，[ ] 和 at 也可以\n * front 返回容器第一个元素\n * back 返回容器最后一个元素\n\n\n# 6.6 deque 排序\n\n功能描述：\n\n * 利用算法实现对 deque 容器进行排序\n\n算法：\n\nsort(iterator beg,iterator end);// 对 beg 和 end 区间内元素进行排序\n\n\n1\n\n\n#include <iostream>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\nvoid printdeque(const deque<int> &d) {\n\tfor (deque<int>::const_iterator it = d.begin(); it != d.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tdeque<int> d;\n\td.push_back(10);\n\td.push_back(20);\n\td.push_front(100);\n\td.push_front(200);\n\n\tprintdeque(d);\n\tsort(d.begin(), d.end());\n\tprintdeque(d);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n总结：\n\n * sort 算法非常实用，使用时包含头文件 algorithm 即可\n\n\n# 6.7 案例——评委打分\n\n> 有5名选手：选手 abcde，10 个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。\n\n实现步骤：\n\n 1. 创建五名选手，放到 vector 中\n 2. 遍历 vector 容器，取出来每一个选手，执行 for 循环，可以把 10 个评分打分存到 deque 容器中\n 3. sort 算法对 deque 容器中分数排序，去除最高和最低分\n 4. deque 容器遍历一遍，累加总分\n 5. 获取平均分\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\nclass person {\npublic:\n\tperson(string name, int num) {\n\t\tthis->m_name = name;\n\t\tthis->m_num = num;\n\t}\npublic:\n\tstring m_name;\n\tint m_num;\n};\n\n// 创建人数\nvoid createperson(vector<person>& v) {\n\tstring nameseed = "abcde";\n\tfor (int i = 0; i < 5; ++i) {\n\t\tstring name = "选手";\n\t\tname += nameseed[i];\n\t\tint num = 0;\n\t\tperson p(name, num);\n\t\t// 将创建的person对象 放入到容器中\n\t\tv.push_back(p);\n\t}\n}\n\nvoid setscore(vector<person>& v) {\n\tfor (vector<person>::iterator it = v.begin(); it != v.end(); it++) {\n\t\t// 将评委的分数 放入到deque容器中\n\t\tdeque<int> d;\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\tint score = rand() % 41 + 60;//60 ~ 100\n\t\t\td.push_back(score);\n\t\t}\n\t\t// 测试\n\t\t/*cout << "选手：" << it->m_name << " 打分：" << it->m_num << endl;\n\t\tfor (deque<int>::iterator dit = d.begin(); dit != d.end(); ++dit) {\n\t\t\tcout << *dit << " ";\n\t\t}\n\t\tcout << endl;\n\t\tcout << "-------------------------------------------------" << endl;*/\n\t\t// 排序\n\t\tsort(d.begin(), d.end());\n\t\t// 取出最高分和最低分\n\t\td.pop_back();\n\t\td.pop_front();\n\t\t// 取平均分\n\t\tint sum = 0;\n\t\tfor (deque<int>::iterator dit = d.begin(); dit != d.end(); ++dit) {\n\t\t\tsum += *dit;\n\t\t}\n\t\tint avg = sum / d.size();\n\t\t// 将平均分 赋值给选手身上\n\t\tit->m_num = avg;\n\t}\n}\n\nvoid showscore(vector<person>& v) {\n\tfor (vector<person>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << "姓名：" << it->m_name << " 平均分：" << it->m_num << endl;\n\t}\n\t/*cout << "-------------------------------------------------" << endl;*/\n}\n\nint main() {\n\tsrand((unsigned int)time(null));\n\n\t// 1、创建5名选手\n\tvector<person> v;// 存放选手的容器\n\tcreateperson(v);\n\t// 测试\n\t/*for (vector<person>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << "姓名：" << (*it).m_name << " 分数：" << (*it).m_num << endl;\n\t}\n\tcout << "-------------------------------------------------" << endl;*/\n\t\n\t// 2、给5名选手打分\n\tsetscore(v);\n\n\t// 3、显示最后得分\n\tshowscore(v);\n\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n',charsets:{cjk:!0}},{title:"vector 容器",frontmatter:{title:"vector 容器",date:"2023-12-15T16:47:20.000Z",permalink:"/pages/13697a/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/60.Cpp%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/05.vector%20%E5%AE%B9%E5%99%A8.html",relativePath:"01.CPP语言/60.Cpp提高编程/05.vector 容器.md",key:"v-2a6914c8",path:"/pages/13697a/",headers:[{level:2,title:"5、vector 容器",slug:"_5、vector-容器",normalizedTitle:"5、vector 容器",charIndex:2},{level:3,title:"5.1 vector构造函数",slug:"_5-1-vector构造函数",normalizedTitle:"5.1 vector构造函数",charIndex:193},{level:3,title:"5.2 vector 赋值操作",slug:"_5-2-vector-赋值操作",normalizedTitle:"5.2 vector 赋值操作",charIndex:1046},{level:3,title:"5.3 vector 容量和大小",slug:"_5-3-vector-容量和大小",normalizedTitle:"5.3 vector 容量和大小",charIndex:1947},{level:3,title:"5.4 vector 插入和删除",slug:"_5-4-vector-插入和删除",normalizedTitle:"5.4 vector 插入和删除",charIndex:3179},{level:3,title:"5.5 vector 互换容器",slug:"_5-5-vector-互换容器",normalizedTitle:"5.5 vector 互换容器",charIndex:5332},{level:3,title:"5.6 vector预留空间",slug:"_5-6-vector预留空间",normalizedTitle:"5.6 vector预留空间",charIndex:6564}],readingTime:{text:"5 min read",minutes:4.69,time:281400.00000000006,words:938},headersStr:"5、vector 容器 5.1 vector构造函数 5.2 vector 赋值操作 5.3 vector 容量和大小 5.4 vector 插入和删除 5.5 vector 互换容器 5.6 vector预留空间",content:'# 5、vector 容器\n\n功能：\n\n * vector 数据结构和数组非常相似，也称为单端数组\n\nvector与普通数组的区别：\n\n * 不同之处在于数组是静态空间，而 vector 可以动态扩展\n\n动态扩展：\n\n * 并不是在原空间之后 续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间\n\n\n\n * vector 容器的迭代器是支持随机访问的迭代器\n\n\n# 5.1 vector构造函数\n\n功能描述：\n\n * 创建 vector 容器\n\n函数原型：\n\nvector<T> v;\t\t\t\t\t\t// 采用模板实现类实现，默认构造函数\nvector(v.begin(), v.end());\t\t\t// 将 v[begin(),end()] 区间中的元素拷贝给本身\nvector(n, elem);\t\t\t\t\t// 构造函数将 n 个 elem 拷贝给本身\nvector(const vector vector &vec);\t// 拷贝构造函数\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nvoid printVector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\nvoid test01() {\n\tvector<int> v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tprintVector(v1);\n\n\tvector<int> v2(v1.begin(),v1.end());\n\tprintVector(v2);\n\n\tvector<int> v3(10, 100);\n\tprintVector(v3);\n\n\tvector<int> v4(v3);\n\tprintVector(v4);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 5.2 vector 赋值操作\n\n功能描述：\n\n * 给 vector 容器进行赋值\n\n函数原型：\n\nvector& operator=(const vector &vec);\t// 重载等号操作符\nassign(beg, end);\t\t\t\t\t\t// 将 [beg, end] 区间中的数据拷贝赋值给本身\nassign(n, elem);\t\t\t\t\t\t// 将 n 个 elem 拷贝赋值给本身\n\n\n1\n2\n3\n\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nvoid printVector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\nvoid test01() {\n\tvector<int> v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tprintVector(v1);\n\n\tvector<int> v2;\n\tv2 = v1;\n\tprintVector(v2);\n\n\tvector<int> v3;\n\tv3.assign(v1.begin(),v1.end());\n\tprintVector(v3);\n\n\tvector<int> v4;\n\tv4.assign(10, 100);\n\tprintVector(v4);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n总结：\n\n * vector 赋值方式比较简单，使用 operator=，或者 assign 都可以\n\n\n# 5.3 vector 容量和大小\n\n功能描述：\n\n * 对 vector 容器的容量和大小操作\n\n函数原型：\n\nempty();\t\t// 判断容器是否为空\ncapacity();\t\t// 容器的容量\nsize();\t\t\t// 返回容器中元素的个数\n\n// 重新指定容器的长度为 num，若容器边长，则默认值填充新位置。\n// 如果容器变短，则末尾超出容器长度的元素被删除。\nresize(int num);\n\n// 重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位\n// 如果容器变短，则末尾超出容器长度的元素被删除\nresize(int num, elem);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printVector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\nvoid test01() {\n\tvector<int> v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tprintVector(v1);\n\tif (v1.empty()) {\n\t\tcout << "v1为空" << endl;\n\t}\n\telse {\n\t\tcout << "v1不为空" << endl;\n\t\tcout << "v1的容量为：" << v1.capacity() << endl;\n\t\tcout << "v1的大小为：" << v1.size() << endl;\n\t}\n \n\t// resize 重新指定大小 ，若指定的更大，默认用 0 填充新位置，可以利用重载版本替换默认填充\n\tv1.resize(15, 10);\n\tprintVector(v1);\n\n\t// resize 重新指定大小 ，若指定的更小，超出部分元素被删除\n\tv1.resize(5);\n\tprintVector(v1);\n\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n总结：\n\n * 判断是否为空 --- empty\n * 返回元素个数 --- size\n * 返回容器容量 --- capacity\n * 重新指定大小 --- resize\n\n\n# 5.4 vector 插入和删除\n\n功能描述：\n\n * 对 vector 容器进行插入、删除操作\n\n函数原型：\n\npush_back(ele);\t\t\t\t\t\t\t\t// 尾部插入元素 ele\npop_back();\t\t\t\t\t\t\t\t\t// 删除最后一个元素\ninsert(const_iterator pos, ele);\t\t\t// 迭代器指向位置 pos 插入元素 ele\n\n// 迭代器指向位置 pos 插入 count 个元素 ele\ninsert(const_iterator pos, int count, ele);\nerase(const_iterator pos);\t\t\t\t\t// 删除迭代器指向的元素\n\n// 删除迭代器从 start 到 end 之间的元素\nerase(const_iterator start, const_iterator end);\nclear();\t\t\t\t\t\t\t\t\t// 删除容器中所有元素\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printVector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\nvoid test01() {\n\tvector<int> v1;\n\t// 尾插\n\tv1.push_back(10);\n\tv1.push_back(20);\n\tv1.push_back(30);\n\tv1.push_back(40);\n\tv1.push_back(50);\n\t\n\t// 尾删\n\tv1.pop_back();\n\tprintVector(v1);\n\n\t// 插入\n\tv1.insert(v1.begin(), 100);\n\tprintVector(v1);\n\n\tv1.insert(v1.begin(), 2, 1000);\n\tprintVector(v1);\n\n\t// 删除\n\tv1.erase(v1.begin());\n\tprintVector(v1);\n\n\t// 清空\n\tv1.erase(v1.begin(), v1.end());\n\tv1.clear();\n\tprintVector(v1);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n总结：\n\n * 尾插 --- push_back\n * 尾删 --- pop_back\n * 插入 --- insert (位置迭代器)\n * 删除 --- erase （位置迭代器）\n * 清空 --- clear\n\n5.5 vecto r数据存取\n\n功能描述：\n\n * 对 vector 中的数据的存取操作\n\n函数原型：\n\nat(int idx);// 返回索引 idx 所指的数据\noperator[]; // 返回索引 idx 所指的数据\nfront();\t// 返回容器中第一个数据元素\nback();\t\t// 返回容器中最后一个数据元素\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid test01() {\n\tvector<int>v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tfor (int i = 0; i < v1.size(); ++i) {\n\t\tcout << v1[i] << " ";\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < v1.size(); ++i) {\n\t\tcout << v1.at(i) << " ";\n\t}\n\tcout << endl;\n\n\tcout << "v1的第一个元素为：" << v1.front() << endl;\n\tcout << "v1的最后一个元素为：" << v1.back() << endl;\n\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n总结：\n\n * 除了用迭代器获取 vector 容器中元素，[ ] 和 at 也可以\n * front 返回容器第一个元素\n * back 返回容器最后一个元素\n\n\n# 5.5 vector 互换容器\n\n功能描述：\n\n * 实现两个容器内元素进行互换\n\n函数原型：\n\nswap(vec);// 将vec与本身的元素互换\n\n\n1\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printVector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tvector<int>v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tprintVector(v1);\n\n\tvector<int>v2;\n\tfor (int i = 10; i > 0; --i) {\n\t\tv2.push_back(i);\n\t}\n\tprintVector(v2);\n\n\t// 互换容器\n\tcout << "互换容器后：" << endl;\n\tv1.swap(v2);\n\tprintVector(v1);\n\tprintVector(v2);\n}\n\nvoid test02() {\n\tvector<int>v;\n\tfor (int i = 0; i < 100000; ++i) {\n\t\tv.push_back(i);\n\t}\n\tcout << "v的容量大小为：" << v.capacity() << endl;\n\tcout << "v的大小为：" << v.size() << endl;\n\tv.resize(3);\n\tcout << "v的容量大小为：" << v.capacity() << endl;\n\tcout << "v的大小为：" << v.size() << endl;\n\n\t// 收缩内存\n\tvector<int>(v).swap(v);// 匿名对象\n\tcout << "v的容量大小为：" << v.capacity() << endl;\n\tcout << "v的大小为：" << v.size() << endl;\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n总结：\n\n * swap 可以使两个容器互换，可以达到实用的收缩内存效果\n\n\n# 5.6 vector预留空间\n\n功能描述：\n\n * 减少 vector 在动态扩展容量时的扩展次数\n\n函数原型：\n\nreserve(int len);// 容器预留 len 个元素长度，预留位置不初始化，元素不可访问\n\n\n1\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid test01() {\n\tvector<int>v;\n\t//预留空间\n\tv.reserve(100000);\n\n\tint num = 0;\n\tint* p = nullptr;\n\tfor (int i = 0; i < 100000; ++i) {\n\t\tv.push_back(i);\n\t\tif (p != &v[0]) {\n\t\t\tp = &v[0];\n\t\t\tnum++;\n\t\t}\n\t}\n\tcout << "num:" << num << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n总结：\n\n * 如果数据量较大，可以一开始利用 reserve 预留空间',normalizedContent:'# 5、vector 容器\n\n功能：\n\n * vector 数据结构和数组非常相似，也称为单端数组\n\nvector与普通数组的区别：\n\n * 不同之处在于数组是静态空间，而 vector 可以动态扩展\n\n动态扩展：\n\n * 并不是在原空间之后 续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间\n\n\n\n * vector 容器的迭代器是支持随机访问的迭代器\n\n\n# 5.1 vector构造函数\n\n功能描述：\n\n * 创建 vector 容器\n\n函数原型：\n\nvector<t> v;\t\t\t\t\t\t// 采用模板实现类实现，默认构造函数\nvector(v.begin(), v.end());\t\t\t// 将 v[begin(),end()] 区间中的元素拷贝给本身\nvector(n, elem);\t\t\t\t\t// 构造函数将 n 个 elem 拷贝给本身\nvector(const vector vector &vec);\t// 拷贝构造函数\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nvoid printvector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\nvoid test01() {\n\tvector<int> v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tprintvector(v1);\n\n\tvector<int> v2(v1.begin(),v1.end());\n\tprintvector(v2);\n\n\tvector<int> v3(10, 100);\n\tprintvector(v3);\n\n\tvector<int> v4(v3);\n\tprintvector(v4);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 5.2 vector 赋值操作\n\n功能描述：\n\n * 给 vector 容器进行赋值\n\n函数原型：\n\nvector& operator=(const vector &vec);\t// 重载等号操作符\nassign(beg, end);\t\t\t\t\t\t// 将 [beg, end] 区间中的数据拷贝赋值给本身\nassign(n, elem);\t\t\t\t\t\t// 将 n 个 elem 拷贝赋值给本身\n\n\n1\n2\n3\n\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nvoid printvector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\nvoid test01() {\n\tvector<int> v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tprintvector(v1);\n\n\tvector<int> v2;\n\tv2 = v1;\n\tprintvector(v2);\n\n\tvector<int> v3;\n\tv3.assign(v1.begin(),v1.end());\n\tprintvector(v3);\n\n\tvector<int> v4;\n\tv4.assign(10, 100);\n\tprintvector(v4);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n总结：\n\n * vector 赋值方式比较简单，使用 operator=，或者 assign 都可以\n\n\n# 5.3 vector 容量和大小\n\n功能描述：\n\n * 对 vector 容器的容量和大小操作\n\n函数原型：\n\nempty();\t\t// 判断容器是否为空\ncapacity();\t\t// 容器的容量\nsize();\t\t\t// 返回容器中元素的个数\n\n// 重新指定容器的长度为 num，若容器边长，则默认值填充新位置。\n// 如果容器变短，则末尾超出容器长度的元素被删除。\nresize(int num);\n\n// 重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位\n// 如果容器变短，则末尾超出容器长度的元素被删除\nresize(int num, elem);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printvector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\nvoid test01() {\n\tvector<int> v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tprintvector(v1);\n\tif (v1.empty()) {\n\t\tcout << "v1为空" << endl;\n\t}\n\telse {\n\t\tcout << "v1不为空" << endl;\n\t\tcout << "v1的容量为：" << v1.capacity() << endl;\n\t\tcout << "v1的大小为：" << v1.size() << endl;\n\t}\n \n\t// resize 重新指定大小 ，若指定的更大，默认用 0 填充新位置，可以利用重载版本替换默认填充\n\tv1.resize(15, 10);\n\tprintvector(v1);\n\n\t// resize 重新指定大小 ，若指定的更小，超出部分元素被删除\n\tv1.resize(5);\n\tprintvector(v1);\n\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n总结：\n\n * 判断是否为空 --- empty\n * 返回元素个数 --- size\n * 返回容器容量 --- capacity\n * 重新指定大小 --- resize\n\n\n# 5.4 vector 插入和删除\n\n功能描述：\n\n * 对 vector 容器进行插入、删除操作\n\n函数原型：\n\npush_back(ele);\t\t\t\t\t\t\t\t// 尾部插入元素 ele\npop_back();\t\t\t\t\t\t\t\t\t// 删除最后一个元素\ninsert(const_iterator pos, ele);\t\t\t// 迭代器指向位置 pos 插入元素 ele\n\n// 迭代器指向位置 pos 插入 count 个元素 ele\ninsert(const_iterator pos, int count, ele);\nerase(const_iterator pos);\t\t\t\t\t// 删除迭代器指向的元素\n\n// 删除迭代器从 start 到 end 之间的元素\nerase(const_iterator start, const_iterator end);\nclear();\t\t\t\t\t\t\t\t\t// 删除容器中所有元素\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printvector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\nvoid test01() {\n\tvector<int> v1;\n\t// 尾插\n\tv1.push_back(10);\n\tv1.push_back(20);\n\tv1.push_back(30);\n\tv1.push_back(40);\n\tv1.push_back(50);\n\t\n\t// 尾删\n\tv1.pop_back();\n\tprintvector(v1);\n\n\t// 插入\n\tv1.insert(v1.begin(), 100);\n\tprintvector(v1);\n\n\tv1.insert(v1.begin(), 2, 1000);\n\tprintvector(v1);\n\n\t// 删除\n\tv1.erase(v1.begin());\n\tprintvector(v1);\n\n\t// 清空\n\tv1.erase(v1.begin(), v1.end());\n\tv1.clear();\n\tprintvector(v1);\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n总结：\n\n * 尾插 --- push_back\n * 尾删 --- pop_back\n * 插入 --- insert (位置迭代器)\n * 删除 --- erase （位置迭代器）\n * 清空 --- clear\n\n5.5 vecto r数据存取\n\n功能描述：\n\n * 对 vector 中的数据的存取操作\n\n函数原型：\n\nat(int idx);// 返回索引 idx 所指的数据\noperator[]; // 返回索引 idx 所指的数据\nfront();\t// 返回容器中第一个数据元素\nback();\t\t// 返回容器中最后一个数据元素\n\n\n1\n2\n3\n4\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid test01() {\n\tvector<int>v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tfor (int i = 0; i < v1.size(); ++i) {\n\t\tcout << v1[i] << " ";\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < v1.size(); ++i) {\n\t\tcout << v1.at(i) << " ";\n\t}\n\tcout << endl;\n\n\tcout << "v1的第一个元素为：" << v1.front() << endl;\n\tcout << "v1的最后一个元素为：" << v1.back() << endl;\n\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n总结：\n\n * 除了用迭代器获取 vector 容器中元素，[ ] 和 at 也可以\n * front 返回容器第一个元素\n * back 返回容器最后一个元素\n\n\n# 5.5 vector 互换容器\n\n功能描述：\n\n * 实现两个容器内元素进行互换\n\n函数原型：\n\nswap(vec);// 将vec与本身的元素互换\n\n\n1\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid printvector(vector<int>& v) {\n\tfor (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n\t\tcout << *it << " ";\n\t}\n\tcout << endl;\n}\n\nvoid test01() {\n\tvector<int>v1;\n\tfor (int i = 0; i < 10; ++i) {\n\t\tv1.push_back(i);\n\t}\n\tprintvector(v1);\n\n\tvector<int>v2;\n\tfor (int i = 10; i > 0; --i) {\n\t\tv2.push_back(i);\n\t}\n\tprintvector(v2);\n\n\t// 互换容器\n\tcout << "互换容器后：" << endl;\n\tv1.swap(v2);\n\tprintvector(v1);\n\tprintvector(v2);\n}\n\nvoid test02() {\n\tvector<int>v;\n\tfor (int i = 0; i < 100000; ++i) {\n\t\tv.push_back(i);\n\t}\n\tcout << "v的容量大小为：" << v.capacity() << endl;\n\tcout << "v的大小为：" << v.size() << endl;\n\tv.resize(3);\n\tcout << "v的容量大小为：" << v.capacity() << endl;\n\tcout << "v的大小为：" << v.size() << endl;\n\n\t// 收缩内存\n\tvector<int>(v).swap(v);// 匿名对象\n\tcout << "v的容量大小为：" << v.capacity() << endl;\n\tcout << "v的大小为：" << v.size() << endl;\n}\n\nint main() {\n\ttest01();\n\ttest02();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n总结：\n\n * swap 可以使两个容器互换，可以达到实用的收缩内存效果\n\n\n# 5.6 vector预留空间\n\n功能描述：\n\n * 减少 vector 在动态扩展容量时的扩展次数\n\n函数原型：\n\nreserve(int len);// 容器预留 len 个元素长度，预留位置不初始化，元素不可访问\n\n\n1\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid test01() {\n\tvector<int>v;\n\t//预留空间\n\tv.reserve(100000);\n\n\tint num = 0;\n\tint* p = nullptr;\n\tfor (int i = 0; i < 100000; ++i) {\n\t\tv.push_back(i);\n\t\tif (p != &v[0]) {\n\t\t\tp = &v[0];\n\t\t\tnum++;\n\t\t}\n\t}\n\tcout << "num:" << num << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n总结：\n\n * 如果数据量较大，可以一开始利用 reserve 预留空间',charsets:{cjk:!0}},{title:"stack 容器",frontmatter:{title:"stack 容器",date:"2023-12-21T09:59:01.000Z",permalink:"/pages/29568d/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/60.Cpp%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/07.stack%20%E5%AE%B9%E5%99%A8.html",relativePath:"01.CPP语言/60.Cpp提高编程/07.stack 容器.md",key:"v-1c42788c",path:"/pages/29568d/",headers:[{level:2,title:"7、stack 容器",slug:"_7、stack-容器",normalizedTitle:"7、stack 容器",charIndex:2},{level:3,title:"7.1 stack 常用接口",slug:"_7-1-stack-常用接口",normalizedTitle:"7.1 stack 常用接口",charIndex:160},{level:3,title:"7.2 stack 遍历",slug:"_7-2-stack-遍历",normalizedTitle:"7.2 stack 遍历",charIndex:973}],readingTime:{text:"1 min read",minutes:.855,time:51300,words:171},headersStr:"7、stack 容器 7.1 stack 常用接口 7.2 stack 遍历",content:'# 7、stack 容器\n\n概念：\n\n * stack 是一种先进后出（First In Last Out，FILO）的数据结构，它只有一个出口\n\n\n\n * 栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为\n * 栈中进入数据称为 --- 入栈 push\n * 栈中弹出数据称为 --- 出栈 pop\n\n\n# 7.1 stack 常用接口\n\n功能描述：\n\n构造函数：\n\nstack<T> stk;\t\t\t\t// stack 采用模板类实现，stack 对象的默认构造形式\nstack(const stack &stk);\t// 拷贝构造函数\n\n\n1\n2\n\n\n赋值操作：\n\nstack& operator=(const stack &stk); \t// 重载等号操作符\n\n\n1\n\n\n数据存取：\n\npush(elem);\t// 向栈顶添加元素\npop();\t\t// 从栈顶移除第一个元素\ntop();\t\t// 返回栈顶元素\n\n\n1\n2\n3\n\n\n大小操作：\n\nempty();\t// 判断堆栈是否为空\nsize();\t\t// 返回栈的大小\n\n\n1\n2\n\n\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nvoid test01() {\n\tstack<int> st;\n\tst.push(10);\n\tst.push(20);\n\tst.push(30);\n\n\twhile (!st.empty()) {\n\t\t// 输出栈顶元素\n\t\tcout << "栈顶元素为：" << st.top() << endl;\n\t\t// 弹出栈顶元素\n\t\tst.pop();\n\t}\n\tcout << "栈的大小为：" << st.size() << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n总结：\n\n * 入栈 --- push\n * 出栈 --- pop\n * 返回栈顶 --- top\n * 判断栈是否为空 --- empty\n * 返回栈大小 --- size\n\n\n# 7.2 stack 遍历\n\nstack<int> st;\nfor (int i = 0; i < 10; ++i) {\n    st.push(i);\n}\nwhile( !st.empty()) {\n    int tp = st.top();\n    st.pop();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'# 7、stack 容器\n\n概念：\n\n * stack 是一种先进后出（first in last out，filo）的数据结构，它只有一个出口\n\n\n\n * 栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为\n * 栈中进入数据称为 --- 入栈 push\n * 栈中弹出数据称为 --- 出栈 pop\n\n\n# 7.1 stack 常用接口\n\n功能描述：\n\n构造函数：\n\nstack<t> stk;\t\t\t\t// stack 采用模板类实现，stack 对象的默认构造形式\nstack(const stack &stk);\t// 拷贝构造函数\n\n\n1\n2\n\n\n赋值操作：\n\nstack& operator=(const stack &stk); \t// 重载等号操作符\n\n\n1\n\n\n数据存取：\n\npush(elem);\t// 向栈顶添加元素\npop();\t\t// 从栈顶移除第一个元素\ntop();\t\t// 返回栈顶元素\n\n\n1\n2\n3\n\n\n大小操作：\n\nempty();\t// 判断堆栈是否为空\nsize();\t\t// 返回栈的大小\n\n\n1\n2\n\n\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nvoid test01() {\n\tstack<int> st;\n\tst.push(10);\n\tst.push(20);\n\tst.push(30);\n\n\twhile (!st.empty()) {\n\t\t// 输出栈顶元素\n\t\tcout << "栈顶元素为：" << st.top() << endl;\n\t\t// 弹出栈顶元素\n\t\tst.pop();\n\t}\n\tcout << "栈的大小为：" << st.size() << endl;\n}\n\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n总结：\n\n * 入栈 --- push\n * 出栈 --- pop\n * 返回栈顶 --- top\n * 判断栈是否为空 --- empty\n * 返回栈大小 --- size\n\n\n# 7.2 stack 遍历\n\nstack<int> st;\nfor (int i = 0; i < 10; ++i) {\n    st.push(i);\n}\nwhile( !st.empty()) {\n    int tp = st.top();\n    st.pop();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0}},{title:"queue 容器",frontmatter:{title:"queue 容器",date:"2023-12-21T09:59:01.000Z",permalink:"/pages/95225a/"},regularPath:"/01.CPP%E8%AF%AD%E8%A8%80/60.Cpp%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/08.queue%20%E5%AE%B9%E5%99%A8.html",relativePath:"01.CPP语言/60.Cpp提高编程/08.queue 容器.md",key:"v-be55bf68",path:"/pages/95225a/",headers:[{level:2,title:"8、queue 容器",slug:"_8、queue-容器",normalizedTitle:"8、queue 容器",charIndex:2},{level:3,title:"8.1 queue 常用接口",slug:"_8-1-queue-常用接口",normalizedTitle:"8.1 queue 常用接口",charIndex:188}],readingTime:{text:"2 min read",minutes:1.12,time:67200,words:224},headersStr:"8、queue 容器 8.1 queue 常用接口",content:'# 8、queue 容器\n\n概念：\n\n * Queue 是一种先进先出（First In First Out，FIFO）的数据结构，他有两个出口\n\n\n\n * 队列容器允许从一端新增元素，从另一端移除元素\n * 队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为\n * 队列中进数据称为 --- 入队 push\n * 队列中出数据称为 --- 出队 pop\n\n\n# 8.1 queue 常用接口\n\n功能描述：\n\n * 栈容器常用的对外接口\n\n构造函数：\n\nqueue<T> que; \t\t\t\t// queue 采用模板类实现，queue 对象的默认构造形式\nqueue(const queue &que); \t// 拷贝构造函数\n\n\n1\n2\n\n\n赋值操作：\n\nqueue& operator=(const queue &que); // 重载等号操作符\n\n\n1\n\n\n数据存取：\n\npush(elem); // 往队尾添加元素\npop(); \t\t// 从队头移除第一个元素\nback(); \t// 返回最后一个元素\nfront(); \t// 返回第一个元素\n\n\n1\n2\n3\n4\n\n\n大小操作：\n\nempty(); \t// 判断堆栈是否为空\nsize(); \t// 返回栈的大小\n\n\n1\n2\n\n\n#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nclass Person\n{\npublic:\n\tPerson(string name, int age)\n\t{\n\t\tthis->m_Name = name;\n\t\tthis->m_Age = age;\n\t}\n\tstring m_Name;\n\tint m_Age;\n};\nvoid test01() {\n\t// 创建队列\n\tqueue<Person> q;\n\t// 准备数据\n\tPerson p1("唐僧", 30);\n\tPerson p2("孙悟空", 1000);\n\tPerson p3("猪八戒", 900);\n\tPerson p4("沙僧", 800);\n\t// 向队列中添加元素 入队操作\n\tq.push(p1);\n\tq.push(p2);\n\tq.push(p3);\n\tq.push(p4);\n\t// 队列不提供迭代器，更不支持随机访问\n\twhile (!q.empty()) {\n\t\t// 输出队头元素\n\t\tcout << "队头元素-- 姓名： " << q.front().m_Name\n\t\t\t<< " 年龄： " << q.front().m_Age << endl;\n\t\tcout << "队尾元素-- 姓名： " << q.back().m_Name\n\t\t\t<< " 年龄： " << q.back().m_Age << endl;\n\t\tcout << endl;\n\t\t// 弹出队头元素\n\t\tq.pop();\n\t}\n\tcout << "队列大小为：" << q.size() << endl;\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n总结：\n\n * 入队 --- push\n * 出队 --- pop\n * 返回队头元素 --- front\n * 返回队尾元素 --- back\n * 判断队是否为空 --- empty\n * 返回队列大小 --- size',normalizedContent:'# 8、queue 容器\n\n概念：\n\n * queue 是一种先进先出（first in first out，fifo）的数据结构，他有两个出口\n\n\n\n * 队列容器允许从一端新增元素，从另一端移除元素\n * 队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为\n * 队列中进数据称为 --- 入队 push\n * 队列中出数据称为 --- 出队 pop\n\n\n# 8.1 queue 常用接口\n\n功能描述：\n\n * 栈容器常用的对外接口\n\n构造函数：\n\nqueue<t> que; \t\t\t\t// queue 采用模板类实现，queue 对象的默认构造形式\nqueue(const queue &que); \t// 拷贝构造函数\n\n\n1\n2\n\n\n赋值操作：\n\nqueue& operator=(const queue &que); // 重载等号操作符\n\n\n1\n\n\n数据存取：\n\npush(elem); // 往队尾添加元素\npop(); \t\t// 从队头移除第一个元素\nback(); \t// 返回最后一个元素\nfront(); \t// 返回第一个元素\n\n\n1\n2\n3\n4\n\n\n大小操作：\n\nempty(); \t// 判断堆栈是否为空\nsize(); \t// 返回栈的大小\n\n\n1\n2\n\n\n#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nclass person\n{\npublic:\n\tperson(string name, int age)\n\t{\n\t\tthis->m_name = name;\n\t\tthis->m_age = age;\n\t}\n\tstring m_name;\n\tint m_age;\n};\nvoid test01() {\n\t// 创建队列\n\tqueue<person> q;\n\t// 准备数据\n\tperson p1("唐僧", 30);\n\tperson p2("孙悟空", 1000);\n\tperson p3("猪八戒", 900);\n\tperson p4("沙僧", 800);\n\t// 向队列中添加元素 入队操作\n\tq.push(p1);\n\tq.push(p2);\n\tq.push(p3);\n\tq.push(p4);\n\t// 队列不提供迭代器，更不支持随机访问\n\twhile (!q.empty()) {\n\t\t// 输出队头元素\n\t\tcout << "队头元素-- 姓名： " << q.front().m_name\n\t\t\t<< " 年龄： " << q.front().m_age << endl;\n\t\tcout << "队尾元素-- 姓名： " << q.back().m_name\n\t\t\t<< " 年龄： " << q.back().m_age << endl;\n\t\tcout << endl;\n\t\t// 弹出队头元素\n\t\tq.pop();\n\t}\n\tcout << "队列大小为：" << q.size() << endl;\n}\nint main() {\n\ttest01();\n\tsystem("pause");\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n总结：\n\n * 入队 --- push\n * 出队 --- pop\n * 返回队头元素 --- front\n * 返回队尾元素 --- back\n * 判断队是否为空 --- empty\n * 返回队列大小 --- size',charsets:{cjk:!0}},{title:"网络核心知识总结",frontmatter:{title:"网络核心知识总结",date:"2023-06-09T10:07:45.000Z",permalink:"/pages/7b1cb2/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.html",relativePath:"02.计算机基础/01.网络/01.网络核心知识总结.md",key:"v-34eff995",path:"/pages/7b1cb2/",headers:[{level:2,title:"基础",slug:"基础",normalizedTitle:"基础",charIndex:14},{level:3,title:"网络分层模型",slug:"网络分层模型",normalizedTitle:"网络分层模型",charIndex:21},{level:4,title:"OSI 七层模型是什么？每一层的作用是什么？",slug:"osi-七层模型是什么-每一层的作用是什么",normalizedTitle:"osi 七层模型是什么？每一层的作用是什么？",charIndex:31},{level:4,title:"TCP/IP 四层模型是什么？每一层的作用是什么？",slug:"tcp-ip-四层模型是什么-每一层的作用是什么",normalizedTitle:"tcp/ip 四层模型是什么？每一层的作用是什么？",charIndex:395},{level:4,title:"为什么网络要分层？",slug:"为什么网络要分层",normalizedTitle:"为什么网络要分层？",charIndex:756},{level:4,title:"各层的封装格式是怎么样的？",slug:"各层的封装格式是怎么样的",normalizedTitle:"各层的封装格式是怎么样的？",charIndex:903},{level:4,title:"常见网络协议",slug:"常见网络协议",normalizedTitle:"常见网络协议",charIndex:1073},{level:5,title:"应用层有哪些常见的协议？",slug:"应用层有哪些常见的协议",normalizedTitle:"应用层有哪些常见的协议？",charIndex:1083},{level:5,title:"传输层有哪些常见的协议？",slug:"传输层有哪些常见的协议",normalizedTitle:"传输层有哪些常见的协议？",charIndex:2149},{level:5,title:"网络层有哪些常见的协议？",slug:"网络层有哪些常见的协议",normalizedTitle:"网络层有哪些常见的协议？",charIndex:2339},{level:2,title:"HTTP（应用层）",slug:"http-应用层",normalizedTitle:"http（应用层）",charIndex:3456},{level:3,title:"从输入 URL 到页面展示到底发生了什么？（重要）",slug:"从输入-url-到页面展示到底发生了什么-重要",normalizedTitle:"从输入 url 到页面展示到底发生了什么？（重要）",charIndex:3470},{level:3,title:"HTTP 状态码有哪些？",slug:"http-状态码有哪些",normalizedTitle:"http 状态码有哪些？",charIndex:3992},{level:3,title:"HTTP Header 中常见的字段有哪些？",slug:"http-header-中常见的字段有哪些",normalizedTitle:"http header 中常见的字段有哪些？",charIndex:4563},{level:4,title:"1、Host 字段",slug:"_1、host-字段",normalizedTitle:"1、host 字段",charIndex:4589},{level:4,title:"2、Content-Length 字段",slug:"_2、content-length-字段",normalizedTitle:"2、content-length 字段",charIndex:4717},{level:4,title:"3、Connection 字段",slug:"_3、connection-字段",normalizedTitle:"3、connection 字段",charIndex:5048},{level:4,title:"4、Content-Type 字段",slug:"_4、content-type-字段",normalizedTitle:"4、content-type 字段",charIndex:5444},{level:4,title:"5、Content-Encoding 字段",slug:"_5、content-encoding-字段",normalizedTitle:"5、content-encoding 字段",charIndex:5698},{level:4,title:"其他字段",slug:"其他字段",normalizedTitle:"其他字段",charIndex:5976},{level:3,title:"HTTP 和 HTTPS 有什么区别？（重要）4",slug:"http-和-https-有什么区别-重要-4",normalizedTitle:"http 和 https 有什么区别？（重要）4",charIndex:5987},{level:3,title:"HTTP/1.0 和 HTTP/1.1 有什么区别？5",slug:"http-1-0-和-http-1-1-有什么区别-5",normalizedTitle:"http/1.0 和 http/1.1 有什么区别？5",charIndex:6442},{level:3,title:"HTTP/1.1 和 HTTP/2.0 有什么区别？4",slug:"http-1-1-和-http-2-0-有什么区别-4",normalizedTitle:"http/1.1 和 http/2.0 有什么区别？4",charIndex:7306},{level:3,title:"HTTP/2.0 和 HTTP/3.0 有什么区别？5",slug:"http-2-0-和-http-3-0-有什么区别-5",normalizedTitle:"http/2.0 和 http/3.0 有什么区别？5",charIndex:7898},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:7},{level:3,title:"HTTP 是不保存状态的协议, 如何保存用户状态？",slug:"http-是不保存状态的协议-如何保存用户状态",normalizedTitle:"http 是不保存状态的协议, 如何保存用户状态？",charIndex:8840},{level:3,title:"URI 和 URL 的区别是什么?",slug:"uri-和-url-的区别是什么",normalizedTitle:"uri 和 url 的区别是什么?",charIndex:9390},{level:3,title:"Cookie 和 Session 有什么区别？",slug:"cookie-和-session-有什么区别",normalizedTitle:"cookie 和 session 有什么区别？",charIndex:9968},{level:3,title:"GET 与 POST",slug:"get-与-post",normalizedTitle:"get 与 post",charIndex:10407},{level:4,title:"GET 和 POST 有什么区别？",slug:"get-和-post-有什么区别",normalizedTitle:"get 和 post 有什么区别？",charIndex:10421},{level:4,title:"GET 和 POST 方法都是安全和幂等的吗？",slug:"get-和-post-方法都是安全和幂等的吗",normalizedTitle:"get 和 post 方法都是安全和幂等的吗？",charIndex:10765},{level:4,title:"GET 一定比 POST 安全吗？",slug:"get-一定比-post-安全吗",normalizedTitle:"get 一定比 post 安全吗？",charIndex:11455},{level:4,title:"GET 请求可以带 body 吗？",slug:"get-请求可以带-body-吗",normalizedTitle:"get 请求可以带 body 吗？",charIndex:11701},{level:4,title:"什么是 RFC 协议？",slug:"什么是-rfc-协议",normalizedTitle:"什么是 rfc 协议？",charIndex:12294},{level:2,title:"TCP 与 UDP（传输层）",slug:"tcp-与-udp-传输层",normalizedTitle:"tcp 与 udp（传输层）",charIndex:12789},{level:3,title:"TCP 与 UDP 的区别（重要）",slug:"tcp-与-udp-的区别-重要",normalizedTitle:"tcp 与 udp 的区别（重要）",charIndex:12808},{level:3,title:"什么时候选择 TCP，什么时候选 UDP?",slug:"什么时候选择-tcp-什么时候选-udp",normalizedTitle:"什么时候选择 tcp，什么时候选 udp?",charIndex:13503},{level:3,title:"HTTP 基于 TCP 还是 UDP？",slug:"http-基于-tcp-还是-udp",normalizedTitle:"http 基于 tcp 还是 udp？",charIndex:13657},{level:3,title:"使用 TCP 的协议有哪些?",slug:"使用-tcp-的协议有哪些",normalizedTitle:"使用 tcp 的协议有哪些?",charIndex:13745},{level:3,title:"使用 UDP 的协议有哪些?",slug:"使用-udp-的协议有哪些",normalizedTitle:"使用 udp 的协议有哪些?",charIndex:13954},{level:2,title:"IP（网络层）",slug:"ip-网络层",normalizedTitle:"ip（网络层）",charIndex:14172},{level:3,title:"IP 协议的作⽤是什么？",slug:"ip-协议的作用是什么",normalizedTitle:"ip 协议的作⽤是什么？",charIndex:14184},{level:3,title:"什么是 IP 地址？",slug:"什么是-ip-地址",normalizedTitle:"什么是 ip 地址？",charIndex:14309},{level:3,title:"IP 寻址如何⼯作？",slug:"ip-寻址如何工作",normalizedTitle:"ip 寻址如何⼯作？",charIndex:14677},{level:3,title:"IPv4 和 IPv6 有什么区别？",slug:"ipv4-和-ipv6-有什么区别",normalizedTitle:"ipv4 和 ipv6 有什么区别？",charIndex:15286},{level:2,title:"PING",slug:"ping",normalizedTitle:"ping",charIndex:15757},{level:3,title:"ping 命令的作用是什么？",slug:"ping-命令的作用是什么",normalizedTitle:"ping 命令的作用是什么？",charIndex:15766},{level:3,title:"PING 命令的工作原理是什么？",slug:"ping-命令的工作原理是什么",normalizedTitle:"ping 命令的工作原理是什么？",charIndex:15907},{level:3,title:"什么是 ICMP 协议？",slug:"什么是-icmp-协议",normalizedTitle:"什么是 icmp 协议？",charIndex:16307},{level:3,title:"ping 命令的输出结果什么样子的？",slug:"ping-命令的输出结果什么样子的",normalizedTitle:"ping 命令的输出结果什么样子的？",charIndex:16509},{level:2,title:"DNS",slug:"dns",normalizedTitle:"dns",charIndex:1140},{level:3,title:"什么是 DNS？",slug:"什么是-dns",normalizedTitle:"什么是 dns？",charIndex:17428},{level:3,title:"DNS 的作用是什么？",slug:"dns-的作用是什么",normalizedTitle:"dns 的作用是什么？",charIndex:17585},{level:3,title:"DNS 服务器有哪些？",slug:"dns-服务器有哪些",normalizedTitle:"dns 服务器有哪些？",charIndex:17794},{level:3,title:"DNS 解析的过程是什么样的？",slug:"dns-解析的过程是什么样的",normalizedTitle:"dns 解析的过程是什么样的？",charIndex:18404},{level:2,title:"ARP",slug:"arp",normalizedTitle:"arp",charIndex:2360},{level:3,title:"什么是 Mac 地址？",slug:"什么是-mac-地址",normalizedTitle:"什么是 mac 地址？",charIndex:18553},{level:3,title:"ARP 协议解决了什么问题？",slug:"arp-协议解决了什么问题",normalizedTitle:"arp 协议解决了什么问题？",charIndex:19087}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"11 min read",minutes:10.065,time:603900,words:2013},headersStr:"基础 网络分层模型 OSI 七层模型是什么？每一层的作用是什么？ TCP/IP 四层模型是什么？每一层的作用是什么？ 为什么网络要分层？ 各层的封装格式是怎么样的？ 常见网络协议 应用层有哪些常见的协议？ 传输层有哪些常见的协议？ 网络层有哪些常见的协议？ HTTP（应用层） 从输入 URL 到页面展示到底发生了什么？（重要） HTTP 状态码有哪些？ HTTP Header 中常见的字段有哪些？ 1、Host 字段 2、Content-Length 字段 3、Connection 字段 4、Content-Type 字段 5、Content-Encoding 字段 其他字段 HTTP 和 HTTPS 有什么区别？（重要）4 HTTP/1.0 和 HTTP/1.1 有什么区别？5 HTTP/1.1 和 HTTP/2.0 有什么区别？4 HTTP/2.0 和 HTTP/3.0 有什么区别？5 总结 HTTP 是不保存状态的协议, 如何保存用户状态？ URI 和 URL 的区别是什么? Cookie 和 Session 有什么区别？ GET 与 POST GET 和 POST 有什么区别？ GET 和 POST 方法都是安全和幂等的吗？ GET 一定比 POST 安全吗？ GET 请求可以带 body 吗？ 什么是 RFC 协议？ TCP 与 UDP（传输层） TCP 与 UDP 的区别（重要） 什么时候选择 TCP，什么时候选 UDP? HTTP 基于 TCP 还是 UDP？ 使用 TCP 的协议有哪些? 使用 UDP 的协议有哪些? IP（网络层） IP 协议的作⽤是什么？ 什么是 IP 地址？ IP 寻址如何⼯作？ IPv4 和 IPv6 有什么区别？ PING ping 命令的作用是什么？ PING 命令的工作原理是什么？ 什么是 ICMP 协议？ ping 命令的输出结果什么样子的？ DNS 什么是 DNS？ DNS 的作用是什么？ DNS 服务器有哪些？ DNS 解析的过程是什么样的？ ARP 什么是 Mac 地址？ ARP 协议解决了什么问题？",content:"# 计算机网络总结\n\n\n# 基础\n\n\n# 网络分层模型\n\n# OSI 七层模型是什么？每一层的作用是什么？\n\nOSI 体系结构是法律上的国家标准，从上往下讲分别是：\n\n 1. 应用层 -- 作用是 -- 为计算机用户提供服务\n 2. 表示层 -- 作用是 -- 数据处理(编解码、加密解密、压缩解压缩)\n 3. 会话层 -- 作用是 -- 管理 (建立、维护、重连) 应用程序之间的会话\n 4. 传输层 -- 作用是 -- 为两台主机进程之间的通信提供通用的数据传输服务\n 5. 网络层 -- 作用是 -- 路由和寻址(决定数据在网络的游走路径)\n 6. 数据链路层 -- 作用是 -- 帧编码和误差纠正控制\n 7. 物理层 -- 作用是 -- 透明地传送比特流传输\n\n\n\n> OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。\n\n# TCP/IP 四层模型是什么？每一层的作用是什么？\n\nTCP/IP 四层模型 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，是事实上的国家标准。\n\n它们分别是：\n\n 1. 应用层 -- 整合了 [应用层、表示层、会话层]\n 2. 传输层\n 3. 网络层\n 4. 网络接口层 -- 整合了 [数据链路层、物理层]\n\n\n\n作用\n\n应用层 -- 主要作用是 -- 解决通过应用进程的交互来实现特定网络应用的问题\n\n传输层 -- 主要作用是 -- 解决进程之间基于网络的通信问题\n\n网络层 -- 主要作用是 -- 解决分组在多个网络上传输 (路由) 的问题\n\n网络接口层 -- 主要作用是 -- 解决分组在一个网络 (或一段链路) 上传输以及使用何种信号来传输比特的问题\n\n# 为什么网络要分层？\n\n计算机网络体系结构之所以要分层，主要是为了实现模块化和分工合作的设计思想，将整个网络系统分解为若干个相对独立的层次，每层都有自己的功能和责任，便于设计、实现和维护网络系统。同时，分层还可以提高网络的灵活性和可扩展性，使得网络系统更易于适应不同的应用需求和技术变革。\n\n# 各层的封装格式是怎么样的？\n\n\n\n 1. 网络接口层的传输单位是帧（frame），更底下的是 比特流\n 2. IP 网络层的传输单位是包（packet）\n 3. TCP 传输层的传输单位是段（segment）\n 4. HTTP 应用层的传输单位则是消息或报文（message）。\n\n但这些名词并没有什么本质的区分，可以统称为数据包。\n\n# 常见网络协议\n\n# 应用层有哪些常见的协议？\n\n9 个：HTTP、SMTP、POP3、IMAP、FTP、Telnet、SSH、RTP、DNS\n\n概览如下图：\n\n\n\n * HTTP（Hypertext Transfer Protocol，超文本传输协议）：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。\n * SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。\n * POP3/IMAP（邮件接收协议）：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。\n * FTP（File Transfer Protocol，文件传输协议） : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。\n * Telnet（远程登陆协议）：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。\n * SSH（Secure Shell Protocol，安全的网络传输协议）：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务\n * RTP（Real-time Transport Protocol，实时传输协议）：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。\n * DNS（Domain Name System，域名管理系统）: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。\n\n# 传输层有哪些常见的协议？\n\n传输控制协议 TCP 和 用户数据协议 UDP\n\n * TCP（Transmission Control Protocol，传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。\n * UDP（User Datagram Protocol，用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。\n\n# 网络层有哪些常见的协议？\n\n7 个：IP、ARP、ICMP、NAT、OSPF、RIP、BGP\n\n * IP（Internet Protocol，网际协议）：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。\n * ARP（Address Resolution Protocol，地址解析协议）：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。\n * ICMP（Internet Control Message Protocol，互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。\n * NAT（Network Address Translation，网络地址转换协议）：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。\n * OSPF（Open Shortest Path First，开放式最短路径优先）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。\n * RIP(Routing Information Protocol，路由信息协议）：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。\n * BGP（Border Gateway Protocol，边界网关协议）：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。\n\n\n# HTTP（应用层）\n\n\n# 从输入 URL 到页面展示到底发生了什么？（重要）\n\n总体来说分为以下几个过程:\n\n 1. DNS 解析 -- 浏览器查找域名的 IP 地址(DNS查找过程: 浏览器缓存、路由器缓存、DNS 缓存)\n 2. 与服务器建立 TCP 连接\n 3. 浏览器向 web 服务器发送一个 HTTP 请求(cookies会随着请求发送给服务器)\n 4. 服务器处理请求并返回 HTTP 报文(请求 处理请求 & 它的参数、cookies、生成一个 HTML 响应)\n 5. 浏览器解析渲染页面 -- 也就是浏览器开始显示 HTML\n 6. 连接结束\n\n期间使用到的协议：\n\n 1. DNS: 获取域名对应 IP\n 2. TCP: 与服务器建立 TCP 连接\n 3. IP: 建立 TCP 协议时，需要发送数据，发送数据在网络层使用 IP 协议\n 4. OSPF: IP 数据包在路由器之间，路由选择使用 OPSF 协议\n 5. ARP: 路由器在与服务器通信时，需要将 ip 地址转换为 MAC 地址，需要使用 ARP 协议\n 6. HTTP: 在 TCP 建立完成后，使用 HTTP 协议访问网页\n\n> 思考：ip 地址与 MAC 地址的区别？\n\n\n# HTTP 状态码有哪些？\n\nHTTP 状态码主要有五大类，用于描述 HTTP 请求的结果。\n\n比如：\n\n      类别                        具体含义                                     常见状态码\n1xx   Informational(信息性状态码)     提示信息，接收的请求正在处理，表示目前是协议处理的中间状态，还需要后续的操作   \n2xx   Success (成功状态码)           成功，请求正常处理完毕                              200、204、206\n3xx   Redirection (重定向状态码)      重定向，资源位置发生变动，需要客户端重新发送请求                 301、302、304\n4xx   Client Error (客户端错误状态码)   客户端错误，请求报文有误，服务器无法处理请求                   400、403、404\n5xx   Server Error (服务器错误状态码)   服务器错误，服务器在处理请求时内部发生了错误                   500、501、502、503\n\n> 思考：每个常见状态码的含义？\n\n\n# HTTP Header 中常见的字段有哪些？\n\n# 1、Host 字段\n\n客户端发送请求时，用来指定服务器的域名。\n\n有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。\n\n示例\n\nHost: www.A.com\n\nHost: en.wikipedia.org:80\n\n\n1\n2\n3\n\n\n# 2、Content-Length 字段\n\n服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。\n\n比如：\n\nContent-Length: 1000\n\n\n1\n\n\n\n\n如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。\n\n> PS：大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。\n> \n> 什么是 TCP 粘包问题？\n\n# 3、Connection 字段\n\nConnection 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。\n\nHTTP 长连接的特点是：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\n\nHTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。\n\nConnection: Keep-Alive\n\n\n1\n\n\n开启了 HTTP Keep-Alive 机制后，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。\n\n> PS：HTTP Keep-Alive 和 TCP Keepalive 是不一样的，具体可以看这篇文章：TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？\n\n# 4、Content-Type 字段\n\nContent-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。（即代表数据格式）\n\n比如：\n\n// 下面类型表明，发送的是网页，而且编码是 UTF-8。\n\nContent-Type: text/html; Charset=utf-8\n\n\n1\n2\n3\n\n\n客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。\n\n// 客户端声明自己可以接受任何格式的数据。\n\nAccept: */*\n\n\n1\n2\n3\n\n\n具体如图所示：\n\n\n\n# 5、Content-Encoding 字段\n\nContent-Encoding 字段指的是数据的压缩方法。表示服务器返回的数据使用了什么压缩格式\n\n// 服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压\n\nContent-Encoding: gzip\n\n\n1\n2\n3\n\n\n客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。\n\n// 客户端能接受 gzip 和 deflate 的压缩数据\n\nAccept-Encoding: gzip, deflate\n\n\n1\n2\n3\n\n\n具体如图所示：\n\n\n\n# 其他字段\n\n\n\n\n# HTTP 和 HTTPS 有什么区别？（重要）4\n\n主要有四个区别：\n\n 1. 端口号：HTTP 默认是 80，HTTPS 默认是 443。\n 2. URL 前缀：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。\n 3. 安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。\n 4. SEO（搜索引擎优化）：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。\n\n\n# HTTP/1.0 和 HTTP/1.1 有什么区别？5\n\n主要有五类区别：\n\n 1. 连接方式:\n    \n    * HTTP/1.0 为短连接；\n    * HTTP/1.1 支持长连接。\n\n 2. 状态响应码: HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。\n    \n    > 比如说：\n    > \n    >  * 100 (Continue)——在请求大资源前的预热请求；\n    >  * 206 (Partial Content)——范围请求的标识码；\n    >  * 409 (Conflict)——请求与当前资源的规定冲突；\n    >  * 410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。\n\n 3. 缓存机制:\n    \n    * 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准；\n    \n    * HTTP/1.1 则引入了更多的缓存控制策略，例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。\n\n 4. 带宽：\n    \n    * HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能\n    * HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n 5. Host 头（Host Header）处理:\n    \n    * HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能；\n    * 而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。\n\n\n# HTTP/1.1 和 HTTP/2.0 有什么区别？4\n\n主要有四个区别：\n\n 1. IO 多路复用（Multiplexing）：\n    \n    * HTTP/1.1 使用串行方式，每个请求和响应都需要独立的连接。\n    * 而 HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本）。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。\n\n 2. 二进制帧（Binary Frames）：\n    \n    * HTTP/1.1 则使用文本格式的报文。\n    * 而 HTTP/2.0 使用二进制帧进行数据传输。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。\n\n 3. 头部压缩（Header Compression）：\n    \n    * HTTP/1.1 支持 Body 压缩，不支持 Header 压缩。\n    \n    * HTTP/2.0 支持对 Header 压缩，减少了网络开销。\n\n 4. 服务器推送（Server Push）：\n    \n    * HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。\n    * 而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。\n\n\n# HTTP/2.0 和 HTTP/3.0 有什么区别？5\n\n 1. 传输协议：\n    \n    * HTTP/2.0 是基于 TCP 协议实现的。\n    \n    * HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections）协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。\n      \n      > 你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。\n\n 2. 连接建立：\n    \n    * HTTP/2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。\n    * 而 HTTP/3.0 由于 QUIC 协议的特性，可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT，零往返时间）。\n\n 3. 队头阻塞：\n    \n    * HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。\n    * 而 HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。\n\n 4. 错误恢复：\n    \n    * HTTP/2.0 需要依赖于 TCP 的错误恢复机制。\n    \n    * 而 HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。\n\n 5. 安全性：\n    \n    HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。\n    \n    * HTTP/2.0 使用 TLS 协议进行加密。\n    * 而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。\n\n\n# 总结\n\n\n\n\n# HTTP 是不保存状态的协议, 如何保存用户状态？\n\nHTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？\n\n使用 Session 机制。\n\nSession 机制的存在就是为了解决这个问题，Session 的主要作用就是：通过服务端记录用户的状态。\n\n * 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。\n\n * 在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。\n\n1、既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？\n\n大部分情况下，都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。\n\n2、Cookie 被禁用怎么办?\n\n最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。\n\n\n# URI 和 URL 的区别是什么?\n\n * URI(Uniform Resource Identifier)：是统一资源标志符，可以唯一标识一个资源。\n   \n   URI 示例，比如一个电子邮件地址：\n   \n   mailto:example@example.com\n   \n   // mailto: 是 URI 方案，后跟实际的电子邮件地址。\n   \n   \n   1\n   2\n   3\n   \n\n * URL(Uniform Resource Locator)：是统一资源定位符，可以提供该资源的路径（用于标识资源的地址）。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\n   \n   URL 示例，比如网页的地址：\n   \n   https://www.example.com/index.html\n   \n   https:// 是 URL 的协议部分\n   www.example.com 是主机名\n   index.html 是在服务器上的文件路径\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\nURI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅可以唯一标识资源，而且还提供了定位该资源的信息。\n\n\n# Cookie 和 Session 有什么区别？\n\nCookie 和 Session 都是在 Web 开发中用于管理用户状态的技术，它们的主要区别有 5 个：\n\n 1. 存储位置：\n    \n    Cookie 保存在客户端，而 Session 保存在服务器端。\n\n 2. 安全性：\n    \n    由于 Cookie 保存在客户端，所以 Cookie 存在被恶意篡改的风险；而 Session 保存在服务器端，相对来说更加安全。\n\n 3. 存储内容：\n    \n    Cookie 保存的信息是明文的，而 Session 保存的信息是加密的。\n\n 4. 生命周期：\n    \n    Cookie 可以设置过期时间，而 Session 默认情况下在用户关闭浏览器后就会过期。\n\n 5. 存储容量：\n    \n    Cookie 存储的数据量有限制，一般为 4KB 左右；而 Session 存储的数据量没有限制，但是过多的 Session 会占用服务器的内存。\n\n\n# GET 与 POST\n\n# GET 和 POST 有什么区别？\n\nGET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。（用 URL 传输数据）\n\nGET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制。（用 body 传输数据）\n\n> HTTP协议本身对 URL 长度并没有做任何规定。\n\nPOST 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。\n\nPOST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。\n\n# GET 和 POST 方法都是安全和幂等的吗？\n\n> 安全和幂等的概念：\n> \n>  * 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。\n>  * 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。\n\n1、从 RFC 规范定义的语义来看：\n\n * GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。\n * POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。\n\n简单总结一下：\n\n * GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。\n * POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。\n\n2、从实际过程来看\n\n在实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：\n\n * 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。\n * 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。\n\n# GET 一定比 POST 安全吗？\n\n如果单从信息是否会被泄漏来判定安全性的话，并不能说 GET 不如 POST 安全。\n\n> 虽然 POST 用 body 传输数据，\n> \n> 而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到\n\n因为 HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。\n\n> 所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。\n\n# GET 请求可以带 body 吗？\n\n可以带。\n\n * RFC 规范并没有规定 GET 请求不能带 body。\n * 理论上，任何请求都是可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。\n\n> 另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。\n\nPOST 请求中的参数通常包含在请求的消息体中，而不是像 GET 请求一样包含在 URL 中。以下是一个登录功能的例子：\n\nPOST /api/login HTTP/1.1\nHost: example.com\nContent-Type: application/x-www-form-urlencoded\nusername=johndoe&amp;password=secret\n\n\n1\n2\n3\n4\n\n\n在这个例子中，我们向 example.com 发送了一个 POST 请求，请求的路径为 /api/login，请求头中包含了 Content-Type 字段，表示请求消息体的格式为 application/x-www-form-urlencoded，请求消息体中包含了两个参数 username 和 password。\n\n在实际开发中，我们可以通过发送 POST 请求并在请求消息体中包含参数，来向服务器提交数据。\n\n# 什么是 RFC 协议？\n\nRFC（Request for Comments）是一系列文件的集合，这些文件包含了关于互联网技术、协议、体系结构和操作的信息和思想。\n\nRFC 文件由互联网工程任务组（IETF）进行维护和发布。IETF 是一个开放的、国际性的组织，旨在推动互联网的技术和标准的发展。\n\nRFC 文件通常描述了互联网标准、协议、流程、算法、编码规范和其他相关主题。RFC 文件的主要目的是促进开放、自由和协作式的标准制定过程，以便所有人都可以参与互联网标准的制定和实施。\n\nRFC 文件不仅仅是一堆文本文件，它们还会被设计成软件规范和协议，以便开发人员可以根据这些规范开发互联网应用程序。 RFC 文件是互联网技术发展史上非常重要的一部分，每个 RFC 文件都有一个唯一的编号和标题，例如 RFC 2616，也称为 HTTP/1.1。这个 RFC 文件定义了 HTTP 协议的版本 1.1，包括 HTTP 请求和响应的格式、语法和语义。其他一些著名的 RFC 文件包括 RFC 793（TCP 协议）、RFC 821（SMTP 协议）和RFC 2822（电子邮件格式）。\n\n\n# TCP 与 UDP（传输层）\n\n\n# TCP 与 UDP 的区别（重要）\n\n总结来说：\n\nUDP 在传送数据之前不需要先建立连接，是无状态的，传输不可靠但效率较高，支持一对多通信；\n\nTCP 在传送数据之前必须先建立连接，是有状态的，提供可靠传输服务，只支持点对点通信。\n\n 1. 是否面向连接：\n    \n    * TCP 在传送数据之前必须先建立连接。\n    * 而 UDP 在传送数据之前不需要先建立连接。\n\n 2. 是否是可靠传输：\n    \n    * TCP 在传递数据之前，会有三次握手来建立连接，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。\n    * 而远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。\n\n 3. 是否有状态：\n    \n    * TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。\n    * 而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。\n\n 4. 传输效率：\n    \n    由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。\n\n 5. 传输形式：\n    \n    * TCP 是面向字节流的，\n    * UDP 是面向报文的。\n\n 6. 首部开销：\n    \n    TCP 首部开销比 UDP 首部开销要大。\n\n 7. 是否提供广播或多播服务：\n    \n    * TCP 只支持点对点通信，\n    * 而 UDP 支持一对一、一对多、多对一、多对多。\n\n\n# 什么时候选择 TCP，什么时候选 UDP?\n\n * UDP 一般用于即时通信，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。\n * TCP 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等。\n\n\n# HTTP 基于 TCP 还是 UDP？\n\n * HTTP/3.0 之前是基于 TCP 协议的，\n * 而 HTTP/3.0 改用 基于 UDP 的 QUIC 协议 。\n\n\n# 使用 TCP 的协议有哪些?\n\n常见的有：\n\n 1. HTTP（HyperText Transfer Protocol，超文本传输协议）\n 2. FTP（File Transfer Protocol，文件传输协议）\n 3. SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）\n 4. Telnet（远程登录协议）\n 5. SSH（Secure Shell，安全外壳协议）\n\n\n# 使用 UDP 的协议有哪些?\n\n常见的有\n\n 1. DNS（Domain Name System，域名系统）\n 2. DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）\n 3. TFTP（Trivial File Transfer Protocol，简单文件传输协议）\n 4. SNMP（Simple Network Management Protocol，简单网络管理协议）\n\n\n# IP（网络层）\n\n\n# IP 协议的作⽤是什么？\n\nIP（Internet Protocol，网际协议） 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议。\n\n主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。\n\n\n# 什么是 IP 地址？\n\nIP 地址是 Internet Protocol Address（网际协议地址）的缩写，是互联网中用于识别设备的数字标识。\n\n在 TCP/IP 协议中，IP 地址用于标识网络中的主机或设备。它是一个 32 位二进制数，通常用“点分十进制”表示法表示，即四个用点分隔的十进制数，每个数的取值范围为 0-255。\n\nIP 地址分为公网 IP 地址和私有 IP 地址两种类型。\n\n * 公网 IP 地址是唯一的，由 ISP（Internet Service Provider，互联网服务提供商）分配，用于在 Internet 上识别设备；\n * 私有 IP 地址不唯一，用于在局域网内标识设备。常见的私有 IP 地址有 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 等。\n\n\n# IP 寻址如何⼯作？\n\nIP 寻址是指：确定数据包在网络中的传输路径，使其能够正确地到达目标设备。\n\nIP 寻址的过程主要分为四个步骤：\n\n 1. 分配 IP 地址：每个设备在接入网络时，需要被分配一个唯一的IP 地址。\n    * 公网 IP 地址由 ISP（Internet Service Provider，互联网服务提供商）分配，\n    * 而私有 IP 地址通常由网络管理员进行分配。\n 2. 确定子网掩码：子网掩码用于将一个 IP 地址分成网络部分和主机部分。在同一网络中的设备必须使用相同的子网掩码。\n 3. 确定默认网关：默认网关（也称为默认路由）是一个设备的出口地址，用于将数据包发送到其他网络。默认网关通常是网络中的路由器。\n 4. 确定 DNS 服务器：DNS 服务器用于将域名解析为 IP 地址。当设备需要访问 Internet 上的其他设备时，需要向 DNS 服务器查询目标设备的 IP 地址。\n 5. 进行 IP 寻址：当设备需要向其他设备发送数据包时，它首先需要确定目标设备的 IP 地址。设备会比较自己的 IP 地址和目标设备的 IP 地址，确定它们是否在同一网段中。\n    * 如果目标设备与自己在同一网段中，则设备会直接发送数据包到目标设备；\n    * 如果目标设备与自己不在同一网段中，则设备会将数据包发送到默认网关，由默认网关将数据包转发到目标设备所在的网络中。\n\n\n# IPv4 和 IPv6 有什么区别？\n\nIPv4 和 IPv6 之间的主要区别在于地址空间大小和地址表示方式。\n\n 1. 地址空间大小：\n    \n    * IPv4 使用 32 位地址，可以表示约 42 亿（2^32）个可用 IP 地址。随着互联网的快速发展，IPv4 地址已经不足以满足需求。\n    * IPv6 使用 128 位地址，可以表示约 340 万亿亿亿亿（2^128）个地址，将满足未来的地址需求。\n\n 2. 地址表示方式：\n    \n    * IPv4 地址使用点分十进制表示法，例如 192.168.1.1；\n    * IPv6 地址使用冒号分组表示法，例如 2001:0db8:85a3:0000:0000:8a2e:0370:7334。为了缩短 IPv6 地址的长度，IPv6 地址中连续的 0 可以省略，例如 2001:0db8:85a3**:😗*8a2e:0370:7334。\n\n除了地址空间大小和地址表示方式之外，IPv6还具有一些其他的优势，例如更好的安全性、更高的性能和更智能的路由选择。\n\n\n# PING\n\n\n# ping 命令的作用是什么？\n\nping 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。\n\n * 如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。\n * 如果往返时间（RTT）过高，则表明网络延迟过高。\n\n\n# PING 命令的工作原理是什么？\n\nping 是基于 ICMP 协议工作的，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。\n\n具体来说：\n\n * 首先 PING 命令会向目标主机发送一个 ICMP Echo Request（请求报文）。\n * 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply（响应报文），PING 命令会接收并分析该数据包，并计算出往返时间（RTT）和丢包率等信息。\n\n> PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型。、\n> \n>  * 8 - 代表回送请求\n>  * 0 - 代表回送应答\n> \n> PING 命令利用 ICMP 协议的 ECHO REQUEST 和 ECHO REPLY 消息来测试目标主机的可达性和网络质量。\n\n\n# 什么是 ICMP 协议？\n\nICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。\n\nICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。\n\nICMP 包头的类型字段，大致可以分为两大类：\n\n * 一类是用于诊断的查询消息，也就是「查询报文类型」\n * 另一类是通知出错原因的错误消息，也就是「差错报文类型」\n\n\n\n\n# ping 命令的输出结果什么样子的？\n\nPING 命令的输出结果通常包括以下几部分信息：\n\n 1. ICMP Echo Request（请求报文）信息：序列号、TTL（Time to Live）值。\n 2. 目标主机的域名或 IP 地址：输出结果的第一行。\n 3. 往返时间（RTT，Round-Trip Time）：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。\n 4. 统计结果（Statistics）：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。\n\n下面是一个 ping 百度的例子：\n\n# 发送4个PING请求数据包到 www.baidu.com\n❯ ping -c 4 www.baidu.com\n\nPING www.a.shifen.com (14.119.104.189): 56 data bytes\n64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms\n64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms\n64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms\n64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms\n\n# 输出的结果\n--- www.a.shifen.com ping statistics ---\n4 packets transmitted, 4 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# DNS\n\n\n# 什么是 DNS？\n\nDNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。\n\nDNS 要解决的是域名和 IP 地址的映射问题。\n\n> 目前 DNS 的设计采用的是分布式、层次数据库结构，DNS 是应用层协议，基于 UDP 协议之上，端口为 53\n\n\n# DNS 的作用是什么？\n\nDNS（Domain Name System）的作用是：将域名转换为 IP 地址，使得用户可以通过更易于记忆的域名来访问网站和其他网络服务。\n\n在互联网上，每个设备都需要一个唯一的 IP 地址来进行通信，而使用域名可以避免用户需要记住许多复杂的 IP 地址。DNS 将域名映射到对应的 IP 地址，使得用户在输入域名时可以自动向正确的 IP 地址发送请求，从而访问相应的网站或服务。\n\n\n# DNS 服务器有哪些？\n\nDNS 服务器自底向上可以依次分为以下 4 个层级：\n\n根 -> 顶级 -> 权威 -> 本地\n\n所有 DNS 服务器都属于这四个类别之一。\n\n>  1. 根域名服务器。它是互联网上最高级别的 DNS 服务器，管理顶级域名服务器的地址，并提供 DNS 递归解析服务。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。\n>  2. 顶级域名服务器（TLD 服务器）。顶级域是指域名的后缀，如 com、org、net 和 edu 等。国家也有自己的顶级域，如 uk、fr 和 ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。\n>  3. 权威域名服务器。它是管理特定域名下所有主机的 DNS 服务器，例如某个网站的域名服务器。权威域名服务器存储着该域名下所有主机的 IP 地址信息，它们只回答自己管理的域名和主机的 DNS 查询请求。\n>  4. 本地域名服务器。它是用户计算机或局域网中的 DNS 服务器，用于缓存 DNS 查询结果，并提供 DNS 递归解析服务。\n> \n>  * 当用户计算机发起 DNS 查询请求时，本地域名服务器会优先检查自己的缓存中是否有该域名对应的 IP 地址信息。\n>  * 如果没有，则向根域名服务器发起 DNS 查询请求，按照自底向上的顺序逐级向下查询，直到找到权威域名服务器并获得 IP 地址信息，最后将结果返回给用户计算机。\n\n\n# DNS 解析的过程是什么样的？\n\nDNS 解析过程大致可以分为以下几步：\n\n 1. 浏览器发起 URL 请求，时\n 2. 操作系统向本地 DNS 服务器查询，\n 3. 本地 DNS 服务器向根域名服务器、顶级域名服务器和权威域名服务器查询，\n 4. 最终返回 IP 地址。\n\n\n# ARP\n\n\n# 什么是 Mac 地址？\n\n简单来说：\n\nMac 地址常被称为物理地址，是用于识别网络设备的唯一标识符且固定不变。\n\n> MAC 地址，全称 Media Access Control Address，即媒体访问控制地址，也称为物理地址或硬件地址，是用于识别网络设备的唯一标识符。MAC 地址通常由 48 位二进制数组成，其中前 24 位表示厂商代码，后 24 位为该厂商设备的序列号。\n> \n> MAC 地址是数据链路层（OSI模型第二层）的概念，用于在同一局域网内识别和寻址网络设备。\n> \n> 在局域网中，每个网络设备都有一个唯一的 MAC 地址。当一个网络设备需要发送数据时，它首先会在目标设备的 ARP 缓存中查找目标设备的 MAC 地址，如果没有找到，则向局域网广播 ARP 请求，请求目标设备的 MAC 地址。当目标设备收到 ARP 请求后，它会向发送设备回复一个 ARP 响应，包含自己的 MAC 地址。发送设备在收到 ARP 响应后，就可以使用目标设备的 MAC 地址来发送数据了。\n> \n> MAC 地址是固定不变的，一般情况下不会被修改。在实际应用中，MAC 地址被广泛应用于网络设备的管理和安全控制，如网络设备的远程管理、访问控制列表等。\n\n\n# ARP 协议解决了什么问题？\n\nARP 协议，全称 地址解析协议（Address Resolution Protocol），解决了 IP 地址转 MAC 地址的一些问题。\n\n因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处\n\n>  * IP 地址属于逻辑地址，\n> \n>  * 而 MAC 地址才是物理地址",normalizedContent:"# 计算机网络总结\n\n\n# 基础\n\n\n# 网络分层模型\n\n# osi 七层模型是什么？每一层的作用是什么？\n\nosi 体系结构是法律上的国家标准，从上往下讲分别是：\n\n 1. 应用层 -- 作用是 -- 为计算机用户提供服务\n 2. 表示层 -- 作用是 -- 数据处理(编解码、加密解密、压缩解压缩)\n 3. 会话层 -- 作用是 -- 管理 (建立、维护、重连) 应用程序之间的会话\n 4. 传输层 -- 作用是 -- 为两台主机进程之间的通信提供通用的数据传输服务\n 5. 网络层 -- 作用是 -- 路由和寻址(决定数据在网络的游走路径)\n 6. 数据链路层 -- 作用是 -- 帧编码和误差纠正控制\n 7. 物理层 -- 作用是 -- 透明地传送比特流传输\n\n\n\n> osi 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。\n\n# tcp/ip 四层模型是什么？每一层的作用是什么？\n\ntcp/ip 四层模型 是目前被广泛采用的一种模型,我们可以将 tcp / ip 模型看作是 osi 七层模型的精简版本，是事实上的国家标准。\n\n它们分别是：\n\n 1. 应用层 -- 整合了 [应用层、表示层、会话层]\n 2. 传输层\n 3. 网络层\n 4. 网络接口层 -- 整合了 [数据链路层、物理层]\n\n\n\n作用\n\n应用层 -- 主要作用是 -- 解决通过应用进程的交互来实现特定网络应用的问题\n\n传输层 -- 主要作用是 -- 解决进程之间基于网络的通信问题\n\n网络层 -- 主要作用是 -- 解决分组在多个网络上传输 (路由) 的问题\n\n网络接口层 -- 主要作用是 -- 解决分组在一个网络 (或一段链路) 上传输以及使用何种信号来传输比特的问题\n\n# 为什么网络要分层？\n\n计算机网络体系结构之所以要分层，主要是为了实现模块化和分工合作的设计思想，将整个网络系统分解为若干个相对独立的层次，每层都有自己的功能和责任，便于设计、实现和维护网络系统。同时，分层还可以提高网络的灵活性和可扩展性，使得网络系统更易于适应不同的应用需求和技术变革。\n\n# 各层的封装格式是怎么样的？\n\n\n\n 1. 网络接口层的传输单位是帧（frame），更底下的是 比特流\n 2. ip 网络层的传输单位是包（packet）\n 3. tcp 传输层的传输单位是段（segment）\n 4. http 应用层的传输单位则是消息或报文（message）。\n\n但这些名词并没有什么本质的区分，可以统称为数据包。\n\n# 常见网络协议\n\n# 应用层有哪些常见的协议？\n\n9 个：http、smtp、pop3、imap、ftp、telnet、ssh、rtp、dns\n\n概览如下图：\n\n\n\n * http（hypertext transfer protocol，超文本传输协议）：基于 tcp 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 web 浏览器与 web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 http 请求进行加载的。\n * smtp（simple mail transfer protocol，简单邮件发送协议）：基于 tcp 协议，是一种用于发送电子邮件的协议。注意 ⚠️：smtp 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 pop3 或 imap 协议。\n * pop3/imap（邮件接收协议）：基于 tcp 协议，两者都是负责邮件接收的协议。imap 协议是比 pop3 更新的协议，它在功能和性能上都更加强大。imap 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 imap。\n * ftp（file transfer protocol，文件传输协议） : 基于 tcp 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：ftp 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 sftp。\n * telnet（远程登陆协议）：基于 tcp 协议，用于通过一个终端登陆到其他服务器。telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 telnet，而是使用一种称为 ssh 的非常安全的网络传输协议的主要原因。\n * ssh（secure shell protocol，安全的网络传输协议）：基于 tcp 协议，通过加密和认证机制实现安全的访问和文件传输等业务\n * rtp（real-time transport protocol，实时传输协议）：通常基于 udp 协议，但也支持 tcp 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 webrtc 实现。\n * dns（domain name system，域名管理系统）: 基于 udp 协议，用于解决域名和 ip 地址的映射问题。\n\n# 传输层有哪些常见的协议？\n\n传输控制协议 tcp 和 用户数据协议 udp\n\n * tcp（transmission control protocol，传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。\n * udp（user datagram protocol，用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。\n\n# 网络层有哪些常见的协议？\n\n7 个：ip、arp、icmp、nat、ospf、rip、bgp\n\n * ip（internet protocol，网际协议）：tcp/ip 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 ip 协议主要分为两种，一种是过去的 ipv4，另一种是较新的 ipv6，目前这两种协议都在使用，但后者已经被提议来取代前者。\n * arp（address resolution protocol，地址解析协议）：arp 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 ip 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 ip 地址属于逻辑地址，而 mac 地址才是物理地址，arp 协议解决了 ip 地址转 mac 地址的一些问题。\n * icmp（internet control message protocol，互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，ping 工具就使用了 icmp 协议来测试网络连通性。\n * nat（network address translation，网络地址转换协议）：nat 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，lan）内，各主机使用的是同一个 lan 下的 ip 地址，但在该 lan 以外，在广域网（wan）中，需要一个统一的 ip 地址来标识该 lan 在整个 internet 上的位置。\n * ospf（open shortest path first，开放式最短路径优先）：一种内部网关协议（interior gateway protocol，igp），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。\n * rip(routing information protocol，路由信息协议）：一种内部网关协议（interior gateway protocol，igp），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。\n * bgp（border gateway protocol，边界网关协议）：一种用来在路由选择域之间交换网络层可达性信息（network layer reachability information，nlri）的路由选择协议，具有高度的灵活性和可扩展性。\n\n\n# http（应用层）\n\n\n# 从输入 url 到页面展示到底发生了什么？（重要）\n\n总体来说分为以下几个过程:\n\n 1. dns 解析 -- 浏览器查找域名的 ip 地址(dns查找过程: 浏览器缓存、路由器缓存、dns 缓存)\n 2. 与服务器建立 tcp 连接\n 3. 浏览器向 web 服务器发送一个 http 请求(cookies会随着请求发送给服务器)\n 4. 服务器处理请求并返回 http 报文(请求 处理请求 & 它的参数、cookies、生成一个 html 响应)\n 5. 浏览器解析渲染页面 -- 也就是浏览器开始显示 html\n 6. 连接结束\n\n期间使用到的协议：\n\n 1. dns: 获取域名对应 ip\n 2. tcp: 与服务器建立 tcp 连接\n 3. ip: 建立 tcp 协议时，需要发送数据，发送数据在网络层使用 ip 协议\n 4. ospf: ip 数据包在路由器之间，路由选择使用 opsf 协议\n 5. arp: 路由器在与服务器通信时，需要将 ip 地址转换为 mac 地址，需要使用 arp 协议\n 6. http: 在 tcp 建立完成后，使用 http 协议访问网页\n\n> 思考：ip 地址与 mac 地址的区别？\n\n\n# http 状态码有哪些？\n\nhttp 状态码主要有五大类，用于描述 http 请求的结果。\n\n比如：\n\n      类别                        具体含义                                     常见状态码\n1xx   informational(信息性状态码)     提示信息，接收的请求正在处理，表示目前是协议处理的中间状态，还需要后续的操作   \n2xx   success (成功状态码)           成功，请求正常处理完毕                              200、204、206\n3xx   redirection (重定向状态码)      重定向，资源位置发生变动，需要客户端重新发送请求                 301、302、304\n4xx   client error (客户端错误状态码)   客户端错误，请求报文有误，服务器无法处理请求                   400、403、404\n5xx   server error (服务器错误状态码)   服务器错误，服务器在处理请求时内部发生了错误                   500、501、502、503\n\n> 思考：每个常见状态码的含义？\n\n\n# http header 中常见的字段有哪些？\n\n# 1、host 字段\n\n客户端发送请求时，用来指定服务器的域名。\n\n有了 host 字段，就可以将请求发往「同一台」服务器上的不同网站。\n\n示例\n\nhost: www.a.com\n\nhost: en.wikipedia.org:80\n\n\n1\n2\n3\n\n\n# 2、content-length 字段\n\n服务器在返回数据时，会有 content-length 字段，表明本次回应的数据长度。\n\n比如：\n\ncontent-length: 1000\n\n\n1\n\n\n\n\n如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。\n\n> ps：大家应该都知道 http 是基于 tcp 传输协议进行通信的，而使用了 tcp 传输协议，就会存在一个“粘包”的问题，http 协议通过设置回车符、换行符作为 http header 的边界，通过 content-length 字段作为 http body 的边界，这两个方式都是为了解决“粘包”的问题。\n> \n> 什么是 tcp 粘包问题？\n\n# 3、connection 字段\n\nconnection 字段最常用于客户端要求服务器使用「http 长连接」机制，以便其他请求复用。\n\nhttp 长连接的特点是：只要任意一端没有明确提出断开连接，则保持 tcp 连接状态。\n\nhttp/1.1 版本的默认连接都是长连接，但为了兼容老版本的 http，需要指定 connection 首部字段的值为 keep-alive。\n\nconnection: keep-alive\n\n\n1\n\n\n开启了 http keep-alive 机制后，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。\n\n> ps：http keep-alive 和 tcp keepalive 是不一样的，具体可以看这篇文章：tcp keepalive 和 http keep-alive 是一个东西吗？\n\n# 4、content-type 字段\n\ncontent-type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。（即代表数据格式）\n\n比如：\n\n// 下面类型表明，发送的是网页，而且编码是 utf-8。\n\ncontent-type: text/html; charset=utf-8\n\n\n1\n2\n3\n\n\n客户端请求的时候，可以使用 accept 字段声明自己可以接受哪些数据格式。\n\n// 客户端声明自己可以接受任何格式的数据。\n\naccept: */*\n\n\n1\n2\n3\n\n\n具体如图所示：\n\n\n\n# 5、content-encoding 字段\n\ncontent-encoding 字段指的是数据的压缩方法。表示服务器返回的数据使用了什么压缩格式\n\n// 服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压\n\ncontent-encoding: gzip\n\n\n1\n2\n3\n\n\n客户端在请求时，用 accept-encoding 字段说明自己可以接受哪些压缩方法。\n\n// 客户端能接受 gzip 和 deflate 的压缩数据\n\naccept-encoding: gzip, deflate\n\n\n1\n2\n3\n\n\n具体如图所示：\n\n\n\n# 其他字段\n\n\n\n\n# http 和 https 有什么区别？（重要）4\n\n主要有四个区别：\n\n 1. 端口号：http 默认是 80，https 默认是 443。\n 2. url 前缀：http 的 url 前缀是 http://，https 的 url 前缀是 https://。\n 3. 安全性和资源消耗：http 协议运行在 tcp 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。https 是运行在 ssl/tls 之上的 http 协议，ssl/tls 运行在 tcp 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，http 安全性没有 https 高，但是 https 比 http 耗费更多服务器资源。\n 4. seo（搜索引擎优化）：搜索引擎通常会更青睐使用 https 协议的网站，因为 https 能够提供更高的安全性和用户隐私保护。使用 https 协议的网站在搜索结果中可能会被优先显示，从而对 seo 产生影响。\n\n\n# http/1.0 和 http/1.1 有什么区别？5\n\n主要有五类区别：\n\n 1. 连接方式:\n    \n    * http/1.0 为短连接；\n    * http/1.1 支持长连接。\n\n 2. 状态响应码: http/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。\n    \n    > 比如说：\n    > \n    >  * 100 (continue)——在请求大资源前的预热请求；\n    >  * 206 (partial content)——范围请求的标识码；\n    >  * 409 (conflict)——请求与当前资源的规定冲突；\n    >  * 410 (gone)——资源已被永久转移，而且没有任何已知的转发地址。\n\n 3. 缓存机制:\n    \n    * 在 http/1.0 中主要使用 header 里的 if-modified-since,expires 来做为缓存判断的标准；\n    \n    * http/1.1 则引入了更多的缓存控制策略，例如 entity tag，if-unmodified-since, if-match, if-none-match 等更多可供选择的缓存头来控制缓存策略。\n\n 4. 带宽：\n    \n    * http/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能\n    * http/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（partial content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n 5. host 头（host header）处理:\n    \n    * http/1.1 引入了 host 头字段，允许在同一 ip 地址上托管多个域名，从而支持虚拟主机的功能；\n    * 而 http/1.0 没有 host 头字段，无法实现虚拟主机。\n\n\n# http/1.1 和 http/2.0 有什么区别？4\n\n主要有四个区别：\n\n 1. io 多路复用（multiplexing）：\n    \n    * http/1.1 使用串行方式，每个请求和响应都需要独立的连接。\n    * 而 http/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 http/1.1 中长链接的升级版本）。这使得 http/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。\n\n 2. 二进制帧（binary frames）：\n    \n    * http/1.1 则使用文本格式的报文。\n    * 而 http/2.0 使用二进制帧进行数据传输。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。\n\n 3. 头部压缩（header compression）：\n    \n    * http/1.1 支持 body 压缩，不支持 header 压缩。\n    \n    * http/2.0 支持对 header 压缩，减少了网络开销。\n\n 4. 服务器推送（server push）：\n    \n    * http/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。\n    * 而 http/1.1 需要客户端自己发送请求来获取相关资源。\n\n\n# http/2.0 和 http/3.0 有什么区别？5\n\n 1. 传输协议：\n    \n    * http/2.0 是基于 tcp 协议实现的。\n    \n    * http/3.0 新增了 quic（quick udp internet connections）协议来实现可靠的传输，提供与 tls/ssl 相当的安全性，具有较低的连接和传输延迟。\n      \n      > 你可以将 quic 看作是 udp 的升级版本，在其基础上新增了很多功能比如加密、重传等等。http/3.0 之前名为 http-over-quic，从这个名字中我们也可以发现，http/3 最大的改造就是使用了 quic。\n\n 2. 连接建立：\n    \n    * http/2.0 需要经过经典的 tcp 三次握手过程（一般是 3 个 rtt）。\n    * 而 http/3.0 由于 quic 协议的特性，可以避免 tcp 三次握手的延迟，允许在第一次连接时发送数据（0 个 rtt，零往返时间）。\n\n 3. 队头阻塞：\n    \n    * http/2.0 多请求复用一个 tcp 连接，一旦发生丢包，就会阻塞住所有的 http 请求。\n    * 而 http/3.0 在一定程度上解决了队头阻塞（head-of-line blocking, 简写：hol blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。\n\n 4. 错误恢复：\n    \n    * http/2.0 需要依赖于 tcp 的错误恢复机制。\n    \n    * 而 http/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。\n\n 5. 安全性：\n    \n    http/2.0 和 http/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。\n    \n    * http/2.0 使用 tls 协议进行加密。\n    * 而 http/3.0 基于 quic 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。\n\n\n# 总结\n\n\n\n\n# http 是不保存状态的协议, 如何保存用户状态？\n\nhttp 是一种不保存状态，即无状态（stateless）协议。也就是说 http 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？\n\n使用 session 机制。\n\nsession 机制的存在就是为了解决这个问题，session 的主要作用就是：通过服务端记录用户的状态。\n\n * 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 http 协议是无状态的。服务端给特定的用户创建特定的 session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 session，过了时间限制，就会销毁这个 session）。\n\n * 在服务端保存 session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。\n\n1、既然 session 存放在服务器端，那么我们如何实现 session 跟踪呢？\n\n大部分情况下，都是通过在 cookie 中附加一个 session id 来方式来跟踪。\n\n2、cookie 被禁用怎么办?\n\n最常用的就是利用 url 重写把 session id 直接附加在 url 路径的后面。\n\n\n# uri 和 url 的区别是什么?\n\n * uri(uniform resource identifier)：是统一资源标志符，可以唯一标识一个资源。\n   \n   uri 示例，比如一个电子邮件地址：\n   \n   mailto:example@example.com\n   \n   // mailto: 是 uri 方案，后跟实际的电子邮件地址。\n   \n   \n   1\n   2\n   3\n   \n\n * url(uniform resource locator)：是统一资源定位符，可以提供该资源的路径（用于标识资源的地址）。它是一种具体的 uri，即 url 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\n   \n   url 示例，比如网页的地址：\n   \n   https://www.example.com/index.html\n   \n   https:// 是 url 的协议部分\n   www.example.com 是主机名\n   index.html 是在服务器上的文件路径\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\nuri 的作用像身份证号一样，url 的作用更像家庭住址一样。url 是一种具体的 uri，它不仅可以唯一标识资源，而且还提供了定位该资源的信息。\n\n\n# cookie 和 session 有什么区别？\n\ncookie 和 session 都是在 web 开发中用于管理用户状态的技术，它们的主要区别有 5 个：\n\n 1. 存储位置：\n    \n    cookie 保存在客户端，而 session 保存在服务器端。\n\n 2. 安全性：\n    \n    由于 cookie 保存在客户端，所以 cookie 存在被恶意篡改的风险；而 session 保存在服务器端，相对来说更加安全。\n\n 3. 存储内容：\n    \n    cookie 保存的信息是明文的，而 session 保存的信息是加密的。\n\n 4. 生命周期：\n    \n    cookie 可以设置过期时间，而 session 默认情况下在用户关闭浏览器后就会过期。\n\n 5. 存储容量：\n    \n    cookie 存储的数据量有限制，一般为 4kb 左右；而 session 存储的数据量没有限制，但是过多的 session 会占用服务器的内存。\n\n\n# get 与 post\n\n# get 和 post 有什么区别？\n\nget 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。（用 url 传输数据）\n\nget 请求的参数位置一般是写在 url 中，url 规定只能支持 ascii，所以 get 请求的参数只允许 ascii 字符 ，而且浏览器会对 url 的长度有限制。（用 body 传输数据）\n\n> http协议本身对 url 长度并没有做任何规定。\n\npost 的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。\n\npost 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。\n\n# get 和 post 方法都是安全和幂等的吗？\n\n> 安全和幂等的概念：\n> \n>  * 在 http 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。\n>  * 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。\n\n1、从 rfc 规范定义的语义来看：\n\n * get 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 get 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 get 请求可以保存为书签。\n * post 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 post 请求，也不能把 post 请求保存为书签。\n\n简单总结一下：\n\n * get 的语义是请求获取指定的资源。get 方法是安全、幂等、可被缓存的。\n * post 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。post 不安全，不幂等，（大部分实现）不可缓存。\n\n2、从实际过程来看\n\n在实际过程中，开发者不一定会按照 rfc 规范定义的语义来实现 get 和 post 方法。比如：\n\n * 可以用 get 方法实现新增或删除数据的请求，这样实现的 get 方法自然就不是安全和幂等。\n * 可以用 post 方法实现查询数据的请求，这样实现的 post 方法自然就是安全和幂等。\n\n# get 一定比 post 安全吗？\n\n如果单从信息是否会被泄漏来判定安全性的话，并不能说 get 不如 post 安全。\n\n> 虽然 post 用 body 传输数据，\n> \n> 而 get 用 url 传输，这样数据会在浏览器地址拦容易看到\n\n因为 http 传输的内容都是明文的，虽然在浏览器地址拦看不到 post 提交的 body 数据，但是只要抓个包就都能看到了。\n\n> 所以，要避免传输过程中数据被窃取，就要使用 https 协议，这样所有 http 的数据都会被加密传输。\n\n# get 请求可以带 body 吗？\n\n可以带。\n\n * rfc 规范并没有规定 get 请求不能带 body。\n * 理论上，任何请求都是可以带 body 的。只是因为 rfc 规范定义的 get 请求是获取资源，所以根据这个语义不需要用到 body。\n\n> 另外，url 中的查询参数也不是 get 所独有的，post 请求的 url 中也可以有参数的。\n\npost 请求中的参数通常包含在请求的消息体中，而不是像 get 请求一样包含在 url 中。以下是一个登录功能的例子：\n\npost /api/login http/1.1\nhost: example.com\ncontent-type: application/x-www-form-urlencoded\nusername=johndoe&amp;password=secret\n\n\n1\n2\n3\n4\n\n\n在这个例子中，我们向 example.com 发送了一个 post 请求，请求的路径为 /api/login，请求头中包含了 content-type 字段，表示请求消息体的格式为 application/x-www-form-urlencoded，请求消息体中包含了两个参数 username 和 password。\n\n在实际开发中，我们可以通过发送 post 请求并在请求消息体中包含参数，来向服务器提交数据。\n\n# 什么是 rfc 协议？\n\nrfc（request for comments）是一系列文件的集合，这些文件包含了关于互联网技术、协议、体系结构和操作的信息和思想。\n\nrfc 文件由互联网工程任务组（ietf）进行维护和发布。ietf 是一个开放的、国际性的组织，旨在推动互联网的技术和标准的发展。\n\nrfc 文件通常描述了互联网标准、协议、流程、算法、编码规范和其他相关主题。rfc 文件的主要目的是促进开放、自由和协作式的标准制定过程，以便所有人都可以参与互联网标准的制定和实施。\n\nrfc 文件不仅仅是一堆文本文件，它们还会被设计成软件规范和协议，以便开发人员可以根据这些规范开发互联网应用程序。 rfc 文件是互联网技术发展史上非常重要的一部分，每个 rfc 文件都有一个唯一的编号和标题，例如 rfc 2616，也称为 http/1.1。这个 rfc 文件定义了 http 协议的版本 1.1，包括 http 请求和响应的格式、语法和语义。其他一些著名的 rfc 文件包括 rfc 793（tcp 协议）、rfc 821（smtp 协议）和rfc 2822（电子邮件格式）。\n\n\n# tcp 与 udp（传输层）\n\n\n# tcp 与 udp 的区别（重要）\n\n总结来说：\n\nudp 在传送数据之前不需要先建立连接，是无状态的，传输不可靠但效率较高，支持一对多通信；\n\ntcp 在传送数据之前必须先建立连接，是有状态的，提供可靠传输服务，只支持点对点通信。\n\n 1. 是否面向连接：\n    \n    * tcp 在传送数据之前必须先建立连接。\n    * 而 udp 在传送数据之前不需要先建立连接。\n\n 2. 是否是可靠传输：\n    \n    * tcp 在传递数据之前，会有三次握手来建立连接，通过 tcp 连接传输的数据，无差错、不丢失、不重复、并且按序到达。\n    * 而远地主机在收到 udp 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。\n\n 3. 是否有状态：\n    \n    * tcp 传输是有状态的，这个有状态说的是 tcp 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。\n    * 而 udp 是无状态服务，简单来说就是不管发出去之后的事情了。\n\n 4. 传输效率：\n    \n    由于使用 tcp 进行传输的时候多了连接、确认、重传等机制，所以 tcp 的传输效率要比 udp 低很多。\n\n 5. 传输形式：\n    \n    * tcp 是面向字节流的，\n    * udp 是面向报文的。\n\n 6. 首部开销：\n    \n    tcp 首部开销比 udp 首部开销要大。\n\n 7. 是否提供广播或多播服务：\n    \n    * tcp 只支持点对点通信，\n    * 而 udp 支持一对一、一对多、多对一、多对多。\n\n\n# 什么时候选择 tcp，什么时候选 udp?\n\n * udp 一般用于即时通信，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。\n * tcp 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等。\n\n\n# http 基于 tcp 还是 udp？\n\n * http/3.0 之前是基于 tcp 协议的，\n * 而 http/3.0 改用 基于 udp 的 quic 协议 。\n\n\n# 使用 tcp 的协议有哪些?\n\n常见的有：\n\n 1. http（hypertext transfer protocol，超文本传输协议）\n 2. ftp（file transfer protocol，文件传输协议）\n 3. smtp（simple mail transfer protocol，简单邮件传输协议）\n 4. telnet（远程登录协议）\n 5. ssh（secure shell，安全外壳协议）\n\n\n# 使用 udp 的协议有哪些?\n\n常见的有\n\n 1. dns（domain name system，域名系统）\n 2. dhcp（dynamic host configuration protocol，动态主机配置协议）\n 3. tftp（trivial file transfer protocol，简单文件传输协议）\n 4. snmp（simple network management protocol，简单网络管理协议）\n\n\n# ip（网络层）\n\n\n# ip 协议的作⽤是什么？\n\nip（internet protocol，网际协议） 是 tcp/ip 协议中最重要的协议之一，属于网络层的协议。\n\n主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。\n\n\n# 什么是 ip 地址？\n\nip 地址是 internet protocol address（网际协议地址）的缩写，是互联网中用于识别设备的数字标识。\n\n在 tcp/ip 协议中，ip 地址用于标识网络中的主机或设备。它是一个 32 位二进制数，通常用“点分十进制”表示法表示，即四个用点分隔的十进制数，每个数的取值范围为 0-255。\n\nip 地址分为公网 ip 地址和私有 ip 地址两种类型。\n\n * 公网 ip 地址是唯一的，由 isp（internet service provider，互联网服务提供商）分配，用于在 internet 上识别设备；\n * 私有 ip 地址不唯一，用于在局域网内标识设备。常见的私有 ip 地址有 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 等。\n\n\n# ip 寻址如何⼯作？\n\nip 寻址是指：确定数据包在网络中的传输路径，使其能够正确地到达目标设备。\n\nip 寻址的过程主要分为四个步骤：\n\n 1. 分配 ip 地址：每个设备在接入网络时，需要被分配一个唯一的ip 地址。\n    * 公网 ip 地址由 isp（internet service provider，互联网服务提供商）分配，\n    * 而私有 ip 地址通常由网络管理员进行分配。\n 2. 确定子网掩码：子网掩码用于将一个 ip 地址分成网络部分和主机部分。在同一网络中的设备必须使用相同的子网掩码。\n 3. 确定默认网关：默认网关（也称为默认路由）是一个设备的出口地址，用于将数据包发送到其他网络。默认网关通常是网络中的路由器。\n 4. 确定 dns 服务器：dns 服务器用于将域名解析为 ip 地址。当设备需要访问 internet 上的其他设备时，需要向 dns 服务器查询目标设备的 ip 地址。\n 5. 进行 ip 寻址：当设备需要向其他设备发送数据包时，它首先需要确定目标设备的 ip 地址。设备会比较自己的 ip 地址和目标设备的 ip 地址，确定它们是否在同一网段中。\n    * 如果目标设备与自己在同一网段中，则设备会直接发送数据包到目标设备；\n    * 如果目标设备与自己不在同一网段中，则设备会将数据包发送到默认网关，由默认网关将数据包转发到目标设备所在的网络中。\n\n\n# ipv4 和 ipv6 有什么区别？\n\nipv4 和 ipv6 之间的主要区别在于地址空间大小和地址表示方式。\n\n 1. 地址空间大小：\n    \n    * ipv4 使用 32 位地址，可以表示约 42 亿（2^32）个可用 ip 地址。随着互联网的快速发展，ipv4 地址已经不足以满足需求。\n    * ipv6 使用 128 位地址，可以表示约 340 万亿亿亿亿（2^128）个地址，将满足未来的地址需求。\n\n 2. 地址表示方式：\n    \n    * ipv4 地址使用点分十进制表示法，例如 192.168.1.1；\n    * ipv6 地址使用冒号分组表示法，例如 2001:0db8:85a3:0000:0000:8a2e:0370:7334。为了缩短 ipv6 地址的长度，ipv6 地址中连续的 0 可以省略，例如 2001:0db8:85a3**:😗*8a2e:0370:7334。\n\n除了地址空间大小和地址表示方式之外，ipv6还具有一些其他的优势，例如更好的安全性、更高的性能和更智能的路由选择。\n\n\n# ping\n\n\n# ping 命令的作用是什么？\n\nping 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。\n\n * 如果 ping 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。\n * 如果往返时间（rtt）过高，则表明网络延迟过高。\n\n\n# ping 命令的工作原理是什么？\n\nping 是基于 icmp 协议工作的，其主要原理就是通过在网络上发送和接收 icmp 报文实现的。\n\n具体来说：\n\n * 首先 ping 命令会向目标主机发送一个 icmp echo request（请求报文）。\n * 如果两个主机的连通性正常，目标主机会返回一个对应的 icmp echo reply（响应报文），ping 命令会接收并分析该数据包，并计算出往返时间（rtt）和丢包率等信息。\n\n> ping 用到的 icmp echo request（类型为 8 ） 和 icmp echo reply（类型为 0） 属于查询报文类型。、\n> \n>  * 8 - 代表回送请求\n>  * 0 - 代表回送应答\n> \n> ping 命令利用 icmp 协议的 echo request 和 echo reply 消息来测试目标主机的可达性和网络质量。\n\n\n# 什么是 icmp 协议？\n\nicmp 全称是 internet control message protocol，也就是互联网控制报文协议。\n\nicmp 报文是封装在 ip 包里面，它工作在网络层，是 ip 协议的助手。\n\nicmp 包头的类型字段，大致可以分为两大类：\n\n * 一类是用于诊断的查询消息，也就是「查询报文类型」\n * 另一类是通知出错原因的错误消息，也就是「差错报文类型」\n\n\n\n\n# ping 命令的输出结果什么样子的？\n\nping 命令的输出结果通常包括以下几部分信息：\n\n 1. icmp echo request（请求报文）信息：序列号、ttl（time to live）值。\n 2. 目标主机的域名或 ip 地址：输出结果的第一行。\n 3. 往返时间（rtt，round-trip time）：从发送 icmp echo request（请求报文）到接收到 icmp echo reply（响应报文）的总时间，用来衡量网络连接的延迟。\n 4. 统计结果（statistics）：包括发送的 icmp 请求数据包数量、接收到的 icmp 响应数据包数量、丢包率、往返时间（rtt）的最小、平均、最大和标准偏差值。\n\n下面是一个 ping 百度的例子：\n\n# 发送4个ping请求数据包到 www.baidu.com\n❯ ping -c 4 www.baidu.com\n\nping www.a.shifen.com (14.119.104.189): 56 data bytes\n64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms\n64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms\n64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms\n64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms\n\n# 输出的结果\n--- www.a.shifen.com ping statistics ---\n4 packets transmitted, 4 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# dns\n\n\n# 什么是 dns？\n\ndns（domain name system）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。\n\ndns 要解决的是域名和 ip 地址的映射问题。\n\n> 目前 dns 的设计采用的是分布式、层次数据库结构，dns 是应用层协议，基于 udp 协议之上，端口为 53\n\n\n# dns 的作用是什么？\n\ndns（domain name system）的作用是：将域名转换为 ip 地址，使得用户可以通过更易于记忆的域名来访问网站和其他网络服务。\n\n在互联网上，每个设备都需要一个唯一的 ip 地址来进行通信，而使用域名可以避免用户需要记住许多复杂的 ip 地址。dns 将域名映射到对应的 ip 地址，使得用户在输入域名时可以自动向正确的 ip 地址发送请求，从而访问相应的网站或服务。\n\n\n# dns 服务器有哪些？\n\ndns 服务器自底向上可以依次分为以下 4 个层级：\n\n根 -> 顶级 -> 权威 -> 本地\n\n所有 dns 服务器都属于这四个类别之一。\n\n>  1. 根域名服务器。它是互联网上最高级别的 dns 服务器，管理顶级域名服务器的地址，并提供 dns 递归解析服务。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。\n>  2. 顶级域名服务器（tld 服务器）。顶级域是指域名的后缀，如 com、org、net 和 edu 等。国家也有自己的顶级域，如 uk、fr 和 ca。tld 服务器提供了权威 dns 服务器的 ip 地址。\n>  3. 权威域名服务器。它是管理特定域名下所有主机的 dns 服务器，例如某个网站的域名服务器。权威域名服务器存储着该域名下所有主机的 ip 地址信息，它们只回答自己管理的域名和主机的 dns 查询请求。\n>  4. 本地域名服务器。它是用户计算机或局域网中的 dns 服务器，用于缓存 dns 查询结果，并提供 dns 递归解析服务。\n> \n>  * 当用户计算机发起 dns 查询请求时，本地域名服务器会优先检查自己的缓存中是否有该域名对应的 ip 地址信息。\n>  * 如果没有，则向根域名服务器发起 dns 查询请求，按照自底向上的顺序逐级向下查询，直到找到权威域名服务器并获得 ip 地址信息，最后将结果返回给用户计算机。\n\n\n# dns 解析的过程是什么样的？\n\ndns 解析过程大致可以分为以下几步：\n\n 1. 浏览器发起 url 请求，时\n 2. 操作系统向本地 dns 服务器查询，\n 3. 本地 dns 服务器向根域名服务器、顶级域名服务器和权威域名服务器查询，\n 4. 最终返回 ip 地址。\n\n\n# arp\n\n\n# 什么是 mac 地址？\n\n简单来说：\n\nmac 地址常被称为物理地址，是用于识别网络设备的唯一标识符且固定不变。\n\n> mac 地址，全称 media access control address，即媒体访问控制地址，也称为物理地址或硬件地址，是用于识别网络设备的唯一标识符。mac 地址通常由 48 位二进制数组成，其中前 24 位表示厂商代码，后 24 位为该厂商设备的序列号。\n> \n> mac 地址是数据链路层（osi模型第二层）的概念，用于在同一局域网内识别和寻址网络设备。\n> \n> 在局域网中，每个网络设备都有一个唯一的 mac 地址。当一个网络设备需要发送数据时，它首先会在目标设备的 arp 缓存中查找目标设备的 mac 地址，如果没有找到，则向局域网广播 arp 请求，请求目标设备的 mac 地址。当目标设备收到 arp 请求后，它会向发送设备回复一个 arp 响应，包含自己的 mac 地址。发送设备在收到 arp 响应后，就可以使用目标设备的 mac 地址来发送数据了。\n> \n> mac 地址是固定不变的，一般情况下不会被修改。在实际应用中，mac 地址被广泛应用于网络设备的管理和安全控制，如网络设备的远程管理、访问控制列表等。\n\n\n# arp 协议解决了什么问题？\n\narp 协议，全称 地址解析协议（address resolution protocol），解决了 ip 地址转 mac 地址的一些问题。\n\n因为一个 ip 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处\n\n>  * ip 地址属于逻辑地址，\n> \n>  * 而 mac 地址才是物理地址",charsets:{cjk:!0}},{title:"TCP 三次握手和四次挥手",frontmatter:{title:"TCP 三次握手和四次挥手",date:"2023-06-12T20:36:51.000Z",permalink:"/pages/0728af/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E7%BD%91%E7%BB%9C/02.TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html",relativePath:"02.计算机基础/01.网络/02.TCP 三次握手和四次挥手.md",key:"v-a3b400f8",path:"/pages/0728af/",headers:[{level:2,title:"建立连接-三次握手",slug:"建立连接-三次握手",normalizedTitle:"建立连接-三次握手",charIndex:20},{level:3,title:"什么是三次握手？",slug:"什么是三次握手",normalizedTitle:"什么是三次握手？",charIndex:34},{level:3,title:"为什么要三次握手？",slug:"为什么要三次握手",normalizedTitle:"为什么要三次握手？",charIndex:599},{level:3,title:"TCP 为什么是三次握手，而不是两次或四次？",slug:"tcp-为什么是三次握手-而不是两次或四次",normalizedTitle:"tcp 为什么是三次握手，而不是两次或四次？",charIndex:898},{level:3,title:"第 2 次握手传回了 ACK，为什么还要传回 SYN？",slug:"第-2-次握手传回了-ack-为什么还要传回-syn",normalizedTitle:"第 2 次握手传回了 ack，为什么还要传回 syn？",charIndex:1002},{level:2,title:"断开连接-四次挥手",slug:"断开连接-四次挥手",normalizedTitle:"断开连接-四次挥手",charIndex:1364},{level:3,title:"什么是四次挥手？",slug:"什么是四次挥手",normalizedTitle:"什么是四次挥手？",charIndex:1378},{level:3,title:"为什么要四次挥手？",slug:"为什么要四次挥手",normalizedTitle:"为什么要四次挥手？",charIndex:2170},{level:3,title:"为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？",slug:"为什么不能把服务器发送的-ack-和-fin-合并起来-变成三次挥手",normalizedTitle:"为什么不能把服务器发送的 ack 和 fin 合并起来，变成三次挥手？",charIndex:2270},{level:3,title:"如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？",slug:"如果第二次挥手时服务器的-ack-没有送达客户端-会怎样",normalizedTitle:"如果第二次挥手时服务器的 ack 没有送达客户端，会怎样？",charIndex:2450},{level:3,title:"为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？",slug:"为什么第四次挥手客户端需要等待-2-msl-报文段最长寿命-时间后才进入-closed-状态",normalizedTitle:"为什么第四次挥手客户端需要等待 2*msl（报文段最长寿命）时间后才进入 closed 状态？",charIndex:2514},{level:3,title:"什么是 MSL?",slug:"什么是-msl",normalizedTitle:"什么是 msl?",charIndex:2800}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.63,time:97800,words:326},headersStr:"建立连接-三次握手 什么是三次握手？ 为什么要三次握手？ TCP 为什么是三次握手，而不是两次或四次？ 第 2 次握手传回了 ACK，为什么还要传回 SYN？ 断开连接-四次挥手 什么是四次挥手？ 为什么要四次挥手？ 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？ 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？ 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？ 什么是 MSL?",content:"# TCP 三次握手和四次挥手\n\n\n# 建立连接-三次握手\n\n\n# 什么是三次握手？\n\n> 简单来说：\n> \n>  1. 客户端向服务器发送 SYN 报文，请求建立连接。\n>  2. 服务器收到 SYN 报文后，回复一个 SYN+ACK 的报文，表示同意建立连接。\n>  3. 客户端收到 SYN+ACK 报文后，再回复一个 ACK 报文，表示确认连接已经建立。\n> \n> SYN -- Synchronize 连接信号；ACK -- Acknowledgment 确认信号\n\n建立一个 TCP 连接需要“三次握手”，缺一不可：\n\n 1. 一次握手:\n    * 客户端发送带有 SYN（SEQ=x）标志的数据包 -> 服务端，\n    * 然后客户端进入 SYN_SEND 状态，等待服务器的确认；\n 2. 二次握手:\n    * 服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端，\n    * 然后服务端进入 SYN_RECV 状态\n 3. 三次握手:\n    * 客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，\n    * 然后客户端和服务器端都进入 ESTABLISHED（established） 状态，完成 TCP 三次握手。\n\n当建立了 3 次握手之后，客户端和服务端就可以传输数据了。\n\n具体如下图所示：\n\n\n\n\n# 为什么要三次握手？\n\n三次握手的主要目的是：确保客户端和服务器之间建立了可靠的连接，同时避免因重复的连接请求造成网络资源的浪费。\n\n 1. 第一次握手：\n    * Client 什么都不能确认；\n    * Server 确认了对方发送正常，自己接收正常\n 2. 第二次握手：\n    * Client 确认了：自己发送、接收正常，对方发送、接收正常；\n    * Server 确认了：对方发送正常，自己接收正常\n 3. 第三次握手：\n    * Client 确认了：自己发送、接收正常，对方发送、接收正常；\n    * Server 确认了：自己发送、接收正常，对方发送、接收正常\n\n\n# TCP 为什么是三次握手，而不是两次或四次？\n\n因为，三次握手是为了确保连接的可靠性和避免网络资源的浪费。而两次握手会存在上述的问题，四次握手则会增加不必要的开销，所以三次握手是一种较为合理的选择。\n\n\n# 第 2 次握手传回了 ACK，为什么还要传回 SYN？\n\n服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。\n\n回传 SYN 则是为了建立并确认从服务端到客户端的通信。\n\n> 什么是 SYN ？\n> \n> SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。\n\n\n# 断开连接-四次挥手\n\n\n# 什么是四次挥手？\n\n> 简单来说：\n> \n>  1. 客户端向服务器发送 FIN 报文，请求关闭连接。\n>  2. 服务器收到 FIN 报文后，回复一个 ACK 报文，确认已经收到客户端的请求。\n>  3. 服务器再向客户端发送一个 FIN 报文，表示服务器也准备关闭连接。\n>  4. 客户端收到服务器的 FIN 报文后，回复一个 ACK 报文，确认已经收到服务器的请求，并关闭连接。\n\n具体如下图所示：\n\n\n\n断开一个 TCP 连接则需要“四次挥手”，缺一不可：\n\n 1. 第一次挥手：\n    \n    * 客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。\n    \n    * 然后，客户端进入 FIN-WAIT-1 状态。\n\n 2. 第二次挥手：\n    \n    * 服务器收到这个 FIN（SEQ=X）标志的数据包，它发送一个 ACK（ACK=x+1）标志的数据包 -> 客户端。\n    * 然后，此时服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。\n\n 3. 第三次挥手：\n    \n    * 服务端关闭与客户端的连接并发送一个 FIN(SEQ=y) 标志的数据包 -> 客户端，请求关闭连接，\n    * 然后，服务端进入 LAST-ACK 状态。\n\n 4. 第四次挥手：\n    \n    * 客户端发送 ACK (ACK=y+1) 标志的数据包 -> 服务端并且进入 TIME-WAIT 状态，\n    * 服务端在收到 ACK (ACK=y+1) 标志的数据包后进入 CLOSE 状态。\n    * 此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。\n\n只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n\n\n# 为什么要四次挥手？\n\nTCP四次挥手的主要目的是：确保客户端和服务器之间的连接能够正常关闭，并且避免因为未处理完的数据包而造成数据的丢失和不完整。\n\n即：为了确保连接的正常关闭和数据的完整性\n\n\n# 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？\n\n因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。\n\n> ACK 的作用是: 确认收到对方发送的数据包，\n> \n> 而 FIN 的作用是: 请求关闭连接。\n\n\n# 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？\n\n客户端没有收到 ACK 确认，会重新发送 FIN 请求。\n\n\n# 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？\n\n因为第四次挥手时，客户端发送给服务器的 ACK 有可能会丢失。\n\n如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，\n\n如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。\n\n> 假设客户端在发送 ACK 之后立即进入 CLOSED 状态（即关闭连接），同时 服务端没有接收到客户端的 ACK 确认，就会一直重发 FIN -- 请求关闭连接。\n\n\n# 什么是 MSL?\n\nMSL(Maximum Segment Lifetime): 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。",normalizedContent:"# tcp 三次握手和四次挥手\n\n\n# 建立连接-三次握手\n\n\n# 什么是三次握手？\n\n> 简单来说：\n> \n>  1. 客户端向服务器发送 syn 报文，请求建立连接。\n>  2. 服务器收到 syn 报文后，回复一个 syn+ack 的报文，表示同意建立连接。\n>  3. 客户端收到 syn+ack 报文后，再回复一个 ack 报文，表示确认连接已经建立。\n> \n> syn -- synchronize 连接信号；ack -- acknowledgment 确认信号\n\n建立一个 tcp 连接需要“三次握手”，缺一不可：\n\n 1. 一次握手:\n    * 客户端发送带有 syn（seq=x）标志的数据包 -> 服务端，\n    * 然后客户端进入 syn_send 状态，等待服务器的确认；\n 2. 二次握手:\n    * 服务端发送带有 syn+ack(seq=y,ack=x+1) 标志的数据包 –> 客户端，\n    * 然后服务端进入 syn_recv 状态\n 3. 三次握手:\n    * 客户端发送带有 ack(ack=y+1) 标志的数据包 –> 服务端，\n    * 然后客户端和服务器端都进入 established（established） 状态，完成 tcp 三次握手。\n\n当建立了 3 次握手之后，客户端和服务端就可以传输数据了。\n\n具体如下图所示：\n\n\n\n\n# 为什么要三次握手？\n\n三次握手的主要目的是：确保客户端和服务器之间建立了可靠的连接，同时避免因重复的连接请求造成网络资源的浪费。\n\n 1. 第一次握手：\n    * client 什么都不能确认；\n    * server 确认了对方发送正常，自己接收正常\n 2. 第二次握手：\n    * client 确认了：自己发送、接收正常，对方发送、接收正常；\n    * server 确认了：对方发送正常，自己接收正常\n 3. 第三次握手：\n    * client 确认了：自己发送、接收正常，对方发送、接收正常；\n    * server 确认了：自己发送、接收正常，对方发送、接收正常\n\n\n# tcp 为什么是三次握手，而不是两次或四次？\n\n因为，三次握手是为了确保连接的可靠性和避免网络资源的浪费。而两次握手会存在上述的问题，四次握手则会增加不必要的开销，所以三次握手是一种较为合理的选择。\n\n\n# 第 2 次握手传回了 ack，为什么还要传回 syn？\n\n服务端传回发送端所发送的 ack 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。\n\n回传 syn 则是为了建立并确认从服务端到客户端的通信。\n\n> 什么是 syn ？\n> \n> syn 同步序列编号(synchronize sequence numbers) 是 tcp/ip 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 tcp 网络连接时，客户机首先发出一个 syn 消息，服务器使用 syn-ack 应答表示接收到了这个消息，最后客户机再以 ack(acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 tcp 连接，数据才可以在客户机和服务器之间传递。\n\n\n# 断开连接-四次挥手\n\n\n# 什么是四次挥手？\n\n> 简单来说：\n> \n>  1. 客户端向服务器发送 fin 报文，请求关闭连接。\n>  2. 服务器收到 fin 报文后，回复一个 ack 报文，确认已经收到客户端的请求。\n>  3. 服务器再向客户端发送一个 fin 报文，表示服务器也准备关闭连接。\n>  4. 客户端收到服务器的 fin 报文后，回复一个 ack 报文，确认已经收到服务器的请求，并关闭连接。\n\n具体如下图所示：\n\n\n\n断开一个 tcp 连接则需要“四次挥手”，缺一不可：\n\n 1. 第一次挥手：\n    \n    * 客户端发送一个 fin（seq=x） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。\n    \n    * 然后，客户端进入 fin-wait-1 状态。\n\n 2. 第二次挥手：\n    \n    * 服务器收到这个 fin（seq=x）标志的数据包，它发送一个 ack（ack=x+1）标志的数据包 -> 客户端。\n    * 然后，此时服务端进入 close-wait 状态，客户端进入 fin-wait-2 状态。\n\n 3. 第三次挥手：\n    \n    * 服务端关闭与客户端的连接并发送一个 fin(seq=y) 标志的数据包 -> 客户端，请求关闭连接，\n    * 然后，服务端进入 last-ack 状态。\n\n 4. 第四次挥手：\n    \n    * 客户端发送 ack (ack=y+1) 标志的数据包 -> 服务端并且进入 time-wait 状态，\n    * 服务端在收到 ack (ack=y+1) 标志的数据包后进入 close 状态。\n    * 此时，如果客户端等待 2msl 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。\n\n只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n\n\n# 为什么要四次挥手？\n\ntcp四次挥手的主要目的是：确保客户端和服务器之间的连接能够正常关闭，并且避免因为未处理完的数据包而造成数据的丢失和不完整。\n\n即：为了确保连接的正常关闭和数据的完整性\n\n\n# 为什么不能把服务器发送的 ack 和 fin 合并起来，变成三次挥手？\n\n因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ack，表示接收到了断开连接的请求。等到数据发完之后再发 fin，断开服务器到客户端的数据传送。\n\n> ack 的作用是: 确认收到对方发送的数据包，\n> \n> 而 fin 的作用是: 请求关闭连接。\n\n\n# 如果第二次挥手时服务器的 ack 没有送达客户端，会怎样？\n\n客户端没有收到 ack 确认，会重新发送 fin 请求。\n\n\n# 为什么第四次挥手客户端需要等待 2*msl（报文段最长寿命）时间后才进入 closed 状态？\n\n因为第四次挥手时，客户端发送给服务器的 ack 有可能会丢失。\n\n如果服务端因为某些原因而没有收到 ack 的话，服务端就会重发 fin，\n\n如果客户端在 2*msl 的时间内收到了 fin，就会重新发送 ack 并再次等待 2msl，防止 server 没有收到 ack 而不断重发 fin。\n\n> 假设客户端在发送 ack 之后立即进入 closed 状态（即关闭连接），同时 服务端没有接收到客户端的 ack 确认，就会一直重发 fin -- 请求关闭连接。\n\n\n# 什么是 msl?\n\nmsl(maximum segment lifetime): 一个片段在网络中最大的存活时间，2msl 就是一个发送和一个回复所需的最大时间。如果直到 2msl，client 都没有再次收到 fin，那么 client 推断 ack 已经被成功接收，则结束 tcp 连接。",charsets:{cjk:!0}},{title:"TCP 传输可靠性问题",frontmatter:{title:"TCP 传输可靠性问题",date:"2023-06-12T20:59:06.000Z",permalink:"/pages/8d5654/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E7%BD%91%E7%BB%9C/03.TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%97%AE%E9%A2%98.html",relativePath:"02.计算机基础/01.网络/03.TCP 传输可靠性问题.md",key:"v-53d48847",path:"/pages/8d5654/",headers:[{level:2,title:"TCP 如何保证传输的可靠性？",slug:"tcp-如何保证传输的可靠性",normalizedTitle:"tcp 如何保证传输的可靠性？",charIndex:18},{level:2,title:"TCP 如何实现流量控制？",slug:"tcp-如何实现流量控制",normalizedTitle:"tcp 如何实现流量控制？",charIndex:567},{level:2,title:"TCP 的拥塞控制是怎么实现的？",slug:"tcp-的拥塞控制是怎么实现的",normalizedTitle:"tcp 的拥塞控制是怎么实现的？",charIndex:1093},{level:2,title:"什么是 ARQ 协议？",slug:"什么是-arq-协议",normalizedTitle:"什么是 arq 协议？",charIndex:1318}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.365,time:21900,words:73},headersStr:"TCP 如何保证传输的可靠性？ TCP 如何实现流量控制？ TCP 的拥塞控制是怎么实现的？ 什么是 ARQ 协议？",content:"# TCP 传输可靠性问题\n\n\n# TCP 如何保证传输的可靠性？\n\nTCP 通过一些机制来保证传输的可靠性：\n\n 1. 建立连接时的三次握手：客户端和服务器在开始数据传输之前进行三次握手，以确保双方都能正常接收和发送数据。\n 2. 数据包的确认和重传：每个数据包都包含一个序号，接收方收到数据包后会回复一个确认报文，确认已经收到该数据包。如果发送方没有收到确认报文，就会重传该数据包。接收方需要缓存已经收到的数据包，以便在需要重传时使用。\n 3. 滑动窗口机制：TCP 协议采用滑动窗口机制，控制数据包的发送速率和流量。发送方和接收方都维护一个窗口，窗口的大小取决于网络的拥塞情况和接收方的处理能力。发送方只有在接收到接收方的确认报文后，才能发送下一个数据包。\n 4. 累积确认机制：接收方可以一次性确认多个数据包，以提高数据传输的效率。\n 5. 超时重传机制：如果发送方没有在一定时间内收到确认报文，就会重传数据包。重传的时间间隔会逐渐加大，以避免网络拥塞。\n 6. 流量控制和拥塞控制：TCP 协议通过流量控制和拥塞控制来避免网络拥塞和丢包。\n    * 流量控制是指：发送方根据接收方的处理能力和网络拥塞情况，调整数据包的发送速率；\n    * 拥塞控制是指：发送方根据网络拥塞情况，调整数据包的发送速率和窗口大小。\n\n\n# TCP 如何实现流量控制？\n\nTCP 协议通过以下机制实现流量控制：\n\n 1. 接收方发送窗口（rwnd）：接收方通过在 TCP 头部中的确认报文中返回一个接收窗口的值，来告诉发送方自己的接收缓存还有多少可用空间。发送方根据这个值来控制数据包的发送速率，以确保接收方能够及时接收数据，避免数据包丢失或拥塞。\n 2. 发送方发送窗口（cwnd）：发送方维护一个拥塞窗口的值，该值用来控制发送方可以发送的数据包数量。当网络拥塞时，发送方会根据网络传输的拥塞情况，调整拥塞窗口的大小，以控制发送速率，防止网络拥塞和数据包丢失。\n 3. 慢启动算法：在连接建立时，发送方会初始化拥塞窗口的大小，然后逐渐增大窗口的大小，以控制发送速率。慢启动算法会根据网络的带宽和延迟，逐渐增大拥塞窗口的大小，直到出现网络拥塞或达到最大窗口值。\n 4. 拥塞避免算法：在发送方发现网络拥塞时，会采用拥塞避免算法，逐渐减小拥塞窗口的大小，以降低发送速率。拥塞避免算法会根据数据包的丢失率和延迟时间，动态调整拥塞窗口的大小，以避免网络拥塞和数据包丢失。\n\n总结：\n\nTCP 主要是通过调整接收方发送窗口和发送方窗口的大小，以及利用慢启动算法和拥塞算法机制来实现流量控制的。\n\n\n# TCP 的拥塞控制是怎么实现的？\n\nTCP 协议的拥塞控制主要是通过慢启动算法、拥塞避免算法、快速重传和快速恢复机制以及拥塞状态机等多个机制来实现的。\n\n其中：\n\n 1. 慢启动算法通过逐渐增大拥塞窗口的大小来控制发送速率，\n 2. 拥塞避免算法通过动态调整拥塞窗口的大小来避免网络拥塞和数据包丢失，\n 3. 快速重传和快速恢复机制可以减少拥塞窗口的大小，避免网络拥塞和数据包丢失，\n 4. 拥塞状态机则通过不同的状态和事件来实现拥塞控制。\n\n\n# 什么是 ARQ 协议？\n\nARQ 全称为 Automatic Repeat Request，即自动重传请求，是一种数据传输协议，主要用于在不可靠的通信信道中保证数据传输的可靠性（通过使用确认和超时这两个机制）。\n\nARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。",normalizedContent:"# tcp 传输可靠性问题\n\n\n# tcp 如何保证传输的可靠性？\n\ntcp 通过一些机制来保证传输的可靠性：\n\n 1. 建立连接时的三次握手：客户端和服务器在开始数据传输之前进行三次握手，以确保双方都能正常接收和发送数据。\n 2. 数据包的确认和重传：每个数据包都包含一个序号，接收方收到数据包后会回复一个确认报文，确认已经收到该数据包。如果发送方没有收到确认报文，就会重传该数据包。接收方需要缓存已经收到的数据包，以便在需要重传时使用。\n 3. 滑动窗口机制：tcp 协议采用滑动窗口机制，控制数据包的发送速率和流量。发送方和接收方都维护一个窗口，窗口的大小取决于网络的拥塞情况和接收方的处理能力。发送方只有在接收到接收方的确认报文后，才能发送下一个数据包。\n 4. 累积确认机制：接收方可以一次性确认多个数据包，以提高数据传输的效率。\n 5. 超时重传机制：如果发送方没有在一定时间内收到确认报文，就会重传数据包。重传的时间间隔会逐渐加大，以避免网络拥塞。\n 6. 流量控制和拥塞控制：tcp 协议通过流量控制和拥塞控制来避免网络拥塞和丢包。\n    * 流量控制是指：发送方根据接收方的处理能力和网络拥塞情况，调整数据包的发送速率；\n    * 拥塞控制是指：发送方根据网络拥塞情况，调整数据包的发送速率和窗口大小。\n\n\n# tcp 如何实现流量控制？\n\ntcp 协议通过以下机制实现流量控制：\n\n 1. 接收方发送窗口（rwnd）：接收方通过在 tcp 头部中的确认报文中返回一个接收窗口的值，来告诉发送方自己的接收缓存还有多少可用空间。发送方根据这个值来控制数据包的发送速率，以确保接收方能够及时接收数据，避免数据包丢失或拥塞。\n 2. 发送方发送窗口（cwnd）：发送方维护一个拥塞窗口的值，该值用来控制发送方可以发送的数据包数量。当网络拥塞时，发送方会根据网络传输的拥塞情况，调整拥塞窗口的大小，以控制发送速率，防止网络拥塞和数据包丢失。\n 3. 慢启动算法：在连接建立时，发送方会初始化拥塞窗口的大小，然后逐渐增大窗口的大小，以控制发送速率。慢启动算法会根据网络的带宽和延迟，逐渐增大拥塞窗口的大小，直到出现网络拥塞或达到最大窗口值。\n 4. 拥塞避免算法：在发送方发现网络拥塞时，会采用拥塞避免算法，逐渐减小拥塞窗口的大小，以降低发送速率。拥塞避免算法会根据数据包的丢失率和延迟时间，动态调整拥塞窗口的大小，以避免网络拥塞和数据包丢失。\n\n总结：\n\ntcp 主要是通过调整接收方发送窗口和发送方窗口的大小，以及利用慢启动算法和拥塞算法机制来实现流量控制的。\n\n\n# tcp 的拥塞控制是怎么实现的？\n\ntcp 协议的拥塞控制主要是通过慢启动算法、拥塞避免算法、快速重传和快速恢复机制以及拥塞状态机等多个机制来实现的。\n\n其中：\n\n 1. 慢启动算法通过逐渐增大拥塞窗口的大小来控制发送速率，\n 2. 拥塞避免算法通过动态调整拥塞窗口的大小来避免网络拥塞和数据包丢失，\n 3. 快速重传和快速恢复机制可以减少拥塞窗口的大小，避免网络拥塞和数据包丢失，\n 4. 拥塞状态机则通过不同的状态和事件来实现拥塞控制。\n\n\n# 什么是 arq 协议？\n\narq 全称为 automatic repeat request，即自动重传请求，是一种数据传输协议，主要用于在不可靠的通信信道中保证数据传输的可靠性（通过使用确认和超时这两个机制）。\n\narq 包括停止等待 arq 协议和连续 arq 协议。",charsets:{cjk:!0}},{title:"常见状态码总结",frontmatter:{title:"常见状态码总结",date:"2023-07-23T11:29:30.000Z",permalink:"/pages/11e44b/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E7%BD%91%E7%BB%9C/04.%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93.html",relativePath:"02.计算机基础/01.网络/04.常见状态码总结.md",key:"v-33f65e3e",path:"/pages/11e44b/",headers:[{level:2,title:"2xx",slug:"_2xx",normalizedTitle:"2xx",charIndex:14},{level:2,title:"3xx",slug:"_3xx",normalizedTitle:"3xx",charIndex:306},{level:2,title:"4xx",slug:"_4xx",normalizedTitle:"4xx",charIndex:645},{level:2,title:"5xx",slug:"_5xx",normalizedTitle:"5xx",charIndex:872}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.545,time:32700.000000000004,words:109},headersStr:"2xx 3xx 4xx 5xx",content:"# 常见状态码总结\n\n\n# 2xx\n\n * 200 OK：表示服务器成功处理了客户端的请求，并返回所请求的数据。这是最常见的状态码，表示一切正常。\n * 201 Created：表示服务器成功处理了客户端的 POST 请求，并在服务器上创建了新的资源。\n * 204 No Content：表示服务器成功处理了客户端的请求，但没有返回任何内容。通常用于删除操作或只需确认请求的场景。\n * 206 Partial Content：表示服务器成功处理了部分 GET 请求，通常在客户端进行文件下载时使用。服务器返回部分内容而不是整个资源，响应头中包含了 Content-Range，指定了返回的数据范围。\n\n\n# 3xx\n\n * 301 Moved Permanently：表示所请求的资源已永久移动到新的 URL，搜索引擎会将原始 URL 替换为新的 URL。浏览器在接收到 301 响应后会自动重定向到新的 URL。\n * 302 Found（或称为 302 Moved Temporarily）：表示所请求的资源临时移动到新的 URL，与 301 类似，但是搜索引擎不会替换原始 URL。浏览器在接收到 302 响应后会自动重定向到新的 URL。\n * 304 Not Modified：表示客户端发送了带有 If-Modified-Since 或 If-None-Match 头部的条件请求，但服务器判断请求资源未发生变化，因此返回 304 响应，客户端可以使用缓存的资源。\n\n\n# 4xx\n\n * 400 Bad Request：请求错误。\n\n * 401 Unauthorized：未授权。\n\n * 403 Forbidden：禁止访问。\n\n * 404 Not Found：未找到请求的资源。(经典 404)\n\n * 405 Method Not Allowed：请求方法不允许。\n\n * 408 Request Timeout：请求超时。\n\n * 415 Unsupported Media Type：不支持的媒体类型。\n\n\n# 5xx\n\n * 500 Internal Server Error：服务器内部错误。\n\n * 502 Bad Gateway：错误的网关。\n\n * **503 Service Unavailable：服务不可用。**通常是因为服务器过载或正在维护\n\n * 504 Gateway Timeout：网关超时。",normalizedContent:"# 常见状态码总结\n\n\n# 2xx\n\n * 200 ok：表示服务器成功处理了客户端的请求，并返回所请求的数据。这是最常见的状态码，表示一切正常。\n * 201 created：表示服务器成功处理了客户端的 post 请求，并在服务器上创建了新的资源。\n * 204 no content：表示服务器成功处理了客户端的请求，但没有返回任何内容。通常用于删除操作或只需确认请求的场景。\n * 206 partial content：表示服务器成功处理了部分 get 请求，通常在客户端进行文件下载时使用。服务器返回部分内容而不是整个资源，响应头中包含了 content-range，指定了返回的数据范围。\n\n\n# 3xx\n\n * 301 moved permanently：表示所请求的资源已永久移动到新的 url，搜索引擎会将原始 url 替换为新的 url。浏览器在接收到 301 响应后会自动重定向到新的 url。\n * 302 found（或称为 302 moved temporarily）：表示所请求的资源临时移动到新的 url，与 301 类似，但是搜索引擎不会替换原始 url。浏览器在接收到 302 响应后会自动重定向到新的 url。\n * 304 not modified：表示客户端发送了带有 if-modified-since 或 if-none-match 头部的条件请求，但服务器判断请求资源未发生变化，因此返回 304 响应，客户端可以使用缓存的资源。\n\n\n# 4xx\n\n * 400 bad request：请求错误。\n\n * 401 unauthorized：未授权。\n\n * 403 forbidden：禁止访问。\n\n * 404 not found：未找到请求的资源。(经典 404)\n\n * 405 method not allowed：请求方法不允许。\n\n * 408 request timeout：请求超时。\n\n * 415 unsupported media type：不支持的媒体类型。\n\n\n# 5xx\n\n * 500 internal server error：服务器内部错误。\n\n * 502 bad gateway：错误的网关。\n\n * **503 service unavailable：服务不可用。**通常是因为服务器过载或正在维护\n\n * 504 gateway timeout：网关超时。",charsets:{cjk:!0}},{title:"《计算机网络》谢希仁",frontmatter:{title:"《计算机网络》谢希仁",date:"2023-07-27T09:21:16.000Z",permalink:"/pages/92d82c/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E7%BD%91%E7%BB%9C/10.%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E8%B0%A2%E5%B8%8C%E4%BB%81.html",relativePath:"02.计算机基础/01.网络/10.《计算机网络》谢希仁.md",key:"v-789efd9e",path:"/pages/92d82c/",headers:[{level:2,title:"博客笔记",slug:"博客笔记",normalizedTitle:"博客笔记",charIndex:2},{level:2,title:"第一章 概述",slug:"第一章-概述",normalizedTitle:"第一章 概述",charIndex:11},{level:3,title:"最重要的内容：",slug:"最重要的内容",normalizedTitle:"最重要的内容：",charIndex:22},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:157},{level:4,title:"1、K和k，B和b的区别",slug:"_1、k和k-b和b的区别",normalizedTitle:"1、k和k，b和b的区别",charIndex:163},{level:4,title:"2、运算方式",slug:"_2、运算方式",normalizedTitle:"2、运算方式",charIndex:229},{level:4,title:"3、网络的性能指标",slug:"_3、网络的性能指标",normalizedTitle:"3、网络的性能指标",charIndex:241},{level:4,title:"5、时延",slug:"_5、时延",normalizedTitle:"5、时延",charIndex:334},{level:4,title:"6、什么是以太网？什么是因特网？",slug:"_6、什么是以太网-什么是因特网",normalizedTitle:"6、什么是以太网？什么是因特网？",charIndex:444},{level:4,title:"7、TCP/IP体系结构中的各层协议",slug:"_7、tcp-ip体系结构中的各层协议",normalizedTitle:"7、tcp/ip体系结构中的各层协议",charIndex:900},{level:4,title:"8、体系结构分层的必要性",slug:"_8、体系结构分层的必要性",normalizedTitle:"8、体系结构分层的必要性",charIndex:926},{level:4,title:"9、体系结构分层思想（请求与响应）",slug:"_9、体系结构分层思想-请求与响应",normalizedTitle:"9、体系结构分层思想（请求与响应）",charIndex:983},{level:4,title:"10、协议是水平的，服务是垂直的",slug:"_10、协议是水平的-服务是垂直的",normalizedTitle:"10、协议是水平的，服务是垂直的",charIndex:2070},{level:4,title:"11、计网体系结构中的专用术语",slug:"_11、计网体系结构中的专用术语",normalizedTitle:"11、计网体系结构中的专用术语",charIndex:2092},{level:3,title:"思考",slug:"思考",normalizedTitle:"思考",charIndex:2144},{level:4,title:"1、若使用电路交换来传送计算机数据，效果如何？",slug:"_1、若使用电路交换来传送计算机数据-效果如何",normalizedTitle:"1、若使用电路交换来传送计算机数据，效果如何？",charIndex:2150},{level:4,title:"2、计算机网络体系结构为什么要分层？各层的主要任务的是什么？",slug:"_2、计算机网络体系结构为什么要分层-各层的主要任务的是什么",normalizedTitle:"2、计算机网络体系结构为什么要分层？各层的主要任务的是什么？",charIndex:2258},{level:4,title:"3、什么是互联网",slug:"_3、什么是互联网",normalizedTitle:"3、什么是互联网",charIndex:2983},{level:2,title:"第二章 物理层",slug:"第二章-物理层",normalizedTitle:"第二章 物理层",charIndex:3040},{level:3,title:"最重要的内容：",slug:"最重要的内容-2",normalizedTitle:"最重要的内容：",charIndex:22},{level:3,title:"2.1 物理层的基本概念",slug:"_2-1-物理层的基本概念",normalizedTitle:"2.1 物理层的基本概念",charIndex:3119},{level:3,title:"2.2 物理层下的传输媒体",slug:"_2-2-物理层下的传输媒体",normalizedTitle:"2.2 物理层下的传输媒体",charIndex:3248},{level:3,title:"2.3 传输方式",slug:"_2-3-传输方式",normalizedTitle:"2.3 传输方式",charIndex:3301},{level:4,title:"串行传输 与 并行传输",slug:"串行传输-与-并行传输",normalizedTitle:"串行传输 与 并行传输",charIndex:3313},{level:4,title:"同步传输 与 异步传输",slug:"同步传输-与-异步传输",normalizedTitle:"同步传输 与 异步传输",charIndex:3365},{level:4,title:"通信",slug:"通信",normalizedTitle:"通信",charIndex:888},{level:3,title:"2.4 编码与调制",slug:"_2-4-编码与调制",normalizedTitle:"2.4 编码与调制",charIndex:3430},{level:4,title:"数据通信中常用术语",slug:"数据通信中常用术语",normalizedTitle:"数据通信中常用术语",charIndex:3445},{level:4,title:"编码",slug:"编码",normalizedTitle:"编码",charIndex:2539},{level:4,title:"调制",slug:"调制",normalizedTitle:"调制",charIndex:2542},{level:4,title:"码元",slug:"码元",normalizedTitle:"码元",charIndex:3535},{level:5,title:"2.4.1 常用编码",slug:"_2-4-1-常用编码",normalizedTitle:"2.4.1 常用编码",charIndex:3574},{level:5,title:"2.4.2 常用调制",slug:"_2-4-2-常用调制",normalizedTitle:"2.4.2 常用调制",charIndex:3623},{level:3,title:"2.5 信道的极限容量",slug:"_2-5-信道的极限容量",normalizedTitle:"2.5 信道的极限容量",charIndex:3703},{level:4,title:"奈氏准则（理想）",slug:"奈氏准则-理想",normalizedTitle:"奈氏准则（理想）",charIndex:3720},{level:4,title:"香农公式（受干扰）",slug:"香农公式-受干扰",normalizedTitle:"香农公式（受干扰）",charIndex:3734},{level:4,title:"影响信道数据的因素",slug:"影响信道数据的因素",normalizedTitle:"影响信道数据的因素",charIndex:3749},{level:4,title:"奈氏准则和香农公式的意义",slug:"奈氏准则和香农公式的意义",normalizedTitle:"奈氏准则和香农公式的意义",charIndex:3764},{level:3,title:"思考",slug:"思考-2",normalizedTitle:"思考",charIndex:2144},{level:2,title:"第三章 数据链路层",slug:"第三章-数据链路层",normalizedTitle:"第三章 数据链路层",charIndex:3968},{level:3,title:"最重要的内容：",slug:"最重要的内容-3",normalizedTitle:"最重要的内容：",charIndex:22},{level:3,title:"思考：",slug:"思考-3",normalizedTitle:"思考：",charIndex:5432}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.905,time:114300,words:381},headersStr:"博客笔记 第一章 概述 最重要的内容： 小结 1、K和k，B和b的区别 2、运算方式 3、网络的性能指标 5、时延 6、什么是以太网？什么是因特网？ 7、TCP/IP体系结构中的各层协议 8、体系结构分层的必要性 9、体系结构分层思想（请求与响应） 10、协议是水平的，服务是垂直的 11、计网体系结构中的专用术语 思考 1、若使用电路交换来传送计算机数据，效果如何？ 2、计算机网络体系结构为什么要分层？各层的主要任务的是什么？ 3、什么是互联网 第二章 物理层 最重要的内容： 2.1 物理层的基本概念 2.2 物理层下的传输媒体 2.3 传输方式 串行传输 与 并行传输 同步传输 与 异步传输 通信 2.4 编码与调制 数据通信中常用术语 编码 调制 码元 2.4.1 常用编码 2.4.2 常用调制 2.5 信道的极限容量 奈氏准则（理想） 香农公式（受干扰） 影响信道数据的因素 奈氏准则和香农公式的意义 思考 第三章 数据链路层 最重要的内容： 思考：",content:"# 博客笔记\n\n\n# 第一章 概述\n\n\n# 最重要的内容：\n\n（1）互联网边缘部分和核心部分的作用，其中包含分组交换的概念。\n\n（2）计算机网络的性能指标。\n\n（3）计算机网络分层次的体系结构，包含协议和服务的概念。\n\n\n\n----------------------------------------\n\n\n# 小结\n\n# 1、K和k，B和b的区别\n\n计算机中 k = 1000（速率）， K = 1024（存储大小）， B 为字节， b为 bit\n\n# 2、运算方式\n\n\n\n# 3、网络的性能指标\n\n**8项：**速率、带宽、吞吐量、时延、时延带宽积、往返时间、利用率、丢包率\n\n4、速率和带宽\n\n速率就是实际速率，带宽是最大速率（比如路由器最大网速）\n\n\n\n# 5、时延\n\n发送时延、传播时延、处理时延（不方便计算，一般忽略）、排队时延（可与处理时延合并为处理时延）\n\n发送时延和传送时延哪个是主导的时延？由例子可知，要具体问题具体分析，不同情况下两种都有可能成为主导。\n\n\n\n# 6、什么是以太网？什么是因特网？\n\n以太网和因特网都是计算机网络领域的概念，但它们的定义和概念略有不同。\n\n 1. 以太网是局域网（LAN）中最常用的协议之一。它是一种基于 CSMA/CD（载波监听多路访问/冲突检测）协议的局域网技术，通过电缆连接多台计算机，实现计算机之间的数据传输。以太网的传输速率可以从最初的10 Mbps，逐步提高到100 Mbps、1 Gbps、10 Gbps等，具有传输速率快、成本低等优点。以太网通常被用于局域网或数据中心内部的连接。\n 2. 而因特网（Internet），是由多个计算机网络互联而成的全球性计算机网络。它是由美国国防部在上世纪60年代末期开发的，最初是为了让美国的研究机构和大学之间可以共享计算机资源和数据。随着互联网技术的不断发展，现在因特网已经成为全球最大的计算机网络，连接了全球数十亿的终端设备和计算机。因特网使用了一系列的协议和技术，例如 TCP/IP协议、域名系统（DNS）、路由协议等，实现了跨越不同地区和国家的计算机网络之间的通信和数据传输。\n\n# 7、TCP/IP体系结构中的各层协议\n\n\n\n\n\n# 8、体系结构分层的必要性\n\n\n\n相当于做一个软件设计时，选择模块化处理，而不是混合到一起，便于处理各种问题\n\n# 9、体系结构分层思想（请求与响应）\n\n分层思想举例 假设现在有一个小型互联网网络，N1，N2是网络，N1那边有主机，N2那边有网络服务器。 我们在主机上用浏览器访问某网址，其实是我们向网络服务器发送一个请求，网络服务器就返回一个响应，浏览器把它解析后我们就看到了网址的页面。\n\n其实是主机的浏览器进程与Web服务器进程基于网络的通信。 五个层次在这个过程的作用是：\n\n 1. 主机发送：（自上而下）\n\n应用层：根据HTTP协议构建一个报文，把报文交给运输层处理。\n\n\n\n运输层：根据HTTP请求报文添加一个TCP首部，使之成为TCP报文段。该首部的作用：区分应用进程、实现可靠传输。然后将TCP报文段交给网络层处理。\n\n\n\n网络层：给TCP报文段添加IP首部，是指成为IP数据报，作用是使之可以在互联网上传输（即，被路由器转发）。然后将IP数据报交给数据链路层处理。\n\n\n\n数据链路层：给IP数据报添加首部和尾部，使之成为帧。帧首部的作用是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接受。帧尾部的目的是让目的主机检查所接受到的帧是否有误码。数据链路层将帧交给物理层。\n\n\n\n物理层：将帧看作比特流。给该比特流前加前导码，作用是让目的主机做好接受帧的准备。物理层将添加前导码的比特流变换成相应的信号发送到传输媒体，信号通过传输媒体到达路由器。\n\n\n\n 2. 路由器转发：（先自下而上 - 解析，后自上而下 - 转发）\n\n物理层：收到信号后将信号变换为比特流，去掉前导码，交付给数据链路层。实际上交付的是帧。 数据链路层：去掉帧的首部和尾部，将其交付给网络层，实际上交付的是IP数据报。 网络层：解析IP数据报的首部，从中提取目的网络地址，查找自身的路由表，确定转发端口，以便数据转发。网络层将IP数据报交付给数据链路层。 数据链路层：添加一个首部和尾部，变成帧。 物理层：接受帧，将其看作比特流，加前导码。将加了前导码的比特流变换成相应的信号发送到传输媒体。\n\n 3. 服务器接收（自下而上 - 解析报文，然后响应）\n\n物理层：信号通过传输媒体到达服务器的物理层，物理层将其变为比特流，去掉前导码，交付给数据链路层。实际上交付的是帧。 数据链路层：去掉帧的首部和尾部，将其交付给网络层，实际上交付的是IP数据报。 网络层：将IP数据报的首部去掉后，将其交付给运输层，实际上交付的是TCP报文段。 运输层：将TCP报文段的首部去掉后，将其交付给应用层。实际上交付的是HTTP请求报文。 应用层：对HTTP请求报文进行解析，然后给主机发回响应报文。\n\n\n\n# 10、协议是水平的，服务是垂直的\n\n\n\n# 11、计网体系结构中的专用术语\n\n\n\nPDU - 对等层之间\n\nSDU - （上下）层与层之间\n\n\n# 思考\n\n# 1、若使用电路交换来传送计算机数据，效果如何？\n\n由于计算机数据的传送具有一定的突发性，用户之间建立连接后一般只有少部分时间用于数据传送，但期间却一直占用着该条连接，因此利用率较低。计算机网络通常采用分组交换\n\n# 2、计算机网络体系结构为什么要分层？各层的主要任务的是什么？\n\n（1）计算机网络体系结构之所以要分层，主要是为了实现模块化和分工合作的设计思想，将整个网络系统分解为若干个相对独立的层次，每层都有自己的功能和责任，便于设计、实现和维护网络系统。同时，分层还可以提高网络的灵活性和可扩展性，使得网络系统更易于适应不同的应用需求和技术变革。 一般而言，计算机网络体系结构分为五层，从下往上依次是物理层、数据链路层、网络层、传输层和应用层。\n\n（2）各层主要任务如下：\n\n 1. 物理层：负责将比特流转化为信号，并通过物理介质传输信号，实现数据的传输。主要任务包括数据的编码、调制、传输介质的选取和接口的设计等。\n 2. 数据链路层：负责将数据帧从一个节点传输到相邻节点，实现可靠的数据传输。主要任务包括数据帧的封装和解封、差错检测和纠正、流量控制和访问控制等。\n 3. 网络层：负责将数据包从源节点传输到目的节点，实现不同网络之间的互连。主要任务包括寻址和路由选择、分组的转发和复制、拥塞控制和服务质量保证等。\n 4. 传输层：负责在端到端的通信中提供可靠的数据传输服务。主要任务包括数据的分段和重组、流量控制和拥塞控制、错误检测和纠正等。\n 5. 应用层：负责提供各种网络应用服务，例如电子邮件、文件传输、远程登录等。主要任务包括应用协议的设计和实现、用户接口的设计和实现、网络安全和管理等。\n\n> 各层之间通过协议栈相互联系，每层协议都有自己的数据单元和头部，通过头部中的控制信息传递给下一层或上一层，从而实现协议的交互和数据的传输。通过分层的设计，可以使得网络协议的设计和实现更加清晰和简单，便于扩展和更新，同时也提高了网络的可靠性和安全性。\n\n# 3、什么是互联网\n\n互联网是指利用标准化的网络协议，将全球范围内数以亿计的计算机网络互相连接而成的网络。\n\n\n# 第二章 物理层\n\n\n# 最重要的内容：\n\n 1. 物理层的任务\n 2. 几种常用的信道复用技术。\n 3. 几种常用的宽带接入技术，重点是 FTFX。\n\n\n# 2.1 物理层的基本概念\n\n物理层是计算机网络体系结构中的第一层，负责传输原始比特流，是整个网络体系结构中最底层的一层。它主要负责将数字信号转换为适合于在物理媒介上传输的信号，并控制数据在传输媒介上传输的方式。\n\n物理层协议的主要任务：四大特性\n\n\n\n\n# 2.2 物理层下的传输媒体\n\n三种：导引型传输媒体、非导引型传输媒体、无线电频谱管理机构\n\n\n\n\n\n\n# 2.3 传输方式\n\n# 串行传输 与 并行传输\n\n计算机远距离传输 -- 串行传输\n\n计算机内部数据传输 -- 并行传输\n\n# 同步传输 与 异步传输\n\n\n\n异步传输：要在每个字节前后分别加上 起始位 和 结束位\n\n思考 同步与异步\n\n# 通信\n\n\n\n\n# 2.4 编码与调制\n\n\n\n# 数据通信中常用术语\n\n三种：消息、数据、信号\n\n# 编码\n\n基带信号 -- 编码 --\x3e 转换为数字信号\n\n# 调制\n\n基带信号 -- 调制 --\x3e 转换为模拟信号（音频）\n\n# 码元\n\n在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。\n\n# 2.4.1 常用编码\n\n四种：不归零编码、归零编码、曼彻斯特编码、差分曼彻斯特编码\n\n\n\n\n\n# 2.4.2 常用调制\n\n 1. 基本调制（二元制）\n    \n    三种：调幅（AM）、调频（FM）、调相（PM）\n\n 2. 混合调制（多元制）\n\n\n\n\n# 2.5 信道的极限容量\n\n\n\n# 奈氏准则（理想）\n\n\n\n# 香农公式（受干扰）\n\n\n\n# 影响信道数据的因素\n\n\n\n# 奈氏准则和香农公式的意义\n\n\n\n\n# 思考\n\n1、如何能使 1 个码元包含更多的比特呢？\n\n采用混合调制的方法 —— （举例）正交振幅调制 QAM\n\n2、混合调制中，每个码元可以包含几个比特？ 每个码元与 4 个比特的对应关系可以随便定义吗？\n\n每个码元可以包含不同数量的比特，具体取决于所使用的调制方式及其他因素。\n\n每个码元与 4 个比特的对应关系不能随便定义，具体取决于所使用的调制方式。\n\n\n\n\n# 第三章 数据链路层\n\n\n# 最重要的内容：\n\n 1. 数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点。\n\n 2. 数据链路层的三个基本问题：封装成帧、透明传输和差错检测。\n\n（1）封装成帧：是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。\n\n * 帧头和帧尾中包含有重要的控制信息。\n\n * 帧头和帧尾的作用之一就是帧定界。（含转义符可代表不是定界）\n\n> 帧头和帧尾包含了一些重要的控制信息，其中一些包括：\n> \n>  1. 帧起始标志：帧头通常包含一个特定的字节序列，用于指示帧的开始，以便接收方能够正确地识别帧的开始位置。\n>  2. 帧长度：帧头中通常包含一个表示帧的长度的字段，用于指示整个帧的长度，以便接收方能够正确地接收和处理整个帧。\n>  3. 协议版本：帧头中可能包含一个表示协议版本的字段，该字段用于指示使用的协议版本，以便接收方能够正确地解析帧的内容。\n>  4. 校验和：帧尾中通常包含一个校验和字段，用于检查整个帧在传输过程中是否出现了错误，并确保接收方接收到的帧是完整和正确的。\n>  5. 帧结束标志：帧尾中通常包含一个特定的字节序列，用于指示帧的结束，以便接收方能够正确地识别帧的结束位置。 这些控制信息可以帮助接收方正确地解析和处理整个帧，并确保数据的完整性和正确性。\n\n（2）透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。\n\n * 面向字节的物理链路层使用字节填充（或称字符填充）的方法实现透明传输。（转义字符 ESC，避免误判）\n * 面向比特的物理链路使用比特填充方法的实现透明传输。（PPP 协议零比特填充）\n\n（3）差错检测：实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1 可能会变成 0，而 0 也可能变成 1。这称为比特差错（只是传输差错的一种，还有分组丢失、分组失序以及分组重复）。\n\n检测方法有：奇偶校验（通常用于较低的数据传输速率和较短的数据长度）、循环冗余校验（CRC）、帧校验序列（FCS） -- 后两者常用，较为可靠\n\n> 检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误。\n> \n> 冗余信息更多的纠错码可以进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。\n> \n> 分组丢失、分组失序以及分组重复：一般不出现在数据链路层，出现在其上层\n\n（4）可靠传输：\n\n可靠传输是一种保证数据传输过程中数据不会丢失、损坏、重复、失序的技术。\n\n * 可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。（不可靠：仅丢弃误码的帧，啥也不做）\n * 不局限于数据链路层，其它层也可实现\n * 但是实现比较复杂，开销较大，是否使用可靠传输取决于应用需求（不使用：误码问题也可由上层解决）\n\n三大协议：\n\n 1. 停止-等待协议 SW -- 要等待确认号才可继续发送（一般情况效率低）\n\n 2. 回退N帧协议 GBN -- 滑动窗口发送与接收，接收方采用累积确认，出现误码会回退 N 帧重传（此时效率低下，浪费资源）\n\n 3. 选择重传协议 SR -- 滑动窗口发送与接收，接收方采用逐一确认，出现误码选择性重传\n\n 4. 以太网 MAC 层的硬件地址。\n\n 5. 适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。\n\nMAC 帧格式：\n\n\n\n点对点协议 PPP 帧的格式：\n\n\n\n\n# 思考：\n\n1、接收方的数据链路层如何从物理层交付的比特流中提取一个个的帧？\n\n接收方的数据链路层从物理层交付的比特流中提取一个个的帧的过程称为帧的“解封装”（De-encapsulation）。该过程可以通过以下步骤完成：\n\n 1. 接收方的物理层将比特流传递给数据链路层，数据链路层需要检查每个比特，以便找到帧的起始标志，通常为一个特定的字节序列，例如01111110。\n 2. 一旦找到起始标志，数据链路层就开始解析帧头。帧头通常包含了一些重要的控制信息，例如帧的长度和协议版本等信息，这些信息可以帮助接收方正确地解析和处理整个帧。\n 3. 接下来，数据链路层从比特流中读取帧的数据部分，并将其存储在接收缓冲区中。这个过程将一直持续到接收到帧结束标志，通常也是一个特定的字节序列，例如01111110。\n 4. 最后，数据链路层对接收到的帧进行错误检查，通常是通过校验和或循环冗余校验（CRC）来完成的。如果帧中检测到错误，数据链路层可以将其丢弃，或者向上层协议发送错误消息。 通过这些步骤，接收方的数据链路层可以从物理层交付的比特流中提取一个个的帧，然后将其传递给更高层的协议进行进一步处理。\n\n----------------------------------------\n\n2、什么是可靠传输？\n\n----------------------------------------\n\n3、既然数据分组（DATA0）需要编号，那么确认数组（ACK0)是否也需要编号呢？\n\n需要 -- 解决确认迟到所导致的重复确认问题 -- 避免发送方重复发送",normalizedContent:"# 博客笔记\n\n\n# 第一章 概述\n\n\n# 最重要的内容：\n\n（1）互联网边缘部分和核心部分的作用，其中包含分组交换的概念。\n\n（2）计算机网络的性能指标。\n\n（3）计算机网络分层次的体系结构，包含协议和服务的概念。\n\n\n\n----------------------------------------\n\n\n# 小结\n\n# 1、k和k，b和b的区别\n\n计算机中 k = 1000（速率）， k = 1024（存储大小）， b 为字节， b为 bit\n\n# 2、运算方式\n\n\n\n# 3、网络的性能指标\n\n**8项：**速率、带宽、吞吐量、时延、时延带宽积、往返时间、利用率、丢包率\n\n4、速率和带宽\n\n速率就是实际速率，带宽是最大速率（比如路由器最大网速）\n\n\n\n# 5、时延\n\n发送时延、传播时延、处理时延（不方便计算，一般忽略）、排队时延（可与处理时延合并为处理时延）\n\n发送时延和传送时延哪个是主导的时延？由例子可知，要具体问题具体分析，不同情况下两种都有可能成为主导。\n\n\n\n# 6、什么是以太网？什么是因特网？\n\n以太网和因特网都是计算机网络领域的概念，但它们的定义和概念略有不同。\n\n 1. 以太网是局域网（lan）中最常用的协议之一。它是一种基于 csma/cd（载波监听多路访问/冲突检测）协议的局域网技术，通过电缆连接多台计算机，实现计算机之间的数据传输。以太网的传输速率可以从最初的10 mbps，逐步提高到100 mbps、1 gbps、10 gbps等，具有传输速率快、成本低等优点。以太网通常被用于局域网或数据中心内部的连接。\n 2. 而因特网（internet），是由多个计算机网络互联而成的全球性计算机网络。它是由美国国防部在上世纪60年代末期开发的，最初是为了让美国的研究机构和大学之间可以共享计算机资源和数据。随着互联网技术的不断发展，现在因特网已经成为全球最大的计算机网络，连接了全球数十亿的终端设备和计算机。因特网使用了一系列的协议和技术，例如 tcp/ip协议、域名系统（dns）、路由协议等，实现了跨越不同地区和国家的计算机网络之间的通信和数据传输。\n\n# 7、tcp/ip体系结构中的各层协议\n\n\n\n\n\n# 8、体系结构分层的必要性\n\n\n\n相当于做一个软件设计时，选择模块化处理，而不是混合到一起，便于处理各种问题\n\n# 9、体系结构分层思想（请求与响应）\n\n分层思想举例 假设现在有一个小型互联网网络，n1，n2是网络，n1那边有主机，n2那边有网络服务器。 我们在主机上用浏览器访问某网址，其实是我们向网络服务器发送一个请求，网络服务器就返回一个响应，浏览器把它解析后我们就看到了网址的页面。\n\n其实是主机的浏览器进程与web服务器进程基于网络的通信。 五个层次在这个过程的作用是：\n\n 1. 主机发送：（自上而下）\n\n应用层：根据http协议构建一个报文，把报文交给运输层处理。\n\n\n\n运输层：根据http请求报文添加一个tcp首部，使之成为tcp报文段。该首部的作用：区分应用进程、实现可靠传输。然后将tcp报文段交给网络层处理。\n\n\n\n网络层：给tcp报文段添加ip首部，是指成为ip数据报，作用是使之可以在互联网上传输（即，被路由器转发）。然后将ip数据报交给数据链路层处理。\n\n\n\n数据链路层：给ip数据报添加首部和尾部，使之成为帧。帧首部的作用是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接受。帧尾部的目的是让目的主机检查所接受到的帧是否有误码。数据链路层将帧交给物理层。\n\n\n\n物理层：将帧看作比特流。给该比特流前加前导码，作用是让目的主机做好接受帧的准备。物理层将添加前导码的比特流变换成相应的信号发送到传输媒体，信号通过传输媒体到达路由器。\n\n\n\n 2. 路由器转发：（先自下而上 - 解析，后自上而下 - 转发）\n\n物理层：收到信号后将信号变换为比特流，去掉前导码，交付给数据链路层。实际上交付的是帧。 数据链路层：去掉帧的首部和尾部，将其交付给网络层，实际上交付的是ip数据报。 网络层：解析ip数据报的首部，从中提取目的网络地址，查找自身的路由表，确定转发端口，以便数据转发。网络层将ip数据报交付给数据链路层。 数据链路层：添加一个首部和尾部，变成帧。 物理层：接受帧，将其看作比特流，加前导码。将加了前导码的比特流变换成相应的信号发送到传输媒体。\n\n 3. 服务器接收（自下而上 - 解析报文，然后响应）\n\n物理层：信号通过传输媒体到达服务器的物理层，物理层将其变为比特流，去掉前导码，交付给数据链路层。实际上交付的是帧。 数据链路层：去掉帧的首部和尾部，将其交付给网络层，实际上交付的是ip数据报。 网络层：将ip数据报的首部去掉后，将其交付给运输层，实际上交付的是tcp报文段。 运输层：将tcp报文段的首部去掉后，将其交付给应用层。实际上交付的是http请求报文。 应用层：对http请求报文进行解析，然后给主机发回响应报文。\n\n\n\n# 10、协议是水平的，服务是垂直的\n\n\n\n# 11、计网体系结构中的专用术语\n\n\n\npdu - 对等层之间\n\nsdu - （上下）层与层之间\n\n\n# 思考\n\n# 1、若使用电路交换来传送计算机数据，效果如何？\n\n由于计算机数据的传送具有一定的突发性，用户之间建立连接后一般只有少部分时间用于数据传送，但期间却一直占用着该条连接，因此利用率较低。计算机网络通常采用分组交换\n\n# 2、计算机网络体系结构为什么要分层？各层的主要任务的是什么？\n\n（1）计算机网络体系结构之所以要分层，主要是为了实现模块化和分工合作的设计思想，将整个网络系统分解为若干个相对独立的层次，每层都有自己的功能和责任，便于设计、实现和维护网络系统。同时，分层还可以提高网络的灵活性和可扩展性，使得网络系统更易于适应不同的应用需求和技术变革。 一般而言，计算机网络体系结构分为五层，从下往上依次是物理层、数据链路层、网络层、传输层和应用层。\n\n（2）各层主要任务如下：\n\n 1. 物理层：负责将比特流转化为信号，并通过物理介质传输信号，实现数据的传输。主要任务包括数据的编码、调制、传输介质的选取和接口的设计等。\n 2. 数据链路层：负责将数据帧从一个节点传输到相邻节点，实现可靠的数据传输。主要任务包括数据帧的封装和解封、差错检测和纠正、流量控制和访问控制等。\n 3. 网络层：负责将数据包从源节点传输到目的节点，实现不同网络之间的互连。主要任务包括寻址和路由选择、分组的转发和复制、拥塞控制和服务质量保证等。\n 4. 传输层：负责在端到端的通信中提供可靠的数据传输服务。主要任务包括数据的分段和重组、流量控制和拥塞控制、错误检测和纠正等。\n 5. 应用层：负责提供各种网络应用服务，例如电子邮件、文件传输、远程登录等。主要任务包括应用协议的设计和实现、用户接口的设计和实现、网络安全和管理等。\n\n> 各层之间通过协议栈相互联系，每层协议都有自己的数据单元和头部，通过头部中的控制信息传递给下一层或上一层，从而实现协议的交互和数据的传输。通过分层的设计，可以使得网络协议的设计和实现更加清晰和简单，便于扩展和更新，同时也提高了网络的可靠性和安全性。\n\n# 3、什么是互联网\n\n互联网是指利用标准化的网络协议，将全球范围内数以亿计的计算机网络互相连接而成的网络。\n\n\n# 第二章 物理层\n\n\n# 最重要的内容：\n\n 1. 物理层的任务\n 2. 几种常用的信道复用技术。\n 3. 几种常用的宽带接入技术，重点是 ftfx。\n\n\n# 2.1 物理层的基本概念\n\n物理层是计算机网络体系结构中的第一层，负责传输原始比特流，是整个网络体系结构中最底层的一层。它主要负责将数字信号转换为适合于在物理媒介上传输的信号，并控制数据在传输媒介上传输的方式。\n\n物理层协议的主要任务：四大特性\n\n\n\n\n# 2.2 物理层下的传输媒体\n\n三种：导引型传输媒体、非导引型传输媒体、无线电频谱管理机构\n\n\n\n\n\n\n# 2.3 传输方式\n\n# 串行传输 与 并行传输\n\n计算机远距离传输 -- 串行传输\n\n计算机内部数据传输 -- 并行传输\n\n# 同步传输 与 异步传输\n\n\n\n异步传输：要在每个字节前后分别加上 起始位 和 结束位\n\n思考 同步与异步\n\n# 通信\n\n\n\n\n# 2.4 编码与调制\n\n\n\n# 数据通信中常用术语\n\n三种：消息、数据、信号\n\n# 编码\n\n基带信号 -- 编码 --\x3e 转换为数字信号\n\n# 调制\n\n基带信号 -- 调制 --\x3e 转换为模拟信号（音频）\n\n# 码元\n\n在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。\n\n# 2.4.1 常用编码\n\n四种：不归零编码、归零编码、曼彻斯特编码、差分曼彻斯特编码\n\n\n\n\n\n# 2.4.2 常用调制\n\n 1. 基本调制（二元制）\n    \n    三种：调幅（am）、调频（fm）、调相（pm）\n\n 2. 混合调制（多元制）\n\n\n\n\n# 2.5 信道的极限容量\n\n\n\n# 奈氏准则（理想）\n\n\n\n# 香农公式（受干扰）\n\n\n\n# 影响信道数据的因素\n\n\n\n# 奈氏准则和香农公式的意义\n\n\n\n\n# 思考\n\n1、如何能使 1 个码元包含更多的比特呢？\n\n采用混合调制的方法 —— （举例）正交振幅调制 qam\n\n2、混合调制中，每个码元可以包含几个比特？ 每个码元与 4 个比特的对应关系可以随便定义吗？\n\n每个码元可以包含不同数量的比特，具体取决于所使用的调制方式及其他因素。\n\n每个码元与 4 个比特的对应关系不能随便定义，具体取决于所使用的调制方式。\n\n\n\n\n# 第三章 数据链路层\n\n\n# 最重要的内容：\n\n 1. 数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（ppp 协议以及 csma/cd 协议）的特点。\n\n 2. 数据链路层的三个基本问题：封装成帧、透明传输和差错检测。\n\n（1）封装成帧：是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。\n\n * 帧头和帧尾中包含有重要的控制信息。\n\n * 帧头和帧尾的作用之一就是帧定界。（含转义符可代表不是定界）\n\n> 帧头和帧尾包含了一些重要的控制信息，其中一些包括：\n> \n>  1. 帧起始标志：帧头通常包含一个特定的字节序列，用于指示帧的开始，以便接收方能够正确地识别帧的开始位置。\n>  2. 帧长度：帧头中通常包含一个表示帧的长度的字段，用于指示整个帧的长度，以便接收方能够正确地接收和处理整个帧。\n>  3. 协议版本：帧头中可能包含一个表示协议版本的字段，该字段用于指示使用的协议版本，以便接收方能够正确地解析帧的内容。\n>  4. 校验和：帧尾中通常包含一个校验和字段，用于检查整个帧在传输过程中是否出现了错误，并确保接收方接收到的帧是完整和正确的。\n>  5. 帧结束标志：帧尾中通常包含一个特定的字节序列，用于指示帧的结束，以便接收方能够正确地识别帧的结束位置。 这些控制信息可以帮助接收方正确地解析和处理整个帧，并确保数据的完整性和正确性。\n\n（2）透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。\n\n * 面向字节的物理链路层使用字节填充（或称字符填充）的方法实现透明传输。（转义字符 esc，避免误判）\n * 面向比特的物理链路使用比特填充方法的实现透明传输。（ppp 协议零比特填充）\n\n（3）差错检测：实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1 可能会变成 0，而 0 也可能变成 1。这称为比特差错（只是传输差错的一种，还有分组丢失、分组失序以及分组重复）。\n\n检测方法有：奇偶校验（通常用于较低的数据传输速率和较短的数据长度）、循环冗余校验（crc）、帧校验序列（fcs） -- 后两者常用，较为可靠\n\n> 检错码只能检测出帧在传输过程中出现了差错，但不能定位错误，因此无法纠正错误。\n> \n> 冗余信息更多的纠错码可以进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。\n> \n> 分组丢失、分组失序以及分组重复：一般不出现在数据链路层，出现在其上层\n\n（4）可靠传输：\n\n可靠传输是一种保证数据传输过程中数据不会丢失、损坏、重复、失序的技术。\n\n * 可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。（不可靠：仅丢弃误码的帧，啥也不做）\n * 不局限于数据链路层，其它层也可实现\n * 但是实现比较复杂，开销较大，是否使用可靠传输取决于应用需求（不使用：误码问题也可由上层解决）\n\n三大协议：\n\n 1. 停止-等待协议 sw -- 要等待确认号才可继续发送（一般情况效率低）\n\n 2. 回退n帧协议 gbn -- 滑动窗口发送与接收，接收方采用累积确认，出现误码会回退 n 帧重传（此时效率低下，浪费资源）\n\n 3. 选择重传协议 sr -- 滑动窗口发送与接收，接收方采用逐一确认，出现误码选择性重传\n\n 4. 以太网 mac 层的硬件地址。\n\n 5. 适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。\n\nmac 帧格式：\n\n\n\n点对点协议 ppp 帧的格式：\n\n\n\n\n# 思考：\n\n1、接收方的数据链路层如何从物理层交付的比特流中提取一个个的帧？\n\n接收方的数据链路层从物理层交付的比特流中提取一个个的帧的过程称为帧的“解封装”（de-encapsulation）。该过程可以通过以下步骤完成：\n\n 1. 接收方的物理层将比特流传递给数据链路层，数据链路层需要检查每个比特，以便找到帧的起始标志，通常为一个特定的字节序列，例如01111110。\n 2. 一旦找到起始标志，数据链路层就开始解析帧头。帧头通常包含了一些重要的控制信息，例如帧的长度和协议版本等信息，这些信息可以帮助接收方正确地解析和处理整个帧。\n 3. 接下来，数据链路层从比特流中读取帧的数据部分，并将其存储在接收缓冲区中。这个过程将一直持续到接收到帧结束标志，通常也是一个特定的字节序列，例如01111110。\n 4. 最后，数据链路层对接收到的帧进行错误检查，通常是通过校验和或循环冗余校验（crc）来完成的。如果帧中检测到错误，数据链路层可以将其丢弃，或者向上层协议发送错误消息。 通过这些步骤，接收方的数据链路层可以从物理层交付的比特流中提取一个个的帧，然后将其传递给更高层的协议进行进一步处理。\n\n----------------------------------------\n\n2、什么是可靠传输？\n\n----------------------------------------\n\n3、既然数据分组（data0）需要编号，那么确认数组（ack0)是否也需要编号呢？\n\n需要 -- 解决确认迟到所导致的重复确认问题 -- 避免发送方重复发送",charsets:{cjk:!0}},{title:"硬件结构",frontmatter:{title:"硬件结构",date:"2023-07-25T11:20:48.000Z",permalink:"/pages/6048a8/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84.html",relativePath:"02.计算机基础/02.操作系统/01.硬件结构.md",key:"v-75f7300c",path:"/pages/6048a8/",headers:[{level:2,title:"CPU 是如何执行程序的？",slug:"cpu-是如何执行程序的",normalizedTitle:"cpu 是如何执行程序的？",charIndex:11},{level:3,title:"图灵机的工作方式",slug:"图灵机的工作方式",normalizedTitle:"图灵机的工作方式",charIndex:278},{level:3,title:"冯诺依曼模型",slug:"冯诺依曼模型",normalizedTitle:"冯诺依曼模型",charIndex:746},{level:4,title:"内存",slug:"内存",normalizedTitle:"内存",charIndex:400},{level:4,title:"中央处理器",slug:"中央处理器",normalizedTitle:"中央处理器",charIndex:825},{level:4,title:"总线",slug:"总线",normalizedTitle:"总线",charIndex:919},{level:4,title:"输入、输出设备",slug:"输入、输出设备",normalizedTitle:"输入、输出设备",charIndex:1965},{level:3,title:"线路位宽与 CPU 位宽",slug:"线路位宽与-cpu-位宽",normalizedTitle:"线路位宽与 cpu 位宽",charIndex:2063},{level:3,title:"程序执行的基本过程",slug:"程序执行的基本过程",normalizedTitle:"程序执行的基本过程",charIndex:2900},{level:3,title:"a = 1 + 2 执行具体过程",slug:"a-1-2-执行具体过程",normalizedTitle:"a = 1 + 2 执行具体过程",charIndex:3564},{level:4,title:"指令",slug:"指令",normalizedTitle:"指令",charIndex:552},{level:4,title:"指令的类型",slug:"指令的类型",normalizedTitle:"指令的类型",charIndex:3318},{level:4,title:"指令的执行速度",slug:"指令的执行速度",normalizedTitle:"指令的执行速度",charIndex:5741},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3396},{level:2,title:"磁盘比内存慢几万倍？",slug:"磁盘比内存慢几万倍",normalizedTitle:"磁盘比内存慢几万倍？",charIndex:7347},{level:3,title:"存储器的层次结构",slug:"存储器的层次结构",normalizedTitle:"存储器的层次结构",charIndex:7598},{level:4,title:"寄存器",slug:"寄存器",normalizedTitle:"寄存器",charIndex:1327},{level:4,title:"CPU Cache",slug:"cpu-cache",normalizedTitle:"cpu cache",charIndex:7639},{level:4,title:"内存",slug:"内存-2",normalizedTitle:"内存",charIndex:400},{level:4,title:"SSD/HDD 硬盘",slug:"ssd-hdd-硬盘",normalizedTitle:"ssd/hdd 硬盘",charIndex:8365},{level:3,title:"存储器的层次关系",slug:"存储器的层次关系",normalizedTitle:"存储器的层次关系",charIndex:8630},{level:2,title:"虚拟地址与物理地址",slug:"虚拟地址与物理地址",normalizedTitle:"虚拟地址与物理地址",charIndex:8643}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"5 min read",minutes:4.875,time:292500,words:975},headersStr:"CPU 是如何执行程序的？ 图灵机的工作方式 冯诺依曼模型 内存 中央处理器 总线 输入、输出设备 线路位宽与 CPU 位宽 程序执行的基本过程 a = 1 + 2 执行具体过程 指令 指令的类型 指令的执行速度 总结 磁盘比内存慢几万倍？ 存储器的层次结构 寄存器 CPU Cache 内存 SSD/HDD 硬盘 存储器的层次关系 虚拟地址与物理地址",content:"# 硬件结构\n\n\n# CPU 是如何执行程序的？\n\n问题：\n\n 1. 代码写了那么多，你知道 a = 1 + 2 这条代码是怎么被 CPU 执行的吗？\n 2. 软件用了那么多，你知道软件的 32 位和 64 位之间的区别吗？32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？\n 3. CPU 看了那么多，我们都知道 CPU 通常分为 32 位和 64 位，你知道 64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？\n\n\n# 图灵机的工作方式\n\n图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，而且还定义了计算机由哪些部分组成，程序又是如何执行的。\n\n图灵机的基本组成如下：\n\n * 有一条「纸带」，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；\n\n * 有一个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写入到纸带的格子；\n\n * 读写头上有一些部件，比如存储单元、控制单元以及运算单元：\n   \n   1、存储单元用于存放数据；\n   \n   2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等；\n   \n   3、运算单元用于执行运算指令；\n\n图灵机主要功能就是：\n\n 1. 读取纸带格子中的内容，然后交给控制单元识别字符是数字还是运算符指令，（读取 -> 识别）\n 2. 如果是数字则存入到图灵机状态中，\n 3. 如果是运算符，则通知运算符单元读取状态中的数值进行计算，计算结果最终返回给读写头，\n 4. 读写头把结果写入到纸带的格子中。\n\n\n\n\n# 冯诺依曼模型\n\n定义计算机基本结构为 5 个部分，分别是运算器、控制器、存储器、输入设备、输出设备，这 5 个部分也被称为冯诺依曼模型。\n\n运算器、控制器是在中央处理器(CPU)里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。\n\n\n\n存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：\n\n\n\n# 内存\n\n我们的程序和数据都是存储在内存，存储的区域是线性的。\n\n在计算机数据存储中，存储数据的基本单位是字节（byte），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。\n\n内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。\n\n# 中央处理器\n\n中央处理器也就是我们常说的 CPU。\n\n32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：\n\n * 32 位 CPU 一次可以计算 4 个字节；（32/8，一字节 8 位）\n * 64 位 CPU 一次可以计算 8 个字节；（64/8)\n\n这里的 32 位和 64 位，通常称为 CPU 的位宽，代表的是 CPU 一次可以计算（运算）的数据量。\n\nCPU 内部还有一些组件，常见的有寄存器、控制单元和逻辑运算单元等。\n\n 1. 控制单元负责控制 CPU 工作，\n 2. 逻辑运算单元负责计算，\n 3. 而寄存器可以分为多种类，每种寄存器的功能又不尽相同。主要作用是存储计算时的数据。\n\n为什么有了内存还需要寄存器？\n\n因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。\n\n常见的寄存器种类：\n\n * 通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。\n * 程序计数器，用来存储 CPU 下一条要执行指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。\n * 指令寄存器，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里\n\n# 总线\n\n总线是用来通信的，在 CPU 和内存以及其他设备之间，总线可分为 3 种：\n\n 1. 地址总线，用于指定 CPU 将要操作的内存地址；\n 2. 数据总线，用于读写内存的数据；\n 3. 控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；\n\n当 CPU 要读写内存数据的时候，是如何通过总线的？\n\n 1. 首先要通过「地址总线」来指定内存的地址；\n 2. 然后通过「控制总线」控制是读或写命令；\n 3. 最后通过「数据总线」来传输数据；\n\n地址总线 -> 控制总线 -> 数据总线\n\n# 输入、输出设备\n\n输入设备向计算机输入数据，计算机经过计算后，（运算器）把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。\n\n\n# 线路位宽与 CPU 位宽\n\n> 线路位宽\n\n数据是如何通过线路传输的呢？\n\n其实是通过操作电压，低电压表示 0，高压电压则表示 1。\n\n如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。\n\n * 这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。\n * 当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。\n\n为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。\n\nCPU 想要操作「内存地址」就需要「地址总线」：\n\n * 如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；\n * 如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。\n\n那么，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 2 ^ 32 = 4G。\n\n> CPU 位宽\n\nCPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。\n\n为什么 64 位 CPU 性能不一定就比 32 位 CPU 高很多？\n\n因为很少应用需要算超过 32 位的数字，\n\n所以如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来。\n\n\n# 程序执行的基本过程\n\n程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。(寄存器)\n\n那 CPU 执行程序的过程如下：\n\n 1. 第一步，\n    * CPU 读取「程序计数器」的值，这个值是指令的内存地址，\n    * 然后 CPU 的【控制单元】操作「地址总线」指定需要访问的内存地址，\n    * 接着通知【内存设备】准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，\n    * CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。\n 2. 第二步，\n    * 「程序计数器」的值自增，表示指向下一条指令。\n    * 这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；\n 3. 第三步，\n    * CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，\n    * 如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；\n    * 如果是存储类型的指令，则交由「控制单元」执行；\n\n简单总结一下就是\n\n一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。\n\nCPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环（执行程序）的过程被称为 CPU 的指令周期。\n\n\n# a = 1 + 2 执行具体过程\n\nCPU 是不认识 a = 1 + 2 这个字符串，这些字符串只是方便我们程序员认识，要想这段程序能跑起来，还需要把整个程序翻译成汇编语言的程序，这个过程称为编译成汇编代码。\n\n针对汇编代码，我们还需要用汇编器翻译成机器码，这些机器码由 0 和 1 组成的机器语言，这一条条机器码，就是一条条的计算机指令，这个才是 CPU 能够真正认识的东西。\n\n下面来看看 a = 1 + 2 在 32 位 CPU 的执行过程。\n\n程序编译过程中，编译器通过分析代码，发现 1 和 2 是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是「数据段」。如下图，数据 1 和 2 的区域位置：\n\n * 数据 1 被存放到 0x200 位置；\n * 数据 2 被存放到 0x204 位置；\n\n\n\n编译器会把 a = 1 + 2 翻译成 4 条指令，存放到正文段中。如图，这 4 条指令被存放到了 0x100 ~ 0x10c 的区域中：\n\n 1. 0x100 的内容是 load 指令将 0x200 地址中的数据 1 装入到(指令)寄存器 R0；\n 2. 0x104 的内容是 load 指令将 0x204 地址中的数据 2 装入到寄存器 R1；\n 3. 0x108 的内容是 add 指令将寄存器 R0 和 R1 的数据相加，并把结果存放到寄存器 R2；\n 4. 0x10c 的内容是 store 指令将寄存器 R2 中的数据存回数据段中的 0x208 地址中，这个地址也就是变量 a 内存中的地址；\n\n> 简单总结就是：add 指令将寄存器 R0 和 R1 的数据相加，并把结果放入到 R2，从而翻译成机器码\n\n编译完成后，具体执行程序的时候，【程序计数器】会被设置为 0x100 地址，然后依次执行这 4 条指令。（编译 -> 执行）\n\n不难发现上面的例子中，地址之间都是相隔 4 个字节\n\n * 指令间隔\n\n这是因为上面的例子是在 32 位 CPU 执行的，因此一条指令是占 32 位大小，所以你会发现每条指令间隔 4 个字节。\n\n * 数据间隔\n\n而数据的大小是根据你在程序中指定的变量类型，比如 int 类型的数据则占 4 个字节，char 类型的数据则占 1 个字节\n\n> string 类型的话，在 UTF-8 编码下，一个英文字母通常占用 1 个字节，一个汉字通常占用 3 个字节。\n\n# 指令\n\n指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，CPU 通过解析机器码来知道指令的内容。\n\n不同的 CPU 有不同的指令集，也就是对应着不同的汇编语言和不同的机器码。\n\n最简单的 MIPS 指集\n\nMIPS 的指令是一个 32 位的整数。\n\n * 高 6 位代表着操作码，表示这条指令是一条什么样的指令，\n * 剩下的 26 位不同指令类型所表示的内容也就不相同，\n * 主要有三种类型 R、I 和 J。\n\n\n\n三种类型的含义：\n\n * R 指令，用在算术和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移操作，后面还有位移操作的「位移量」，而最后的「功能码」则是再前面的操作码不够的时候，扩展操作码来表示对应的具体指令的；\n * I 指令，用在数据传输、条件分支等。这个类型的指令，就没有了位移量和功能码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或一个常数；\n * J 指令，用在跳转，高 6 位之外的 26 位都是一个跳转后的地址；\n\n编译器在编译程序的时候，会构造指令，这个过程叫做指令的编码。\n\nCPU 执行程序的时候，就会解析指令，这个过程叫作指令的解码。\n\n执行指令的方式\n\n大多数 CPU 都使用来【流水线】的方式来执行指令，所谓的流水线就是【把一个任务拆分成多个小任务】，于是一条指令通常分为 4 个阶段，称为 4 级流水线。\n\n四个阶段的具体含义：\n\n 1. CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 Fetch（取得指令）；\n 2. CPU 对指令进行解码，这个部分称为 Decode（指令译码）；\n 3. CPU 执行指令，这个部分称为 Execution（执行指令）；\n 4. CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 Store（数据回写）；\n\n上面这 4 个阶段，我们称为指令周期（Instrution Cycle），CPU 的工作就是一个周期接着一个周期，周而复始。\n\n# 指令的类型\n\n指令从功能角度划分，可以分为 5 大类：\n\n 1. 数据传输类型的指令，比如 store/load 是寄存器与内存间数据传输的指令，mov 是将一个内存地址的数据移动到另一个内存地址的指令；\n 2. 运算类型的指令，比如加减乘除、位运算、比较大小等等，它们最多只能处理两个寄存器中的数据；\n 3. 跳转类型的指令，通过修改程序计数器的值来达到跳转执行指令的过程，比如编程中常见的 if-else、switch-case、函数调用等。\n 4. 信号类型的指令，比如发生中断的指令 trap；\n 5. 闲置类型的指令，比如指令 nop，执行后 CPU 会空转一个周期\n\n传输、运算、跳转、信号、闲置\n\n# 指令的执行速度\n\nCPU 的硬件参数都会有 GHz 这个参数（主频），比如一个 1 GHz 的 CPU，指的是时钟频率是 1 G，代表着 1 秒会产生 1G 次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，称为时钟周期。\n\n对于 CPU 来说，在一个时钟周期内，CPU 仅能完成一个最基本的动作，时钟频率越高，时钟周期就越短，工作速度也就越快。(v=f/T)\n\n一个时钟周期一定能执行完一条指令吗？\n\n答案是不一定的，大多数指令不能在一个时钟周期完成，通常需要若干个时钟周期。不同的指令需要的时钟周期是不同的，加法和乘法都对应着一条 CPU 指令，但是乘法需要的时钟周期就要比加法多。\n\n如何让程序跑的更快？\n\n程序的 CPU 执行时间 越少 程序就跑得 越快。\n\n\n\n主频越高说明 CPU 的工作速度就越快，比如我手头上的电脑的 CPU 是 2.4 GHz 四核 Intel Core i5，这里的 2.4 GHz 就是电脑的主频，时钟周期时间就是 1/2.4G。\n\nCPU 时钟周期数 = 指令数 x 每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）\n\n因此，要想程序跑的更快，优化这三者即可：\n\n * 指令数，表示执行程序所需要多少条指令，以及哪些指令。需优化编译器。\n * 每条指令的平均时钟周期数 CPI，表示一条指令需要多少个时钟周期数，依赖于流水线方式；\n * 时钟周期时间，表示计算机主频，取决于计算机硬件。\n\n\n# 总结\n\n冯诺依曼模型\n\n\n\n> 你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？\n\n64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：\n\n * 如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令；\n * 操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。\n\n总之，硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽\n\n> 64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？\n\n64 位相比 32 位 CPU 的优势主要体现在两个方面：\n\n * 64 位 CPU 可以一次计算超过 32 位的数字，而 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进行计算，效率就没那么高，但是大部分应用程序很少会计算那么大的数字，所以只有运算大数字的时候，64 位 CPU 的优势才能体现出来，否则和 32 位 CPU 的计算性能相差不大。\n * 通常来说 64 位 CPU 的地址总线是 48 位，而 32 位 CPU 的地址总线是 32 位，所以 64 位 CPU 可以寻址更大的物理内存空间。如果一个 32 位 CPU 的地址总线是 32 位，那么该 CPU 最大寻址能力是 4G，即使你加了 8G 大小的物理内存，也还是只能寻址到 4G 大小的地址，而如果一个 64 位 CPU 的地址总线是 48 位，那么该 CPU 最大寻址能力是 2^48，远超于 32 位 CPU 最大寻址能力。\n\n为什么通常说 64 位 CPU 的地址总线是 48 位的？\n\n这涉及到物理寻址和虚拟内存的设计。实际上，64 位 CPU 的地址总线并不是固定为 48 位，而是有一定的范围。\n\n\n# 磁盘比内存慢几万倍？\n\n> 如果大家自己想组装电脑的话，肯定需要购买一个 CPU 和存储器方面的设备。\n\n相信大家都知道内存和硬盘都属于计算机的存储设备，断电后内存的数据是会丢失的，而硬盘则不会，因为硬盘是持久化存储设备，同时也是一个 I/O 设备。\n\n但其实 CPU 内部也有存储数据的组件，比如寄存器、CPU L1/L2/L3 Cache 也都是属于存储设备，只不过它们能存储的数据非常小。\n\n那机械硬盘、固态硬盘、内存这三个存储器，到底和 CPU L1 Cache 相比速度差多少倍呢？\n\n\n# 存储器的层次结构\n\n\n\n寄存器，处理速度是最快的，但是能存储的数据也是最少的。\n\nCPU Cache，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。\n\nL1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。\n\n对于存储器，它的速度越快、能耗会越高、而且材料的成本也是越贵的，以至于速度快的存储器的容量都比较小。\n\n> CPU 里的寄存器和 Cache，是整个计算机存储器中价格最贵的\n\n# 寄存器\n\n寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（byte）的数据。比如：\n\n * 32 位 CPU 中大多数寄存器可以存储 4 个字节；\n * 64 位 CPU 中大多数寄存器可以存储 8 个字节。\n\n如果寄存器的速度太慢，则会拉长指令的处理周期，从而给用户的感觉，就是电脑「很慢」。\n\n# CPU Cache\n\nCPU Cache 用的是一种叫 **SRAM（Static Random-Access Memory，静态随机存储器）**的芯片。\n\nSRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。\n\n# 内存\n\n内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 **DRAM（Dynamic Random Access Memory，动态随机存取存储器）**的芯片。\n\n相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。\n\n因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因\n\n# SSD/HDD 硬盘\n\nSSD（Solid-state disk）就是我们常说的固态硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 10~1000 倍。\n\n当然，还有一款传统的硬盘，也就是机械硬盘（Hard Disk Drive, HDD），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢 10W 倍左右。\n\n> 由于 SSD 的价格快接近机械硬盘了，因此机械硬盘已经逐渐被 SSD 替代了。\n\n\n# 存储器的层次关系\n\n\n# 虚拟地址与物理地址\n\n 1. 虚拟地址（Virtual Address）：虚拟地址是由 CPU 生成的用于访问内存的地址空间，它是在程序运行时由操作系统提供给每个进程或线程的抽象地址。虚拟地址空间是每个进程独立的，使得每个进程可以认为自己独占整个内存空间，不受其他进程的影响。虚拟地址空间可以比实际的物理内存大小大得多，这样就允许每个进程使用的内存超过实际可用的物理内存。\n 2. 物理地址（Physical Address）：物理地址是内存中实际存储数据的地址，是 CPU 通过地址总线直接访问内存单元的地址。它对应着计算机中实际的硬件内存空间。每个物理地址都与内存模块上的特定存储单元（如 RAM）相关联。\n\n在计算机系统中，虚拟地址与物理地址之间的映射是由操作系统的内存管理单元（MMU，Memory Management Unit）来实现的。MMU 将虚拟地址映射到物理地址，使得程序访问虚拟地址时，可以被正确地映射到对应的物理地址，从而实现正确的内存访问。\n\n * 虚拟地址和物理地址的使用有助于提高计算机系统的性能和安全性，使得每个进程可以独立使用自己的地址空间，且不受其他进程的影响。\n * 同时，操作系统可以使用虚拟地址空间来提供内存隔离和保护机制，从而增强计算机系统的安全性和稳定性。",normalizedContent:"# 硬件结构\n\n\n# cpu 是如何执行程序的？\n\n问题：\n\n 1. 代码写了那么多，你知道 a = 1 + 2 这条代码是怎么被 cpu 执行的吗？\n 2. 软件用了那么多，你知道软件的 32 位和 64 位之间的区别吗？32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？\n 3. cpu 看了那么多，我们都知道 cpu 通常分为 32 位和 64 位，你知道 64 位相比 32 位 cpu 的优势在哪吗？64 位 cpu 的计算性能一定比 32 位 cpu 高很多吗？\n\n\n# 图灵机的工作方式\n\n图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，而且还定义了计算机由哪些部分组成，程序又是如何执行的。\n\n图灵机的基本组成如下：\n\n * 有一条「纸带」，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；\n\n * 有一个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写入到纸带的格子；\n\n * 读写头上有一些部件，比如存储单元、控制单元以及运算单元：\n   \n   1、存储单元用于存放数据；\n   \n   2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等；\n   \n   3、运算单元用于执行运算指令；\n\n图灵机主要功能就是：\n\n 1. 读取纸带格子中的内容，然后交给控制单元识别字符是数字还是运算符指令，（读取 -> 识别）\n 2. 如果是数字则存入到图灵机状态中，\n 3. 如果是运算符，则通知运算符单元读取状态中的数值进行计算，计算结果最终返回给读写头，\n 4. 读写头把结果写入到纸带的格子中。\n\n\n\n\n# 冯诺依曼模型\n\n定义计算机基本结构为 5 个部分，分别是运算器、控制器、存储器、输入设备、输出设备，这 5 个部分也被称为冯诺依曼模型。\n\n运算器、控制器是在中央处理器(cpu)里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。\n\n\n\n存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：\n\n\n\n# 内存\n\n我们的程序和数据都是存储在内存，存储的区域是线性的。\n\n在计算机数据存储中，存储数据的基本单位是字节（byte），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。\n\n内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。\n\n# 中央处理器\n\n中央处理器也就是我们常说的 cpu。\n\n32 位和 64 位 cpu 最主要区别在于一次能计算多少字节数据：\n\n * 32 位 cpu 一次可以计算 4 个字节；（32/8，一字节 8 位）\n * 64 位 cpu 一次可以计算 8 个字节；（64/8)\n\n这里的 32 位和 64 位，通常称为 cpu 的位宽，代表的是 cpu 一次可以计算（运算）的数据量。\n\ncpu 内部还有一些组件，常见的有寄存器、控制单元和逻辑运算单元等。\n\n 1. 控制单元负责控制 cpu 工作，\n 2. 逻辑运算单元负责计算，\n 3. 而寄存器可以分为多种类，每种寄存器的功能又不尽相同。主要作用是存储计算时的数据。\n\n为什么有了内存还需要寄存器？\n\n因为内存离 cpu 太远了，而寄存器就在 cpu 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。\n\n常见的寄存器种类：\n\n * 通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。\n * 程序计数器，用来存储 cpu 下一条要执行指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。\n * 指令寄存器，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里\n\n# 总线\n\n总线是用来通信的，在 cpu 和内存以及其他设备之间，总线可分为 3 种：\n\n 1. 地址总线，用于指定 cpu 将要操作的内存地址；\n 2. 数据总线，用于读写内存的数据；\n 3. 控制总线，用于发送和接收信号，比如中断、设备复位等信号，cpu 收到信号后自然进行响应，这时也需要控制总线；\n\n当 cpu 要读写内存数据的时候，是如何通过总线的？\n\n 1. 首先要通过「地址总线」来指定内存的地址；\n 2. 然后通过「控制总线」控制是读或写命令；\n 3. 最后通过「数据总线」来传输数据；\n\n地址总线 -> 控制总线 -> 数据总线\n\n# 输入、输出设备\n\n输入设备向计算机输入数据，计算机经过计算后，（运算器）把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 cpu 进行交互的，这时就需要用到控制总线了。\n\n\n# 线路位宽与 cpu 位宽\n\n> 线路位宽\n\n数据是如何通过线路传输的呢？\n\n其实是通过操作电压，低电压表示 0，高压电压则表示 1。\n\n如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。\n\n * 这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。\n * 当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。\n\n为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。\n\ncpu 想要操作「内存地址」就需要「地址总线」：\n\n * 如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 cpu 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；\n * 如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 cpu 能操作的内存地址最大数量为 4（2^2）个。\n\n那么，想要 cpu 操作 4g 大的内存，那么就需要 32 条地址总线，因为 2 ^ 32 = 4g。\n\n> cpu 位宽\n\ncpu 的位宽最好不要小于线路位宽，比如 32 位 cpu 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 cpu 最好和 32 位宽的线路搭配，因为 32 位 cpu 一次最多只能操作 32 位宽的地址总线和数据总线。\n\n为什么 64 位 cpu 性能不一定就比 32 位 cpu 高很多？\n\n因为很少应用需要算超过 32 位的数字，\n\n所以如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 cpu 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来。\n\n\n# 程序执行的基本过程\n\n程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 cpu 了。(寄存器)\n\n那 cpu 执行程序的过程如下：\n\n 1. 第一步，\n    * cpu 读取「程序计数器」的值，这个值是指令的内存地址，\n    * 然后 cpu 的【控制单元】操作「地址总线」指定需要访问的内存地址，\n    * 接着通知【内存设备】准备数据，数据准备好后通过「数据总线」将指令数据传给 cpu，\n    * cpu 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。\n 2. 第二步，\n    * 「程序计数器」的值自增，表示指向下一条指令。\n    * 这个自增的大小，由 cpu 的位宽决定，比如 32 位的 cpu，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；\n 3. 第三步，\n    * cpu 分析「指令寄存器」中的指令，确定指令的类型和参数，\n    * 如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；\n    * 如果是存储类型的指令，则交由「控制单元」执行；\n\n简单总结一下就是\n\n一个程序执行的时候，cpu 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。\n\ncpu 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环（执行程序）的过程被称为 cpu 的指令周期。\n\n\n# a = 1 + 2 执行具体过程\n\ncpu 是不认识 a = 1 + 2 这个字符串，这些字符串只是方便我们程序员认识，要想这段程序能跑起来，还需要把整个程序翻译成汇编语言的程序，这个过程称为编译成汇编代码。\n\n针对汇编代码，我们还需要用汇编器翻译成机器码，这些机器码由 0 和 1 组成的机器语言，这一条条机器码，就是一条条的计算机指令，这个才是 cpu 能够真正认识的东西。\n\n下面来看看 a = 1 + 2 在 32 位 cpu 的执行过程。\n\n程序编译过程中，编译器通过分析代码，发现 1 和 2 是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是「数据段」。如下图，数据 1 和 2 的区域位置：\n\n * 数据 1 被存放到 0x200 位置；\n * 数据 2 被存放到 0x204 位置；\n\n\n\n编译器会把 a = 1 + 2 翻译成 4 条指令，存放到正文段中。如图，这 4 条指令被存放到了 0x100 ~ 0x10c 的区域中：\n\n 1. 0x100 的内容是 load 指令将 0x200 地址中的数据 1 装入到(指令)寄存器 r0；\n 2. 0x104 的内容是 load 指令将 0x204 地址中的数据 2 装入到寄存器 r1；\n 3. 0x108 的内容是 add 指令将寄存器 r0 和 r1 的数据相加，并把结果存放到寄存器 r2；\n 4. 0x10c 的内容是 store 指令将寄存器 r2 中的数据存回数据段中的 0x208 地址中，这个地址也就是变量 a 内存中的地址；\n\n> 简单总结就是：add 指令将寄存器 r0 和 r1 的数据相加，并把结果放入到 r2，从而翻译成机器码\n\n编译完成后，具体执行程序的时候，【程序计数器】会被设置为 0x100 地址，然后依次执行这 4 条指令。（编译 -> 执行）\n\n不难发现上面的例子中，地址之间都是相隔 4 个字节\n\n * 指令间隔\n\n这是因为上面的例子是在 32 位 cpu 执行的，因此一条指令是占 32 位大小，所以你会发现每条指令间隔 4 个字节。\n\n * 数据间隔\n\n而数据的大小是根据你在程序中指定的变量类型，比如 int 类型的数据则占 4 个字节，char 类型的数据则占 1 个字节\n\n> string 类型的话，在 utf-8 编码下，一个英文字母通常占用 1 个字节，一个汉字通常占用 3 个字节。\n\n# 指令\n\n指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，cpu 通过解析机器码来知道指令的内容。\n\n不同的 cpu 有不同的指令集，也就是对应着不同的汇编语言和不同的机器码。\n\n最简单的 mips 指集\n\nmips 的指令是一个 32 位的整数。\n\n * 高 6 位代表着操作码，表示这条指令是一条什么样的指令，\n * 剩下的 26 位不同指令类型所表示的内容也就不相同，\n * 主要有三种类型 r、i 和 j。\n\n\n\n三种类型的含义：\n\n * r 指令，用在算术和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移操作，后面还有位移操作的「位移量」，而最后的「功能码」则是再前面的操作码不够的时候，扩展操作码来表示对应的具体指令的；\n * i 指令，用在数据传输、条件分支等。这个类型的指令，就没有了位移量和功能码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或一个常数；\n * j 指令，用在跳转，高 6 位之外的 26 位都是一个跳转后的地址；\n\n编译器在编译程序的时候，会构造指令，这个过程叫做指令的编码。\n\ncpu 执行程序的时候，就会解析指令，这个过程叫作指令的解码。\n\n执行指令的方式\n\n大多数 cpu 都使用来【流水线】的方式来执行指令，所谓的流水线就是【把一个任务拆分成多个小任务】，于是一条指令通常分为 4 个阶段，称为 4 级流水线。\n\n四个阶段的具体含义：\n\n 1. cpu 通过程序计数器读取对应内存地址的指令，这个部分称为 fetch（取得指令）；\n 2. cpu 对指令进行解码，这个部分称为 decode（指令译码）；\n 3. cpu 执行指令，这个部分称为 execution（执行指令）；\n 4. cpu 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 store（数据回写）；\n\n上面这 4 个阶段，我们称为指令周期（instrution cycle），cpu 的工作就是一个周期接着一个周期，周而复始。\n\n# 指令的类型\n\n指令从功能角度划分，可以分为 5 大类：\n\n 1. 数据传输类型的指令，比如 store/load 是寄存器与内存间数据传输的指令，mov 是将一个内存地址的数据移动到另一个内存地址的指令；\n 2. 运算类型的指令，比如加减乘除、位运算、比较大小等等，它们最多只能处理两个寄存器中的数据；\n 3. 跳转类型的指令，通过修改程序计数器的值来达到跳转执行指令的过程，比如编程中常见的 if-else、switch-case、函数调用等。\n 4. 信号类型的指令，比如发生中断的指令 trap；\n 5. 闲置类型的指令，比如指令 nop，执行后 cpu 会空转一个周期\n\n传输、运算、跳转、信号、闲置\n\n# 指令的执行速度\n\ncpu 的硬件参数都会有 ghz 这个参数（主频），比如一个 1 ghz 的 cpu，指的是时钟频率是 1 g，代表着 1 秒会产生 1g 次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，称为时钟周期。\n\n对于 cpu 来说，在一个时钟周期内，cpu 仅能完成一个最基本的动作，时钟频率越高，时钟周期就越短，工作速度也就越快。(v=f/t)\n\n一个时钟周期一定能执行完一条指令吗？\n\n答案是不一定的，大多数指令不能在一个时钟周期完成，通常需要若干个时钟周期。不同的指令需要的时钟周期是不同的，加法和乘法都对应着一条 cpu 指令，但是乘法需要的时钟周期就要比加法多。\n\n如何让程序跑的更快？\n\n程序的 cpu 执行时间 越少 程序就跑得 越快。\n\n\n\n主频越高说明 cpu 的工作速度就越快，比如我手头上的电脑的 cpu 是 2.4 ghz 四核 intel core i5，这里的 2.4 ghz 就是电脑的主频，时钟周期时间就是 1/2.4g。\n\ncpu 时钟周期数 = 指令数 x 每条指令的平均时钟周期数（cycles per instruction，简称 cpi）\n\n因此，要想程序跑的更快，优化这三者即可：\n\n * 指令数，表示执行程序所需要多少条指令，以及哪些指令。需优化编译器。\n * 每条指令的平均时钟周期数 cpi，表示一条指令需要多少个时钟周期数，依赖于流水线方式；\n * 时钟周期时间，表示计算机主频，取决于计算机硬件。\n\n\n# 总结\n\n冯诺依曼模型\n\n\n\n> 你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？\n\n64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：\n\n * 如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令；\n * 操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。\n\n总之，硬件的 64 位和 32 位指的是 cpu 的位宽，软件的 64 位和 32 位指的是指令的位宽\n\n> 64 位相比 32 位 cpu 的优势在哪吗？64 位 cpu 的计算性能一定比 32 位 cpu 高很多吗？\n\n64 位相比 32 位 cpu 的优势主要体现在两个方面：\n\n * 64 位 cpu 可以一次计算超过 32 位的数字，而 32 位 cpu 如果要计算超过 32 位的数字，要分多步骤进行计算，效率就没那么高，但是大部分应用程序很少会计算那么大的数字，所以只有运算大数字的时候，64 位 cpu 的优势才能体现出来，否则和 32 位 cpu 的计算性能相差不大。\n * 通常来说 64 位 cpu 的地址总线是 48 位，而 32 位 cpu 的地址总线是 32 位，所以 64 位 cpu 可以寻址更大的物理内存空间。如果一个 32 位 cpu 的地址总线是 32 位，那么该 cpu 最大寻址能力是 4g，即使你加了 8g 大小的物理内存，也还是只能寻址到 4g 大小的地址，而如果一个 64 位 cpu 的地址总线是 48 位，那么该 cpu 最大寻址能力是 2^48，远超于 32 位 cpu 最大寻址能力。\n\n为什么通常说 64 位 cpu 的地址总线是 48 位的？\n\n这涉及到物理寻址和虚拟内存的设计。实际上，64 位 cpu 的地址总线并不是固定为 48 位，而是有一定的范围。\n\n\n# 磁盘比内存慢几万倍？\n\n> 如果大家自己想组装电脑的话，肯定需要购买一个 cpu 和存储器方面的设备。\n\n相信大家都知道内存和硬盘都属于计算机的存储设备，断电后内存的数据是会丢失的，而硬盘则不会，因为硬盘是持久化存储设备，同时也是一个 i/o 设备。\n\n但其实 cpu 内部也有存储数据的组件，比如寄存器、cpu l1/l2/l3 cache 也都是属于存储设备，只不过它们能存储的数据非常小。\n\n那机械硬盘、固态硬盘、内存这三个存储器，到底和 cpu l1 cache 相比速度差多少倍呢？\n\n\n# 存储器的层次结构\n\n\n\n寄存器，处理速度是最快的，但是能存储的数据也是最少的。\n\ncpu cache，中文称为 cpu 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。\n\nl1 cache 通常分成「数据缓存」和「指令缓存」，l1 是距离 cpu 最近的，因此它比 l2、l3 的读写速度都快、存储空间都小。\n\n对于存储器，它的速度越快、能耗会越高、而且材料的成本也是越贵的，以至于速度快的存储器的容量都比较小。\n\n> cpu 里的寄存器和 cache，是整个计算机存储器中价格最贵的\n\n# 寄存器\n\n寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（byte）的数据。比如：\n\n * 32 位 cpu 中大多数寄存器可以存储 4 个字节；\n * 64 位 cpu 中大多数寄存器可以存储 8 个字节。\n\n如果寄存器的速度太慢，则会拉长指令的处理周期，从而给用户的感觉，就是电脑「很慢」。\n\n# cpu cache\n\ncpu cache 用的是一种叫 **sram（static random-access memory，静态随机存储器）**的芯片。\n\nsram 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。\n\n# 内存\n\n内存用的芯片和 cpu cache 有所不同，它使用的是一种叫作 **dram（dynamic random access memory，动态随机存取存储器）**的芯片。\n\n相比 sram，dram 的密度更高，功耗更低，有更大的容量，而且造价比 sram 芯片便宜很多。\n\n因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 dram 之所以被称为「动态」存储器的原因\n\n# ssd/hdd 硬盘\n\nssd（solid-state disk）就是我们常说的固态硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 ssd 大概快 10~1000 倍。\n\n当然，还有一款传统的硬盘，也就是机械硬盘（hard disk drive, hdd），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢 10w 倍左右。\n\n> 由于 ssd 的价格快接近机械硬盘了，因此机械硬盘已经逐渐被 ssd 替代了。\n\n\n# 存储器的层次关系\n\n\n# 虚拟地址与物理地址\n\n 1. 虚拟地址（virtual address）：虚拟地址是由 cpu 生成的用于访问内存的地址空间，它是在程序运行时由操作系统提供给每个进程或线程的抽象地址。虚拟地址空间是每个进程独立的，使得每个进程可以认为自己独占整个内存空间，不受其他进程的影响。虚拟地址空间可以比实际的物理内存大小大得多，这样就允许每个进程使用的内存超过实际可用的物理内存。\n 2. 物理地址（physical address）：物理地址是内存中实际存储数据的地址，是 cpu 通过地址总线直接访问内存单元的地址。它对应着计算机中实际的硬件内存空间。每个物理地址都与内存模块上的特定存储单元（如 ram）相关联。\n\n在计算机系统中，虚拟地址与物理地址之间的映射是由操作系统的内存管理单元（mmu，memory management unit）来实现的。mmu 将虚拟地址映射到物理地址，使得程序访问虚拟地址时，可以被正确地映射到对应的物理地址，从而实现正确的内存访问。\n\n * 虚拟地址和物理地址的使用有助于提高计算机系统的性能和安全性，使得每个进程可以独立使用自己的地址空间，且不受其他进程的影响。\n * 同时，操作系统可以使用虚拟地址空间来提供内存隔离和保护机制，从而增强计算机系统的安全性和稳定性。",charsets:{cjk:!0}},{title:"数据结构基础小结",frontmatter:{title:"数据结构基础小结",date:"2023-07-23T11:42:54.000Z",permalink:"/pages/3b34ba/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93.html",relativePath:"02.计算机基础/03.数据结构/01.数据结构基础小结.md",key:"v-7c46b244",path:"/pages/3b34ba/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:15},{level:3,title:"什么是算法？",slug:"什么是算法",normalizedTitle:"什么是算法？",charIndex:22},{level:3,title:"什么是数据结构？",slug:"什么是数据结构",normalizedTitle:"什么是数据结构？",charIndex:95},{level:3,title:"数据结构都有哪些组成方式？",slug:"数据结构都有哪些组成方式",normalizedTitle:"数据结构都有哪些组成方式？",charIndex:173},{level:4,title:"基本数据结构",slug:"基本数据结构",normalizedTitle:"基本数据结构",charIndex:190},{level:4,title:"其他数据结构",slug:"其他数据结构",normalizedTitle:"其他数据结构",charIndex:370},{level:3,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:78},{level:3,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:84},{level:2,title:"线性结构",slug:"线性结构",normalizedTitle:"线性结构",charIndex:202},{level:3,title:"什么是数组",slug:"什么是数组",normalizedTitle:"什么是数组",charIndex:709},{level:3,title:"什么是链表",slug:"什么是链表",normalizedTitle:"什么是链表",charIndex:824},{level:3,title:"什么是栈",slug:"什么是栈",normalizedTitle:"什么是栈",charIndex:954},{level:3,title:"什么是队列",slug:"什么是队列",normalizedTitle:"什么是队列",charIndex:1020},{level:3,title:"什么是散列表",slug:"什么是散列表",normalizedTitle:"什么是散列表",charIndex:1090},{level:2,title:"树",slug:"树",normalizedTitle:"树",charIndex:264},{level:3,title:"什么是树",slug:"什么是树",normalizedTitle:"什么是树",charIndex:1762},{level:3,title:"什么是二叉树",slug:"什么是二叉树",normalizedTitle:"什么是二叉树",charIndex:1853},{level:3,title:"什么是二叉堆",slug:"什么是二叉堆",normalizedTitle:"什么是二叉堆",charIndex:2900},{level:3,title:"什么是优先队列",slug:"什么是优先队列",normalizedTitle:"什么是优先队列",charIndex:3013},{level:2,title:"图",slug:"图",normalizedTitle:"图",charIndex:325},{level:3,title:"什么是图",slug:"什么是图",normalizedTitle:"什么是图",charIndex:3147},{level:3,title:"图的分类",slug:"图的分类",normalizedTitle:"图的分类",charIndex:3270},{level:3,title:"图的表示方式",slug:"图的表示方式",normalizedTitle:"图的表示方式",charIndex:3387},{level:3,title:"常见图算法",slug:"常见图算法",normalizedTitle:"常见图算法",charIndex:3451},{level:3,title:"实际应用",slug:"实际应用",normalizedTitle:"实际应用",charIndex:3617},{level:2,title:"红黑树",slug:"红黑树",normalizedTitle:"红黑树",charIndex:1551},{level:2,title:"布隆过滤器",slug:"布隆过滤器",normalizedTitle:"布隆过滤器",charIndex:4274}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.585,time:95100,words:317},headersStr:"概述 什么是算法？ 什么是数据结构？ 数据结构都有哪些组成方式？ 基本数据结构 其他数据结构 时间复杂度 空间复杂度 线性结构 什么是数组 什么是链表 什么是栈 什么是队列 什么是散列表 树 什么是树 什么是二叉树 什么是二叉堆 什么是优先队列 图 什么是图 图的分类 图的表示方式 常见图算法 实际应用 红黑树 布隆过滤器",content:"# 数据结构基础小结\n\n\n# 概述\n\n\n# 什么是算法？\n\n在计算机领域里，算法是一系列程序指令，用于处理特定的运算和逻辑问题。\n\n衡量算法优劣的主要标准是时间复杂度和空间复杂度。\n\n\n# 什么是数据结构？\n\n数据结构，对应的英文单词是 data structure，是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。\n\n\n# 数据结构都有哪些组成方式？\n\n# 基本数据结构\n\n 1. 线性结构\n    \n    线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来的栈、 队列、哈希表。\n\n 2. 树\n    \n    树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构。\n\n 3. 图\n    \n    图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系。\n\n# 其他数据结构\n\n除上述所列的几种基本数据结构以外，还有一些其他的千奇百怪的数据结构。它们由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等\n\n\n# 时间复杂度\n\n时间复杂度是对一个算法运行时间长短的量度。它描述了算法运行时间与输入大小之间的关系，记作 T(n)=O(f(n))。\n\n时间复杂度通常用大 O 记号（O表示）来表示，表示算法执行时间的上界。\n\n因为渐进时间复杂度用大写 O 来表示，所以也被称为大 O 表示法。\n\nO(1) < O(logn) < O(n) < O（n²)\n\n\n# 空间复杂度\n\n空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用了大 O 表示法，记作 S(n)=O(f(n))。\n\n\n# 线性结构\n\n\n# 什么是数组\n\n数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序存储，访问方式是随机访问。\n\n * 利用下标查找数组元素的时间复杂度是 O(1)，\n * 中间插入、删除数组元素的时间复杂度是 O(n)。\n\n\n# 什么是链表\n\n链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。（和数组相反）\n\n * 查找链表节点的时间复杂度是 O(n)，\n * 中间插入、删除节点的时间复杂度是 O(1)。\n\n\n# 什么是栈\n\n栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和出栈操作，遵循先入后出的原则（FILO）。\n\n\n# 什么是队列\n\n队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。\n\n\n# 什么是散列表\n\n散列表也叫哈希表，是存储 Key-Value 映射的集合。对于某一个 Key，散列表可以在接近 O(1) 的时间内进行读写操作。\n\n散列表通过哈希函数实现 Key 和数组下标的转换，通过【开放寻址法】和【链表法】来解决哈希冲突。\n\n 1. 开放寻址法：当发生冲突时，它会尝试在哈希表中的其他位置继续寻找可用的位置来存储数据，直到找到一个空闲的位置为止。\n    \n    具体来说，开放寻址法通过以下方式处理哈希冲突：\n    \n    * 线性探测法：发生冲突时，依次检查下一个位置，直到找到一个空闲位置。\n    * 二次探测法：发生冲突时，按照某个固定的二次探测序列依次检查下一个位置，直到找到一个空闲位置。\n    * 双重哈希法：使用两个不同的哈希函数来计算下一个探测位置。\n    \n    > 开放寻址法的优点是不需要额外的数据结构来存储冲突的数据，节省了内存空间。但它的缺点是容易产生聚集性冲突，导致哈希表的性能下降。\n\n 2. 链表法：它在哈希表的每个桶中维护一个链表（或其他数据结构，如红黑树），当发生冲突时，将冲突的数据存储在该桶的链表中。\n    \n    具体来说，链表法通过以下方式处理哈希冲突：\n    \n    * 将哈希表的每个桶初始化为一个空链表。\n    * 当发生哈希冲突时，将新的数据插入到对应桶的链表中。\n    \n    > 链表法的优点是容易实现，且能够有效地处理较多的哈希冲突。然而，当链表过长时，会影响哈希表的性能，因为查找操作需要在链表上进行线性搜索。\n\n\n# 树\n\n\n# 什么是树\n\n树是 n 个节点的有限集，有且仅有一个特定的称为根的节点。\n\n当 n>1 时，其余节点可分为 m 个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。\n\n\n# 什么是二叉树\n\n二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点。\n\n> 二叉树包含【完全二叉树】和【满二叉树】两种特殊形式。\n\n 1. 完全二叉树（Complete Binary Tree）：除了最后一层可能不满外，其他层的节点都必须是满的，并且最后一层的节点都尽量靠左排列。\n    \n    具体特点如下：\n    \n    * 所有叶子节点都集中在二叉树的最后两层。\n    * 最后一层的叶子节点都靠左排列。\n    * 如果一个节点只有右子树而没有左子树，那么它必定是最后一层的节点。\n    \n    完全二叉树在数组中的存储非常高效，因为它的特殊结构允许用数组的形式表示，无需使用额外的指针。\n\n 2. 满二叉树（Full Binary Tree）：除了叶子节点外，每个节点都有两个子节点，即每个节点的度数都是 2。\n    \n    具体特点如下：\n    \n    * 所有非叶子节点都有两个子节点。\n    * 所有叶子节点都在同一层上。\n    \n    满二叉树的高度是固定的，由节点数决定，且在给定节点数下，它的高度是最小的。但是满二叉树并不常见，一般完全二叉树更为常见。\n\n> 二叉树的遍历方式有四种，根据遍历节点之间的关系，可以分为以下 4 种方式：\n\n 1. 前序遍历（Pre-order Traversal）：先访问根节点，然后按照左子树、右子树的顺序递归遍历。（根左右）\n 2. 中序遍历（In-order Traversal）：先按照左子树的顺序递归遍历，然后访问根节点，最后按照右子树的顺序递归遍历。（左根右）\n 3. 后序遍历（Post-order Traversal）：先按照左子树、右子树的顺序递归遍历，然后访问根节点。（左右根）\n 4. 层序遍历（Level-order Traversal）：从上到下逐层遍历二叉树的节点，同一层节点按照从左到右的顺序访问。（上到下）\n\n> 另外，从更宏观的角度划分，二叉树的遍历方式可以分为两大类：\n\n 1. 深度优先遍历（Depth-First Traversal）：以深度为优先级的遍历方式，即先访问根节点，然后递归遍历左子树和右子树。（根左右）\n 2. 广度优先遍历（Breadth-First Traversal）：以广度为优先级的遍历方式，即按照层序遍历的顺序逐层遍历二叉树的节点。\n\n深度优先遍历适用于查找、搜索等问题（栈），而广度优先遍历适用于层次遍历和最短路径等问题（队列）。\n\n\n# 什么是二叉堆\n\n二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。\n\n * 在最大堆中，任何一个父节点的值，都大于或等于它左、右孩子节点的值。\n * 在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的值。\n\n\n# 什么是优先队列\n\n优先队列分为最大优先队列和最小优先队列。\n\n * 在最大优先队列中，无论入队顺序如何，当前最大的元素都会优先出队，这是基于最大堆实现的。\n * 在最小优先队列中，无论入队顺序如何，当前最小的元素都会优先出队，这是基于最小堆实现的\n\n\n# 图\n\n\n# 什么是图\n\n图是由一组节点（顶点）和连接这些节点的边组成的集合。\n\n节点表示实体，边表示节点之间的关系。\n\n图可以是有向图（Directed Graph），即边有方向性，也可以是无向图（Undirected Graph），边没有方向性。\n\n\n# 图的分类\n\n * 简单图：图中没有自环和重复的边。\n * 带权图：图的边带有权重，表示节点之间的距离或代价。\n * 连通图：任意两个节点之间都有路径连接。\n * 有向无环图（DAG）：没有环的有向图，常用于表示任务依赖关系。\n\n\n# 图的表示方式\n\n * 邻接矩阵：使用二维数组表示节点之间的连接关系。\n * 邻接表：使用链表或数组表示节点的邻居节点。\n\n\n# 常见图算法\n\n * 广度优先搜索（BFS）：用于在图中查找最短路径或层次遍历。\n * 深度优先搜索（DFS）：用于查找图中的所有路径或判断是否存在环。\n * Dijkstra 算法：用于找到带权图中的最短路径。\n * Kruskal 算法：用于求最小生成树，适用于带权无向图。\n * 拓扑排序：用于有向无环图中的任务调度。\n\n\n# 实际应用\n\n * 网络通信：图可用于表示计算机网络中的节点和连接。\n * 社交网络：图可用于表示用户之间的关系，进行社交网络分析。\n * 路径规划：图可用于地图导航、GPS 定位等。\n * 数据库查询优化：用图的拓扑排序来优化数据库查询计划。\n * 任务调度：用有向无环图表示任务依赖，实现任务调度和并行处理。\n\n>  1. BFS - 广度优先搜索（Breadth-First Search）\n>  2. DFS - 深度优先搜索（Depth-First Search）\n>  3. DAG - 有向无环图（Directed Acyclic Graph）\n>  4. GPS - 全球定位系统（Global Positioning System）\n\n\n# 红黑树\n\n红黑树是一种自平衡二叉搜索树（通过颜色调整和旋转操作），它在插入和删除节点时能够自动调整结构，保持树的平衡性，从而保证查找、插入和删除操作的时间复杂度稳定在 O(log n)。\n\n红黑树特点：\n\n * 每个节点都是红色或黑色。\n * 根节点是黑色。\n * 叶子节点（空节点）都是黑色。\n * 红色节点的子节点都是黑色。\n * 从任意节点到其每个叶子节点的路径上包含相同数量的黑色节点（即相同的黑色高度）。\n\n红黑树的应用：\n\nTreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。\n\n为什么要用红黑树？\n\n简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\n\n\n# 布隆过滤器\n\n布隆过滤器（Bloom Filter）是一种空间高效的概率型数据结构，用于快速判断一个元素是否存在于一个集合中。\n\n实际上是一个位数组（通常用二进制位表示），以及一系列哈希函数。\n\n它的主要特点是快速查询、低存储消耗，但可能会产生一定的误判率。\n\n布隆过滤器通常用于以下场景：\n\n 1. 缓存加速：在缓存中判断一个数据是否存在，如果不存在，则不需要从数据库或其他存储中加载数据，从而加速数据的查询。\n 2. 数据库查询优化：可以在数据库查询之前，先通过布隆过滤器快速判断数据是否可能存在，从而减少对数据库的查询负担。\n 3. 分布式系统：在分布式系统中，可以使用布隆过滤器来快速判断数据是否存在于分布式缓存或分布式数据库中。\n 4. 防止缓存穿透：当请求的数据在缓存中不存在时，可以使用布隆过滤器先进行判断，如果判断结果为不存在，则可以直接返回，避免对数据库等存储系统的过多查询。\n\n由于误判率的存在，布隆过滤器不适合用于需要绝对精确判断的场景\n\n具体实现步骤如下：\n\n 1. 初始化位数组：创建一个位数组，并将所有位初始化为 0。位数组的大小通常根据预期元素数量和期望的误判率来确定。\n 2. 添加元素：将待添加的元素通过多个哈希函数计算出一系列哈希值，然后将对应位置的位设置为 1。通常会选择多个不同的哈希函数，以增加散列效果。\n 3. 查询元素：将待查询的元素通过相同的哈希函数计算出一系列哈希值，然后检查对应位置的位。如果所有位置的位都为 1，则表示元素可能存在；如果有任何一位为 0，则表示元素一定不存在。",normalizedContent:"# 数据结构基础小结\n\n\n# 概述\n\n\n# 什么是算法？\n\n在计算机领域里，算法是一系列程序指令，用于处理特定的运算和逻辑问题。\n\n衡量算法优劣的主要标准是时间复杂度和空间复杂度。\n\n\n# 什么是数据结构？\n\n数据结构，对应的英文单词是 data structure，是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。\n\n\n# 数据结构都有哪些组成方式？\n\n# 基本数据结构\n\n 1. 线性结构\n    \n    线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来的栈、 队列、哈希表。\n\n 2. 树\n    \n    树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构。\n\n 3. 图\n    \n    图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系。\n\n# 其他数据结构\n\n除上述所列的几种基本数据结构以外，还有一些其他的千奇百怪的数据结构。它们由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等\n\n\n# 时间复杂度\n\n时间复杂度是对一个算法运行时间长短的量度。它描述了算法运行时间与输入大小之间的关系，记作 t(n)=o(f(n))。\n\n时间复杂度通常用大 o 记号（o表示）来表示，表示算法执行时间的上界。\n\n因为渐进时间复杂度用大写 o 来表示，所以也被称为大 o 表示法。\n\no(1) < o(logn) < o(n) < o（n²)\n\n\n# 空间复杂度\n\n空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用了大 o 表示法，记作 s(n)=o(f(n))。\n\n\n# 线性结构\n\n\n# 什么是数组\n\n数组是由有限个相同类型的变量所组成的有序集合，它的物理存储方式是顺序存储，访问方式是随机访问。\n\n * 利用下标查找数组元素的时间复杂度是 o(1)，\n * 中间插入、删除数组元素的时间复杂度是 o(n)。\n\n\n# 什么是链表\n\n链表是一种链式数据结构，由若干节点组成，每个节点包含指向下一节点的指针。链表的物理存储方式是随机存储，访问方式是顺序访问。（和数组相反）\n\n * 查找链表节点的时间复杂度是 o(n)，\n * 中间插入、删除节点的时间复杂度是 o(1)。\n\n\n# 什么是栈\n\n栈是一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和出栈操作，遵循先入后出的原则（filo）。\n\n\n# 什么是队列\n\n队列也是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（fifo）。\n\n\n# 什么是散列表\n\n散列表也叫哈希表，是存储 key-value 映射的集合。对于某一个 key，散列表可以在接近 o(1) 的时间内进行读写操作。\n\n散列表通过哈希函数实现 key 和数组下标的转换，通过【开放寻址法】和【链表法】来解决哈希冲突。\n\n 1. 开放寻址法：当发生冲突时，它会尝试在哈希表中的其他位置继续寻找可用的位置来存储数据，直到找到一个空闲的位置为止。\n    \n    具体来说，开放寻址法通过以下方式处理哈希冲突：\n    \n    * 线性探测法：发生冲突时，依次检查下一个位置，直到找到一个空闲位置。\n    * 二次探测法：发生冲突时，按照某个固定的二次探测序列依次检查下一个位置，直到找到一个空闲位置。\n    * 双重哈希法：使用两个不同的哈希函数来计算下一个探测位置。\n    \n    > 开放寻址法的优点是不需要额外的数据结构来存储冲突的数据，节省了内存空间。但它的缺点是容易产生聚集性冲突，导致哈希表的性能下降。\n\n 2. 链表法：它在哈希表的每个桶中维护一个链表（或其他数据结构，如红黑树），当发生冲突时，将冲突的数据存储在该桶的链表中。\n    \n    具体来说，链表法通过以下方式处理哈希冲突：\n    \n    * 将哈希表的每个桶初始化为一个空链表。\n    * 当发生哈希冲突时，将新的数据插入到对应桶的链表中。\n    \n    > 链表法的优点是容易实现，且能够有效地处理较多的哈希冲突。然而，当链表过长时，会影响哈希表的性能，因为查找操作需要在链表上进行线性搜索。\n\n\n# 树\n\n\n# 什么是树\n\n树是 n 个节点的有限集，有且仅有一个特定的称为根的节点。\n\n当 n>1 时，其余节点可分为 m 个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。\n\n\n# 什么是二叉树\n\n二叉树是树的一种特殊形式，每一个节点最多有两个孩子节点。\n\n> 二叉树包含【完全二叉树】和【满二叉树】两种特殊形式。\n\n 1. 完全二叉树（complete binary tree）：除了最后一层可能不满外，其他层的节点都必须是满的，并且最后一层的节点都尽量靠左排列。\n    \n    具体特点如下：\n    \n    * 所有叶子节点都集中在二叉树的最后两层。\n    * 最后一层的叶子节点都靠左排列。\n    * 如果一个节点只有右子树而没有左子树，那么它必定是最后一层的节点。\n    \n    完全二叉树在数组中的存储非常高效，因为它的特殊结构允许用数组的形式表示，无需使用额外的指针。\n\n 2. 满二叉树（full binary tree）：除了叶子节点外，每个节点都有两个子节点，即每个节点的度数都是 2。\n    \n    具体特点如下：\n    \n    * 所有非叶子节点都有两个子节点。\n    * 所有叶子节点都在同一层上。\n    \n    满二叉树的高度是固定的，由节点数决定，且在给定节点数下，它的高度是最小的。但是满二叉树并不常见，一般完全二叉树更为常见。\n\n> 二叉树的遍历方式有四种，根据遍历节点之间的关系，可以分为以下 4 种方式：\n\n 1. 前序遍历（pre-order traversal）：先访问根节点，然后按照左子树、右子树的顺序递归遍历。（根左右）\n 2. 中序遍历（in-order traversal）：先按照左子树的顺序递归遍历，然后访问根节点，最后按照右子树的顺序递归遍历。（左根右）\n 3. 后序遍历（post-order traversal）：先按照左子树、右子树的顺序递归遍历，然后访问根节点。（左右根）\n 4. 层序遍历（level-order traversal）：从上到下逐层遍历二叉树的节点，同一层节点按照从左到右的顺序访问。（上到下）\n\n> 另外，从更宏观的角度划分，二叉树的遍历方式可以分为两大类：\n\n 1. 深度优先遍历（depth-first traversal）：以深度为优先级的遍历方式，即先访问根节点，然后递归遍历左子树和右子树。（根左右）\n 2. 广度优先遍历（breadth-first traversal）：以广度为优先级的遍历方式，即按照层序遍历的顺序逐层遍历二叉树的节点。\n\n深度优先遍历适用于查找、搜索等问题（栈），而广度优先遍历适用于层次遍历和最短路径等问题（队列）。\n\n\n# 什么是二叉堆\n\n二叉堆是一种特殊的完全二叉树，分为最大堆和最小堆。\n\n * 在最大堆中，任何一个父节点的值，都大于或等于它左、右孩子节点的值。\n * 在最小堆中，任何一个父节点的值，都小于或等于它左、右孩子节点的值。\n\n\n# 什么是优先队列\n\n优先队列分为最大优先队列和最小优先队列。\n\n * 在最大优先队列中，无论入队顺序如何，当前最大的元素都会优先出队，这是基于最大堆实现的。\n * 在最小优先队列中，无论入队顺序如何，当前最小的元素都会优先出队，这是基于最小堆实现的\n\n\n# 图\n\n\n# 什么是图\n\n图是由一组节点（顶点）和连接这些节点的边组成的集合。\n\n节点表示实体，边表示节点之间的关系。\n\n图可以是有向图（directed graph），即边有方向性，也可以是无向图（undirected graph），边没有方向性。\n\n\n# 图的分类\n\n * 简单图：图中没有自环和重复的边。\n * 带权图：图的边带有权重，表示节点之间的距离或代价。\n * 连通图：任意两个节点之间都有路径连接。\n * 有向无环图（dag）：没有环的有向图，常用于表示任务依赖关系。\n\n\n# 图的表示方式\n\n * 邻接矩阵：使用二维数组表示节点之间的连接关系。\n * 邻接表：使用链表或数组表示节点的邻居节点。\n\n\n# 常见图算法\n\n * 广度优先搜索（bfs）：用于在图中查找最短路径或层次遍历。\n * 深度优先搜索（dfs）：用于查找图中的所有路径或判断是否存在环。\n * dijkstra 算法：用于找到带权图中的最短路径。\n * kruskal 算法：用于求最小生成树，适用于带权无向图。\n * 拓扑排序：用于有向无环图中的任务调度。\n\n\n# 实际应用\n\n * 网络通信：图可用于表示计算机网络中的节点和连接。\n * 社交网络：图可用于表示用户之间的关系，进行社交网络分析。\n * 路径规划：图可用于地图导航、gps 定位等。\n * 数据库查询优化：用图的拓扑排序来优化数据库查询计划。\n * 任务调度：用有向无环图表示任务依赖，实现任务调度和并行处理。\n\n>  1. bfs - 广度优先搜索（breadth-first search）\n>  2. dfs - 深度优先搜索（depth-first search）\n>  3. dag - 有向无环图（directed acyclic graph）\n>  4. gps - 全球定位系统（global positioning system）\n\n\n# 红黑树\n\n红黑树是一种自平衡二叉搜索树（通过颜色调整和旋转操作），它在插入和删除节点时能够自动调整结构，保持树的平衡性，从而保证查找、插入和删除操作的时间复杂度稳定在 o(log n)。\n\n红黑树特点：\n\n * 每个节点都是红色或黑色。\n * 根节点是黑色。\n * 叶子节点（空节点）都是黑色。\n * 红色节点的子节点都是黑色。\n * 从任意节点到其每个叶子节点的路径上包含相同数量的黑色节点（即相同的黑色高度）。\n\n红黑树的应用：\n\ntreemap、treeset 以及 jdk1.8 的 hashmap 底层都用到了红黑树。\n\n为什么要用红黑树？\n\n简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\n\n\n# 布隆过滤器\n\n布隆过滤器（bloom filter）是一种空间高效的概率型数据结构，用于快速判断一个元素是否存在于一个集合中。\n\n实际上是一个位数组（通常用二进制位表示），以及一系列哈希函数。\n\n它的主要特点是快速查询、低存储消耗，但可能会产生一定的误判率。\n\n布隆过滤器通常用于以下场景：\n\n 1. 缓存加速：在缓存中判断一个数据是否存在，如果不存在，则不需要从数据库或其他存储中加载数据，从而加速数据的查询。\n 2. 数据库查询优化：可以在数据库查询之前，先通过布隆过滤器快速判断数据是否可能存在，从而减少对数据库的查询负担。\n 3. 分布式系统：在分布式系统中，可以使用布隆过滤器来快速判断数据是否存在于分布式缓存或分布式数据库中。\n 4. 防止缓存穿透：当请求的数据在缓存中不存在时，可以使用布隆过滤器先进行判断，如果判断结果为不存在，则可以直接返回，避免对数据库等存储系统的过多查询。\n\n由于误判率的存在，布隆过滤器不适合用于需要绝对精确判断的场景\n\n具体实现步骤如下：\n\n 1. 初始化位数组：创建一个位数组，并将所有位初始化为 0。位数组的大小通常根据预期元素数量和期望的误判率来确定。\n 2. 添加元素：将待添加的元素通过多个哈希函数计算出一系列哈希值，然后将对应位置的位设置为 1。通常会选择多个不同的哈希函数，以增加散列效果。\n 3. 查询元素：将待查询的元素通过相同的哈希函数计算出一系列哈希值，然后检查对应位置的位。如果所有位置的位都为 1，则表示元素可能存在；如果有任何一位为 0，则表示元素一定不存在。",charsets:{cjk:!0}},{title:"两数之和",frontmatter:{title:"两数之和",date:"2023-12-01T17:16:09.000Z",permalink:"/pages/2dcfa1/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html",relativePath:"02.计算机基础/04.算法/1. 两数之和.md",key:"v-39fe2a71",path:"/pages/2dcfa1/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:14},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:154},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:503},{level:3,title:"方法一：暴力枚举",slug:"方法一-暴力枚举",normalizedTitle:"方法一：暴力枚举",charIndex:511},{level:3,title:"方法二：哈希法",slug:"方法二-哈希法",normalizedTitle:"方法二：哈希法",charIndex:988}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.405,time:84300,words:281},headersStr:"题目： 示例： 解题： 方法一：暴力枚举 方法二：哈希法",content:"# 1. 两数之和\n\n\n# 题目：\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n1\n2\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n1\n2\n\n\n提示：\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * 只会存在一个有效答案\n\n**进阶：**你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n\n\n# 解题：\n\n\n# 方法一：暴力枚举\n\n思路？不需要，每个相加就好了。\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        for(int i = 0; i < nums.size(); ++i) {\n            for(int j = i + 1; j < nums.size(); ++j) {\n                if(nums[i] + nums[j] == target) {\n                    return {i,j};\n                }\n            }\n        }\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n复杂度分析\n\n * 时间复杂度：O(N2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n\n * 空间复杂度：O(1)。\n\n\n# 方法二：哈希法\n\n创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\n\nkey --\x3e 元素值x   value --\x3e 下标i\n即\nkey --\x3e nums[i]  value --\x3e i\n\n\n1\n2\n3\n\n\n举个例子，比如说 nums = [2,7,11,15], target = 9，一开始，我的哈希表 mmap 为空，那么第一次进入 for 循环，i = 0 的时候，it 存储的是 9 - 2 = 7，这个时候 if(it != mmap.end()) 语句肯定不成立，因为，我的 mmap 里元素为空，肯定找不到 7，于是，就直接把 nums[i] 即 元素2 插入到哈希表中。以此类推，当 for 循环遍历到 nums[1] 时， it 存储的是 9 - 7 = 2 这个时候 if(it != mmap.end()) 语句成立，就可以输出 it 元素值的下标和当前遍历位置的下标。\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mmap;\n        for(int i = 0; i < nums.size(); ++i) {\n            auto it = mmap.find(target-nums[i]);\n            if(it != mmap.end()) {\n                return{it->second,i};\n            }\n            mmap[nums[i]] = i;\t\t// key --\x3e nums[i]  value --\x3e i\n        }\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n复杂度分析\n\n时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。\n\n空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。",normalizedContent:"# 1. 两数之和\n\n\n# 题目：\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n1\n2\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n1\n2\n\n\n提示：\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * 只会存在一个有效答案\n\n**进阶：**你可以想出一个时间复杂度小于 o(n2) 的算法吗？\n\n\n# 解题：\n\n\n# 方法一：暴力枚举\n\n思路？不需要，每个相加就好了。\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& nums, int target) {\n        for(int i = 0; i < nums.size(); ++i) {\n            for(int j = i + 1; j < nums.size(); ++j) {\n                if(nums[i] + nums[j] == target) {\n                    return {i,j};\n                }\n            }\n        }\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n复杂度分析\n\n * 时间复杂度：o(n2)，其中 n 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n\n * 空间复杂度：o(1)。\n\n\n# 方法二：哈希法\n\n创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\n\nkey --\x3e 元素值x   value --\x3e 下标i\n即\nkey --\x3e nums[i]  value --\x3e i\n\n\n1\n2\n3\n\n\n举个例子，比如说 nums = [2,7,11,15], target = 9，一开始，我的哈希表 mmap 为空，那么第一次进入 for 循环，i = 0 的时候，it 存储的是 9 - 2 = 7，这个时候 if(it != mmap.end()) 语句肯定不成立，因为，我的 mmap 里元素为空，肯定找不到 7，于是，就直接把 nums[i] 即 元素2 插入到哈希表中。以此类推，当 for 循环遍历到 nums[1] 时， it 存储的是 9 - 7 = 2 这个时候 if(it != mmap.end()) 语句成立，就可以输出 it 元素值的下标和当前遍历位置的下标。\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& nums, int target) {\n        unordered_map<int, int> mmap;\n        for(int i = 0; i < nums.size(); ++i) {\n            auto it = mmap.find(target-nums[i]);\n            if(it != mmap.end()) {\n                return{it->second,i};\n            }\n            mmap[nums[i]] = i;\t\t// key --\x3e nums[i]  value --\x3e i\n        }\n        return {};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n复杂度分析\n\n时间复杂度：o(n)，其中 n 是数组中的元素数量。对于每一个元素 x，我们可以 o(1) 地寻找 target - x。\n\n空间复杂度：o(n)，其中 n 是数组中的元素数量。主要为哈希表的开销。",charsets:{cjk:!0}},{title:"对称二叉树",frontmatter:{title:"对称二叉树",date:"2023-11-24T16:30:01.000Z",permalink:"/pages/3ec756/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"02.计算机基础/04.算法/101. 对称二叉树.md",key:"v-1d0967af",path:"/pages/3ec756/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:17},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:55},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:261},{level:3,title:"方法一：递归",slug:"方法一-递归",normalizedTitle:"方法一：递归",charIndex:269},{level:3,title:"方法二：迭代",slug:"方法二-迭代",normalizedTitle:"方法二：迭代",charIndex:2009}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.465,time:87900,words:293},headersStr:"题目： 示例： 解题： 方法一：递归 方法二：迭代",content:"# 101. 对称二叉树\n\n\n# 题目：\n\n给你一个二叉树的根节点 root ， 检查它是否轴对称。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：root = [1,2,2,null,3,null,3]\n输出：false\n\n\n1\n2\n\n\n提示：\n\n * 树中节点数目在范围 [1, 1000] 内\n * -100 <= Node.val <= 100\n\n**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？\n\n\n# 解题：\n\n\n# 方法一：递归\n\n二叉树对称，说明它们关于根节点镜像，左子树=右子树，反之亦然。因此可以用两个指针，同时向根节点的左右子树两个方向遍历。\n\np指针左移，则q指针右移，每次移动检查当前指针所指向的节点的值是否相等，反之亦然。\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool check(TreeNode *p, TreeNode *q) {\n        // 如果两个节点都为空，也是对称的\n        if(!p && !q) return true;\n        // 如果其中一个节点不为空，不对称\n        if(!p || !q) return false;\n        // 节点值不相等，不对称\n        // 递归检查左子树的左子树与右子树的右子树，以及左子树的右子树与右子树的左子树\n        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);\n    }\n    bool isSymmetric(TreeNode* root) {\n        return check(root, root);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n通俗易懂版本\n\nclass Solution {\npublic:\n    bool check(TreeNode *p, TreeNode *q) {\n        // 如果两个节点都为空，也是对称的\n        if(p == nullptr && q == nullptr) {\n            return true;\n        }\n        // 如果其中一个节点不为空，不对称\n        if(p == nullptr || q == nullptr) {\n            return false;\n        }\n        // 节点值不相等，不对称\n        if(p->val != q->val) {\n            return false;\n        }\n        // 递归检查左子树的左子树与右子树的右子树，以及左子树的右子树与右子树的左子树\n        return check(p->left, q->right) && check(p->right, q->left);\n    }\n    bool isSymmetric(TreeNode* root) {\n        return check(root, root);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n复杂度分析\n\n假设树上一共 n 个节点。\n\n * 时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。\n * 空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。\n\n\n# 方法二：迭代\n\n基本思路是使用队列，将每一层的节点按照对称的顺序加入队列，然后依次比较队列中的节点是否对称。每次从队列中取出两个节点进行比较，并按照对称的顺序将它们的子节点加入队列。**要注意的是根节点要加入队列两次。**当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。\n\nclass Solution {\npublic:\n  \tbool check(TreeNode *u, TreeNode *v) {\n        queue<TreeNode*> q;\n        q.push(u); q.push(v);\n        while(!q.empty()) {\n            u = q.front(); q.pop();\n            v = q.front(); q.pop();\n            if(!u && !v) continue;\n            if((!u || !v) || u->val != v->val)) return false;\n            q.push(u->left);\n            q.push(v->right);\n            q.push(u->right);\n            q.push(v->left);\n        }\n        return true;\n    }\n    bool isSymmetric(TreeNode *root) {\n        return check(root, root);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，同「方法一」。\n\n * 空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。",normalizedContent:"# 101. 对称二叉树\n\n\n# 题目：\n\n给你一个二叉树的根节点 root ， 检查它是否轴对称。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：root = [1,2,2,3,4,4,3]\n输出：true\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：root = [1,2,2,null,3,null,3]\n输出：false\n\n\n1\n2\n\n\n提示：\n\n * 树中节点数目在范围 [1, 1000] 内\n * -100 <= node.val <= 100\n\n**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？\n\n\n# 解题：\n\n\n# 方法一：递归\n\n二叉树对称，说明它们关于根节点镜像，左子树=右子树，反之亦然。因此可以用两个指针，同时向根节点的左右子树两个方向遍历。\n\np指针左移，则q指针右移，每次移动检查当前指针所指向的节点的值是否相等，反之亦然。\n\n/**\n * definition for a binary tree node.\n * struct treenode {\n *     int val;\n *     treenode *left;\n *     treenode *right;\n *     treenode() : val(0), left(nullptr), right(nullptr) {}\n *     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass solution {\npublic:\n    bool check(treenode *p, treenode *q) {\n        // 如果两个节点都为空，也是对称的\n        if(!p && !q) return true;\n        // 如果其中一个节点不为空，不对称\n        if(!p || !q) return false;\n        // 节点值不相等，不对称\n        // 递归检查左子树的左子树与右子树的右子树，以及左子树的右子树与右子树的左子树\n        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);\n    }\n    bool issymmetric(treenode* root) {\n        return check(root, root);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n通俗易懂版本\n\nclass solution {\npublic:\n    bool check(treenode *p, treenode *q) {\n        // 如果两个节点都为空，也是对称的\n        if(p == nullptr && q == nullptr) {\n            return true;\n        }\n        // 如果其中一个节点不为空，不对称\n        if(p == nullptr || q == nullptr) {\n            return false;\n        }\n        // 节点值不相等，不对称\n        if(p->val != q->val) {\n            return false;\n        }\n        // 递归检查左子树的左子树与右子树的右子树，以及左子树的右子树与右子树的左子树\n        return check(p->left, q->right) && check(p->right, q->left);\n    }\n    bool issymmetric(treenode* root) {\n        return check(root, root);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n复杂度分析\n\n假设树上一共 n 个节点。\n\n * 时间复杂度：这里遍历了这棵树，渐进时间复杂度为 o(n)。\n * 空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 o(n)。\n\n\n# 方法二：迭代\n\n基本思路是使用队列，将每一层的节点按照对称的顺序加入队列，然后依次比较队列中的节点是否对称。每次从队列中取出两个节点进行比较，并按照对称的顺序将它们的子节点加入队列。**要注意的是根节点要加入队列两次。**当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。\n\nclass solution {\npublic:\n  \tbool check(treenode *u, treenode *v) {\n        queue<treenode*> q;\n        q.push(u); q.push(v);\n        while(!q.empty()) {\n            u = q.front(); q.pop();\n            v = q.front(); q.pop();\n            if(!u && !v) continue;\n            if((!u || !v) || u->val != v->val)) return false;\n            q.push(u->left);\n            q.push(v->right);\n            q.push(u->right);\n            q.push(v->left);\n        }\n        return true;\n    }\n    bool issymmetric(treenode *root) {\n        return check(root, root);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，同「方法一」。\n\n * 空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 o(n)。",charsets:{cjk:!0}},{title:"二叉树的最大深度",frontmatter:{title:"二叉树的最大深度",date:"2023-12-01T17:16:20.000Z",permalink:"/pages/cfaacb/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html",relativePath:"02.计算机基础/04.算法/104. 二叉树的最大深度.md",key:"v-10241104",path:"/pages/cfaacb/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:20},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:88},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:252},{level:3,title:"方法一：深度优先搜索",slug:"方法一-深度优先搜索",normalizedTitle:"方法一：深度优先搜索",charIndex:260},{level:3,title:"方法二：广度优先遍历",slug:"方法二-广度优先遍历",normalizedTitle:"方法二：广度优先遍历",charIndex:1850}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.565,time:93899.99999999999,words:313},headersStr:"题目： 示例： 解题： 方法一：深度优先搜索 方法二：广度优先遍历",content:'# 104. 二叉树的最大深度\n\n\n# 题目：\n\n给定一个二叉树 root ，返回其最大深度。\n\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：root = [3,9,20,null,null,15,7]\n输出：3\n\n\n1\n2\n\n\n示例 2：\n\n输入：root = [1,null,2]\n输出：2\n\n\n1\n2\n\n\n提示：\n\n * 树中节点的数量在 [0, 104] 区间内。\n * -100 <= Node.val <= 100\n\n\n# 解题：\n\n\n# 方法一：深度优先搜索\n\n如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1\n\n而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。\n\n一定要理解其中的过程才用这种方法！\n\nclass Solution {\npublic:\n\tint maxDepth(TreeNode* root) {\n        if(root == nullptr) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可调试的代码\n\n#include <iostream>\n#include <algorithm>\n\n// 二叉树节点定义\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n\tint maxDepth(TreeNode* root) {\n        if(root == nullptr) return 0;\n        return std::max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n}\n\nint main() {\n    // 创建一棵示例二叉树\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(9);\n    root->right = new TreeNode(20);\n    root->right->left = new TreeNode(15);\n    root->right->right = new TreeNode(7);\n\n    // 创建 Solution 对象\n    Solution solution;\n    // 计算二叉树的最大深度\n    int depth = solution.maxDepth(root);\n    // 输出结果\n    std::cout << "二叉树的最大深度: " << depth << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n\n * 空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n\n# 方法二：广度优先遍历\n\n使用广度优先搜索（BFS）解决这个问题的思路是通过层次遍历二叉树，每一层结束后深度加 1，直到遍历到最后一层。\n\n 1. 初始化： 创建一个队列 Q 用于层次遍历，将根节点入队，同时初始化深度 ans 为 0。\n\n 2. 循环： 使用一个外层循环，不断处理队列中的节点，每个外层循环代表一层的遍历。\n    \n    * a. 在外层循环开始前，通过 int sz = Q.size(); 记录当前队列的大小，即当前层的节点数。\n    \n    * b. 使用一个内层循环，将当前层的节点逐个出队，同时将它们的左右子节点（如果存在）入队。\n    \n    * c. 在内层循环结束后，通过 sz -= 1; 将当前层的节点数减 1，直到当前层的节点全部处理完。\n    \n    * d. 在外层循环结束后，通过 ans += 1; 将深度加 1，表示已经处理完一层。\n\n 3. 返回结果： 最终返回深度 ans。\n\n这样，通过层次遍历，每次处理完一层的节点后深度加 1，直到遍历到最后一层，就能得到整个二叉树的最大深度。\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        queue<TreeNode*> Q;\n        Q.push(root);\n        int ans = 0;\n        while (!Q.empty()) {\n            int sz = Q.size();\n            while (sz > 0) {\n                TreeNode* node = Q.front();Q.pop();\n                if (node->left) Q.push(node->left);\n                if (node->right) Q.push(node->right);\n                sz -= 1;\n            }\n            ans += 1;\n        } \n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。\n\n * 空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。',normalizedContent:'# 104. 二叉树的最大深度\n\n\n# 题目：\n\n给定一个二叉树 root ，返回其最大深度。\n\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：root = [3,9,20,null,null,15,7]\n输出：3\n\n\n1\n2\n\n\n示例 2：\n\n输入：root = [1,null,2]\n输出：2\n\n\n1\n2\n\n\n提示：\n\n * 树中节点的数量在 [0, 104] 区间内。\n * -100 <= node.val <= 100\n\n\n# 解题：\n\n\n# 方法一：深度优先搜索\n\n如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1\n\n而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 o(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。\n\n一定要理解其中的过程才用这种方法！\n\nclass solution {\npublic:\n\tint maxdepth(treenode* root) {\n        if(root == nullptr) return 0;\n        return max(maxdepth(root->left), maxdepth(root->right)) + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可调试的代码\n\n#include <iostream>\n#include <algorithm>\n\n// 二叉树节点定义\nstruct treenode {\n    int val;\n    treenode *left;\n    treenode *right;\n    treenode() : val(0), left(nullptr), right(nullptr) {}\n    treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n    treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n};\n\nclass solution {\npublic:\n\tint maxdepth(treenode* root) {\n        if(root == nullptr) return 0;\n        return std::max(maxdepth(root->left), maxdepth(root->right)) + 1;\n    }\n}\n\nint main() {\n    // 创建一棵示例二叉树\n    treenode* root = new treenode(3);\n    root->left = new treenode(9);\n    root->right = new treenode(20);\n    root->right->left = new treenode(15);\n    root->right->right = new treenode(7);\n\n    // 创建 solution 对象\n    solution solution;\n    // 计算二叉树的最大深度\n    int depth = solution.maxdepth(root);\n    // 输出结果\n    std::cout << "二叉树的最大深度: " << depth << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n\n * 空间复杂度：o(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n\n# 方法二：广度优先遍历\n\n使用广度优先搜索（bfs）解决这个问题的思路是通过层次遍历二叉树，每一层结束后深度加 1，直到遍历到最后一层。\n\n 1. 初始化： 创建一个队列 q 用于层次遍历，将根节点入队，同时初始化深度 ans 为 0。\n\n 2. 循环： 使用一个外层循环，不断处理队列中的节点，每个外层循环代表一层的遍历。\n    \n    * a. 在外层循环开始前，通过 int sz = q.size(); 记录当前队列的大小，即当前层的节点数。\n    \n    * b. 使用一个内层循环，将当前层的节点逐个出队，同时将它们的左右子节点（如果存在）入队。\n    \n    * c. 在内层循环结束后，通过 sz -= 1; 将当前层的节点数减 1，直到当前层的节点全部处理完。\n    \n    * d. 在外层循环结束后，通过 ans += 1; 将深度加 1，表示已经处理完一层。\n\n 3. 返回结果： 最终返回深度 ans。\n\n这样，通过层次遍历，每次处理完一层的节点后深度加 1，直到遍历到最后一层，就能得到整个二叉树的最大深度。\n\nclass solution {\npublic:\n    int maxdepth(treenode* root) {\n        if (root == nullptr) return 0;\n        queue<treenode*> q;\n        q.push(root);\n        int ans = 0;\n        while (!q.empty()) {\n            int sz = q.size();\n            while (sz > 0) {\n                treenode* node = q.front();q.pop();\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n                sz -= 1;\n            }\n            ans += 1;\n        } \n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。\n\n * 空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 o(n)。',charsets:{cjk:!0}},{title:"LCR寻找文件副本",frontmatter:{title:"LCR寻找文件副本",date:"2023-12-15T09:55:58.000Z",permalink:"/pages/5b2b9b/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/120.%20LCR%E5%AF%BB%E6%89%BE%E6%96%87%E4%BB%B6%E5%89%AF%E6%9C%AC.html",relativePath:"02.计算机基础/04.算法/120. LCR寻找文件副本.md",key:"v-4624b883",path:"/pages/5b2b9b/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:22},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:105},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:223},{level:3,title:"方法一：哈希表",slug:"方法一-哈希表",normalizedTitle:"方法一：哈希表",charIndex:231}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.13,time:67800,words:226},headersStr:"题目： 示例： 解题： 方法一：哈希表",content:'# LCR 120. 寻找文件副本\n\n\n# 题目：\n\n设备中存有 n 个文件，文件 id 记于数组 documents。若文件 id 相同，则定义为该文件存在副本。请返回 任一存在 副本的文件 id。\n\n\n# 示例：\n\n示例 1：\n\n输入：documents = [2, 5, 3, 0, 5, 0]\n输出：0 或 5\n\n\n1\n2\n\n\n提示：\n\n * 0 ≤ documents[i] ≤ n-1\n * 2 <= n <= 100000\n\n\n# 解题：\n\n\n# 方法一：哈希表\n\n利用数据结构特点，容易想到使用哈希表（Map）记录数组的各个数字，当查找到重复数字则直接返回。\n\n==注意：题目是返回任一，也就是返回其中一个就行==\n\n算法流程：\n\n 1. 初始化： 新建 HashMap ，记为 hmap ；\n 2. 遍历数组 documents 中的每个数字 doc ：\n    * 当 doc 在 hmap 中，说明重复，直接返回 doc；\n    * 将 doc 添加至 hmap 中；\n 3. 返回 −1。本题中一定有重复数字，因此这里返回多少都可以。\n\nclass Solution {\npublic:\n    int findRepeatDocument(vector<int>& documents) {\n        unordered_map<int, bool> hmap;\n        for(int doc: documents) {\n          if(hmap[doc]) return doc;\n          hmap[doc] = true;\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复杂度分析：\n\n * 时间复杂度 O(N) ： 遍历数组使用 O(N) ，HashMap 添加与查找元素皆为 O(1) 。\n * 空间复杂度 O(N) ： HashMap 占用 O(N) 大小的额外空间。\n\n可调试的代码：\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findRepeatDocument(vector<int>& documents) {\n        unordered_map<int, bool> hmap;\n        for (int doc : documents) {\n            if (hmap[doc]) return doc;\n            hmap[doc] = true;\n        }\n        return -1;\n    }\n};\n\nint main() {\n    // 示例用法\n    vector<int> documents = { 1, 2, 3, 1, 5, 2 }; // 包含文件 ID 1、2 的副本\n    Solution solution;\n    int duplicateID = solution.findRepeatDocument(documents);\n\n    if (duplicateID != -1) {\n        cout << "存在副本的文件 ID 是: " << duplicateID << endl;\n    }\n    else {\n        cout << "未找到存在副本的文件 ID" << endl;\n    }\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',normalizedContent:'# lcr 120. 寻找文件副本\n\n\n# 题目：\n\n设备中存有 n 个文件，文件 id 记于数组 documents。若文件 id 相同，则定义为该文件存在副本。请返回 任一存在 副本的文件 id。\n\n\n# 示例：\n\n示例 1：\n\n输入：documents = [2, 5, 3, 0, 5, 0]\n输出：0 或 5\n\n\n1\n2\n\n\n提示：\n\n * 0 ≤ documents[i] ≤ n-1\n * 2 <= n <= 100000\n\n\n# 解题：\n\n\n# 方法一：哈希表\n\n利用数据结构特点，容易想到使用哈希表（map）记录数组的各个数字，当查找到重复数字则直接返回。\n\n==注意：题目是返回任一，也就是返回其中一个就行==\n\n算法流程：\n\n 1. 初始化： 新建 hashmap ，记为 hmap ；\n 2. 遍历数组 documents 中的每个数字 doc ：\n    * 当 doc 在 hmap 中，说明重复，直接返回 doc；\n    * 将 doc 添加至 hmap 中；\n 3. 返回 −1。本题中一定有重复数字，因此这里返回多少都可以。\n\nclass solution {\npublic:\n    int findrepeatdocument(vector<int>& documents) {\n        unordered_map<int, bool> hmap;\n        for(int doc: documents) {\n          if(hmap[doc]) return doc;\n          hmap[doc] = true;\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复杂度分析：\n\n * 时间复杂度 o(n) ： 遍历数组使用 o(n) ，hashmap 添加与查找元素皆为 o(1) 。\n * 空间复杂度 o(n) ： hashmap 占用 o(n) 大小的额外空间。\n\n可调试的代码：\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass solution {\npublic:\n    int findrepeatdocument(vector<int>& documents) {\n        unordered_map<int, bool> hmap;\n        for (int doc : documents) {\n            if (hmap[doc]) return doc;\n            hmap[doc] = true;\n        }\n        return -1;\n    }\n};\n\nint main() {\n    // 示例用法\n    vector<int> documents = { 1, 2, 3, 1, 5, 2 }; // 包含文件 id 1、2 的副本\n    solution solution;\n    int duplicateid = solution.findrepeatdocument(documents);\n\n    if (duplicateid != -1) {\n        cout << "存在副本的文件 id 是: " << duplicateid << endl;\n    }\n    else {\n        cout << "未找到存在副本的文件 id" << endl;\n    }\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n',charsets:{cjk:!0}},{title:"买卖股票的最佳时机",frontmatter:{title:"买卖股票的最佳时机",date:"2023-12-07T14:10:51.000Z",permalink:"/pages/4e735a/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html",relativePath:"02.计算机基础/04.算法/121. 买卖股票的最佳时机.md",key:"v-1ad60d6d",path:"/pages/4e735a/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:21},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:184},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:487},{level:3,title:"方法一：一次循环贪心法",slug:"方法一-一次循环贪心法",normalizedTitle:"方法一：一次循环贪心法",charIndex:495}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.85,time:51e3,words:170},headersStr:"题目： 示例： 解题： 方法一：一次循环贪心法",content:"# 121. 买卖股票的最佳时机\n\n\n# 题目：\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n\n# 示例：\n\n示例 1：\n\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n\n1\n2\n3\n4\n\n\n示例 2：\n\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 \n\n\n1\n2\n3\n\n\n提示：\n\n * 1 <= prices.length <= 105\n * 0 <= prices[i] <= 104\n\n\n# 解题：\n\n\n# 方法一：一次循环贪心法\n\n解题思路：\n\n 1. 初始化变量： 使用 inf（正无穷大的常量）初始化 minprice，表示遍历过程中的最小价格，同时初始化 maxprofit 为 0，表示卖出股票时的最大利润。\n\n 2. 遍历数组： 对于每一天的股票价格，进行以下操作：\n    \n    * 更新 maxprofit：比较当前价格减去 minprice 得到的利润与之前的 maxprofit，取较大者作为新的 maxprofit。\n    * 更新 minprice：比较当前价格与之前的 minprice，取较小者作为新的 minprice。\n\n 3. 返回结果： 最终返回 maxprofit，即最大利润。\n\n这种方法的核心思想是，在遍历数组的过程中，始终保持 minprice 记录的是当前为止的最小价格，而 maxprofit 记录的是当前为止的最大利润。通过不断更新这两个变量，可以在一次遍历中找到最佳的买入和卖出时机，从而得到最大利润。\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int inf = 1e9;          // 用于表示正无穷大的常量\n        int minprice = inf;      // 记录遍历过程中的最小价格\n        int maxprofit = 0;       // 记录卖出股票时的最大利润\n\n        for (int price: prices) {\n            maxprofit = max(maxprofit, price - minprice);  // 更新最大利润\n            minprice = min(price, minprice);               // 更新最小价格\n        }\n\n        return maxprofit;  // 返回最终的最大利润\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，只需要遍历一次。\n * 空间复杂度：O(1)，只使用了常数个变量。",normalizedContent:"# 121. 买卖股票的最佳时机\n\n\n# 题目：\n\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n\n# 示例：\n\n示例 1：\n\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\n\n1\n2\n3\n4\n\n\n示例 2：\n\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 \n\n\n1\n2\n3\n\n\n提示：\n\n * 1 <= prices.length <= 105\n * 0 <= prices[i] <= 104\n\n\n# 解题：\n\n\n# 方法一：一次循环贪心法\n\n解题思路：\n\n 1. 初始化变量： 使用 inf（正无穷大的常量）初始化 minprice，表示遍历过程中的最小价格，同时初始化 maxprofit 为 0，表示卖出股票时的最大利润。\n\n 2. 遍历数组： 对于每一天的股票价格，进行以下操作：\n    \n    * 更新 maxprofit：比较当前价格减去 minprice 得到的利润与之前的 maxprofit，取较大者作为新的 maxprofit。\n    * 更新 minprice：比较当前价格与之前的 minprice，取较小者作为新的 minprice。\n\n 3. 返回结果： 最终返回 maxprofit，即最大利润。\n\n这种方法的核心思想是，在遍历数组的过程中，始终保持 minprice 记录的是当前为止的最小价格，而 maxprofit 记录的是当前为止的最大利润。通过不断更新这两个变量，可以在一次遍历中找到最佳的买入和卖出时机，从而得到最大利润。\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int inf = 1e9;          // 用于表示正无穷大的常量\n        int minprice = inf;      // 记录遍历过程中的最小价格\n        int maxprofit = 0;       // 记录卖出股票时的最大利润\n\n        for (int price: prices) {\n            maxprofit = max(maxprofit, price - minprice);  // 更新最大利润\n            minprice = min(price, minprice);               // 更新最小价格\n        }\n\n        return maxprofit;  // 返回最终的最大利润\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，只需要遍历一次。\n * 空间复杂度：o(1)，只使用了常数个变量。",charsets:{cjk:!0}},{title:"LCR图书整理 II",frontmatter:{title:"LCR图书整理 II",date:"2023-12-15T09:56:04.000Z",permalink:"/pages/61a107/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/125.%20LCR%E5%9B%BE%E4%B9%A6%E6%95%B4%E7%90%86%20II.html",relativePath:"02.计算机基础/04.算法/125. LCR图书整理 II.md",key:"v-54a29711",path:"/pages/61a107/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:23},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:246},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:607},{level:3,title:"方法一：双栈法",slug:"方法一-双栈法",normalizedTitle:"方法一：双栈法",charIndex:615}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.035,time:62099.99999999999,words:207},headersStr:"题目： 示例： 解题： 方法一：双栈法",content:'# LCR 125. 图书整理 II\n\n\n# 题目：\n\n读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：\n\n * push(bookID)：把借阅的书籍还到图书馆。\n * pop()：从图书馆中借出书籍。\n\n为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 最早 归还到图书馆的书籍。你需要返回 每次读者借出书的值 。\n\n如果没有归还的书可以取出，返回 -1 。\n\n\n# 示例：\n\n示例 1：\n\n输入：\n["BookQueue", "push", "push", "pop"]\n[[], [1], [2], []]\n输出：[null,null,null,1]\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.pop(); // return 1, queue is [2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n提示：\n\n * 1 <= bookID <= 10000\n * 最多会对 push、pop 进行 10000 次调用\n\n\n# 解题：\n\n\n# 方法一：双栈法\n\n将一个栈当作输入栈，用于压入 appendTail 传入的数据；另一个栈当作输出栈，用于 deleteHead 操作。\n\n每次 deleteHead 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\n\n 1. 加入队尾 appendTail() ： 将数字 val 加入栈 A 即可。\n\n 2. 删除队首deleteHead() ： 有以下三种情况。\n    \n    1. 当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。\n    2. 否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1 。\n    3. 否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass CQueue {\nprivate:\n    stack<int> inStack,outStack;\n    void in2out(){\n        while(!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\npublic:\n    CQueue() {\n\n    }\n    \n    void appendTail(int value) {\n        inStack.push(value);\n    }\n    \n    int deleteHead() {\n        if(outStack.empty()) {\n            if(inStack.empty()) {\n                return -1;\n            }\n            in2out();\n        }\n        int value = outStack.top();\n        outStack.pop();\n        return value;\n    }\n};\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue* obj = new CQueue();\n * obj->appendTail(value);\n * int param_2 = obj->deleteHead();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',normalizedContent:'# lcr 125. 图书整理 ii\n\n\n# 题目：\n\n读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：\n\n * push(bookid)：把借阅的书籍还到图书馆。\n * pop()：从图书馆中借出书籍。\n\n为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 最早 归还到图书馆的书籍。你需要返回 每次读者借出书的值 。\n\n如果没有归还的书可以取出，返回 -1 。\n\n\n# 示例：\n\n示例 1：\n\n输入：\n["bookqueue", "push", "push", "pop"]\n[[], [1], [2], []]\n输出：[null,null,null,1]\n解释：\nmyqueue myqueue = new myqueue();\nmyqueue.push(1); // queue is: [1]\nmyqueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyqueue.pop(); // return 1, queue is [2]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n提示：\n\n * 1 <= bookid <= 10000\n * 最多会对 push、pop 进行 10000 次调用\n\n\n# 解题：\n\n\n# 方法一：双栈法\n\n将一个栈当作输入栈，用于压入 appendtail 传入的数据；另一个栈当作输出栈，用于 deletehead 操作。\n\n每次 deletehead 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\n\n 1. 加入队尾 appendtail() ： 将数字 val 加入栈 a 即可。\n\n 2. 删除队首deletehead() ： 有以下三种情况。\n    \n    1. 当栈 b 不为空： b中仍有已完成倒序的元素，因此直接返回 b 的栈顶元素。\n    2. 否则，当 a 为空： 即两个栈都为空，无元素，因此返回 -1 。\n    3. 否则： 将栈 a 元素全部转移至栈 b 中，实现元素倒序，并返回栈 b 的栈顶元素。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass cqueue {\nprivate:\n    stack<int> instack,outstack;\n    void in2out(){\n        while(!instack.empty()) {\n            outstack.push(instack.top());\n            instack.pop();\n        }\n    }\npublic:\n    cqueue() {\n\n    }\n    \n    void appendtail(int value) {\n        instack.push(value);\n    }\n    \n    int deletehead() {\n        if(outstack.empty()) {\n            if(instack.empty()) {\n                return -1;\n            }\n            in2out();\n        }\n        int value = outstack.top();\n        outstack.pop();\n        return value;\n    }\n};\n\n/**\n * your cqueue object will be instantiated and called as such:\n * cqueue* obj = new cqueue();\n * obj->appendtail(value);\n * int param_2 = obj->deletehead();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',charsets:{cjk:!0}},{title:"只出现一次的数字",frontmatter:{title:"只出现一次的数字",date:"2023-11-24T16:30:01.000Z",permalink:"/pages/d2368e/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"02.计算机基础/04.算法/136. 只出现一次的数字.md",key:"v-4eb718aa",path:"/pages/d2368e/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:20},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:130},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:356},{level:3,title:"方法一：集合法",slug:"方法一-集合法",normalizedTitle:"方法一：集合法",charIndex:391},{level:3,title:"方法二：哈希表法",slug:"方法二-哈希表法",normalizedTitle:"方法二：哈希表法",charIndex:988},{level:3,title:"方法三：元素之和两倍性质",slug:"方法三-元素之和两倍性质",normalizedTitle:"方法三：元素之和两倍性质",charIndex:1543},{level:3,title:"方法四：位运算（线性时间复杂度，常数空间复杂度）",slug:"方法四-位运算-线性时间复杂度-常数空间复杂度",normalizedTitle:"方法四：位运算（线性时间复杂度，常数空间复杂度）",charIndex:2303}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.395,time:83700,words:279},headersStr:"题目： 示例： 解题： 方法一：集合法 方法二：哈希表法 方法三：元素之和两倍性质 方法四：位运算（线性时间复杂度，常数空间复杂度）",content:"# 136. 只出现一次的数字\n\n\n# 题目：\n\n给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n\n# 示例：\n\n示例 1 ：\n\n输入：nums = [2,2,1]\n输出：1\n\n\n1\n2\n\n\n示例 2 ：\n\n输入：nums = [4,1,2,1,2]\n输出：4\n\n\n1\n2\n\n\n示例 3 ：\n\n输入：nums = [1]\n输出：1\n\n\n1\n2\n\n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * -3 * 104 <= nums[i] <= 3 * 104\n * 除了某个元素只出现一次以外，其余每个元素均出现两次。\n\n\n# 解题：\n\n如果不考虑时间复杂度和空间复杂度的限制方法有很多：\n\n\n# 方法一：集合法\n\n使用集合unordered_set存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_set<int> numSet;\n        for(int num : nums) {\n            // 如果集合中已经有当前数字，则从集合中删除\n            if(numSet.find(num) != numSet.end()) {\n                numSet.erase(num);\n            } else {\n                // 如果集合中没有当前数字，则加入集合\n                numSet.insert(num);\n            }\n        }\n        // 集合中剩下的就是只出现一次的数字\n        return *numSet.begin();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 方法二：哈希表法\n\n使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_map<int,int> numCount;\n        // 遍历数组，更新哈希表中数字的出现次数\n        for(int num : nums) {\n            numCount[num]++;\n        }\n        // 遍历哈希表，找到只出现一次的数字\n        for(auto& pair : numCount) {\n            if(pair.second == 1) {\n                return pair.first;\n            }\n        }\n        // 如果没有找到只出现一次的数字，返回默认值0\n        return 0;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 方法三：元素之和两倍性质\n\n由于集合保证元素无重复，所以使用集合unordered_set不重复的存储数组的元素，也就是每个元素只存储一次，重复的不存储，计算它们的和，就相当于所有数字的两倍之和。然后将原数组中的元素全部相加，就相当于只出现了一次的元素加上全部出现了两次的元素。如此看来，它们的差就是就差了一个只出现一次的元素了。\n\nclass Solution {\npublic:\n    int singleNUmber(vector<int>& nums) {\n        unordered_set<int> numSet;\n        int sumSet = 0;\n        int sumArray = 0;\n        // 遍历数组，更新集合中的元素之和和数组中的元素之和\n        for(int num : nums) {\n            if(numSet.find(num) == numSet.end()) {\n                numSet.insert(num);\n                sumSet += num;\n            }\n            sumArray += num;\n        }\n        // 计算集合中的元素之和的两倍减去数组中的元素之和，得到只出现一次的数字\n        return 2*sumSet - sumArray;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上述三种解法都需要额外使用 O(n) 的空间，其中 n 是数组长度。\n\n如何才能做到线性时间复杂度和常数空间复杂度呢？\n\n\n# 方法四：位运算（线性时间复杂度，常数空间复杂度）\n\n异或运算有以下三个性质：\n\n 1. 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。\n\n 2. 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。\n\n 3. 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。\n\n\n\n\n\n\n\n假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。\n\n令 a~1~ 、a~2~ 、…、a~m~为出现两次的 m 个数，a~m+1~为出现一次的数。\n\n根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：\n\n * (a~1~⊕a~1~)⊕(a~2~⊕a~2~)⊕⋯⊕(a~m~⊕a~m~)⊕a~m+1~\n\n根据性质 2 和性质 1，上式可化简和计算得到如下结果：\n\n * 0⊕0⊕⋯⊕0⊕a~m+1~=a~m+1~\n\n因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ret = 0;\n        for(auto e : nums) ret ^= e;\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。\n * 空间复杂度：O(1)。",normalizedContent:"# 136. 只出现一次的数字\n\n\n# 题目：\n\n给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n\n# 示例：\n\n示例 1 ：\n\n输入：nums = [2,2,1]\n输出：1\n\n\n1\n2\n\n\n示例 2 ：\n\n输入：nums = [4,1,2,1,2]\n输出：4\n\n\n1\n2\n\n\n示例 3 ：\n\n输入：nums = [1]\n输出：1\n\n\n1\n2\n\n\n提示：\n\n * 1 <= nums.length <= 3 * 104\n * -3 * 104 <= nums[i] <= 3 * 104\n * 除了某个元素只出现一次以外，其余每个元素均出现两次。\n\n\n# 解题：\n\n如果不考虑时间复杂度和空间复杂度的限制方法有很多：\n\n\n# 方法一：集合法\n\n使用集合unordered_set存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。\n\nclass solution {\npublic:\n    int singlenumber(vector<int>& nums) {\n        unordered_set<int> numset;\n        for(int num : nums) {\n            // 如果集合中已经有当前数字，则从集合中删除\n            if(numset.find(num) != numset.end()) {\n                numset.erase(num);\n            } else {\n                // 如果集合中没有当前数字，则加入集合\n                numset.insert(num);\n            }\n        }\n        // 集合中剩下的就是只出现一次的数字\n        return *numset.begin();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 方法二：哈希表法\n\n使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。\n\nclass solution {\npublic:\n    int singlenumber(vector<int>& nums) {\n        unordered_map<int,int> numcount;\n        // 遍历数组，更新哈希表中数字的出现次数\n        for(int num : nums) {\n            numcount[num]++;\n        }\n        // 遍历哈希表，找到只出现一次的数字\n        for(auto& pair : numcount) {\n            if(pair.second == 1) {\n                return pair.first;\n            }\n        }\n        // 如果没有找到只出现一次的数字，返回默认值0\n        return 0;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 方法三：元素之和两倍性质\n\n由于集合保证元素无重复，所以使用集合unordered_set不重复的存储数组的元素，也就是每个元素只存储一次，重复的不存储，计算它们的和，就相当于所有数字的两倍之和。然后将原数组中的元素全部相加，就相当于只出现了一次的元素加上全部出现了两次的元素。如此看来，它们的差就是就差了一个只出现一次的元素了。\n\nclass solution {\npublic:\n    int singlenumber(vector<int>& nums) {\n        unordered_set<int> numset;\n        int sumset = 0;\n        int sumarray = 0;\n        // 遍历数组，更新集合中的元素之和和数组中的元素之和\n        for(int num : nums) {\n            if(numset.find(num) == numset.end()) {\n                numset.insert(num);\n                sumset += num;\n            }\n            sumarray += num;\n        }\n        // 计算集合中的元素之和的两倍减去数组中的元素之和，得到只出现一次的数字\n        return 2*sumset - sumarray;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上述三种解法都需要额外使用 o(n) 的空间，其中 n 是数组长度。\n\n如何才能做到线性时间复杂度和常数空间复杂度呢？\n\n\n# 方法四：位运算（线性时间复杂度，常数空间复杂度）\n\n异或运算有以下三个性质：\n\n 1. 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。\n\n 2. 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。\n\n 3. 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。\n\n\n\n\n\n\n\n假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。\n\n令 a~1~ 、a~2~ 、…、a~m~为出现两次的 m 个数，a~m+1~为出现一次的数。\n\n根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：\n\n * (a~1~⊕a~1~)⊕(a~2~⊕a~2~)⊕⋯⊕(a~m~⊕a~m~)⊕a~m+1~\n\n根据性质 2 和性质 1，上式可化简和计算得到如下结果：\n\n * 0⊕0⊕⋯⊕0⊕a~m+1~=a~m+1~\n\n因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。\n\nclass solution {\npublic:\n    int singlenumber(vector<int>& nums) {\n        int ret = 0;\n        for(auto e : nums) ret ^= e;\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是数组长度。只需要对数组遍历一次。\n * 空间复杂度：o(1)。",charsets:{cjk:!0}},{title:"最长公共前缀",frontmatter:{title:"最长公共前缀",date:"2023-12-07T14:10:43.000Z",permalink:"/pages/d52abe/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html",relativePath:"02.计算机基础/04.算法/14. 最长公共前缀.md",key:"v-8c26678c",path:"/pages/d52abe/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:17},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:72},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:296},{level:3,title:"方法一：字符串排序",slug:"方法一-字符串排序",normalizedTitle:"方法一：字符串排序",charIndex:304}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.335,time:80100,words:267},headersStr:"题目： 示例： 解题： 方法一：字符串排序",content:'# 14. 最长公共前缀\n\n\n# 题目：\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 ""。\n\n\n# 示例：\n\n示例 1：\n\n输入：strs = ["flower","flow","flight"]\n输出："fl"\n\n\n1\n2\n\n\n示例 2：\n\n输入：strs = ["dog","racecar","car"]\n输出：""\n解释：输入不存在公共前缀。\n\n\n1\n2\n3\n\n\n提示：\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] 仅由小写英文字母组成\n\n\n# 解题：\n\n\n# 方法一：字符串排序\n\n通过排序，将字符串数组中的相似字符串放在一起，使得最长公共前缀出现在排序后的第一个字符串和最后一个字符串之间。然后通过比较这两个字符串找出最长公共前缀。这样的实现在一些情况下可以提高效率，尤其是当字符串数组中的字符串较长时。\n\n这种实现方法的思路可以总结为以下几步：\n\n 1. **处理边界情况：**首先检查输入的字符串数组是否为空，如果为空，直接返回空字符串，因为在空数组中不存在公共前缀。\n\n 2. **对字符串数组排序：**使用 std::sort 对字符串数组进行排序，这样数组中的字符串就按照字典序排列。\n\n 3. **比较排序后的首尾字符串：**取排序后的数组的第一个字符串为 first_str，最后一个字符串为 last_str。\n\n 4. **寻找最长公共前缀：**通过比较 first_str 和 last_str 的每个字符，逐个检查它们是否相等，直到遇到不相等的字符或者其中一个字符串结束。在这个过程中，将相等的字符逐个添加到 common_prefix 中。\n\n 5. **返回结果：**最终返回得到的 common_prefix，即为排序后的字符串数组中的最长公共前缀。\n\n这种方法的优势在于通过排序的方式，将相似的字符串靠在一起，从而简化了寻找最长公共前缀的过程。不过需要注意，这种方法可能在某些情况下效率较高，但在某些情况下排序的开销可能会比水平扫描法更大。选择适当的方法取决于具体的应用场景和输入数据的特点。\n\nclass Solution {\npublic:\n    std::string longestCommonPrefix(std::vector<std::string>& strs) {\n        if (strs.empty()) {\n            return "";\n        }\n        std::sort(strs.begin(), strs.end());\n        std::string first_str = strs[0];\n        std::string last_str = strs[strs.size() - 1];\n        std::string common_prefix = "";\n        int i = 0;\n        while (i < first_str.size() && i < last_str.size() && first_str[i] == last_str[i]) {\n            common_prefix += first_str[i];\n            i++;\n        }\n        return common_prefix;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n可调试的代码\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::string longestCommonPrefix(std::vector<std::string>& strs) {\n        if (strs.empty()) {\n            return "";\n        }\n        std::sort(strs.begin(), strs.end());\n        std::string first_str = strs[0];\n        std::string last_str = strs[strs.size() - 1];\n        std::string common_prefix = "";\n        int i = 0;\n        while (i < first_str.size() && i < last_str.size() && first_str[i] == last_str[i]) {\n            common_prefix += first_str[i];\n            i++;\n        }\n        return common_prefix;\n    }\n};\n\nint main() {\n    // 示例输入\n    std::vector<std::string> strs = {"flower", "flow", "flight"};\n    // 创建 Solution 对象\n    Solution solution;\n    // 查找最长公共前缀\n    std::string result = solution.longestCommonPrefix(strs);\n    // 输出结果\n    std::cout << "最长公共前缀: " << result << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n复杂度分析\n\n * 时间复杂度：\n   * 排序字符串数组的时间复杂度为 O(nlog~n~)，其中 n 是字符串数组的长度。\n   * 找到最长公共前缀的过程需要遍历排序后的首尾字符串，最坏情况下需要 O(m) 次比较，其中 m 是最长公共前缀的长度。\n\n综合起来，排序的时间复杂度是主导因素，因此整体的时间复杂度为 O(nlog~n~)。\n\n * 空间复杂度：\n   * 除了输入和输出之外，额外使用了一些常量级的空间，比如 first_str、last_str、common_prefix 以及一些循环变量。这些空间的使用与输入规模无关，可以看作是常数级别的。\n   * 如果忽略常数级别的空间，整体空间复杂度为 O(1)。\n\n综合起来，这个算法的时间复杂度为 O(nlog~n~)，空间复杂度为 O(1)。\n\n其他解法 LeetCode 也很详细\n\n14. 最长公共前缀 - 力扣（LeetCode）',normalizedContent:'# 14. 最长公共前缀\n\n\n# 题目：\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 ""。\n\n\n# 示例：\n\n示例 1：\n\n输入：strs = ["flower","flow","flight"]\n输出："fl"\n\n\n1\n2\n\n\n示例 2：\n\n输入：strs = ["dog","racecar","car"]\n输出：""\n解释：输入不存在公共前缀。\n\n\n1\n2\n3\n\n\n提示：\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] 仅由小写英文字母组成\n\n\n# 解题：\n\n\n# 方法一：字符串排序\n\n通过排序，将字符串数组中的相似字符串放在一起，使得最长公共前缀出现在排序后的第一个字符串和最后一个字符串之间。然后通过比较这两个字符串找出最长公共前缀。这样的实现在一些情况下可以提高效率，尤其是当字符串数组中的字符串较长时。\n\n这种实现方法的思路可以总结为以下几步：\n\n 1. **处理边界情况：**首先检查输入的字符串数组是否为空，如果为空，直接返回空字符串，因为在空数组中不存在公共前缀。\n\n 2. **对字符串数组排序：**使用 std::sort 对字符串数组进行排序，这样数组中的字符串就按照字典序排列。\n\n 3. **比较排序后的首尾字符串：**取排序后的数组的第一个字符串为 first_str，最后一个字符串为 last_str。\n\n 4. **寻找最长公共前缀：**通过比较 first_str 和 last_str 的每个字符，逐个检查它们是否相等，直到遇到不相等的字符或者其中一个字符串结束。在这个过程中，将相等的字符逐个添加到 common_prefix 中。\n\n 5. **返回结果：**最终返回得到的 common_prefix，即为排序后的字符串数组中的最长公共前缀。\n\n这种方法的优势在于通过排序的方式，将相似的字符串靠在一起，从而简化了寻找最长公共前缀的过程。不过需要注意，这种方法可能在某些情况下效率较高，但在某些情况下排序的开销可能会比水平扫描法更大。选择适当的方法取决于具体的应用场景和输入数据的特点。\n\nclass solution {\npublic:\n    std::string longestcommonprefix(std::vector<std::string>& strs) {\n        if (strs.empty()) {\n            return "";\n        }\n        std::sort(strs.begin(), strs.end());\n        std::string first_str = strs[0];\n        std::string last_str = strs[strs.size() - 1];\n        std::string common_prefix = "";\n        int i = 0;\n        while (i < first_str.size() && i < last_str.size() && first_str[i] == last_str[i]) {\n            common_prefix += first_str[i];\n            i++;\n        }\n        return common_prefix;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n可调试的代码\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nclass solution {\npublic:\n    std::string longestcommonprefix(std::vector<std::string>& strs) {\n        if (strs.empty()) {\n            return "";\n        }\n        std::sort(strs.begin(), strs.end());\n        std::string first_str = strs[0];\n        std::string last_str = strs[strs.size() - 1];\n        std::string common_prefix = "";\n        int i = 0;\n        while (i < first_str.size() && i < last_str.size() && first_str[i] == last_str[i]) {\n            common_prefix += first_str[i];\n            i++;\n        }\n        return common_prefix;\n    }\n};\n\nint main() {\n    // 示例输入\n    std::vector<std::string> strs = {"flower", "flow", "flight"};\n    // 创建 solution 对象\n    solution solution;\n    // 查找最长公共前缀\n    std::string result = solution.longestcommonprefix(strs);\n    // 输出结果\n    std::cout << "最长公共前缀: " << result << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n复杂度分析\n\n * 时间复杂度：\n   * 排序字符串数组的时间复杂度为 o(nlog~n~)，其中 n 是字符串数组的长度。\n   * 找到最长公共前缀的过程需要遍历排序后的首尾字符串，最坏情况下需要 o(m) 次比较，其中 m 是最长公共前缀的长度。\n\n综合起来，排序的时间复杂度是主导因素，因此整体的时间复杂度为 o(nlog~n~)。\n\n * 空间复杂度：\n   * 除了输入和输出之外，额外使用了一些常量级的空间，比如 first_str、last_str、common_prefix 以及一些循环变量。这些空间的使用与输入规模无关，可以看作是常数级别的。\n   * 如果忽略常数级别的空间，整体空间复杂度为 o(1)。\n\n综合起来，这个算法的时间复杂度为 o(nlog~n~)，空间复杂度为 o(1)。\n\n其他解法 leetcode 也很详细\n\n14. 最长公共前缀 - 力扣（leetcode）',charsets:{cjk:!0}},{title:"LCR 训练计划 II",frontmatter:{title:"LCR 训练计划 II",date:"2023-12-15T09:56:09.000Z",permalink:"/pages/4806d9/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/140.%20LCR%20%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92%20II.html",relativePath:"02.计算机基础/04.算法/140. LCR 训练计划 II.md",key:"v-c8298182",path:"/pages/4806d9/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:23},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:90},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:230},{level:3,title:"方法一：双指针法",slug:"方法一-双指针法",normalizedTitle:"方法一：双指针法",charIndex:238}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.085,time:65099.99999999999,words:217},headersStr:"题目： 示例： 解题： 方法一：双指针法",content:"# LCR 140. 训练计划 II\n\n\n# 题目：\n\n给定一个头节点为 head 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 cnt 个训练项目编号。\n\n\n# 示例：\n\n示例 1：\n\n输入：head = [2,4,7,8], cnt = 1\n输出：8\n\n\n1\n2\n\n\n提示：\n\n * 1 <= head.length <= 100\n * 0 <= head[i] <= 100\n * 1 <= cnt <= head.length\n\n\n# 解题：\n\n\n# 方法一：双指针法\n\n 1. 初始化： 前指针 first 、后指针 last，双指针都指向头节点 head 。\n\n 2. 构建双指针距离： 前指针 first 先向前走 cnt 步（结束后，双指针 first 和 last 间相距 cnt 步）。\n\n 3. 双指针共同移动： 循环中，双指针 first 和 last 每轮都向前走一步，直至 first 走过链表 尾节点 时跳出（跳出后，last 与尾节点距离为 cnt−1 ，即 last 指向倒数第 cnt 个节点）。\n\n 4. 返回值： 返回 last 即可。\n\n\n\n\n\nclass Solution {\npublic:\n    ListNode* trainingPlan(ListNode* head, int cnt) {\n        ListNode* first = head, *last = head;\n        for(int i = 0; i < cnt; ++i)\n            first = first->next;\n        while(first != nullptr) {\n            first = first->next;\n            last = last->next;\n        }\n        return last;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n本题没有 cnt > 链表长度的测试样例 ，因此不用考虑越界。考虑越界问题的代码如下：\n\nclass Solution {\npublic:\n    ListNode* trainingPlan(ListNode* head, int cnt) {\n        ListNode *former = head, *latter = head;\n        for(int i = 0; i < cnt; i++) {\n            if(former == nullptr) return nullptr;\n            former = former->next;\n        }\n        while(former != nullptr) {\n            former = former->next;\n            latter = latter->next;\n        }\n        return latter;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n复杂度分析：\n\n * 时间复杂度 O(n) ： n 为链表长度；总体看，first 走了 n 步，last走了 (−cnt) 步。\n * 空间复杂度 O(1) ： 双指针 first , last 使用常数大小的额外空间。",normalizedContent:"# lcr 140. 训练计划 ii\n\n\n# 题目：\n\n给定一个头节点为 head 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 cnt 个训练项目编号。\n\n\n# 示例：\n\n示例 1：\n\n输入：head = [2,4,7,8], cnt = 1\n输出：8\n\n\n1\n2\n\n\n提示：\n\n * 1 <= head.length <= 100\n * 0 <= head[i] <= 100\n * 1 <= cnt <= head.length\n\n\n# 解题：\n\n\n# 方法一：双指针法\n\n 1. 初始化： 前指针 first 、后指针 last，双指针都指向头节点 head 。\n\n 2. 构建双指针距离： 前指针 first 先向前走 cnt 步（结束后，双指针 first 和 last 间相距 cnt 步）。\n\n 3. 双指针共同移动： 循环中，双指针 first 和 last 每轮都向前走一步，直至 first 走过链表 尾节点 时跳出（跳出后，last 与尾节点距离为 cnt−1 ，即 last 指向倒数第 cnt 个节点）。\n\n 4. 返回值： 返回 last 即可。\n\n\n\n\n\nclass solution {\npublic:\n    listnode* trainingplan(listnode* head, int cnt) {\n        listnode* first = head, *last = head;\n        for(int i = 0; i < cnt; ++i)\n            first = first->next;\n        while(first != nullptr) {\n            first = first->next;\n            last = last->next;\n        }\n        return last;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n本题没有 cnt > 链表长度的测试样例 ，因此不用考虑越界。考虑越界问题的代码如下：\n\nclass solution {\npublic:\n    listnode* trainingplan(listnode* head, int cnt) {\n        listnode *former = head, *latter = head;\n        for(int i = 0; i < cnt; i++) {\n            if(former == nullptr) return nullptr;\n            former = former->next;\n        }\n        while(former != nullptr) {\n            former = former->next;\n            latter = latter->next;\n        }\n        return latter;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n复杂度分析：\n\n * 时间复杂度 o(n) ： n 为链表长度；总体看，first 走了 n 步，last走了 (−cnt) 步。\n * 空间复杂度 o(1) ： 双指针 first , last 使用常数大小的额外空间。",charsets:{cjk:!0}},{title:"环形链表",frontmatter:{title:"环形链表",date:"2023-12-05T16:26:49.000Z",permalink:"/pages/6ac024/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html",relativePath:"02.计算机基础/04.算法/141. 环形链表.md",key:"v-f015cfe8",path:"/pages/6ac024/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:16},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:218},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:563},{level:3,title:"方法一：哈希表法",slug:"方法一-哈希表法",normalizedTitle:"方法一：哈希表法",charIndex:571},{level:3,title:"方法二：快慢指针",slug:"方法二-快慢指针",normalizedTitle:"方法二：快慢指针",charIndex:1181}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.09,time:65400.00000000001,words:218},headersStr:"题目： 示例： 解题： 方法一：哈希表法 方法二：快慢指针",content:"# 141. 环形链表\n\n\n# 题目：\n\n给你一个链表的头节点 head ，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n1\n2\n3\n\n\n示例 3：\n\n\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n1\n2\n3\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 104]\n * -105 <= Node.val <= 105\n * pos 为 -1 或者链表中的一个 有效索引 。\n\n**进阶：**你能用 O(1)（即，常量）内存解决此问题吗？\n\n\n# 解题：\n\n\n# 方法一：哈希表法\n\n每次遍历到一个节点时，判断该节点此前是否被访问过。具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        unordered_set<ListNode*> seen;\n        while(head != nullptr) {\n            if(seen.count(head)) {\n                return true;\n            }\n            seen.insert(head);\n            head = head->next;\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n复杂度分析\n\n * 时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。\n\n * 空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。\n\n\n# 方法二：快慢指针\n\n基本思路如下：\n\n 1. 初始化： 使用两个指针，一个称为慢指针（slow），另一个称为快指针（fast）。初始时，它们都指向链表的头节点。\n\n 2. 移动： 在每一步中，慢指针移动一步，而快指针移动两步。这样就形成了一种“龟兔赛跑”的情景。\n\n 3. 判断： 如果链表中不存在环，快指针最终会到达链表的尾部（nullptr），而慢指针也会到达链表的某个节点。如果链表中存在环，快慢指针会在环中的某个位置相遇。\n\n 4. 判断环的起始位置： 如果链表中存在环，相遇后，可以将其中一个指针（例如快指针）重新指向链表头部，然后两个指针以相同的速度每次移动一步。它们的相遇点即为环的起始位置。\n\n快慢指针的关键在于快指针的速度是慢指针的两倍，这样如果存在环，快指针就会“追上”慢指针。这是一种通过相对速度来检测环的有效方法。\n\n这个思路可以应用于多种链表问题，不仅仅是检测环，还可以用于找到链表的中点等。在解决链表问题时，思考是否可以使用快慢指针是一个常用的技巧。\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return false;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        while (slow != fast) {\n            if (fast == nullptr || fast->next == nullptr) {\n                return false;\n            }\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n复杂度分析\n\n * 时间复杂度：O(N)，其中 NNN 是链表中的节点数。\n   \n   * 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。\n   \n   * 当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。\n\n * 空间复杂度：O(1)。我们只使用了两个指针的额外空间。",normalizedContent:"# 141. 环形链表\n\n\n# 题目：\n\n给你一个链表的头节点 head ，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n1\n2\n3\n\n\n示例 3：\n\n\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n1\n2\n3\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 104]\n * -105 <= node.val <= 105\n * pos 为 -1 或者链表中的一个 有效索引 。\n\n**进阶：**你能用 o(1)（即，常量）内存解决此问题吗？\n\n\n# 解题：\n\n\n# 方法一：哈希表法\n\n每次遍历到一个节点时，判断该节点此前是否被访问过。具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。\n\nclass solution {\npublic:\n    bool hascycle(listnode *head) {\n        unordered_set<listnode*> seen;\n        while(head != nullptr) {\n            if(seen.count(head)) {\n                return true;\n            }\n            seen.insert(head);\n            head = head->next;\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。\n\n * 空间复杂度：o(n)，其中 n 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。\n\n\n# 方法二：快慢指针\n\n基本思路如下：\n\n 1. 初始化： 使用两个指针，一个称为慢指针（slow），另一个称为快指针（fast）。初始时，它们都指向链表的头节点。\n\n 2. 移动： 在每一步中，慢指针移动一步，而快指针移动两步。这样就形成了一种“龟兔赛跑”的情景。\n\n 3. 判断： 如果链表中不存在环，快指针最终会到达链表的尾部（nullptr），而慢指针也会到达链表的某个节点。如果链表中存在环，快慢指针会在环中的某个位置相遇。\n\n 4. 判断环的起始位置： 如果链表中存在环，相遇后，可以将其中一个指针（例如快指针）重新指向链表头部，然后两个指针以相同的速度每次移动一步。它们的相遇点即为环的起始位置。\n\n快慢指针的关键在于快指针的速度是慢指针的两倍，这样如果存在环，快指针就会“追上”慢指针。这是一种通过相对速度来检测环的有效方法。\n\n这个思路可以应用于多种链表问题，不仅仅是检测环，还可以用于找到链表的中点等。在解决链表问题时，思考是否可以使用快慢指针是一个常用的技巧。\n\nclass solution {\npublic:\n    bool hascycle(listnode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return false;\n        }\n        listnode* slow = head;\n        listnode* fast = head->next;\n        while (slow != fast) {\n            if (fast == nullptr || fast->next == nullptr) {\n                return false;\n            }\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 nnn 是链表中的节点数。\n   \n   * 当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。\n   \n   * 当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 n 轮。\n\n * 空间复杂度：o(1)。我们只使用了两个指针的额外空间。",charsets:{cjk:!0}},{title:"反转链表",frontmatter:{title:"反转链表",date:"2023-12-01T17:16:24.000Z",permalink:"/pages/7c062a/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html",relativePath:"02.计算机基础/04.算法/206. 反转链表.md",key:"v-1b717988",path:"/pages/7c062a/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:16},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:59},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:298},{level:3,title:"方法一：迭代",slug:"方法一-迭代",normalizedTitle:"方法一：迭代",charIndex:306},{level:3,title:"方法二：递归",slug:"方法二-递归",normalizedTitle:"方法二：递归",charIndex:1183}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.99,time:59400,words:198},headersStr:"题目： 示例： 解题： 方法一：迭代 方法二：递归",content:"# 206. 反转链表\n\n\n# 题目：\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：head = [1,2]\n输出：[2,1]\n\n\n1\n2\n\n\n示例 3：\n\n输入：head = []\n输出：[]\n\n\n1\n2\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 5000]\n * -5000 <= Node.val <= 5000\n\n**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n\n\n# 解题：\n\n\n# 方法一：迭代\n\n\n\n之前链表的头节点是元素 1， 反转之后头结点就是元素 5 ，这里并没有添加或者删除节点，仅仅是改变 next 指针的方向。\n\n思路是：\n\n首先定义一个 cur 指针，指向头结点，再定义一个 pre 指针，初始化为 null。\n\n然后就要开始反转了，首先要把 cur->next 节点用 tmp 指针保存一下，也就是保存一下这个节点。\n\n为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向 pre ，此时已经反转了第一个节点了。\n\n接下来，就是循环走如下代码逻辑了，继续移动 pre 和 cur 指针。\n\n最后，cur 指针已经指向了 null，循环结束，链表也反转完毕了。 此时我们 return pre 指针就可以了，pre 指针就指向了新的头结点。\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* temp; // 保存cur的下一个节点\n        ListNode* cur = head;\n        ListNode* pre = NULL;\n        while(cur) {\n            temp = cur->next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next\n            cur->next = pre; // 翻转操作\n            // 更新pre 和 cur指针\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。\n * 空间复杂度：O(1)。\n\n\n# 方法二：递归\n\n看官方解答吧，这里只贴一下解题代码\n\n206. 反转链表 - 力扣（LeetCode）\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (!head || !head->next) {\n            return head;\n        }\n        ListNode* newHead = reverseList(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return newHead;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。\n\n * 空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。",normalizedContent:"# 206. 反转链表\n\n\n# 题目：\n\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：head = [1,2]\n输出：[2,1]\n\n\n1\n2\n\n\n示例 3：\n\n输入：head = []\n输出：[]\n\n\n1\n2\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 5000]\n * -5000 <= node.val <= 5000\n\n**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n\n\n# 解题：\n\n\n# 方法一：迭代\n\n\n\n之前链表的头节点是元素 1， 反转之后头结点就是元素 5 ，这里并没有添加或者删除节点，仅仅是改变 next 指针的方向。\n\n思路是：\n\n首先定义一个 cur 指针，指向头结点，再定义一个 pre 指针，初始化为 null。\n\n然后就要开始反转了，首先要把 cur->next 节点用 tmp 指针保存一下，也就是保存一下这个节点。\n\n为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向 pre ，此时已经反转了第一个节点了。\n\n接下来，就是循环走如下代码逻辑了，继续移动 pre 和 cur 指针。\n\n最后，cur 指针已经指向了 null，循环结束，链表也反转完毕了。 此时我们 return pre 指针就可以了，pre 指针就指向了新的头结点。\n\nclass solution {\npublic:\n    listnode* reverselist(listnode* head) {\n        listnode* temp; // 保存cur的下一个节点\n        listnode* cur = head;\n        listnode* pre = null;\n        while(cur) {\n            temp = cur->next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next\n            cur->next = pre; // 翻转操作\n            // 更新pre 和 cur指针\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是链表的长度。需要遍历链表一次。\n * 空间复杂度：o(1)。\n\n\n# 方法二：递归\n\n看官方解答吧，这里只贴一下解题代码\n\n206. 反转链表 - 力扣（leetcode）\n\nclass solution {\npublic:\n    listnode* reverselist(listnode* head) {\n        if (!head || !head->next) {\n            return head;\n        }\n        listnode* newhead = reverselist(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return newhead;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。\n\n * 空间复杂度：o(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。",charsets:{cjk:!0}},{title:"翻转二叉树",frontmatter:{title:"翻转二叉树",date:"2023-12-05T16:26:54.000Z",permalink:"/pages/28ad9f/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"02.计算机基础/04.算法/226. 翻转二叉树.md",key:"v-58b77b9c",path:"/pages/28ad9f/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:17},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:61},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:268},{level:2,title:"视频讲解",slug:"视频讲解",normalizedTitle:"视频讲解",charIndex:276}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.48,time:28799.999999999996,words:96},headersStr:"题目： 示例： 解题： 视频讲解",content:"# 226. 翻转二叉树\n\n\n# 题目：\n\n给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：root = [2,1,3]\n输出：[2,3,1]\n\n\n1\n2\n\n\n示例 3：\n\n输入：root = []\n输出：[]\n\n\n1\n2\n\n\n提示：\n\n * 树中节点数目范围在 [0, 100] 内\n * -100 <= Node.val <= 100\n\n\n# 解题：\n\n\n# 视频讲解\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == nullptr) {\n            return nullptr;\n        }\n        TreeNode* left = invertTree(root->left);\n        TreeNode* right = invertTree(root->right);\n        root->left = right;\n        root->right = left;\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n复杂度分析\n\n * 时间复杂度：O(N)，其中 NNN 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。\n\n * 空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(log⁡N)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。",normalizedContent:"# 226. 翻转二叉树\n\n\n# 题目：\n\n给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：root = [2,1,3]\n输出：[2,3,1]\n\n\n1\n2\n\n\n示例 3：\n\n输入：root = []\n输出：[]\n\n\n1\n2\n\n\n提示：\n\n * 树中节点数目范围在 [0, 100] 内\n * -100 <= node.val <= 100\n\n\n# 解题：\n\n\n# 视频讲解\n\nclass solution {\npublic:\n    treenode* inverttree(treenode* root) {\n        if(root == nullptr) {\n            return nullptr;\n        }\n        treenode* left = inverttree(root->left);\n        treenode* right = inverttree(root->right);\n        root->left = right;\n        root->right = left;\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 nnn 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。\n\n * 空间复杂度：o(n)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 o(log⁡n)。而在最坏情况下，树形成链状，空间复杂度为 o(n)。",charsets:{cjk:!0}},{title:"回文链表",frontmatter:{title:"回文链表",date:"2023-11-24T16:30:01.000Z",permalink:"/pages/29ee33/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.html",relativePath:"02.计算机基础/04.算法/234. 回文链表.md",key:"v-9bf9313e",path:"/pages/29ee33/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:16},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:85},{level:2,title:"提示：",slug:"提示",normalizedTitle:"提示：",charIndex:180},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:276},{level:3,title:"方法一：在数组中使用双指针法  时间=空间O(n)",slug:"方法一-在数组中使用双指针法-时间-空间o-n",normalizedTitle:"方法一：在数组中使用双指针法  时间=空间o(n)",charIndex:null},{level:3,title:"方法二：递归  时间=空间=O(n)",slug:"方法二-递归-时间-空间-o-n",normalizedTitle:"方法二：递归  时间=空间=o(n)",charIndex:null}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.38,time:82800,words:276},headersStr:"题目： 示例： 提示： 解题： 方法一：在数组中使用双指针法  时间=空间O(n) 方法二：递归  时间=空间=O(n)",content:"# 234. 回文链表\n\n\n# 题目：\n\n给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：head = [1,2,2,1]\n输出：true\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：head = [1,2]\n输出：false\n\n\n1\n2\n\n\n\n# 提示：\n\n * 链表中节点数目在范围[1, 105] 内\n * 0 <= Node.val <= 9\n\n**进阶：**你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？\n\n\n# 解题：\n\n\n# 方法一：在数组中使用双指针法 时间=空间O(n)\n\n把单链表中的值复制到数组中，然后使用双指针法，一头一尾相向遍历。这需要 O(n) 的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        vector<int> values;\n        while(head != nullptr) {\n            values.emplace_back(head->val);\n            head = head->next;\n        }\n        for(int i = 0, j = (int)values.size() - 1; i < j; ++i,--j) {\n            if(values[i] != values[j]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n复杂度分析：\n\n * 时间复杂度：O(n)，其中 n 指的是链表的元素个数。\n   * 第一步： 遍历链表并将值复制到数组中，O(n)。\n   * 第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。\n   * 总的时间复杂度：O(2n)=O(n)。\n * 空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。\n\n----------------------------------------\n\n\n# 方法二：递归 时间=空间=O(n)\n\n使用递归反向迭代节点，同时使用递归函数外的变量向前迭代，就可以判断链表是否为回文。算法的正确性在于递归处理节点的顺序是相反的，而我们在函数外又记录了一个变量，因此从本质上，我们同时在正向和逆向迭代匹配。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\n    ListNode* frontPointer;\npublic:\n    bool recursivelyCheck(ListNode* currentNode) {\n        if(currentNode != nullptr) {\n            if(!recursivelyCheck(currentNode->next)) {\n                return false;\n            }\n            if(currentNode->val != frontPointer->val) {\n                return false;\n            }\n            frontPointer = frontPointer->next;\n        }\n        return true;\n    }\n    bool isPalindrome(ListNode* head) {\n        frontPointer = head;\n        return recursivelyCheck(head);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 指的是链表的大小。\n * 空间复杂度：O(n)，其中 n 指的是链表的大小。\n\n> 理解计算机是如何运行递归函数的？\n> \n> 我们要理解计算机如何运行递归函数，在一个函数中调用一个函数时，计算机需要在进入被调用函数之前跟踪它在当前函数中的位置（以及任何局部变量的值），通过运行时存放在堆栈中来实现（堆栈帧）。在堆栈中存放好了数据后就可以进入被调用的函数。在完成被调用函数之后，他会弹出堆栈顶部元素，以恢复在进行函数调用之前所在的函数。在进行回文检查之前，递归函数将在堆栈中创建 n 个堆栈帧，计算机会逐个弹出进行处理。所以在使用递归时空间复杂度要考虑堆栈的使用情况。",normalizedContent:"# 234. 回文链表\n\n\n# 题目：\n\n给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：head = [1,2,2,1]\n输出：true\n\n\n1\n2\n\n\n示例 2：\n\n\n\n输入：head = [1,2]\n输出：false\n\n\n1\n2\n\n\n\n# 提示：\n\n * 链表中节点数目在范围[1, 105] 内\n * 0 <= node.val <= 9\n\n**进阶：**你能否用 o(n) 时间复杂度和 o(1) 空间复杂度解决此题？\n\n\n# 解题：\n\n\n# 方法一：在数组中使用双指针法 时间=空间o(n)\n\n把单链表中的值复制到数组中，然后使用双指针法，一头一尾相向遍历。这需要 o(n) 的时间，因为访问每个元素的时间是 o(1)，而有 n 个元素要访问。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    bool ispalindrome(listnode* head) {\n        vector<int> values;\n        while(head != nullptr) {\n            values.emplace_back(head->val);\n            head = head->next;\n        }\n        for(int i = 0, j = (int)values.size() - 1; i < j; ++i,--j) {\n            if(values[i] != values[j]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n复杂度分析：\n\n * 时间复杂度：o(n)，其中 n 指的是链表的元素个数。\n   * 第一步： 遍历链表并将值复制到数组中，o(n)。\n   * 第二步：双指针判断是否为回文，执行了 o(n/2) 次的判断，即 o(n)。\n   * 总的时间复杂度：o(2n)=o(n)。\n * 空间复杂度：o(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。\n\n----------------------------------------\n\n\n# 方法二：递归 时间=空间=o(n)\n\n使用递归反向迭代节点，同时使用递归函数外的变量向前迭代，就可以判断链表是否为回文。算法的正确性在于递归处理节点的顺序是相反的，而我们在函数外又记录了一个变量，因此从本质上，我们同时在正向和逆向迭代匹配。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\n    listnode* frontpointer;\npublic:\n    bool recursivelycheck(listnode* currentnode) {\n        if(currentnode != nullptr) {\n            if(!recursivelycheck(currentnode->next)) {\n                return false;\n            }\n            if(currentnode->val != frontpointer->val) {\n                return false;\n            }\n            frontpointer = frontpointer->next;\n        }\n        return true;\n    }\n    bool ispalindrome(listnode* head) {\n        frontpointer = head;\n        return recursivelycheck(head);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 指的是链表的大小。\n * 空间复杂度：o(n)，其中 n 指的是链表的大小。\n\n> 理解计算机是如何运行递归函数的？\n> \n> 我们要理解计算机如何运行递归函数，在一个函数中调用一个函数时，计算机需要在进入被调用函数之前跟踪它在当前函数中的位置（以及任何局部变量的值），通过运行时存放在堆栈中来实现（堆栈帧）。在堆栈中存放好了数据后就可以进入被调用的函数。在完成被调用函数之后，他会弹出堆栈顶部元素，以恢复在进行函数调用之前所在的函数。在进行回文检查之前，递归函数将在堆栈中创建 n 个堆栈帧，计算机会逐个弹出进行处理。所以在使用递归时空间复杂度要考虑堆栈的使用情况。",charsets:{cjk:!0}},{title:"删除有序数组中的重复项",frontmatter:{title:"删除有序数组中的重复项",date:"2023-12-07T14:09:40.000Z",permalink:"/pages/4c0819/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/26.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html",relativePath:"02.计算机基础/04.算法/26. 删除有序数组中的重复项.md",key:"v-9aa3c6f6",path:"/pages/4c0819/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:22},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:560},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:927},{level:3,title:"方法一：双指针",slug:"方法一-双指针",normalizedTitle:"方法一：双指针",charIndex:935}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.405,time:84300,words:281},headersStr:"题目： 示例： 解题： 方法一：双指针",content:"# 26. 删除有序数组中的重复项\n\n\n# 题目：\n\n给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n\n * 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\n * 返回 k 。\n\n判题标准:\n\n系统会用下面的代码来测试你的题解:\n\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果所有断言都通过，那么您的题解将被 通过。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n\n1\n2\n3\n\n\n提示：\n\n * 1 <= nums.length <= 3 * 10^4^\n * -10^4^ <= nums[i] <= 10^4^\n * nums 已按 非严格递增 排列\n\n\n# 解题：\n\n\n# 方法一：双指针\n\n思路如下：\n\n如果数组 nums 的长度为 0，则数组不包含任何元素，因此返回 0。\n\n当数组 nums的长度大于 0 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 nums[0] 保持原状即可，从下标 1 开始删除重复元素。\n\n定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。\n\n假设数组 nums 的长度为 n。将快指针 fast 依次遍历从 1 到 n−1 的每个位置，对于每个位置，如果 nums[fast]≠nums[fast−1]，说明 nums[fast] 和之前的元素都不同，因此将 nums[fast] 的值复制到 nums[slow]，然后将 slow 的值加 1，即指向下一个位置。\n\n遍历结束之后，从 nums[0] 到 nums[slow−1] 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 slow，返回 slow 即可。\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) {return 0;}\n        int fast = 1, slow = 1;\n        while(fast < n) {\n            if(nums[fast] != nums[fast-1]) {\n                nums[slow] = nums[fast];\n                ++slow;\n            }\n            ++fast;\n        }\n        return slow;\n        // for( ; fast < n ; ++fast) {\n        //     if(nums[fast] != nums[fast-1]) {\n        //         nums[slow] = nums[fast];\n        //         slow++;\n        //     }\n        // }\n        // return slow;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。\n\n * 空间复杂度：O(1)。只需要使用常数的额外空间。",normalizedContent:"# 26. 删除有序数组中的重复项\n\n\n# 题目：\n\n给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n\n * 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\n * 返回 k 。\n\n判题标准:\n\n系统会用下面的代码来测试你的题解:\n\nint[] nums = [...]; // 输入数组\nint[] expectednums = [...]; // 长度正确的期望答案\n\nint k = removeduplicates(nums); // 调用\n\nassert k == expectednums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectednums[i];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果所有断言都通过，那么您的题解将被 通过。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n\n1\n2\n3\n\n\n提示：\n\n * 1 <= nums.length <= 3 * 10^4^\n * -10^4^ <= nums[i] <= 10^4^\n * nums 已按 非严格递增 排列\n\n\n# 解题：\n\n\n# 方法一：双指针\n\n思路如下：\n\n如果数组 nums 的长度为 0，则数组不包含任何元素，因此返回 0。\n\n当数组 nums的长度大于 0 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 nums[0] 保持原状即可，从下标 1 开始删除重复元素。\n\n定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。\n\n假设数组 nums 的长度为 n。将快指针 fast 依次遍历从 1 到 n−1 的每个位置，对于每个位置，如果 nums[fast]=nums[fast−1]，说明 nums[fast] 和之前的元素都不同，因此将 nums[fast] 的值复制到 nums[slow]，然后将 slow 的值加 1，即指向下一个位置。\n\n遍历结束之后，从 nums[0] 到 nums[slow−1] 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 slow，返回 slow 即可。\n\nclass solution {\npublic:\n    int removeduplicates(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) {return 0;}\n        int fast = 1, slow = 1;\n        while(fast < n) {\n            if(nums[fast] != nums[fast-1]) {\n                nums[slow] = nums[fast];\n                ++slow;\n            }\n            ++fast;\n        }\n        return slow;\n        // for( ; fast < n ; ++fast) {\n        //     if(nums[fast] != nums[fast-1]) {\n        //         nums[slow] = nums[fast];\n        //         slow++;\n        //     }\n        // }\n        // return slow;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。\n\n * 空间复杂度：o(1)。只需要使用常数的额外空间。",charsets:{cjk:!0}},{title:"移动零",frontmatter:{title:"移动零",date:"2023-11-24T16:30:01.000Z",permalink:"/pages/e85eda/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6.html",relativePath:"02.计算机基础/04.算法/283. 移动零.md",key:"v-d65ef770",path:"/pages/e85eda/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:15},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:101},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:290},{level:3,title:"方法一：双指针法",slug:"方法一-双指针法",normalizedTitle:"方法一：双指针法",charIndex:298}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.47,time:28200,words:94},headersStr:"题目： 示例： 解题： 方法一：双指针法",content:"# 283. 移动零\n\n\n# 题目：\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n\n\n# 示例：\n\n示例 1:\n\n输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n\n1\n2\n\n\n示例 2:\n\n输入: nums = [0]\n输出: [0]\n\n\n1\n2\n\n\n提示:\n\n * 1 <= nums.length <= 104\n * -231 <= nums[i] <= 231 - 1\n\n**进阶：**你能尽量减少完成的操作次数吗？\n\n\n# 解题：\n\n\n# 方法一：双指针法\n\n使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。如果数组中没有0，这个时候左右指针始终指向同一个位置，每个位置都是自己和自己交换。如果数组中有0，这个时候不会执行交换，左指针停留在指向0的位置，而右指针则继续往右移动，直到找到一个非0元素，然后进行左右指针元素的交换。\n\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int n = nums.size(), left = 0, right = 0;\n        while(right < n) {\n            if(nums[right]) {\n                swap(nums[left],nums[right]);\n                left++;\n            }\n            right++;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 为序列长度。每个位置至多被遍历两次。\n\n * 空间复杂度：O(1)。只需要常数的空间存放若干变量。",normalizedContent:"# 283. 移动零\n\n\n# 题目：\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n\n\n# 示例：\n\n示例 1:\n\n输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n\n1\n2\n\n\n示例 2:\n\n输入: nums = [0]\n输出: [0]\n\n\n1\n2\n\n\n提示:\n\n * 1 <= nums.length <= 104\n * -231 <= nums[i] <= 231 - 1\n\n**进阶：**你能尽量减少完成的操作次数吗？\n\n\n# 解题：\n\n\n# 方法一：双指针法\n\n使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。如果数组中没有0，这个时候左右指针始终指向同一个位置，每个位置都是自己和自己交换。如果数组中有0，这个时候不会执行交换，左指针停留在指向0的位置，而右指针则继续往右移动，直到找到一个非0元素，然后进行左右指针元素的交换。\n\nclass solution {\npublic:\n    void movezeroes(vector<int>& nums) {\n        int n = nums.size(), left = 0, right = 0;\n        while(right < n) {\n            if(nums[right]) {\n                swap(nums[left],nums[right]);\n                left++;\n            }\n            right++;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 为序列长度。每个位置至多被遍历两次。\n\n * 空间复杂度：o(1)。只需要常数的空间存放若干变量。",charsets:{cjk:!0}},{title:"最长回文串",frontmatter:{title:"最长回文串",date:"2023-12-21T09:58:32.000Z",permalink:"/pages/5d801b/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/409.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html",relativePath:"02.计算机基础/04.算法/409. 最长回文串.md",key:"v-54831b1a",path:"/pages/5d801b/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:17},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:112},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:323},{level:3,title:"方法一：贪心法",slug:"方法一-贪心法",normalizedTitle:"方法一：贪心法",charIndex:331}],readingTime:{text:"1 min read",minutes:.99,time:59400,words:198},headersStr:"题目： 示例： 解题： 方法一：贪心法",content:'# 409. 最长回文串\n\n\n# 题目：\n\n给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。\n\n在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。\n\n\n# 示例：\n\n示例 1:\n\n输入:s = "abccccdd"\n输出:7\n解释:\n我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。\n\n\n1\n2\n3\n4\n\n\n示例 2:\n\n输入:s = "a"\n输出:1\n\n\n1\n2\n\n\n示例 3：\n\n输入:s = "aaaaaccc"\n输出:7\n\n\n1\n2\n\n\n提示:\n\n * 1 <= s.length <= 2000\n * s 只由小写 和/或 大写英文字母组成\n\n\n# 解题：\n\n\n# 方法一：贪心法\n\n思路：\n\n通过统计字符串中每个字符的出现次数，然后计算可以构造的回文串的长度。在遍历字符出现次数的统计结果时，对于每个字符，可以使用它出现次数的偶数部分，因为偶数个相同字符可以构成回文串的一部分。然后，检查是否存在出现奇数次的字符，如果存在，可以将其中一个字符作为回文串的中心，长度加一。\n\n具体步骤如下：\n\n 1. 创建一个哈希表 charCount，用于记录每个字符的出现次数。\n 2. 遍历字符串 s，统计每个字符的出现次数，并更新 charCount。\n 3. 初始化回文串的长度 length 为 0，初始化标志变量 hasOddCount 为 false。\n 4. 遍历 charCount 中的统计结果，计算可以构造的回文串的长度。对于每个字符，使用它出现次数的偶数部分。\n 5. 如果某个字符出现次数是奇数，将 hasOddCount 标记为 true。\n 6. 如果存在出现奇数次的字符，将回文串的长度加一。\n 7. 返回最终的回文串长度。\n\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestPalindrome(string s) {\n        unordered_map<char, int> charCount;\n\n        // 统计每个字符的出现次数\n        for (char c : s) {\n            charCount[c]++;\n        }\n\n        int length = 0;\n        bool hasOddCount = false;\n\n        // 遍历统计结果\n        for (const auto& entry : charCount) {\n            length += entry.second / 2 * 2; // 使用偶数次的字符\n            if (entry.second % 2 == 1) {\n                hasOddCount = true; \t\t// 标记是否存在出现奇数次的字符\n            }\n        }\n\n        // 如果存在出现奇数次的字符，可以使用其中一个作为回文串的中心\n        if (hasOddCount) {\n            length++;\n        }\n\n        return length;\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = "abccccdd";\n    int result = solution.longestPalindrome(s);\n    cout << "通过构造的最长回文串长度是: " << result << endl;\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n',normalizedContent:'# 409. 最长回文串\n\n\n# 题目：\n\n给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。\n\n在构造过程中，请注意 区分大小写 。比如 "aa" 不能当做一个回文字符串。\n\n\n# 示例：\n\n示例 1:\n\n输入:s = "abccccdd"\n输出:7\n解释:\n我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。\n\n\n1\n2\n3\n4\n\n\n示例 2:\n\n输入:s = "a"\n输出:1\n\n\n1\n2\n\n\n示例 3：\n\n输入:s = "aaaaaccc"\n输出:7\n\n\n1\n2\n\n\n提示:\n\n * 1 <= s.length <= 2000\n * s 只由小写 和/或 大写英文字母组成\n\n\n# 解题：\n\n\n# 方法一：贪心法\n\n思路：\n\n通过统计字符串中每个字符的出现次数，然后计算可以构造的回文串的长度。在遍历字符出现次数的统计结果时，对于每个字符，可以使用它出现次数的偶数部分，因为偶数个相同字符可以构成回文串的一部分。然后，检查是否存在出现奇数次的字符，如果存在，可以将其中一个字符作为回文串的中心，长度加一。\n\n具体步骤如下：\n\n 1. 创建一个哈希表 charcount，用于记录每个字符的出现次数。\n 2. 遍历字符串 s，统计每个字符的出现次数，并更新 charcount。\n 3. 初始化回文串的长度 length 为 0，初始化标志变量 hasoddcount 为 false。\n 4. 遍历 charcount 中的统计结果，计算可以构造的回文串的长度。对于每个字符，使用它出现次数的偶数部分。\n 5. 如果某个字符出现次数是奇数，将 hasoddcount 标记为 true。\n 6. 如果存在出现奇数次的字符，将回文串的长度加一。\n 7. 返回最终的回文串长度。\n\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nclass solution {\npublic:\n    int longestpalindrome(string s) {\n        unordered_map<char, int> charcount;\n\n        // 统计每个字符的出现次数\n        for (char c : s) {\n            charcount[c]++;\n        }\n\n        int length = 0;\n        bool hasoddcount = false;\n\n        // 遍历统计结果\n        for (const auto& entry : charcount) {\n            length += entry.second / 2 * 2; // 使用偶数次的字符\n            if (entry.second % 2 == 1) {\n                hasoddcount = true; \t\t// 标记是否存在出现奇数次的字符\n            }\n        }\n\n        // 如果存在出现奇数次的字符，可以使用其中一个作为回文串的中心\n        if (hasoddcount) {\n            length++;\n        }\n\n        return length;\n    }\n};\n\nint main() {\n    solution solution;\n    string s = "abccccdd";\n    int result = solution.longestpalindrome(s);\n    cout << "通过构造的最长回文串长度是: " << result << endl;\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n',charsets:{cjk:!0}},{title:"汉明距离",frontmatter:{title:"汉明距离",date:"2023-12-15T09:56:19.000Z",permalink:"/pages/55ec77/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB.html",relativePath:"02.计算机基础/04.算法/461. 汉明距离.md",key:"v-43aa51a6",path:"/pages/55ec77/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:16},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:92},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:248},{level:3,title:"方法一：内置位计数功能",slug:"方法一-内置位计数功能",normalizedTitle:"方法一：内置位计数功能",charIndex:452},{level:3,title:"方法二：移位实现位计数",slug:"方法二-移位实现位计数",normalizedTitle:"方法二：移位实现位计数",charIndex:671}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.73,time:43800,words:146},headersStr:"题目： 示例： 解题： 方法一：内置位计数功能 方法二：移位实现位计数",content:"# 461. 汉明距离\n\n\n# 题目：\n\n两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。\n\n给你两个整数 x 和 y，计算并返回它们之间的汉明距离。\n\n\n# 示例：\n\n示例 1：\n\n输入：x = 1, y = 4\n输出：2\n解释：\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n上面的箭头指出了对应二进制位不同的位置。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例 2：\n\n输入：x = 3, y = 1\n输出：1\n\n\n1\n2\n\n\n\n# 解题：\n\n汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。\n\n两个整数之间的汉明距离是对应位置上数字不同的位数。\n\n根据以上定义，我们使用异或运算，记为 ⊕，当且仅当输入位不同时输出为 1。\n\n\n\n计算 x 和 y 之间的汉明距离，可以先计算 x⊕y，然后统计结果中等于 1 的位数。\n\n现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。\n\n\n# 方法一：内置位计数功能\n\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        return __builtin_popcout(x ^ y);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n复杂度分析\n\n * 时间复杂度：O(1)。不同语言的实现方法不一，我们可以近似认为其时间复杂度为 O(1)。\n\n * 空间复杂度：O(1)。\n\n\n# 方法二：移位实现位计数\n\n本方法将使用位运算中移位的操作实现位计数功能。\n\n\n\n具体地，记 s=x⊕y，我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。\n\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int s = x^y, ret = 0;\n        while(s) {\n            ret += s & 1;\n            s >>= 1;\n        }\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# 461. 汉明距离\n\n\n# 题目：\n\n两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。\n\n给你两个整数 x 和 y，计算并返回它们之间的汉明距离。\n\n\n# 示例：\n\n示例 1：\n\n输入：x = 1, y = 4\n输出：2\n解释：\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n上面的箭头指出了对应二进制位不同的位置。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例 2：\n\n输入：x = 3, y = 1\n输出：1\n\n\n1\n2\n\n\n\n# 解题：\n\n汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。\n\n两个整数之间的汉明距离是对应位置上数字不同的位数。\n\n根据以上定义，我们使用异或运算，记为 ⊕，当且仅当输入位不同时输出为 1。\n\n\n\n计算 x 和 y 之间的汉明距离，可以先计算 x⊕y，然后统计结果中等于 1 的位数。\n\n现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。\n\n\n# 方法一：内置位计数功能\n\nclass solution {\npublic:\n    int hammingdistance(int x, int y) {\n        return __builtin_popcout(x ^ y);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n复杂度分析\n\n * 时间复杂度：o(1)。不同语言的实现方法不一，我们可以近似认为其时间复杂度为 o(1)。\n\n * 空间复杂度：o(1)。\n\n\n# 方法二：移位实现位计数\n\n本方法将使用位运算中移位的操作实现位计数功能。\n\n\n\n具体地，记 s=x⊕y，我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。\n\nclass solution {\npublic:\n    int hammingdistance(int x, int y) {\n        int s = x^y, ret = 0;\n        while(s) {\n            ret += s & 1;\n            s >>= 1;\n        }\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0}},{title:"最大子数组和",frontmatter:{title:"最大子数组和",date:"2023-12-01T17:16:13.000Z",permalink:"/pages/edd6da/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C.html",relativePath:"02.计算机基础/04.算法/53. 最大子数组和.md",key:"v-60c6683a",path:"/pages/edd6da/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:17},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:98},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:377},{level:3,title:"方法一：动态规划",slug:"方法一-动态规划",normalizedTitle:"方法一：动态规划",charIndex:385}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.315,time:18900,words:63},headersStr:"题目： 示例： 解题： 方法一：动态规划",content:"# 53. 最大子数组和\n\n\n# 题目：\n\n给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n子数组 是数组中的一个连续部分。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [1]\n输出：1\n\n\n1\n2\n\n\n示例 3：\n\n输入：nums = [5,4,-1,7,8]\n输出：23\n\n\n1\n2\n\n\n提示：\n\n * 1 <= nums.length <= 105\n * -104 <= nums[i] <= 104\n\n**进阶：**如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n\n\n# 解题：\n\n\n# 方法一：动态规划",normalizedContent:"# 53. 最大子数组和\n\n\n# 题目：\n\n给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n子数组 是数组中的一个连续部分。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [1]\n输出：1\n\n\n1\n2\n\n\n示例 3：\n\n输入：nums = [5,4,-1,7,8]\n输出：23\n\n\n1\n2\n\n\n提示：\n\n * 1 <= nums.length <= 105\n * -104 <= nums[i] <= 104\n\n**进阶：**如果你已经实现复杂度为 o(n) 的解法，尝试使用更为精妙的 分治法 求解。\n\n\n# 解题：\n\n\n# 方法一：动态规划",charsets:{cjk:!0}},{title:"把二叉搜索树转换为累加树",frontmatter:{title:"把二叉搜索树转换为累加树",date:"2023-12-01T17:16:32.000Z",permalink:"/pages/299c79/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/538.%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html",relativePath:"02.计算机基础/04.算法/538. 把二叉搜索树转换为累加树.md",key:"v-3aa2523b",path:"/pages/299c79/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:24},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:308},{level:2,title:"题目解释：",slug:"题目解释",normalizedTitle:"题目解释：",charIndex:447},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:1223},{level:4,title:"方法一：反序中序遍历",slug:"方法一-反序中序遍历",normalizedTitle:"方法一：反序中序遍历",charIndex:1230},{level:4,title:"方法二：Morris 遍历",slug:"方法二-morris-遍历",normalizedTitle:"方法二：morris 遍历",charIndex:3373}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.615,time:96900,words:323},headersStr:"题目： 示例： 题目解释： 解题： 方法一：反序中序遍历 方法二：Morris 遍历",content:'# 538. 把二叉搜索树转换为累加树\n\n\n# 题目：\n\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\n提醒一下，二叉搜索树满足下列约束条件：\n\n * 节点的左子树仅包含键 小于 节点键的节点。\n * 节点的右子树仅包含键 大于 节点键的节点。\n * 左右子树也必须是二叉搜索树。\n\n注意： 本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\n\n1\n2\n\n\n\n# 题目解释：\n\n是不是没读懂题目？没关系，举个例子你就明白了：\n\n> 比如说根节点4转换为累加树之后为什么新值是30？按题目中的意思就是大于等于根节点4的原来二叉树的值全部加起来，即根节点4+（它的右子树）= 4 + 6 + 5 + 7 + 8 = 30，同理根节点4的左孩子节点1，那就是要将大于等于1的原二叉树的值全部加起来，那就是从自身开始1 + 2 + 3 + （之前根节点4累加的值，因为它们都比1大） = 36，所以新值为36，依此类推。\n\n这样子看来，题目是读懂了，但是没啥规律啊？解不了题啊？\n\n根据题目的提示会发现原二叉树是满足以下性质的：\n\n 1. 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n 2. 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n 3. 它的左、右子树也分别为二叉搜索树。\n\n说明原二叉树就是二叉搜索树，而累加树则刚好与二叉搜索树性质相反，刚好二叉搜索树的中序遍历是一个单调递增的有序序列。那么是否意味着累加树的逆序中序遍历是一个单调递减的有序序列。\n\n二叉搜索树的中序遍历：[0、1、2、3、4、5、6、7、8]\n\n累加树的中序遍历：[36、36、35、33、30、26、24、15、8]\n\n果然如此！\n\n示例 2：\n\n输入：root = [0,null,1]\n输出：[1,null,1]\n\n\n1\n2\n\n\n示例 3：\n\n输入：root = [1,0,2]\n输出：[3,3,2]\n\n\n1\n2\n\n\n示例 4：\n\n输入：root = [3,2,4,1]\n输出：[7,9,4,10]\n\n\n1\n2\n\n\n提示：\n\n * 树中的节点数介于 0 和 104 之间。\n * 每个节点的值介于 -104 和 104 之间。\n * 树中的所有值 互不相同 。\n * 给定的树为二叉搜索树。\n\n\n# 解题：\n\n# 方法一：反序中序遍历\n\n所以根据我的题目解释，这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。\n\nclass Solution {\npublic:\n    int sum = 0;\n    TreeNode* convertBST(TreeNode* root) {\n        if(root != nullptr) {\n            convertBST(root->right);\n            sum += root->val;\n            root->val = sum;\n            convertBST(root->left);\n        }\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n复杂度分析：\n\n * 时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。\n\n * 空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log~⁡n~)，最坏情况下树呈现链状，为 O(n)。\n\n看不懂代码的可以去调试一下代码就懂了\n\n#include <iostream>\n\n// 二叉树节点定义\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* convertBST(TreeNode* root) {\n        if(root != nullptr) {\n            convertBST(root->right);\n            sum += root->val;\n            root->val = sum;\n            convertBST(root->left);\n        }\n        return root;\n    }\n\nprivate:\n    int sum = 0; // 成员变量用于记录累加值\n};\n\n// 中序遍历打印二叉树\nvoid inOrderTraversal(TreeNode* root) {\n    if (root) {\n        inOrderTraversal(root->left);\n        std::cout << root->val << " ";\n        inOrderTraversal(root->right);\n    }\n}\n\nint main() {\n    // 示例用法\n    // 创建一棵示例二叉搜索树\n    TreeNode* root = new TreeNode(4);\n    root->left = new TreeNode(1);\n    root->right = new TreeNode(6);\n    root->left->left = new TreeNode(0);\n    root->left->right = new TreeNode(2);\n    root->right->left = new TreeNode(5);\n    root->right->right = new TreeNode(7);\n    root->left->right->right = new TreeNode(3);\n    root->right->right->right = new TreeNode(8);\n\n\n    // 创建 Solution 对象\n    Solution solution;\n\n    // 转换为累加树（使用你提供的方式）\n    TreeNode* greaterSumTree = solution.convertBST(root);\n\n    // 打印累加树的中序遍历结果\n    std::cout << "累加树的中序遍历结果: ";\n    inOrderTraversal(greaterSumTree);\n    std::cout << std::endl;\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n下面给出部分调试过程：\n\n一开始先一直递归，直到右子树的末尾叶子节点8\n\n\n\n\n\n然后递归里的执行：\n\n\n\n\n\n\n\n# 方法二：Morris 遍历\n\n这个方法不搞了，第一个理解透彻就挺累的了。有需要自己去看吧\n\n538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）',normalizedContent:'# 538. 把二叉搜索树转换为累加树\n\n\n# 题目：\n\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（greater sum tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\n提醒一下，二叉搜索树满足下列约束条件：\n\n * 节点的左子树仅包含键 小于 节点键的节点。\n * 节点的右子树仅包含键 大于 节点键的节点。\n * 左右子树也必须是二叉搜索树。\n\n注意： 本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\n\n1\n2\n\n\n\n# 题目解释：\n\n是不是没读懂题目？没关系，举个例子你就明白了：\n\n> 比如说根节点4转换为累加树之后为什么新值是30？按题目中的意思就是大于等于根节点4的原来二叉树的值全部加起来，即根节点4+（它的右子树）= 4 + 6 + 5 + 7 + 8 = 30，同理根节点4的左孩子节点1，那就是要将大于等于1的原二叉树的值全部加起来，那就是从自身开始1 + 2 + 3 + （之前根节点4累加的值，因为它们都比1大） = 36，所以新值为36，依此类推。\n\n这样子看来，题目是读懂了，但是没啥规律啊？解不了题啊？\n\n根据题目的提示会发现原二叉树是满足以下性质的：\n\n 1. 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n 2. 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n 3. 它的左、右子树也分别为二叉搜索树。\n\n说明原二叉树就是二叉搜索树，而累加树则刚好与二叉搜索树性质相反，刚好二叉搜索树的中序遍历是一个单调递增的有序序列。那么是否意味着累加树的逆序中序遍历是一个单调递减的有序序列。\n\n二叉搜索树的中序遍历：[0、1、2、3、4、5、6、7、8]\n\n累加树的中序遍历：[36、36、35、33、30、26、24、15、8]\n\n果然如此！\n\n示例 2：\n\n输入：root = [0,null,1]\n输出：[1,null,1]\n\n\n1\n2\n\n\n示例 3：\n\n输入：root = [1,0,2]\n输出：[3,3,2]\n\n\n1\n2\n\n\n示例 4：\n\n输入：root = [3,2,4,1]\n输出：[7,9,4,10]\n\n\n1\n2\n\n\n提示：\n\n * 树中的节点数介于 0 和 104 之间。\n * 每个节点的值介于 -104 和 104 之间。\n * 树中的所有值 互不相同 。\n * 给定的树为二叉搜索树。\n\n\n# 解题：\n\n# 方法一：反序中序遍历\n\n所以根据我的题目解释，这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。\n\nclass solution {\npublic:\n    int sum = 0;\n    treenode* convertbst(treenode* root) {\n        if(root != nullptr) {\n            convertbst(root->right);\n            sum += root->val;\n            root->val = sum;\n            convertbst(root->left);\n        }\n        return root;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n复杂度分析：\n\n * 时间复杂度：o(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。\n\n * 空间复杂度：o(n)，为递归过程中栈的开销，平均情况下为 o(log~⁡n~)，最坏情况下树呈现链状，为 o(n)。\n\n看不懂代码的可以去调试一下代码就懂了\n\n#include <iostream>\n\n// 二叉树节点定义\nstruct treenode {\n    int val;\n    treenode* left;\n    treenode* right;\n    treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass solution {\npublic:\n    treenode* convertbst(treenode* root) {\n        if(root != nullptr) {\n            convertbst(root->right);\n            sum += root->val;\n            root->val = sum;\n            convertbst(root->left);\n        }\n        return root;\n    }\n\nprivate:\n    int sum = 0; // 成员变量用于记录累加值\n};\n\n// 中序遍历打印二叉树\nvoid inordertraversal(treenode* root) {\n    if (root) {\n        inordertraversal(root->left);\n        std::cout << root->val << " ";\n        inordertraversal(root->right);\n    }\n}\n\nint main() {\n    // 示例用法\n    // 创建一棵示例二叉搜索树\n    treenode* root = new treenode(4);\n    root->left = new treenode(1);\n    root->right = new treenode(6);\n    root->left->left = new treenode(0);\n    root->left->right = new treenode(2);\n    root->right->left = new treenode(5);\n    root->right->right = new treenode(7);\n    root->left->right->right = new treenode(3);\n    root->right->right->right = new treenode(8);\n\n\n    // 创建 solution 对象\n    solution solution;\n\n    // 转换为累加树（使用你提供的方式）\n    treenode* greatersumtree = solution.convertbst(root);\n\n    // 打印累加树的中序遍历结果\n    std::cout << "累加树的中序遍历结果: ";\n    inordertraversal(greatersumtree);\n    std::cout << std::endl;\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n下面给出部分调试过程：\n\n一开始先一直递归，直到右子树的末尾叶子节点8\n\n\n\n\n\n然后递归里的执行：\n\n\n\n\n\n\n\n# 方法二：morris 遍历\n\n这个方法不搞了，第一个理解透彻就挺累的了。有需要自己去看吧\n\n538. 把二叉搜索树转换为累加树 - 力扣（leetcode）',charsets:{cjk:!0}},{title:"最短无序连续子数组",frontmatter:{title:"最短无序连续子数组",date:"2023-11-24T16:30:01.000Z",permalink:"/pages/6354db/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84.html",relativePath:"02.计算机基础/04.算法/581. 最短无序连续子数组.md",key:"v-b47686b4",path:"/pages/6354db/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:21},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:118},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:392},{level:3,title:"方法一：排序比较",slug:"方法一-排序比较",normalizedTitle:"方法一：排序比较",charIndex:400},{level:3,title:"方法二：双指针一次遍历法",slug:"方法二-双指针一次遍历法",normalizedTitle:"方法二：双指针一次遍历法",charIndex:1384}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.035,time:122100.00000000001,words:407},headersStr:"题目： 示例： 解题： 方法一：排序比较 方法二：双指针一次遍历法",content:'# 581. 最短无序连续子数组\n\n\n# 题目：\n\n给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。\n\n请你找出符合题意的 最短 子数组，并输出它的长度。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [2,6,4,8,10,9,15]\n输出：5\n解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [1,2,3,4]\n输出：0\n\n\n1\n2\n\n\n示例 3：\n\n输入：nums = [1]\n输出：0\n\n\n1\n2\n\n\n提示：\n\n * 1 <= nums.length <= 104\n * -105 <= nums[i] <= 105\n\n**进阶：**你可以设计一个时间复杂度为 O(n) 的解决方案吗？\n\n\n# 解题：\n\n\n# 方法一：排序比较\n\n从示例1可以得知，数组可以分为三部分，nums1部分，nums2部分，nums3部分。当进行升序排序之后发现nums1部分和nums3部分不会发生变化，因此只要nums1+nums3部分求出最大，则可以得到nums2部分最短。\n\n基本思路是：把原来的数组复制到另一个数组中进行排序，然后两个数组进行比较，然后我们从左向右找到第一个两数组不同的位置，即为 nums2 的左边界。同理也可以找到 nums2 的右边界。最后我们输出 nums2 的长度即可。\n\nclass Solution {\npublic:\n    int findUnsortedSubarray(vector<int>& nums) {\n        if(is_sorted(nums.begin(),nums.end())) {\n            // 如果数组已经是升序排序，返回0\n            return 0;\n        }\n        vector<int> numsSorted(nums);\n        sort(numsSorted.begin(), numsSorted.end());\n        int left = 0;\n        while(nums[left] == numsSorted[left]) {\n            left++;\n        }\n        int right = nums.size()-1;\n        while(nums[right] == numsSorted[right]) {\n            right--;\n        }\n        return right-left+1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n复杂度分析\n\n * 时间复杂度：O(nlog⁡n)，其中 n 为给定数组的长度。我们需要 O(nlog⁡n) 的时间进行排序，以及 O(n) 的时间遍历数组，因此总时间复杂度为 O(n)。\n\n * 空间复杂度：O(n)，其中 n 为给定数组的长度。我们需要额外的一个数组保存排序后的数组 numsSorted。\n\n\n# 方法二：双指针一次遍历法\n\n使用两个指针，一个从数组的开头向右移动，找到第一个无序的元素，另一个从数组的末尾向左移动，找到第一个无序的元素。然后，这两个指针之间的子数组就是我们要找的连续子数组。\n\nclass Solution {\npublic:\n    int findUnsortedSubarray(vector<int>& nums) {\n        int n = nums.size();\n        //从左向右找到第一个无序的元素\n        int left = 0;\n        while(left < n-1 && nums[left] <= nums[left+1]) {\n            left++;\n        }\n        // 如果数组已经有序，返回0\n        if(left == n-1) {\n            return 0;\n        }\n        //从右向左找到第一个无序的元素\n        int right = n-1;\n        while(right > 0 && nums[right] >= nums[right - 1]) {\n            right--;\n        }\n        //找到无序子数组的最小值和最大值\n        int min_val = INT_MAX, max_val = INT_MIN;\n        for(int i = left; i <= right; ++i) {\n            min_val = min(min_val, nums[i]);\n            max_val = max(max_val, nums[i]);\n        }\n        // 扩展左边界\n        while(left > 0 && nums[left - 1] > min_val) {\n            left--;\n        }\n        // 扩展右边界\n        while(right < n-1 && nums[right + 1] < max_val) {\n            right++;\n        }\n        // 返回子数组的长度\n        return right - left + 1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n更加简洁的写法：\n\nclass Solution {\npublic:\n    int findUnsortedSubarray(std::vector<int>& nums) {\n        int n = nums.size();\n        int maxn = INT_MIN, right = -1;  // 初始化最大值和右边界\n        int minn = INT_MAX, left = -1;   // 初始化最小值和左边界\n\n        for (int i = 0; i < n; i++) {\n            // 从左向右遍历找到右边界\n            if (maxn > nums[i]) {\n                right = i;\n            } else {\n                maxn = nums[i];\n            }\n\n            // 从右向左遍历找到左边界\n            if (minn < nums[n - i - 1]) {\n                left = n - i - 1;\n            } else {\n                minn = nums[n - i - 1];\n            }\n        }\n        // 如果 right 仍然是初始值 -1，表示数组已经有序，返回 0\n        // 否则，返回无序子数组的长度\n        return right == -1 ? 0 : right - left + 1;\n    }\n};\nint main() {\n    std::vector<int> nums = {2, 6, 4, 8, 10, 9, 15};\n    Solution solution;\n    int result = solution.findUnsortedSubarray(nums);\n\n    std::cout << "最短无序连续子数组的长度为: " << result << std::endl;\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n不理解？没关系，根据例子看图说话！\n\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 是给定数组的长度，我们仅需要遍历该数组一次。\n\n * 空间复杂度：O(1)。我们只需要常数的空间保存若干变量。',normalizedContent:'# 581. 最短无序连续子数组\n\n\n# 题目：\n\n给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。\n\n请你找出符合题意的 最短 子数组，并输出它的长度。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [2,6,4,8,10,9,15]\n输出：5\n解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n\n\n1\n2\n3\n\n\n示例 2：\n\n输入：nums = [1,2,3,4]\n输出：0\n\n\n1\n2\n\n\n示例 3：\n\n输入：nums = [1]\n输出：0\n\n\n1\n2\n\n\n提示：\n\n * 1 <= nums.length <= 104\n * -105 <= nums[i] <= 105\n\n**进阶：**你可以设计一个时间复杂度为 o(n) 的解决方案吗？\n\n\n# 解题：\n\n\n# 方法一：排序比较\n\n从示例1可以得知，数组可以分为三部分，nums1部分，nums2部分，nums3部分。当进行升序排序之后发现nums1部分和nums3部分不会发生变化，因此只要nums1+nums3部分求出最大，则可以得到nums2部分最短。\n\n基本思路是：把原来的数组复制到另一个数组中进行排序，然后两个数组进行比较，然后我们从左向右找到第一个两数组不同的位置，即为 nums2 的左边界。同理也可以找到 nums2 的右边界。最后我们输出 nums2 的长度即可。\n\nclass solution {\npublic:\n    int findunsortedsubarray(vector<int>& nums) {\n        if(is_sorted(nums.begin(),nums.end())) {\n            // 如果数组已经是升序排序，返回0\n            return 0;\n        }\n        vector<int> numssorted(nums);\n        sort(numssorted.begin(), numssorted.end());\n        int left = 0;\n        while(nums[left] == numssorted[left]) {\n            left++;\n        }\n        int right = nums.size()-1;\n        while(nums[right] == numssorted[right]) {\n            right--;\n        }\n        return right-left+1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n复杂度分析\n\n * 时间复杂度：o(nlog⁡n)，其中 n 为给定数组的长度。我们需要 o(nlog⁡n) 的时间进行排序，以及 o(n) 的时间遍历数组，因此总时间复杂度为 o(n)。\n\n * 空间复杂度：o(n)，其中 n 为给定数组的长度。我们需要额外的一个数组保存排序后的数组 numssorted。\n\n\n# 方法二：双指针一次遍历法\n\n使用两个指针，一个从数组的开头向右移动，找到第一个无序的元素，另一个从数组的末尾向左移动，找到第一个无序的元素。然后，这两个指针之间的子数组就是我们要找的连续子数组。\n\nclass solution {\npublic:\n    int findunsortedsubarray(vector<int>& nums) {\n        int n = nums.size();\n        //从左向右找到第一个无序的元素\n        int left = 0;\n        while(left < n-1 && nums[left] <= nums[left+1]) {\n            left++;\n        }\n        // 如果数组已经有序，返回0\n        if(left == n-1) {\n            return 0;\n        }\n        //从右向左找到第一个无序的元素\n        int right = n-1;\n        while(right > 0 && nums[right] >= nums[right - 1]) {\n            right--;\n        }\n        //找到无序子数组的最小值和最大值\n        int min_val = int_max, max_val = int_min;\n        for(int i = left; i <= right; ++i) {\n            min_val = min(min_val, nums[i]);\n            max_val = max(max_val, nums[i]);\n        }\n        // 扩展左边界\n        while(left > 0 && nums[left - 1] > min_val) {\n            left--;\n        }\n        // 扩展右边界\n        while(right < n-1 && nums[right + 1] < max_val) {\n            right++;\n        }\n        // 返回子数组的长度\n        return right - left + 1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n更加简洁的写法：\n\nclass solution {\npublic:\n    int findunsortedsubarray(std::vector<int>& nums) {\n        int n = nums.size();\n        int maxn = int_min, right = -1;  // 初始化最大值和右边界\n        int minn = int_max, left = -1;   // 初始化最小值和左边界\n\n        for (int i = 0; i < n; i++) {\n            // 从左向右遍历找到右边界\n            if (maxn > nums[i]) {\n                right = i;\n            } else {\n                maxn = nums[i];\n            }\n\n            // 从右向左遍历找到左边界\n            if (minn < nums[n - i - 1]) {\n                left = n - i - 1;\n            } else {\n                minn = nums[n - i - 1];\n            }\n        }\n        // 如果 right 仍然是初始值 -1，表示数组已经有序，返回 0\n        // 否则，返回无序子数组的长度\n        return right == -1 ? 0 : right - left + 1;\n    }\n};\nint main() {\n    std::vector<int> nums = {2, 6, 4, 8, 10, 9, 15};\n    solution solution;\n    int result = solution.findunsortedsubarray(nums);\n\n    std::cout << "最短无序连续子数组的长度为: " << result << std::endl;\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n不理解？没关系，根据例子看图说话！\n\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是给定数组的长度，我们仅需要遍历该数组一次。\n\n * 空间复杂度：o(1)。我们只需要常数的空间保存若干变量。',charsets:{cjk:!0}},{title:"合并二叉树",frontmatter:{title:"合并二叉树",date:"2023-11-24T16:30:01.000Z",permalink:"/pages/2998a0/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/617.%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"02.计算机基础/04.算法/617. 合并二叉树.md",key:"v-372f1e78",path:"/pages/2998a0/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:17},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:216},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:430},{level:3,title:"方法一：深度优先搜索",slug:"方法一-深度优先搜索",normalizedTitle:"方法一：深度优先搜索",charIndex:438},{level:3,title:"方法二：广度优先搜索",slug:"方法二-广度优先搜索",normalizedTitle:"方法二：广度优先搜索",charIndex:1376}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.69,time:101399.99999999999,words:338},headersStr:"题目： 示例： 解题： 方法一：深度优先搜索 方法二：广度优先搜索",content:"# 617. 合并二叉树\n\n\n# 题目：\n\n给你两棵二叉树： root1 和 root2 。\n\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n\n返回合并后的二叉树。\n\n注意: 合并过程必须从两个树的根节点开始。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n输出：[3,4,5,5,4,null,7]\n\n\n1\n2\n\n\n示例 2：\n\n输入：root1 = [1], root2 = [1,2]\n输出：[2,2]\n\n\n1\n2\n\n\n提示：\n\n * 两棵树中的节点数目在范围 [0, 2000] 内\n * -104 <= Node.val <= 104\n\n\n# 解题：\n\n\n# 方法一：深度优先搜索\n\n从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。\n\n两个二叉树的对应节点可能存在以下三种情况：\n\n * 如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；\n\n * 如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；\n\n * 如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。\n\n对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。\n\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if (t1 == nullptr) {\n            return t2;\n        }\n        if (t2 == nullptr) {\n            return t1;\n        }\n        auto merged = new TreeNode(t1->val + t2->val);\n        merged->left = mergeTrees(t1->left, t2->left);\n        merged->right = mergeTrees(t1->right, t2->right);\n        return merged;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n复杂度分析\n\n * 时间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。\n\n * 空间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。\n\n\n# 方法二：广度优先搜索\n\n当使用广度优先搜索（BFS）合并两个二叉树时，我们按照层次遍历的方式一层一层地进行。首先，我们判断两个树的根节点是否存在，然后创建一个新树的根节点，值为两个原始树根节点的值之和。接下来，我们使用三个队列，分别存储新树、原始树1和原始树2的节点。\n\n开始循环，每次从这三个队列中分别取出一个节点。对于新树的节点和原始树的相应节点，我们判断它们的左右子节点情况：\n\n * 如果两个原始树的节点都存在左子节点，那么新树的对应节点的左子节点的值就是两个原始树的左子节点值之和。然后，将两个原始树的左子节点加入相应的队列中，以便下一轮继续处理它们的左子节点。\n * 如果两个原始树的节点中有一个左子节点为空，那么新树的对应节点的左子节点就是非空的那个原始树的左子节点。\n\n右子节点和右子树的处理方式与左子节点和左子树相同。\n\n整个过程会一直进行，直到队列为空。最终，新树就是合并后的二叉树。\n\n这种方法保证了我们按照层次顺序逐步合并节点，同时处理了不同子树为空的情况，确保了合并后的二叉树的正确性。\n\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if (t1 == nullptr) {\n            return t2;\n        }\n        if (t2 == nullptr) {\n            return t1;\n        }\n        auto merged = new TreeNode(t1->val + t2->val);\n        auto q = queue<TreeNode*>();\n        auto queue1 = queue<TreeNode*>();\n        auto queue2 = queue<TreeNode*>();\n        q.push(merged);\n        queue1.push(t1);\n        queue2.push(t2);\n        while (!queue1.empty() && !queue2.empty()) {\n            auto node = q.front(), node1 = queue1.front(), node2 = queue2.front();\n            q.pop();\n            queue1.pop();\n            queue2.pop();\n            auto left1 = node1->left, left2 = node2->left, right1 = node1->right, right2 = node2->right;\n            if (left1 != nullptr || left2 != nullptr) {\n                if (left1 != nullptr && left2 != nullptr) {\n                    auto left = new TreeNode(left1->val + left2->val);\n                    node->left = left;\n                    q.push(left);\n                    queue1.push(left1);\n                    queue2.push(left2);\n                } else if (left1 != nullptr) {\n                    node->left = left1;\n                } else if (left2 != nullptr) {\n                    node->left = left2;\n                }\n            }\n            if (right1 != nullptr || right2 != nullptr) {\n                if (right1 != nullptr && right2 != nullptr) {\n                    auto right = new TreeNode(right1->val + right2->val);\n                    node->right = right;\n                    q.push(right);\n                    queue1.push(right1);\n                    queue2.push(right2);\n                } else if (right1 != nullptr) {\n                    node->right = right1;\n                } else {\n                    node->right = right2;\n                }\n            }\n        }\n        return merged;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n复杂度分析\n\n * 时间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行广度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。\n\n * 空间复杂度：O(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的节点数。",normalizedContent:"# 617. 合并二叉树\n\n\n# 题目：\n\n给你两棵二叉树： root1 和 root2 。\n\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n\n返回合并后的二叉树。\n\n注意: 合并过程必须从两个树的根节点开始。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n输出：[3,4,5,5,4,null,7]\n\n\n1\n2\n\n\n示例 2：\n\n输入：root1 = [1], root2 = [1,2]\n输出：[2,2]\n\n\n1\n2\n\n\n提示：\n\n * 两棵树中的节点数目在范围 [0, 2000] 内\n * -104 <= node.val <= 104\n\n\n# 解题：\n\n\n# 方法一：深度优先搜索\n\n从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。\n\n两个二叉树的对应节点可能存在以下三种情况：\n\n * 如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；\n\n * 如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；\n\n * 如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。\n\n对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。\n\nclass solution {\npublic:\n    treenode* mergetrees(treenode* t1, treenode* t2) {\n        if (t1 == nullptr) {\n            return t2;\n        }\n        if (t2 == nullptr) {\n            return t1;\n        }\n        auto merged = new treenode(t1->val + t2->val);\n        merged->left = mergetrees(t1->left, t2->left);\n        merged->right = mergetrees(t1->right, t2->right);\n        return merged;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n复杂度分析\n\n * 时间复杂度：o(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。\n\n * 空间复杂度：o(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。\n\n\n# 方法二：广度优先搜索\n\n当使用广度优先搜索（bfs）合并两个二叉树时，我们按照层次遍历的方式一层一层地进行。首先，我们判断两个树的根节点是否存在，然后创建一个新树的根节点，值为两个原始树根节点的值之和。接下来，我们使用三个队列，分别存储新树、原始树1和原始树2的节点。\n\n开始循环，每次从这三个队列中分别取出一个节点。对于新树的节点和原始树的相应节点，我们判断它们的左右子节点情况：\n\n * 如果两个原始树的节点都存在左子节点，那么新树的对应节点的左子节点的值就是两个原始树的左子节点值之和。然后，将两个原始树的左子节点加入相应的队列中，以便下一轮继续处理它们的左子节点。\n * 如果两个原始树的节点中有一个左子节点为空，那么新树的对应节点的左子节点就是非空的那个原始树的左子节点。\n\n右子节点和右子树的处理方式与左子节点和左子树相同。\n\n整个过程会一直进行，直到队列为空。最终，新树就是合并后的二叉树。\n\n这种方法保证了我们按照层次顺序逐步合并节点，同时处理了不同子树为空的情况，确保了合并后的二叉树的正确性。\n\nclass solution {\npublic:\n    treenode* mergetrees(treenode* t1, treenode* t2) {\n        if (t1 == nullptr) {\n            return t2;\n        }\n        if (t2 == nullptr) {\n            return t1;\n        }\n        auto merged = new treenode(t1->val + t2->val);\n        auto q = queue<treenode*>();\n        auto queue1 = queue<treenode*>();\n        auto queue2 = queue<treenode*>();\n        q.push(merged);\n        queue1.push(t1);\n        queue2.push(t2);\n        while (!queue1.empty() && !queue2.empty()) {\n            auto node = q.front(), node1 = queue1.front(), node2 = queue2.front();\n            q.pop();\n            queue1.pop();\n            queue2.pop();\n            auto left1 = node1->left, left2 = node2->left, right1 = node1->right, right2 = node2->right;\n            if (left1 != nullptr || left2 != nullptr) {\n                if (left1 != nullptr && left2 != nullptr) {\n                    auto left = new treenode(left1->val + left2->val);\n                    node->left = left;\n                    q.push(left);\n                    queue1.push(left1);\n                    queue2.push(left2);\n                } else if (left1 != nullptr) {\n                    node->left = left1;\n                } else if (left2 != nullptr) {\n                    node->left = left2;\n                }\n            }\n            if (right1 != nullptr || right2 != nullptr) {\n                if (right1 != nullptr && right2 != nullptr) {\n                    auto right = new treenode(right1->val + right2->val);\n                    node->right = right;\n                    q.push(right);\n                    queue1.push(right1);\n                    queue2.push(right2);\n                } else if (right1 != nullptr) {\n                    node->right = right1;\n                } else {\n                    node->right = right2;\n                }\n            }\n        }\n        return merged;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n复杂度分析\n\n * 时间复杂度：o(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行广度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。\n\n * 空间复杂度：o(min⁡(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的节点数。",charsets:{cjk:!0}},{title:"x 的平方根",frontmatter:{title:"x 的平方根",date:"2023-12-05T16:26:39.000Z",permalink:"/pages/480e04/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html",relativePath:"02.计算机基础/04.算法/69. x 的平方根.md",key:"v-66f71cf5",path:"/pages/480e04/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:17},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:145},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:287},{level:3,title:"方法一：二分查找",slug:"方法一-二分查找",normalizedTitle:"方法一：二分查找",charIndex:295},{level:3,title:"方法二：袖珍计算器算法",slug:"方法二-袖珍计算器算法",normalizedTitle:"方法二：袖珍计算器算法",charIndex:1449}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.635,time:98100,words:327},headersStr:"题目： 示例： 解题： 方法一：二分查找 方法二：袖珍计算器算法",content:'# 69. x 的平方根\n\n\n# 题目：\n\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n\n**注意：**不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n\n\n# 示例：\n\n示例 1：\n\n输入：x = 4\n输出：2\n\n\n1\n2\n\n\n示例 2：\n\n输入：x = 8\n输出：2\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n\n\n1\n2\n3\n\n\n提示：\n\n * 0 <= x <= 2^31^ - 1\n\n\n# 解题：\n\n\n# 方法一：二分查找\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        int left = 1, right = x, ans = -1;\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if((long long)mid*mid <= x) {\n                ans = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n复杂度分析\n\n * 时间复杂度：O(log⁡x)，即为二分查找需要的次数。\n * 空间复杂度：O(1)。\n\n可调式的代码\n\n#include <iostream>\nint mySqrt(int x) {\n        int left = 1, right = x, ans = -1;\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if((long long)mid*mid <= x) {\n                ans = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }\nint main() {\n    int test_values[] = {0, 1, 2, 3, 4, 5, 16, 25, 36, 49, 81, 100};\n    for (int x : test_values) {\n        std::cout << "The integer square root of " << x << " is: " << mySqrt(x) << std::endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 方法二：袖珍计算器算法\n\n「袖珍计算器算法」是一种用指数函数 exp⁡ 和对数函数 ln⁡ 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。\n\n这种方法的思路是通过数学函数 exp（指数函数）和 log（对数函数）来进行近似计算平方根。\n\n具体步骤如下：\n\n 1. 如果输入 x 为 0，则直接返回 0，因为 0 的平方根也是 0。\n 2. 使用 exp(0.5 * log(x)) 计算 x 的平方根的初步估计值。这里通过对 x 取对数，然后取指数，相当于计算 x 的平方根。这一步是为了得到一个初始猜测值，以便下一步逼近。\n 3. 判断 (ans + 1) * (ans + 1) 是否小于等于 x，如果是，则返回 ans + 1，否则返回 ans。这一步是为了修正初始估计值，使其更接近实际的整数平方根。\n\n这种方法在一定程度上避免了浮点数精度问题，因为整数运算通常不会引起浮点数精度损失。然而，由于使用了浮点数函数，可能会有一些误差。强制类型转换 (long long) 用于防止整数溢出问题。这种方法的关键在于使用对数和指数函数进行近似，以达到更高的精度。\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0) return 0;\n        int ans = exp(0.5*log(x));\n        return ((long long)(ans + 1) * (ans + 1) <= x ? ans+1 : ans);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n复杂度分析\n\n * 时间复杂度：O(1)，由于内置的 exp 函数与 log 函数一般都很快，我们在这里将其复杂度视为 O(1)。\n\n * 空间复杂度：O(1)。',normalizedContent:'# 69. x 的平方根\n\n\n# 题目：\n\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n\n**注意：**不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n\n\n# 示例：\n\n示例 1：\n\n输入：x = 4\n输出：2\n\n\n1\n2\n\n\n示例 2：\n\n输入：x = 8\n输出：2\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n\n\n1\n2\n3\n\n\n提示：\n\n * 0 <= x <= 2^31^ - 1\n\n\n# 解题：\n\n\n# 方法一：二分查找\n\nclass solution {\npublic:\n    int mysqrt(int x) {\n        int left = 1, right = x, ans = -1;\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if((long long)mid*mid <= x) {\n                ans = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n复杂度分析\n\n * 时间复杂度：o(log⁡x)，即为二分查找需要的次数。\n * 空间复杂度：o(1)。\n\n可调式的代码\n\n#include <iostream>\nint mysqrt(int x) {\n        int left = 1, right = x, ans = -1;\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if((long long)mid*mid <= x) {\n                ans = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return ans;\n    }\nint main() {\n    int test_values[] = {0, 1, 2, 3, 4, 5, 16, 25, 36, 49, 81, 100};\n    for (int x : test_values) {\n        std::cout << "the integer square root of " << x << " is: " << mysqrt(x) << std::endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 方法二：袖珍计算器算法\n\n「袖珍计算器算法」是一种用指数函数 exp⁡ 和对数函数 ln⁡ 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。\n\n这种方法的思路是通过数学函数 exp（指数函数）和 log（对数函数）来进行近似计算平方根。\n\n具体步骤如下：\n\n 1. 如果输入 x 为 0，则直接返回 0，因为 0 的平方根也是 0。\n 2. 使用 exp(0.5 * log(x)) 计算 x 的平方根的初步估计值。这里通过对 x 取对数，然后取指数，相当于计算 x 的平方根。这一步是为了得到一个初始猜测值，以便下一步逼近。\n 3. 判断 (ans + 1) * (ans + 1) 是否小于等于 x，如果是，则返回 ans + 1，否则返回 ans。这一步是为了修正初始估计值，使其更接近实际的整数平方根。\n\n这种方法在一定程度上避免了浮点数精度问题，因为整数运算通常不会引起浮点数精度损失。然而，由于使用了浮点数函数，可能会有一些误差。强制类型转换 (long long) 用于防止整数溢出问题。这种方法的关键在于使用对数和指数函数进行近似，以达到更高的精度。\n\nclass solution {\npublic:\n    int mysqrt(int x) {\n        if(x==0) return 0;\n        int ans = exp(0.5*log(x));\n        return ((long long)(ans + 1) * (ans + 1) <= x ? ans+1 : ans);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n复杂度分析\n\n * 时间复杂度：o(1)，由于内置的 exp 函数与 log 函数一般都很快，我们在这里将其复杂度视为 o(1)。\n\n * 空间复杂度：o(1)。',charsets:{cjk:!0}},{title:"爬楼梯",frontmatter:{title:"爬楼梯",date:"2023-11-24T16:30:01.000Z",permalink:"/pages/6b01fc/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF.html",relativePath:"02.计算机基础/04.算法/70. 爬楼梯.md",key:"v-46b4dd50",path:"/pages/6b01fc/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:14},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:84},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:283},{level:4,title:"方法一：动态规划",slug:"方法一-动态规划",normalizedTitle:"方法一：动态规划",charIndex:290},{level:4,title:"方法二：dp动态规划三部曲",slug:"方法二-dp动态规划三部曲",normalizedTitle:"方法二：dp动态规划三部曲",charIndex:862}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.155,time:69300,words:231},headersStr:"题目： 示例： 解题： 方法一：动态规划 方法二：dp动态规划三部曲",content:"# 70. 爬楼梯\n\n\n# 题目：\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n\n# 示例：\n\n示例 1：\n\n输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n\n\n1\n2\n3\n4\n5\n\n\n示例 2：\n\n输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n\n\n1\n2\n3\n4\n5\n6\n\n\n提示：\n\n * 1 <= n <= 45\n\n\n# 解题：\n\n# 方法一：动态规划\n\n一级台阶一种方法，二级台阶两种方法（1+1，2），三级台阶三种方法（1+1+1，1+2，2+1）。。。\n\n * n=1, f(n) = 1;\n * n=2, f(n) = 2;\n * n=3, f(n) = 3;\n * n=4, f(n) = 5;\n\n这不是斐波那契数列吗？f(n) = f(n-2) + f(n-1)；\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int first = 0, second = 0, third = 1;\n        for(int i = 1; i <= n; ++i) {\n            first = second;\n            second = third;\n            third = first + second;\n        }\n        return third;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n复杂度分析\n\n * 时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。\n * 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。\n\n# 方法二：dp动态规划三部曲\n\n 1. 定义dp数组 我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？\n 2. 找出递推关系式 动态规划类似于高中数学的数学归纳法，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。\n 3. 找出初始值 找出了递推公式，我们还需要初始值，因为递推公式就是靠前面的值推出后面的值，但总得有个头吧，这个头就是初始值。\n\n#include <vector>\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if(n == 1) {\n            return 1;\n        }\n        std::vector<int> dp(n + 1, 0);\n        dp[1] = 1;\n        dp[2] = 2;\n        for(int i = 3; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i -2];\n        }\n        return dp[n];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# 70. 爬楼梯\n\n\n# 题目：\n\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n\n# 示例：\n\n示例 1：\n\n输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n\n\n1\n2\n3\n4\n5\n\n\n示例 2：\n\n输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n\n\n1\n2\n3\n4\n5\n6\n\n\n提示：\n\n * 1 <= n <= 45\n\n\n# 解题：\n\n# 方法一：动态规划\n\n一级台阶一种方法，二级台阶两种方法（1+1，2），三级台阶三种方法（1+1+1，1+2，2+1）。。。\n\n * n=1, f(n) = 1;\n * n=2, f(n) = 2;\n * n=3, f(n) = 3;\n * n=4, f(n) = 5;\n\n这不是斐波那契数列吗？f(n) = f(n-2) + f(n-1)；\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        int first = 0, second = 0, third = 1;\n        for(int i = 1; i <= n; ++i) {\n            first = second;\n            second = third;\n            third = first + second;\n        }\n        return third;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n复杂度分析\n\n * 时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 o(n)。\n * 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 o(1)。\n\n# 方法二：dp动态规划三部曲\n\n 1. 定义dp数组 我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？\n 2. 找出递推关系式 动态规划类似于高中数学的数学归纳法，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。\n 3. 找出初始值 找出了递推公式，我们还需要初始值，因为递推公式就是靠前面的值推出后面的值，但总得有个头吧，这个头就是初始值。\n\n#include <vector>\nclass solution {\npublic:\n    int climbstairs(int n) {\n        if(n == 1) {\n            return 1;\n        }\n        std::vector<int> dp(n + 1, 0);\n        dp[1] = 1;\n        dp[2] = 2;\n        for(int i = 3; i <= n; ++i) {\n            dp[i] = dp[i - 1] + dp[i -2];\n        }\n        return dp[n];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0}},{title:"二分查找",frontmatter:{title:"二分查找",date:"2023-12-15T09:56:24.000Z",permalink:"/pages/173765/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/704.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"02.计算机基础/04.算法/704. 二分查找.md",key:"v-5b5f2600",path:"/pages/173765/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:16},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:111},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:384},{level:3,title:"方法一：二分查找",slug:"方法一-二分查找",normalizedTitle:"方法一：二分查找",charIndex:392}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.86,time:51600,words:172},headersStr:"题目： 示例： 解题： 方法一：二分查找",content:"# 704. 二分查找\n\n\n# 题目：\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n\n# 示例：\n\n示例 1:\n\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n\n1\n2\n3\n\n\n示例 2:\n\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n\n\n1\n2\n3\n\n\n提示：\n\n 1. 你可以假设 nums 中的所有元素是不重复的。\n 2. n 将在 [1, 10000]之间。\n 3. nums 的每个元素都将在 [-9999, 9999]之间。\n\n\n# 解题：\n\n\n# 方法一：二分查找\n\n在升序数组 nums 中寻找目标值 target，对于特定下标 iii，比较 nums[i] 和 target 的大小：\n\n * 如果 nums[i]=target，则下标 i 即为要寻找的下标；\n\n * 如果 nums[i]>target，则 target 只可能在下标 i 的左侧；\n\n * 如果 nums[i]<target，则 target 只可能在下标 i 的右侧。\n\n基于上述事实，可以在有序数组中使用二分查找寻找目标值。\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0,right = nums.size()-1;\n        while(left <= right) {\n            int mid = left + (right - left)/2;\n            if(target < nums[mid]) {\n                right = mid - 1;\n            } else if(target > nums[mid]) {\n                left = mid + 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n复杂度分析\n\n * 时间复杂度：O(log⁡n)，其中 n 是数组的长度。\n * 空间复杂度：O(1)。",normalizedContent:"# 704. 二分查找\n\n\n# 题目：\n\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n\n# 示例：\n\n示例 1:\n\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n\n1\n2\n3\n\n\n示例 2:\n\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n\n\n1\n2\n3\n\n\n提示：\n\n 1. 你可以假设 nums 中的所有元素是不重复的。\n 2. n 将在 [1, 10000]之间。\n 3. nums 的每个元素都将在 [-9999, 9999]之间。\n\n\n# 解题：\n\n\n# 方法一：二分查找\n\n在升序数组 nums 中寻找目标值 target，对于特定下标 iii，比较 nums[i] 和 target 的大小：\n\n * 如果 nums[i]=target，则下标 i 即为要寻找的下标；\n\n * 如果 nums[i]>target，则 target 只可能在下标 i 的左侧；\n\n * 如果 nums[i]<target，则 target 只可能在下标 i 的右侧。\n\n基于上述事实，可以在有序数组中使用二分查找寻找目标值。\n\nclass solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0,right = nums.size()-1;\n        while(left <= right) {\n            int mid = left + (right - left)/2;\n            if(target < nums[mid]) {\n                right = mid - 1;\n            } else if(target > nums[mid]) {\n                left = mid + 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n复杂度分析\n\n * 时间复杂度：o(log⁡n)，其中 n 是数组的长度。\n * 空间复杂度：o(1)。",charsets:{cjk:!0}},{title:"链表的中间结点",frontmatter:{title:"链表的中间结点",date:"2023-12-21T09:58:25.000Z",permalink:"/pages/d178f3/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.html",relativePath:"02.计算机基础/04.算法/876. 链表的中间结点.md",key:"v-0853ad4b",path:"/pages/d178f3/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:19},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:83},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:305},{level:3,title:"方法一：数组",slug:"方法一-数组",normalizedTitle:"方法一：数组",charIndex:313},{level:3,title:"方法二：单指针法",slug:"方法二-单指针法",normalizedTitle:"方法二：单指针法",charIndex:783},{level:3,title:"方法三：快慢指针法",slug:"方法三-快慢指针法",normalizedTitle:"方法三：快慢指针法",charIndex:1387}],readingTime:{text:"2 min read",minutes:1.12,time:67200,words:224},headersStr:"题目： 示例： 解题： 方法一：数组 方法二：单指针法 方法三：快慢指针法",content:"# 876. 链表的中间结点\n\n\n# 题目：\n\n给你单链表的头结点 head ，请你找出并返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：head = [1,2,3,4,5]\n输出：[3,4,5]\n解释：链表只有一个中间结点，值为 3 。\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：head = [1,2,3,4,5,6]\n输出：[4,5,6]\n解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n\n\n1\n2\n3\n\n\n提示：\n\n * 链表的结点数范围是 [1, 100]\n * 1 <= Node.val <= 100\n\n\n# 解题：\n\n\n# 方法一：数组\n\n链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。\n\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        vector<ListNode*> nodes;\n        while(head != nullptr) {\n            nodes.push_back(head);\n            head = head->next;\n        }\n        return nodes[nodes.size()/2];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复杂度分析\n\n * 时间复杂度：O(N)，其中 N 是给定链表中的结点数目。\n * 空间复杂度：O(N)，即数组 A 用去的空间。\n\n\n# 方法二：单指针法\n\n我们可以对方法一进行空间优化，省去数组 nodes。\n\n我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。\n\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        int n = 0;\n        ListNode* cur = head;\n        while (cur != nullptr) {\n            ++n;\n            cur = cur->next;\n        }\n        int k = 0;\n        cur = head;\n        while (k < n / 2) {\n            ++k;\n            cur = cur->next;\n        }\n        return cur;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n复杂度分析\n\n * 时间复杂度：O(N)，其中 N 是给定链表的结点数目。\n\n * 空间复杂度：O(1)，只需要常数空间存放变量和指针。\n\n\n# 方法三：快慢指针法\n\n我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。\n\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n复杂度分析\n\n * 时间复杂度：O(N)，其中 N 是给定链表的结点数目。\n\n * 空间复杂度：O(1)，只需要常数空间存放 slow 和 fast 两个指针。",normalizedContent:"# 876. 链表的中间结点\n\n\n# 题目：\n\n给你单链表的头结点 head ，请你找出并返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n\n# 示例：\n\n示例 1：\n\n\n\n输入：head = [1,2,3,4,5]\n输出：[3,4,5]\n解释：链表只有一个中间结点，值为 3 。\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：head = [1,2,3,4,5,6]\n输出：[4,5,6]\n解释：该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。\n\n\n1\n2\n3\n\n\n提示：\n\n * 链表的结点数范围是 [1, 100]\n * 1 <= node.val <= 100\n\n\n# 解题：\n\n\n# 方法一：数组\n\n链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 a 中。如果我们遍历到了 n 个元素，那么链表以及数组的长度也为 n，对应的中间节点即为 a[n/2]。\n\nclass solution {\npublic:\n    listnode* middlenode(listnode* head) {\n        vector<listnode*> nodes;\n        while(head != nullptr) {\n            nodes.push_back(head);\n            head = head->next;\n        }\n        return nodes[nodes.size()/2];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是给定链表中的结点数目。\n * 空间复杂度：o(n)，即数组 a 用去的空间。\n\n\n# 方法二：单指针法\n\n我们可以对方法一进行空间优化，省去数组 nodes。\n\n我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 n；第二次遍历时，我们遍历到第 n/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。\n\nclass solution {\npublic:\n    listnode* middlenode(listnode* head) {\n        int n = 0;\n        listnode* cur = head;\n        while (cur != nullptr) {\n            ++n;\n            cur = cur->next;\n        }\n        int k = 0;\n        cur = head;\n        while (k < n / 2) {\n            ++k;\n            cur = cur->next;\n        }\n        return cur;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是给定链表的结点数目。\n\n * 空间复杂度：o(1)，只需要常数空间存放变量和指针。\n\n\n# 方法三：快慢指针法\n\n我们可以继续优化方法二，用两个指针 slow 与 fast 一起遍历链表。slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。\n\nclass solution {\npublic:\n    listnode* middlenode(listnode* head) {\n        listnode* slow = head;\n        listnode* fast = head;\n        while (fast != null && fast->next != null) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是给定链表的结点数目。\n\n * 空间复杂度：o(1)，只需要常数空间存放 slow 和 fast 两个指针。",charsets:{cjk:!0}},{title:"有序数组的平方",frontmatter:{title:"有序数组的平方",date:"2023-12-21T09:58:22.000Z",permalink:"/pages/67ccea/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/977.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html",relativePath:"02.计算机基础/04.算法/977. 有序数组的平方.md",key:"v-1e8d5707",path:"/pages/67ccea/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:19},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:86},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:378},{level:3,title:"方法一：直接排序",slug:"方法一-直接排序",normalizedTitle:"方法一：直接排序",charIndex:386},{level:3,title:"方法二：双指针法",slug:"方法二-双指针法",normalizedTitle:"方法二：双指针法",charIndex:797},{level:3,title:"方法三：双指针",slug:"方法三-双指针",normalizedTitle:"方法三：双指针",charIndex:2357}],readingTime:{text:"2 min read",minutes:1.63,time:97800,words:326},headersStr:"题目： 示例： 解题： 方法一：直接排序 方法二：双指针法 方法三：双指针",content:"# 977. 有序数组的平方\n\n\n# 题目：\n\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n\n\n1\n2\n3\n4\n\n\n示例 2：\n\n输入：nums = [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n\n\n1\n2\n\n\n提示：\n\n * 1 <= nums.length <= 104\n * -104 <= nums[i] <= 104\n * nums 已按 非递减顺序 排序\n\n进阶：\n\n * 请你设计时间复杂度为 O(n) 的算法解决本问题\n\n\n# 解题：\n\n\n# 方法一：直接排序\n\n最简单的方法就是将数组 nums 中的数平方后直接排序。\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> ans;\n        for(int num : nums) {\n            ans.push_back(num * num);\n        }\n        sort(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复杂度分析\n\n时间复杂度：O(nlog⁡n)，其中 n 是数组 nums 的长度。\n\n空间复杂度：O(log⁡n)。除了存储答案的数组以外，我们需要 O(log⁡n) 的栈空间进行排序。\n\n\n# 方法二：双指针法\n\n方法一没有利用「数组 nums 已经按照升序排序」这个条件。显然，如果数组 nums 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组 nums 中的所有数都是负数，那么将每个数平方后，数组会保持降序。\n\n这样一来，如果我们能够找到数组 nums 中负数与非负数的分界线，那么就可以用类似「归并排序」的方法了。具体地，我们设 neg 为数组 nums 中负数与非负数的分界线，也就是说，nums[0] 到 nums[neg] 均为负数，而 nums[neg+1] 到 nums[n−1] 均为非负数。当我们将数组 nums 中的数平方后，那么 nums[0] 到 nums[neg] 单调递减，nums[neg+1] 到 nums[n−1] 单调递增。\n\n由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置 neg 和 neg+1，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        int negative = -1;\n        for(int i = 0; i < n; ++i) {\n            if(nums[i] < 0) {\n                negative = i;\n            } else {\n                break;\n            }\n        }\n        vector<int> ans;\n        int i = negative, j = negative + 1;\n        while(i >= 0 || j < n) {\n            if(i < 0) { \t\t\t// 说明数组没有负数\n                ans.push_back(nums[j]*nums[j]);\n                ++j;\n            } else if (j == n) {    // 说明数组全是负数\n                ans.push_back(nums[i]*nums[i]);\n                --i;\n            } else if(nums[i]*nums[i] < nums[j]*nums[j]) { // 数组有正有负，比较两边\n                ans.push_back(nums[i]*nums[i]);\n                --i;\n            } else {\n                ans.push_back(nums[j]*nums[j]);\n                ++j;\n            }\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 是数组 nums 的长度。\n\n * 空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。\n\n\n# 方法三：双指针\n\n同样地，我们可以使用两个指针分别指向位置 0 和 n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，读者可以仔细思考其精髓所在。\n\n因此，对于前半部分负数而言，从前往后遍历，平方后相当于逆序（从大到小），对于后半部分正数而言，从后往前遍历，也相当于逆序（从大到小），因此，可以看成两个逆序数组数组从大到小排序，然后取较大者插入到答案数组尾部中。\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> ans(n);\n        for (int i = 0, j = n - 1, pos = n - 1; i <= j;) {\n            if (nums[i] * nums[i] > nums[j] * nums[j]) {\n                ans[pos] = nums[i] * nums[i];\n                ++i;\n            }\n            else {\n                ans[pos] = nums[j] * nums[j];\n                --j;\n            }\n            --pos;\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n复杂度分析\n\n * 时间复杂度：O(n)，其中 n 是数组 nums 的长度。\n\n * 空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。",normalizedContent:"# 977. 有序数组的平方\n\n\n# 题目：\n\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n\n\n# 示例：\n\n示例 1：\n\n输入：nums = [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n\n\n1\n2\n3\n4\n\n\n示例 2：\n\n输入：nums = [-7,-3,2,3,11]\n输出：[4,9,9,49,121]\n\n\n1\n2\n\n\n提示：\n\n * 1 <= nums.length <= 104\n * -104 <= nums[i] <= 104\n * nums 已按 非递减顺序 排序\n\n进阶：\n\n * 请你设计时间复杂度为 o(n) 的算法解决本问题\n\n\n# 解题：\n\n\n# 方法一：直接排序\n\n最简单的方法就是将数组 nums 中的数平方后直接排序。\n\nclass solution {\npublic:\n    vector<int> sortedsquares(vector<int>& nums) {\n        vector<int> ans;\n        for(int num : nums) {\n            ans.push_back(num * num);\n        }\n        sort(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n复杂度分析\n\n时间复杂度：o(nlog⁡n)，其中 n 是数组 nums 的长度。\n\n空间复杂度：o(log⁡n)。除了存储答案的数组以外，我们需要 o(log⁡n) 的栈空间进行排序。\n\n\n# 方法二：双指针法\n\n方法一没有利用「数组 nums 已经按照升序排序」这个条件。显然，如果数组 nums 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组 nums 中的所有数都是负数，那么将每个数平方后，数组会保持降序。\n\n这样一来，如果我们能够找到数组 nums 中负数与非负数的分界线，那么就可以用类似「归并排序」的方法了。具体地，我们设 neg 为数组 nums 中负数与非负数的分界线，也就是说，nums[0] 到 nums[neg] 均为负数，而 nums[neg+1] 到 nums[n−1] 均为非负数。当我们将数组 nums 中的数平方后，那么 nums[0] 到 nums[neg] 单调递减，nums[neg+1] 到 nums[n−1] 单调递增。\n\n由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置 neg 和 neg+1，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。\n\nclass solution {\npublic:\n    vector<int> sortedsquares(vector<int>& nums) {\n        int n = nums.size();\n        int negative = -1;\n        for(int i = 0; i < n; ++i) {\n            if(nums[i] < 0) {\n                negative = i;\n            } else {\n                break;\n            }\n        }\n        vector<int> ans;\n        int i = negative, j = negative + 1;\n        while(i >= 0 || j < n) {\n            if(i < 0) { \t\t\t// 说明数组没有负数\n                ans.push_back(nums[j]*nums[j]);\n                ++j;\n            } else if (j == n) {    // 说明数组全是负数\n                ans.push_back(nums[i]*nums[i]);\n                --i;\n            } else if(nums[i]*nums[i] < nums[j]*nums[j]) { // 数组有正有负，比较两边\n                ans.push_back(nums[i]*nums[i]);\n                --i;\n            } else {\n                ans.push_back(nums[j]*nums[j]);\n                ++j;\n            }\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是数组 nums 的长度。\n\n * 空间复杂度：o(1)。除了存储答案的数组以外，我们只需要维护常量空间。\n\n\n# 方法三：双指针\n\n同样地，我们可以使用两个指针分别指向位置 0 和 n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，读者可以仔细思考其精髓所在。\n\n因此，对于前半部分负数而言，从前往后遍历，平方后相当于逆序（从大到小），对于后半部分正数而言，从后往前遍历，也相当于逆序（从大到小），因此，可以看成两个逆序数组数组从大到小排序，然后取较大者插入到答案数组尾部中。\n\nclass solution {\npublic:\n    vector<int> sortedsquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> ans(n);\n        for (int i = 0, j = n - 1, pos = n - 1; i <= j;) {\n            if (nums[i] * nums[i] > nums[j] * nums[j]) {\n                ans[pos] = nums[i] * nums[i];\n                ++i;\n            }\n            else {\n                ans[pos] = nums[j] * nums[j];\n                --j;\n            }\n            --pos;\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n复杂度分析\n\n * 时间复杂度：o(n)，其中 n 是数组 nums 的长度。\n\n * 空间复杂度：o(1)。除了存储答案的数组以外，我们只需要维护常量空间。",charsets:{cjk:!0}},{title:"找到小镇的法官",frontmatter:{title:"找到小镇的法官",date:"2023-12-21T09:58:18.000Z",permalink:"/pages/33a1c0/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E7%AE%97%E6%B3%95/997.%20%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98.html",relativePath:"02.计算机基础/04.算法/997. 找到小镇的法官.md",key:"v-ac1d6b14",path:"/pages/33a1c0/",headers:[{level:2,title:"题目：",slug:"题目",normalizedTitle:"题目：",charIndex:19},{level:2,title:"示例：",slug:"示例",normalizedTitle:"示例：",charIndex:263},{level:2,title:"解题：",slug:"解题",normalizedTitle:"解题：",charIndex:574},{level:3,title:"方法一：计算各节点的入度和出度",slug:"方法一-计算各节点的入度和出度",normalizedTitle:"方法一：计算各节点的入度和出度",charIndex:582}],readingTime:{text:"2 min read",minutes:1.755,time:105300,words:351},headersStr:"题目： 示例： 解题： 方法一：计算各节点的入度和出度",content:'# 997. 找到小镇的法官\n\n\n# 题目：\n\n小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。\n\n如果小镇法官真的存在，那么：\n\n 1. 小镇法官不会信任任何人。\n 2. 每个人（除了小镇法官）都信任这位小镇法官。\n 3. 只有一个人同时满足属性 1 和属性 2 。\n\n给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。\n\n如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。\n\n\n# 示例：\n\n示例 1：\n\n输入：n = 2, trust = [[1,2]]\n输出：2\n\n\n1\n2\n\n\n示例 2：\n\n输入：n = 3, trust = [[1,3],[2,3]]\n输出：3\n\n\n1\n2\n\n\n示例 3：\n\n输入：n = 3, trust = [[1,3],[2,3],[3,1]]\n输出：-1\n\n\n1\n2\n\n\n提示：\n\n * 1 <= n <= 1000\n * 0 <= trust.length <= 104\n * trust[i].length == 2\n * trust 中的所有trust[i] = [ai, bi] 互不相同\n * ai != bi\n * 1 <= ai, bi <= n\n\n\n# 解题：\n\n\n# 方法一：计算各节点的入度和出度\n\n本题需要用到有向图中节点的入度和出度的概念。在有向图中，一个节点的入度是指向该节点的边的数量；而一个节点的出度是从该节点出发的边的数量。\n\n题干描述了一个有向图。每个人是图的节点，trust 的元素 trust[i] 是图的有向边，从 trust[i][0] 指向 trust[i][1]。我们可以遍历 trust，统计每个节点的入度和出度，存储在 inDegrees 和 outDegrees 中。\n\n根据题意，在法官存在的情况下，法官不相信任何人，每个人（除了法官外）都信任法官，且只有一名法官。因此法官这个节点的入度是 n−1, 出度是 0。\n\n我们可以遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，我们可以直接返回结果；如果不存在符合条件的点，则返回 −1。\n\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        // 定义入度和出度数组\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        // 遍历trust数组，计算入度和出度\n        for(auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        // 遍历入度和出度数组，查找入度为n-1，出度为0的节点\n        for(int i = 1; i <= n; ++i) {\n            if(inDegrees[i] == n-1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n复杂度分析\n\n * 时间复杂度：O(n+m)，其中 m 是 trust 的长度。首先需要遍历 trust 计算出 inDegrees 和 outDegrees，然后需要遍历 inDegrees 和 outDegrees 来确定法官。\n\n * 空间复杂度：O(n)。记录各个节点的入度和出度需要 O(n) 的空间。\n\n可调试的代码：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        // 定义入度和出度数组\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        // 遍历trust数组，计算入度和出度\n        for(auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        // 遍历入度和出度数组，查找入度为n-1，出度为0的节点\n        for(int i = 1; i <= n; ++i) {\n            if(inDegrees[i] == n-1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n    // 小镇人数\n    int n = 4;\n    // 信任关系\n    vector<vector<int>> trust = {{1, 3}, {1, 4}, {2, 3}, {2, 4}, {4, 3}};\n    // 找到小镇法官\n    int judge = solution.findJudge(n, trust);\n    // 判断是否存在小镇法官\n    if (judge != -1) {\n        cout << "小镇法官的编号是: " << judge << endl;\n    } else {\n        cout << "没有找到小镇法官" << endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n',normalizedContent:'# 997. 找到小镇的法官\n\n\n# 题目：\n\n小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。\n\n如果小镇法官真的存在，那么：\n\n 1. 小镇法官不会信任任何人。\n 2. 每个人（除了小镇法官）都信任这位小镇法官。\n 3. 只有一个人同时满足属性 1 和属性 2 。\n\n给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。\n\n如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。\n\n\n# 示例：\n\n示例 1：\n\n输入：n = 2, trust = [[1,2]]\n输出：2\n\n\n1\n2\n\n\n示例 2：\n\n输入：n = 3, trust = [[1,3],[2,3]]\n输出：3\n\n\n1\n2\n\n\n示例 3：\n\n输入：n = 3, trust = [[1,3],[2,3],[3,1]]\n输出：-1\n\n\n1\n2\n\n\n提示：\n\n * 1 <= n <= 1000\n * 0 <= trust.length <= 104\n * trust[i].length == 2\n * trust 中的所有trust[i] = [ai, bi] 互不相同\n * ai != bi\n * 1 <= ai, bi <= n\n\n\n# 解题：\n\n\n# 方法一：计算各节点的入度和出度\n\n本题需要用到有向图中节点的入度和出度的概念。在有向图中，一个节点的入度是指向该节点的边的数量；而一个节点的出度是从该节点出发的边的数量。\n\n题干描述了一个有向图。每个人是图的节点，trust 的元素 trust[i] 是图的有向边，从 trust[i][0] 指向 trust[i][1]。我们可以遍历 trust，统计每个节点的入度和出度，存储在 indegrees 和 outdegrees 中。\n\n根据题意，在法官存在的情况下，法官不相信任何人，每个人（除了法官外）都信任法官，且只有一名法官。因此法官这个节点的入度是 n−1, 出度是 0。\n\n我们可以遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，我们可以直接返回结果；如果不存在符合条件的点，则返回 −1。\n\nclass solution {\npublic:\n    int findjudge(int n, vector<vector<int>>& trust) {\n        // 定义入度和出度数组\n        vector<int> indegrees(n + 1);\n        vector<int> outdegrees(n + 1);\n        // 遍历trust数组，计算入度和出度\n        for(auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++indegrees[y];\n            ++outdegrees[x];\n        }\n        // 遍历入度和出度数组，查找入度为n-1，出度为0的节点\n        for(int i = 1; i <= n; ++i) {\n            if(indegrees[i] == n-1 && outdegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n复杂度分析\n\n * 时间复杂度：o(n+m)，其中 m 是 trust 的长度。首先需要遍历 trust 计算出 indegrees 和 outdegrees，然后需要遍历 indegrees 和 outdegrees 来确定法官。\n\n * 空间复杂度：o(n)。记录各个节点的入度和出度需要 o(n) 的空间。\n\n可调试的代码：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass solution {\npublic:\n    int findjudge(int n, vector<vector<int>>& trust) {\n        // 定义入度和出度数组\n        vector<int> indegrees(n + 1);\n        vector<int> outdegrees(n + 1);\n        // 遍历trust数组，计算入度和出度\n        for(auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++indegrees[y];\n            ++outdegrees[x];\n        }\n        // 遍历入度和出度数组，查找入度为n-1，出度为0的节点\n        for(int i = 1; i <= n; ++i) {\n            if(indegrees[i] == n-1 && outdegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\nint main() {\n    solution solution;\n    // 小镇人数\n    int n = 4;\n    // 信任关系\n    vector<vector<int>> trust = {{1, 3}, {1, 4}, {2, 3}, {2, 4}, {4, 3}};\n    // 找到小镇法官\n    int judge = solution.findjudge(n, trust);\n    // 判断是否存在小镇法官\n    if (judge != -1) {\n        cout << "小镇法官的编号是: " << judge << endl;\n    } else {\n        cout << "没有找到小镇法官" << endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n',charsets:{cjk:!0}},{title:"Linux基础小结",frontmatter:{title:"Linux基础小结",date:"2023-06-16T16:36:11.000Z",permalink:"/pages/412fe7/"},regularPath:"/02.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/05.Linux/01.Linux%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93.html",relativePath:"02.计算机基础/05.Linux/01.Linux基础小结.md",key:"v-410564b4",path:"/pages/412fe7/",headers:[{level:2,title:"常见目录说明",slug:"常见目录说明",normalizedTitle:"常见目录说明",charIndex:12},{level:2,title:"Linux 常用指令",slug:"linux-常用指令",normalizedTitle:"linux 常用指令",charIndex:676},{level:3,title:"文件和目录操作",slug:"文件和目录操作",normalizedTitle:"文件和目录操作",charIndex:691},{level:4,title:"ls 指令",slug:"ls-指令",normalizedTitle:"ls 指令",charIndex:702},{level:4,title:"cd 指令",slug:"cd-指令",normalizedTitle:"cd 指令",charIndex:795},{level:4,title:"mkdir 指令",slug:"mkdir-指令",normalizedTitle:"mkdir 指令",charIndex:877},{level:4,title:"touch 指令",slug:"touch-指令",normalizedTitle:"touch 指令",charIndex:959},{level:4,title:"cp 指令",slug:"cp-指令",normalizedTitle:"cp 指令",charIndex:1034},{level:4,title:"mv 指令",slug:"mv-指令",normalizedTitle:"mv 指令",charIndex:1237},{level:4,title:"rm 指令",slug:"rm-指令",normalizedTitle:"rm 指令",charIndex:1443},{level:4,title:"cat 指令",slug:"cat-指令",normalizedTitle:"cat 指令",charIndex:1626},{level:4,title:"pwd 指令",slug:"pwd-指令",normalizedTitle:"pwd 指令",charIndex:1840},{level:4,title:"chmod 指令",slug:"chmod-指令",normalizedTitle:"chmod 指令",charIndex:1873},{level:3,title:"系统信息和进程管理",slug:"系统信息和进程管理",normalizedTitle:"系统信息和进程管理",charIndex:1981},{level:4,title:"uname 指令",slug:"uname-指令",normalizedTitle:"uname 指令",charIndex:1994},{level:4,title:"top 指令",slug:"top-指令",normalizedTitle:"top 指令",charIndex:2068},{level:4,title:"ps 指令",slug:"ps-指令",normalizedTitle:"ps 指令",charIndex:2105},{level:4,title:"kill 指令",slug:"kill-指令",normalizedTitle:"kill 指令",charIndex:2169},{level:4,title:"shutdown 指令",slug:"shutdown-指令",normalizedTitle:"shutdown 指令",charIndex:2247},{level:3,title:"网络操作",slug:"网络操作",normalizedTitle:"网络操作",charIndex:2360},{level:4,title:"ping 指令",slug:"ping-指令",normalizedTitle:"ping 指令",charIndex:2368},{level:4,title:"ifconfig 指令",slug:"ifconfig-指令",normalizedTitle:"ifconfig 指令",charIndex:2472},{level:4,title:"netstat 指令",slug:"netstat-指令",normalizedTitle:"netstat 指令",charIndex:2560},{level:4,title:"wget 指令",slug:"wget-指令",normalizedTitle:"wget 指令",charIndex:2645},{level:4,title:"scp 指令",slug:"scp-指令",normalizedTitle:"scp 指令",charIndex:2752},{level:3,title:"压缩和解压缩",slug:"压缩和解压缩",normalizedTitle:"压缩和解压缩",charIndex:2917},{level:4,title:"tar 指令",slug:"tar-指令",normalizedTitle:"tar 指令",charIndex:2927},{level:4,title:"gzip 指令",slug:"gzip-指令",normalizedTitle:"gzip 指令",charIndex:3046},{level:4,title:"unzip 指令",slug:"unzip-指令",normalizedTitle:"unzip 指令",charIndex:3158},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:568},{level:4,title:"man 指令",slug:"man-指令",normalizedTitle:"man 指令",charIndex:3266},{level:4,title:"history 指令",slug:"history-指令",normalizedTitle:"history 指令",charIndex:3337},{level:4,title:"grep 指令",slug:"grep-指令",normalizedTitle:"grep 指令",charIndex:3419},{level:4,title:"输出重定向",slug:"输出重定向",normalizedTitle:"输出重定向",charIndex:3526},{level:4,title:"df 指令",slug:"df-指令",normalizedTitle:"df 指令",charIndex:3771},{level:3,title:"部署时可能会用到",slug:"部署时可能会用到",normalizedTitle:"部署时可能会用到",charIndex:3823},{level:4,title:"free -h 指令",slug:"free-h-指令",normalizedTitle:"free -h 指令",charIndex:3835},{level:4,title:"nohup 指令",slug:"nohup-指令",normalizedTitle:"nohup 指令",charIndex:4231},{level:4,title:"jobs 指令",slug:"jobs-指令",normalizedTitle:"jobs 指令",charIndex:4974},{level:4,title:"netstat -ntlp 指令",slug:"netstat-ntlp-指令",normalizedTitle:"netstat -ntlp 指令",charIndex:5418},{level:4,title:"jps 命令",slug:"jps-命令",normalizedTitle:"jps 命令",charIndex:5891},{level:4,title:"df 指令",slug:"df-指令-2",normalizedTitle:"df 指令",charIndex:3771},{level:2,title:"vim 常用指令",slug:"vim-常用指令",normalizedTitle:"vim 常用指令",charIndex:6558},{level:3,title:"移动光标",slug:"移动光标",normalizedTitle:"移动光标",charIndex:6665},{level:3,title:"编辑文本",slug:"编辑文本",normalizedTitle:"编辑文本",charIndex:6776},{level:3,title:"搜索和替换",slug:"搜索和替换",normalizedTitle:"搜索和替换",charIndex:6896},{level:3,title:"保存和退出",slug:"保存和退出",normalizedTitle:"保存和退出",charIndex:7057},{level:2,title:"环境变量",slug:"环境变量",normalizedTitle:"环境变量",charIndex:7138}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"5 min read",minutes:4.28,time:256800,words:856},headersStr:"常见目录说明 Linux 常用指令 文件和目录操作 ls 指令 cd 指令 mkdir 指令 touch 指令 cp 指令 mv 指令 rm 指令 cat 指令 pwd 指令 chmod 指令 系统信息和进程管理 uname 指令 top 指令 ps 指令 kill 指令 shutdown 指令 网络操作 ping 指令 ifconfig 指令 netstat 指令 wget 指令 scp 指令 压缩和解压缩 tar 指令 gzip 指令 unzip 指令 其他 man 指令 history 指令 grep 指令 输出重定向 df 指令 部署时可能会用到 free -h 指令 nohup 指令 jobs 指令 netstat -ntlp 指令 jps 命令 df 指令 vim 常用指令 移动光标 编辑文本 搜索和替换 保存和退出 环境变量",content:'# Linux\n\n\n# 常见目录说明\n\n * /bin：存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；\n * /sbin: 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；\n * /etc：存放系统管理和配置文件；\n * /root：超级用户（系统管理员）的主目录；\n * /home：存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是 /home/user，可以用 ~user 表示；\n * /dev：用于存放设备文件；\n * /usr：用于存放系统应用程序；\n * /lib 和/lib64：存放着和系统运行相关的库文件；\n * /tmp：用于存放各种临时文件，是公用的临时文件存储点；\n * /var：用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等）等；\n * /opt：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；\n * /proc：虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；\n * /mnt：系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；\n * /boot：存放用于系统引导时使用的各种文件；\n * /lost+found：这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。\n\n\n# Linux 常用指令\n\n\n# 文件和目录操作\n\n# ls 指令\n\n作用：列出当前工作目录下的所有文件/文件夹的名称\n\n用法：ls [选项] [目录]\n\nls -l 路径（ll）：以详细列表的形式展示指定路径下的所有文件/文件夹名称\n\n# cd 指令\n\n作用：改变目录，进入用户输入的目录\n\n用法：cd [目录]\n\n示例：切换到 /usr/local 目录\n\ncd /usr/local\n\n\n1\n\n\n# mkdir 指令\n\n作用: 创建目录\n\n用法：mkdir [选项] 目录\n\nmkdir -p + 路径：当一次性创建多层不存在的目录的时候，添加 -p 参数\n\n# touch 指令\n\n作用：创建文件\n\n示例：在当前目录中创建一个名为 test.txt 的空文件\n\ntouch ./test.txt\n\n\n1\n\n\n# cp 指令\n\n作用：复制文件或目录\n\n用法：cp [选项] 被复制的文档路径 文档被复制到的路径\n\n示例：\n\n1、复制文件\n\n将当前目录的 test.txt 文件复制到上个工作目录中\n\ncp ./test.txt ../test.txt \n\n\n1\n\n\n2、复制文件夹\n\n利用 -r 参数，将当前工作目录的 test 文件夹复制到上一个工作目录下\n\ncp -r ./test ../test\n\n\n1\n\n\n# mv 指令\n\n作用：移动文件或目录，也可以重命名文件或目录\n\n用法：mv [选项] 源文件路径 需要保存的位置路径\n\n注意：使用 mv 移动文件语法格式和移动文件夹相同，移动文件夹不需要加 -r\n\n示例：\n\n将当前目录中的 test.txt 文件移动到 /usr/local 目录中，并重命名为 new_test.txt\n\nmv test.txt /usr/local/new_test.txt\n\n\n1\n\n\n# rm 指令\n\n作用：删除文件或目录\n\n用法：rm [选项] 文件或目录\n\n选项：\n\n-f：force，强制删除，否则会每个文件都询问是否删除\n\n-r：表示递归，移除文件夹的时候需要使用\n\n示例：\n\n删除当前目录中的 test.txt 文件\n\nrm test.txt\n\n\n1\n\n\n删除指定目录及其内的全部子文件，一并都强制删除\n\nrm -rf Dir\n\n\n1\n\n\n# cat 指令\n\n作用：\n\n 1. 查看文件内容\n\n 2. 对两个文件进行合并\n\n用法：\n\n 1. cat 文件的路径\n 2. cat 待合并的文件路径1 待合并的文件路径2 …. 文件路径n > 合并之后的文件路径\n\n示例：\n\n查看当前目录中的 test.txt 文件的内容\n\ncat test.txt\n\n\n1\n\n\n合并路径\n\ncat ./test1.txt ./test2.txt > ./test3.txt\n\n\n1\n\n\n# pwd 指令\n\n作用：查看当前工作目录路径\n\n用法：pwd\n\n# chmod 指令\n\n作用: 修改文件权限\n\n用法：chmod [选项] 权限 文件或目录\n\n示例：\n\n将当前目录中的 test.txt 文件的权限设置为只读\n\nchmod 444 test.txt\n\n\n1\n\n\n\n# 系统信息和进程管理\n\n# uname 指令\n\n作用：查看系统信息\n\n用法：uname [选项]\n\n示例：\n\n查看系统的操作系统名称和版本\n\nuname -a\n\n\n1\n\n\n# top 指令\n\n作用: 查看系统进程和资源占用情况\n\n用法：top\n\n# ps 指令\n\n作用: 查看当前用户进程\n\n用法：ps [选项]\n\n示例：查看当前用户的所有进程\n\nps -ef\n\n\n1\n\n\n# kill 指令\n\n作用：结束一个进程\n\n用法：kill [选项] 进程号\n\n示例：\n\n结束进程号为 1234 的进程\n\nkill 1234\n\n\n1\n\n\n# shutdown 指令\n\n作用：关机或重启系统\n\n用法：shutdown [选项]\n\n示例：\n\n将系统立即关机\n\nshutdown -h now\n\n\n1\n\n\n将系统立即重启\n\nshutdown -r now\n\n\n1\n\n\n\n# 网络操作\n\n# ping 指令\n\n作用：测试网络连接是否通畅\n\n用法：ping [选项] 目标地址\n\n示例：\n\n测试目标地址 www.google.com 是否可达\n\nping www.google.com\n\n\n1\n\n\n# ifconfig 指令\n\n作用: 查看网络接口信息\n\n用法：ifconfig [选项]\n\n示例：\n\n查看当前系统中所有网络接口的信息\n\nifconfig -a\n\n\n1\n\n\n# netstat 指令\n\n作用: 查看网络连接状态\n\n用法：netstat [选项]\n\n示例：\n\n查看当前系统中所有网络连接的状态\n\nnetstat -a\n\n\n1\n\n\n# wget 指令\n\n作用: 下载文件\n\n用法：wget [选项] URL\n\n示例：\n\n下载指定 URL 的文件并保存到当前目录中\n\nwget https://example.com/file.zip\n\n\n1\n\n\n# scp 指令\n\n作用: 在不同的主机之间拷贝文件\n\n用法：scp [选项] 源文件 目标主机:目标路径\n\n示例：\n\n将当前目录中的 test.txt 文件拷贝到远程主机 example.com 的 /home/user 目录中\n\nscp test.txt user@example.com:/home/user\n\n\n1\n\n\n\n# 压缩和解压缩\n\n# tar 指令\n\n作用: 压缩和解压缩文件和目录\n\n用法：tar [选项] 文件或目录\n\n示例：\n\n将当前目录中的所有文件和目录压缩成一个名为 archive.tar 的文件\n\ntar -cvf archive.tar *\n\n\n1\n\n\n# gzip 指令\n\n作用：压缩和解压缩文件\n\n用法：gzip [选项] 文件\n\n示例：\n\n将当前目录中的 test.txt 文件压缩成一个名为 test.txt.gz 的压缩文件\n\ngzip test.txt\n\n\n1\n\n\n# unzip 指令\n\n作用：解压缩 zip 文件\n\n用法：unzip [选项] 文件.zip\n\n示例：\n\n解压缩名为 archive.zip 的文件\n\nunzip archive.zip\n\n\n1\n\n\n\n# 其他\n\n# man 指令\n\n作用: 查看指令的帮助手册\n\n用法：man [指令]\n\n示例：\n\n查看 ls 命令的帮助手册\n\nman ls\n\n\n1\n\n\n# history 指令\n\n作用: 查看历史命令\n\n用法：history [选项]\n\n示例：\n\n查看当前用户执行过的所有命令历史记录\n\nhistory\n\n\n1\n\n\n# grep 指令\n\n作用: 在文件中搜索指定字符串\n\n用法：grep [选项] 字符串 文件\n\n示例：\n\n在当前目录中的所有文件中搜索包含字符串 example 的行\n\ngrep example *\n\n\n1\n\n\n# 输出重定向\n\n作用：将一些命令的执行结果保存到文件中\n\n用法：正常执行的指令 （> 或 >>） 文件的路径\n\n 1. >：覆盖输出，会覆盖掉原先的文件内容\n 2. >>：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加\n\n示例：\n\n使用覆盖重定向，将 ls -la 的执行结果，保存到当前目录下的 ls.txt\n\nls -la > ls.txt \n\n\n1\n\n\n使用追加重定向，将 ls -la 的执行结果追加到 ls.txt 中\n\nls -la >> ls.txt\n\n\n1\n\n\n# df 指令\n\n作用：查看磁盘的空间\n\n用法：df -h\n\n-h：表示以可读性较高的形式展示大小\n\n\n# 部署时可能会用到\n\n# free -h 指令\n\n作用：用于显示系统的内存使用情况。\n\n              total        used        free      shared  buff/cache   available\nMem:           7.8G        3.9G        1.1G        254M        2.8G        3.3G\nSwap:          2.0G        1.2G        830M\n\n\n\n1\n2\n3\n4\n\n * total: 系统内存总量。\n * used: 已使用的内存量。\n * free: 可用的空闲内存量。\n * shared: 被共享的内存量。\n * buff/cache: 用于缓冲区和缓存的内存量。\n * available: 系统可用的内存量，它包括空闲内存、缓冲区和缓存的内存。\n\n# nohup 指令\n\n作用：用于在后台运行程序，并且不受终端关闭影响。它的作用是将程序的标准输出和标准错误输出重定向到一个名为 nohup.out 的文件中，这样即使终端关闭，程序仍然可以继续在后台运行。\n\n例如：nohup java -jar /root/services/user-center-backend/target/user-center-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod &\n\n 1. java -jar /root/services/user-center-backend/target/user-center-0.0.1-SNAPSHOT.jar: 这部分是运行 Java 应用程序的命令。java是 Java 的运行命令，-jar表示要运行的是一个可执行的 JAR 文件，后面紧跟着 JAR 文件的路径/root/services/user-center-backend/target/user-center-0.0.1-SNAPSHOT.jar，这是一个 Java 可执行文件。\n 2. --spring.profiles.active=prod: 这部分是 Spring Boot 应用程序的参数，用于指定使用哪个配置文件。在这里，prod是一个配置文件的名称，表示使用生产环境的配置。\n 3. &: 是 Linux 中的后台运行符号，它使得命令在后台运行，而不阻塞当前终端。这样可以让 Java 应用程序在后台持续运行，即使终端关闭也不会影响它。\n\n综合起来，这行代码的作用是在 Linux 系统下以生产环境的配置运行一个 Java 应用程序，并将其放在后台持续运行，不受终端关闭的影响。\n\n# jobs 指令\n\n作用：用于显示当前终端（shell会话）中正在运行或挂起的作业（进程）列表。\n\n当你在终端中运行一个命令并在后台使用 & 运行时，该命令就成为一个作业。jobs命令可以列出这些作业，以及它们的状态。\n\n输出通常会显示每个作业的编号（Job ID）、状态、命令和作业编号（Process ID）等信息。作业状态可能有以下几种：\n\n * Running: 作业正在前台或后台运行。\n * Stopped: 作业被挂起（暂停）。\n * Done: 作业已完成。\n\n你可以使用fg（foreground）和bg（background）命令来控制作业的前台和后台运行。例如，使用fg命令可以将一个后台作业切换到前台运行，而使用bg命令可以将一个前台作业切换到后台运行。\n\n如果要结束一个作业，可以使用kill命令，加上作业的编号或进程编号。\n\n请注意，jobs命令只显示当前终端会话中的作业，如果你在另一个终端窗口中运行作业，则在当前终端中使用jobs是看不到这些作业的。\n\n# netstat -ntlp 指令\n\n作用：用于查看当前系统上的网络连接和监听端口信息。以下是该命令的解释：\n\n * netstat: 是网络统计（network statistics）的缩写，用于显示网络连接信息和统计数据。\n * -n: 指定显示网络地址和端口号时不进行反向域名解析，以 IP 地址和端口号的形式显示，而不是域名和服务名。\n * -t: 仅显示 TCP 协议相关的网络连接信息。\n * -l: 仅显示监听状态（LISTEN）的网络连接信息，即显示系统正在监听的端口。\n * -p: 显示与网络连接相关的进程信息，包括进程的 PID（Process ID）和进程的名称。\n\n执行netstat -ntlp命令后，将会列出所有当前系统上正在监听的 TCP 端口，并显示与这些端口相关联的进程信息。这对于查看哪些服务正在监听哪些端口以及是否存在非常有用。例如，你可以通过这个命令来查看 Web 服务器（如 Apache、Nginx）是否正在监听 80 端口，或者数据库服务器（如 MySQL）是否正在监听 3306 端口。\n\n\n\n# jps 命令\n\njps 是 Java Virtual Machine Process Status Tool 的缩写，是 JDK（Java Development Kit）中的一个命令行工具。它用于列出当前系统上所有正在运行的 Java 进程的进程 ID（PID）和主类名称。\n\n执行jps命令后，将会显示当前系统上所有正在运行的 Java 进程的信息，包括它们的 PID 和对应的主类名称。通常用于在命令行中快速查看正在运行的 Java 进程，方便开发者进行进程管理和调试。\n\n例如，执行jps命令可能会输出类似以下的结果：\n\n1234 MyApp\n5678 AnotherApp\n\n\n1\n2\n\n\n其中，1234和5678是 Java 进程的 PID，MyApp和AnotherApp是对应的 Java 主类名称。\n\n# df 指令\n\ndf -h 是一个常用的 Linux/Unix 命令，用于显示磁盘空间使用情况，并以易读的方式（以 KB、MB、GB 等单位）显示输出结果。\n\n具体来说，df 表示 "disk free"，用于显示文件系统的磁盘空间信息。而 -h 选项表示 "human-readable"，使得输出结果以易读的方式呈现，比如使用 KB、MB、GB 等单位，而不是以字节为单位。\n\n当你在终端中运行 df -h 命令时，它将显示所有挂载点的磁盘空间使用情况，包括总容量、已用空间、可用空间、使用百分比和挂载点等信息。这对于查看磁盘的使用情况很有帮助，可以帮助你了解哪些磁盘分区或挂载点占用了最多的空间。\n\n\n# vim 常用指令\n\n作用：打开并进入一个文件（文件可以不存在，会自动创建）\n\n用法：vim 文件的路径\n\n示例：\n\n打开进入当前目录下的 test.txt 文件\n\nvim ./test.txt \n\n\n1\n\n\n\n# 移动光标\n\n * h: 左移一个字符\n * j: 下移一行\n * k: 上移一行\n * l: 右移一个字符\n * ^: 移动到行首\n * $: 移动到行尾\n * gg: 移动到文档开头\n * G: 移动到文档结尾\n\n\n# 编辑文本\n\n * i: 插入文本，光标会进入插入模式，可以输入文本\n * a: 在光标后插入文本\n * o: 在当前行的下一行插入新行，并进入插入模式\n * dd: 删除当前行\n * yy: 复制当前行\n * p: 粘贴复制的文本\n\n\n# 搜索和替换\n\n * /pattern: 向下搜索 pattern\n * ?pattern: 向上搜索 pattern\n * n: 下一个匹配项\n * N: 上一个匹配项\n * 😒/old/new/g: 替换当前行中所有 old 为new\n * :%s/old/new/g: 替换整个文档中所有 old 为new\n\n\n# 保存和退出\n\n * :w: 保存当前文件\n * :wq: 保存并退出\n * :q: 退出（如果没有更改过文件内容）\n * :q!: 强制退出，不保存更改\n\n\n# 环境变量\n\n进入环境变量文件\n\nvim /etc/profile\n\n\n1\n\n\n修改完成后，用 source 命令使其生效\n\nsource /etc/profile\n\n\n1\n',normalizedContent:'# linux\n\n\n# 常见目录说明\n\n * /bin：存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；\n * /sbin: 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；\n * /etc：存放系统管理和配置文件；\n * /root：超级用户（系统管理员）的主目录；\n * /home：存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是 /home/user，可以用 ~user 表示；\n * /dev：用于存放设备文件；\n * /usr：用于存放系统应用程序；\n * /lib 和/lib64：存放着和系统运行相关的库文件；\n * /tmp：用于存放各种临时文件，是公用的临时文件存储点；\n * /var：用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等）等；\n * /opt：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；\n * /proc：虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；\n * /mnt：系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；\n * /boot：存放用于系统引导时使用的各种文件；\n * /lost+found：这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。\n\n\n# linux 常用指令\n\n\n# 文件和目录操作\n\n# ls 指令\n\n作用：列出当前工作目录下的所有文件/文件夹的名称\n\n用法：ls [选项] [目录]\n\nls -l 路径（ll）：以详细列表的形式展示指定路径下的所有文件/文件夹名称\n\n# cd 指令\n\n作用：改变目录，进入用户输入的目录\n\n用法：cd [目录]\n\n示例：切换到 /usr/local 目录\n\ncd /usr/local\n\n\n1\n\n\n# mkdir 指令\n\n作用: 创建目录\n\n用法：mkdir [选项] 目录\n\nmkdir -p + 路径：当一次性创建多层不存在的目录的时候，添加 -p 参数\n\n# touch 指令\n\n作用：创建文件\n\n示例：在当前目录中创建一个名为 test.txt 的空文件\n\ntouch ./test.txt\n\n\n1\n\n\n# cp 指令\n\n作用：复制文件或目录\n\n用法：cp [选项] 被复制的文档路径 文档被复制到的路径\n\n示例：\n\n1、复制文件\n\n将当前目录的 test.txt 文件复制到上个工作目录中\n\ncp ./test.txt ../test.txt \n\n\n1\n\n\n2、复制文件夹\n\n利用 -r 参数，将当前工作目录的 test 文件夹复制到上一个工作目录下\n\ncp -r ./test ../test\n\n\n1\n\n\n# mv 指令\n\n作用：移动文件或目录，也可以重命名文件或目录\n\n用法：mv [选项] 源文件路径 需要保存的位置路径\n\n注意：使用 mv 移动文件语法格式和移动文件夹相同，移动文件夹不需要加 -r\n\n示例：\n\n将当前目录中的 test.txt 文件移动到 /usr/local 目录中，并重命名为 new_test.txt\n\nmv test.txt /usr/local/new_test.txt\n\n\n1\n\n\n# rm 指令\n\n作用：删除文件或目录\n\n用法：rm [选项] 文件或目录\n\n选项：\n\n-f：force，强制删除，否则会每个文件都询问是否删除\n\n-r：表示递归，移除文件夹的时候需要使用\n\n示例：\n\n删除当前目录中的 test.txt 文件\n\nrm test.txt\n\n\n1\n\n\n删除指定目录及其内的全部子文件，一并都强制删除\n\nrm -rf dir\n\n\n1\n\n\n# cat 指令\n\n作用：\n\n 1. 查看文件内容\n\n 2. 对两个文件进行合并\n\n用法：\n\n 1. cat 文件的路径\n 2. cat 待合并的文件路径1 待合并的文件路径2 …. 文件路径n > 合并之后的文件路径\n\n示例：\n\n查看当前目录中的 test.txt 文件的内容\n\ncat test.txt\n\n\n1\n\n\n合并路径\n\ncat ./test1.txt ./test2.txt > ./test3.txt\n\n\n1\n\n\n# pwd 指令\n\n作用：查看当前工作目录路径\n\n用法：pwd\n\n# chmod 指令\n\n作用: 修改文件权限\n\n用法：chmod [选项] 权限 文件或目录\n\n示例：\n\n将当前目录中的 test.txt 文件的权限设置为只读\n\nchmod 444 test.txt\n\n\n1\n\n\n\n# 系统信息和进程管理\n\n# uname 指令\n\n作用：查看系统信息\n\n用法：uname [选项]\n\n示例：\n\n查看系统的操作系统名称和版本\n\nuname -a\n\n\n1\n\n\n# top 指令\n\n作用: 查看系统进程和资源占用情况\n\n用法：top\n\n# ps 指令\n\n作用: 查看当前用户进程\n\n用法：ps [选项]\n\n示例：查看当前用户的所有进程\n\nps -ef\n\n\n1\n\n\n# kill 指令\n\n作用：结束一个进程\n\n用法：kill [选项] 进程号\n\n示例：\n\n结束进程号为 1234 的进程\n\nkill 1234\n\n\n1\n\n\n# shutdown 指令\n\n作用：关机或重启系统\n\n用法：shutdown [选项]\n\n示例：\n\n将系统立即关机\n\nshutdown -h now\n\n\n1\n\n\n将系统立即重启\n\nshutdown -r now\n\n\n1\n\n\n\n# 网络操作\n\n# ping 指令\n\n作用：测试网络连接是否通畅\n\n用法：ping [选项] 目标地址\n\n示例：\n\n测试目标地址 www.google.com 是否可达\n\nping www.google.com\n\n\n1\n\n\n# ifconfig 指令\n\n作用: 查看网络接口信息\n\n用法：ifconfig [选项]\n\n示例：\n\n查看当前系统中所有网络接口的信息\n\nifconfig -a\n\n\n1\n\n\n# netstat 指令\n\n作用: 查看网络连接状态\n\n用法：netstat [选项]\n\n示例：\n\n查看当前系统中所有网络连接的状态\n\nnetstat -a\n\n\n1\n\n\n# wget 指令\n\n作用: 下载文件\n\n用法：wget [选项] url\n\n示例：\n\n下载指定 url 的文件并保存到当前目录中\n\nwget https://example.com/file.zip\n\n\n1\n\n\n# scp 指令\n\n作用: 在不同的主机之间拷贝文件\n\n用法：scp [选项] 源文件 目标主机:目标路径\n\n示例：\n\n将当前目录中的 test.txt 文件拷贝到远程主机 example.com 的 /home/user 目录中\n\nscp test.txt user@example.com:/home/user\n\n\n1\n\n\n\n# 压缩和解压缩\n\n# tar 指令\n\n作用: 压缩和解压缩文件和目录\n\n用法：tar [选项] 文件或目录\n\n示例：\n\n将当前目录中的所有文件和目录压缩成一个名为 archive.tar 的文件\n\ntar -cvf archive.tar *\n\n\n1\n\n\n# gzip 指令\n\n作用：压缩和解压缩文件\n\n用法：gzip [选项] 文件\n\n示例：\n\n将当前目录中的 test.txt 文件压缩成一个名为 test.txt.gz 的压缩文件\n\ngzip test.txt\n\n\n1\n\n\n# unzip 指令\n\n作用：解压缩 zip 文件\n\n用法：unzip [选项] 文件.zip\n\n示例：\n\n解压缩名为 archive.zip 的文件\n\nunzip archive.zip\n\n\n1\n\n\n\n# 其他\n\n# man 指令\n\n作用: 查看指令的帮助手册\n\n用法：man [指令]\n\n示例：\n\n查看 ls 命令的帮助手册\n\nman ls\n\n\n1\n\n\n# history 指令\n\n作用: 查看历史命令\n\n用法：history [选项]\n\n示例：\n\n查看当前用户执行过的所有命令历史记录\n\nhistory\n\n\n1\n\n\n# grep 指令\n\n作用: 在文件中搜索指定字符串\n\n用法：grep [选项] 字符串 文件\n\n示例：\n\n在当前目录中的所有文件中搜索包含字符串 example 的行\n\ngrep example *\n\n\n1\n\n\n# 输出重定向\n\n作用：将一些命令的执行结果保存到文件中\n\n用法：正常执行的指令 （> 或 >>） 文件的路径\n\n 1. >：覆盖输出，会覆盖掉原先的文件内容\n 2. >>：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加\n\n示例：\n\n使用覆盖重定向，将 ls -la 的执行结果，保存到当前目录下的 ls.txt\n\nls -la > ls.txt \n\n\n1\n\n\n使用追加重定向，将 ls -la 的执行结果追加到 ls.txt 中\n\nls -la >> ls.txt\n\n\n1\n\n\n# df 指令\n\n作用：查看磁盘的空间\n\n用法：df -h\n\n-h：表示以可读性较高的形式展示大小\n\n\n# 部署时可能会用到\n\n# free -h 指令\n\n作用：用于显示系统的内存使用情况。\n\n              total        used        free      shared  buff/cache   available\nmem:           7.8g        3.9g        1.1g        254m        2.8g        3.3g\nswap:          2.0g        1.2g        830m\n\n\n\n1\n2\n3\n4\n\n * total: 系统内存总量。\n * used: 已使用的内存量。\n * free: 可用的空闲内存量。\n * shared: 被共享的内存量。\n * buff/cache: 用于缓冲区和缓存的内存量。\n * available: 系统可用的内存量，它包括空闲内存、缓冲区和缓存的内存。\n\n# nohup 指令\n\n作用：用于在后台运行程序，并且不受终端关闭影响。它的作用是将程序的标准输出和标准错误输出重定向到一个名为 nohup.out 的文件中，这样即使终端关闭，程序仍然可以继续在后台运行。\n\n例如：nohup java -jar /root/services/user-center-backend/target/user-center-0.0.1-snapshot.jar --spring.profiles.active=prod &\n\n 1. java -jar /root/services/user-center-backend/target/user-center-0.0.1-snapshot.jar: 这部分是运行 java 应用程序的命令。java是 java 的运行命令，-jar表示要运行的是一个可执行的 jar 文件，后面紧跟着 jar 文件的路径/root/services/user-center-backend/target/user-center-0.0.1-snapshot.jar，这是一个 java 可执行文件。\n 2. --spring.profiles.active=prod: 这部分是 spring boot 应用程序的参数，用于指定使用哪个配置文件。在这里，prod是一个配置文件的名称，表示使用生产环境的配置。\n 3. &: 是 linux 中的后台运行符号，它使得命令在后台运行，而不阻塞当前终端。这样可以让 java 应用程序在后台持续运行，即使终端关闭也不会影响它。\n\n综合起来，这行代码的作用是在 linux 系统下以生产环境的配置运行一个 java 应用程序，并将其放在后台持续运行，不受终端关闭的影响。\n\n# jobs 指令\n\n作用：用于显示当前终端（shell会话）中正在运行或挂起的作业（进程）列表。\n\n当你在终端中运行一个命令并在后台使用 & 运行时，该命令就成为一个作业。jobs命令可以列出这些作业，以及它们的状态。\n\n输出通常会显示每个作业的编号（job id）、状态、命令和作业编号（process id）等信息。作业状态可能有以下几种：\n\n * running: 作业正在前台或后台运行。\n * stopped: 作业被挂起（暂停）。\n * done: 作业已完成。\n\n你可以使用fg（foreground）和bg（background）命令来控制作业的前台和后台运行。例如，使用fg命令可以将一个后台作业切换到前台运行，而使用bg命令可以将一个前台作业切换到后台运行。\n\n如果要结束一个作业，可以使用kill命令，加上作业的编号或进程编号。\n\n请注意，jobs命令只显示当前终端会话中的作业，如果你在另一个终端窗口中运行作业，则在当前终端中使用jobs是看不到这些作业的。\n\n# netstat -ntlp 指令\n\n作用：用于查看当前系统上的网络连接和监听端口信息。以下是该命令的解释：\n\n * netstat: 是网络统计（network statistics）的缩写，用于显示网络连接信息和统计数据。\n * -n: 指定显示网络地址和端口号时不进行反向域名解析，以 ip 地址和端口号的形式显示，而不是域名和服务名。\n * -t: 仅显示 tcp 协议相关的网络连接信息。\n * -l: 仅显示监听状态（listen）的网络连接信息，即显示系统正在监听的端口。\n * -p: 显示与网络连接相关的进程信息，包括进程的 pid（process id）和进程的名称。\n\n执行netstat -ntlp命令后，将会列出所有当前系统上正在监听的 tcp 端口，并显示与这些端口相关联的进程信息。这对于查看哪些服务正在监听哪些端口以及是否存在非常有用。例如，你可以通过这个命令来查看 web 服务器（如 apache、nginx）是否正在监听 80 端口，或者数据库服务器（如 mysql）是否正在监听 3306 端口。\n\n\n\n# jps 命令\n\njps 是 java virtual machine process status tool 的缩写，是 jdk（java development kit）中的一个命令行工具。它用于列出当前系统上所有正在运行的 java 进程的进程 id（pid）和主类名称。\n\n执行jps命令后，将会显示当前系统上所有正在运行的 java 进程的信息，包括它们的 pid 和对应的主类名称。通常用于在命令行中快速查看正在运行的 java 进程，方便开发者进行进程管理和调试。\n\n例如，执行jps命令可能会输出类似以下的结果：\n\n1234 myapp\n5678 anotherapp\n\n\n1\n2\n\n\n其中，1234和5678是 java 进程的 pid，myapp和anotherapp是对应的 java 主类名称。\n\n# df 指令\n\ndf -h 是一个常用的 linux/unix 命令，用于显示磁盘空间使用情况，并以易读的方式（以 kb、mb、gb 等单位）显示输出结果。\n\n具体来说，df 表示 "disk free"，用于显示文件系统的磁盘空间信息。而 -h 选项表示 "human-readable"，使得输出结果以易读的方式呈现，比如使用 kb、mb、gb 等单位，而不是以字节为单位。\n\n当你在终端中运行 df -h 命令时，它将显示所有挂载点的磁盘空间使用情况，包括总容量、已用空间、可用空间、使用百分比和挂载点等信息。这对于查看磁盘的使用情况很有帮助，可以帮助你了解哪些磁盘分区或挂载点占用了最多的空间。\n\n\n# vim 常用指令\n\n作用：打开并进入一个文件（文件可以不存在，会自动创建）\n\n用法：vim 文件的路径\n\n示例：\n\n打开进入当前目录下的 test.txt 文件\n\nvim ./test.txt \n\n\n1\n\n\n\n# 移动光标\n\n * h: 左移一个字符\n * j: 下移一行\n * k: 上移一行\n * l: 右移一个字符\n * ^: 移动到行首\n * $: 移动到行尾\n * gg: 移动到文档开头\n * g: 移动到文档结尾\n\n\n# 编辑文本\n\n * i: 插入文本，光标会进入插入模式，可以输入文本\n * a: 在光标后插入文本\n * o: 在当前行的下一行插入新行，并进入插入模式\n * dd: 删除当前行\n * yy: 复制当前行\n * p: 粘贴复制的文本\n\n\n# 搜索和替换\n\n * /pattern: 向下搜索 pattern\n * ?pattern: 向上搜索 pattern\n * n: 下一个匹配项\n * n: 上一个匹配项\n * 😒/old/new/g: 替换当前行中所有 old 为new\n * :%s/old/new/g: 替换整个文档中所有 old 为new\n\n\n# 保存和退出\n\n * :w: 保存当前文件\n * :wq: 保存并退出\n * :q: 退出（如果没有更改过文件内容）\n * :q!: 强制退出，不保存更改\n\n\n# 环境变量\n\n进入环境变量文件\n\nvim /etc/profile\n\n\n1\n\n\n修改完成后，用 source 命令使其生效\n\nsource /etc/profile\n\n\n1\n',charsets:{cjk:!0}},{title:"数据库基础知识小结",frontmatter:{title:"数据库基础知识小结",date:"2023-07-23T23:00:07.000Z",permalink:"/pages/efa3f2/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93.html",relativePath:"03.数据库/01.基础/01.数据库基础知识小结.md",key:"v-27236994",path:"/pages/efa3f2/",headers:[{level:2,title:"什么是数据库，数据库管理员，数据库管理员，数据库系统？",slug:"什么是数据库-数据库管理员-数据库管理员-数据库系统",normalizedTitle:"什么是数据库，数据库管理员，数据库管理员，数据库系统？",charIndex:16},{level:2,title:"什么是元组，码，候选码，主码，外码，主属性，非主属性？",slug:"什么是元组-码-候选码-主码-外码-主属性-非主属性",normalizedTitle:"什么是元组，码，候选码，主码，外码，主属性，非主属性？",charIndex:316},{level:2,title:"什么是 ER 图？",slug:"什么是-er-图",normalizedTitle:"什么是 er 图？",charIndex:936},{level:2,title:"讲讲数据库范式",slug:"讲讲数据库范式",normalizedTitle:"讲讲数据库范式",charIndex:1385},{level:2,title:"主键和外键有什么区别?",slug:"主键和外键有什么区别",normalizedTitle:"主键和外键有什么区别?",charIndex:2446},{level:2,title:"为什么不推荐使用外键与级联？",slug:"为什么不推荐使用外键与级联",normalizedTitle:"为什么不推荐使用外键与级联？",charIndex:2572},{level:2,title:"什么是存储过程？",slug:"什么是存储过程",normalizedTitle:"什么是存储过程？",charIndex:3682},{level:2,title:"drop、delete 与 truncate 区别？",slug:"drop、delete-与-truncate-区别",normalizedTitle:"drop、delete 与 truncate 区别？",charIndex:4250},{level:2,title:"数据库设计通常分为哪几步？",slug:"数据库设计通常分为哪几步",normalizedTitle:"数据库设计通常分为哪几步？",charIndex:5309},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:5545}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.945,time:116700,words:389},headersStr:"什么是数据库，数据库管理员，数据库管理员，数据库系统？ 什么是元组，码，候选码，主码，外码，主属性，非主属性？ 什么是 ER 图？ 讲讲数据库范式 主键和外键有什么区别? 为什么不推荐使用外键与级联？ 什么是存储过程？ drop、delete 与 truncate 区别？ 数据库设计通常分为哪几步？ 参考",content:"# 数据库基础知识小结\n\n\n# 什么是数据库，数据库管理员，数据库管理员，数据库系统？\n\n数据库: 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。\n\n数据库管理系统: 数据库管理系统(DataBase Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。\n\n数据库管理员: 数据库管理员(DataBase Administrator, 简称 DBA)负责全面管理和控制数据库系统。\n\n数据库系统: 数据库系统(DataBase System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。\n\n\n# 什么是元组，码，候选码，主码，外码，主属性，非主属性？\n\n * 元组：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。在二维表里，元组也称为行。\n * 码：码就是能唯一标识实体的属性，对应表中的列。\n * 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。\n * 主码: 主码也叫主键。主码是从候选码中选出来的。一个实体集中只能有一个主码，但可以有多个候选码。\n * 外码: 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。\n * 主属性：候选码中出现过的属性称为主属性。比如工人表（工号，身份证号，姓名，性别，部门），显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。\n * 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。\n\n关系 -- 表，行 -- 行，属性 -- 列\n\n\n# 什么是 ER 图？\n\nER 图 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。\n\nER 图由下面 3 个要素组成：\n\n * 实体：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。\n * 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。\n * 联系：即实体与实体之间的关系，在 ER 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。（一对多关系）\n\nER 图示例：学生选课\n\n每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1:N）。\n\n\n\n\n# 讲讲数据库范式\n\n数据库范式是用于规范化数据库设计的一组规则，旨在消除数据冗余、提高数据存储效率和数据完整性。\n\n数据库范式有 3 种：\n\n * 1NF(第一范式)：属性不可再分。\n * 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。\n * 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖。\n\n重要概念详解：\n\n> 函数依赖（Functional Dependency）：\n\n函数依赖是指在一个关系（表）中，一个或多个属性的值可以唯一确定其他属性的值。在关系中，一个属性（或属性组合）称为决定因素（Determinant），其他属性称为依赖因素（Dependent）。如果在关系 R 中，X 是决定因素，Y 是依赖因素，并且对于任意两个元组 t1 和 t2，如果 t1 的 X 值相等于 t2 的 X 值，则它们的 Y 值也必须相等，那么我们可以说 Y 函数依赖于 X，用符号表示为 X -> Y。\n\n> 部分函数依赖（Partial Functional Dependency）：\n\n部分函数依赖是指在一个关系中，一个属性（或属性组合）依赖于另一个属性（或属性组合），但是该属性（或属性组合）只依赖于决定因素的一部分而不是全部。换句话说，存在非主属性依赖于候选码的一部分。\n\n例如，考虑一个关系 R (学号, 姓名, 班级, 年龄)，假设学号是主属性（候选码），姓名和班级依赖于学号，但是年龄只依赖于班级，而不是学号，那么年龄对于班级是部分函数依赖。\n\n> 完全函数依赖（Full Functional Dependency）：\n\n完全函数依赖是指在一个关系中，一个属性（或属性组合）依赖于另一个属性（或属性组合），且该属性（或属性组合）对于决定因素是完全依赖的，没有部分依赖。换句话说，所有的非主属性都完全依赖于候选码。\n\n继续上述例子，如果年龄只依赖于学号，而不依赖于班级，那么年龄对于学号就是完全函数依赖。\n\n> 传递函数依赖（Transitive Functional Dependency）：\n\n传递函数依赖是指在一个关系中，如果 X -> Y 且 Y -> Z，则可以推导出 X -> Z。换句话说，如果存在函数依赖 X -> Y 和 Y -> Z，那么就存在传递函数依赖 X -> Z。\n\n例如，考虑一个关系 R (学号, 姓名, 班级, 学校)，假设学号决定了姓名，姓名决定了班级，那么就存在传递函数依赖 学号 -> 班级。\n\n\n# 主键和外键有什么区别?\n\n * 主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。\n * 外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。\n\n\n# 为什么不推荐使用外键与级联？\n\n阿里巴巴开发手册：\n\n> 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n> \n> 说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风险; 外键影响数据库的插入速度\n\n原因：\n\n 1. 数据库性能：使用外键和级联操作可能会导致数据库性能下降。级联操作会引起多表之间的复杂关联和更新操作，可能增加数据库的负担，特别是在大规模数据库和高并发情况下。\n 2. 数据库复杂性：外键和级联操作会增加数据库的复杂性。当数据库结构涉及多个表之间的关联关系时，外键和级联操作可能增加数据管理和维护的复杂性，不适用于简单的数据库结构。\n 3. 数据库死锁：使用级联操作时，可能会引发数据库死锁问题。如果多个表之间存在循环级联更新或删除操作，可能导致死锁情况，影响数据库的正常运行。\n 4. 数据一致性：级联操作可能导致数据一致性问题。当使用级联操作时，可能会导致意外删除或更新关联的数据，从而影响数据库的数据一致性。\n 5. 增加了复杂性（每次做 DELETE 或者 UPDATE 都必须考虑外键约束）\n 6. 对分库分表不友好（因为分库分表下外键是无法生效的）\n\n使用外键的好处：\n\n * 数据完整性：外键可以确保数据库中的数据完整性。通过在一个表中引用另一个表的主键作为外键，可以确保两个表之间的关联关系是有效的。这样可以防止数据不一致和无效数据的插入，保持数据库的一致性。\n * 数据一致性：外键可以帮助维护数据库中的数据一致性。当对主表的数据进行更新或删除操作时，有了外键约束，数据库会自动检查关联的从表是否有相应的数据，并执行相应的操作，避免了数据的不一致性。\n * 数据查询和连接：使用外键可以更方便地进行数据查询和连接操作。通过外键，可以简化多表之间的数据查询，避免了复杂的嵌套查询和多表连接操作，提高查询效率。\n * 数据库性能：外键可以提高数据库的性能。通过外键，数据库优化器可以更好地理解表之间的关联关系，从而优化查询计划，提高查询效率。\n * 索引使用：外键通常会自动创建索引，提高数据查询的速度。通过在外键字段上创建索引，可以加速表之间的关联查询。\n * 约束管理：使用外键可以更好地管理数据库中的约束。通过外键，可以明确定义表之间的关系，简化数据管理，减少数据错误和异常情况的发生。\n\n\n# 什么是存储过程？\n\n存储过程（Stored Procedure）是一种预先编译的数据库操作代码块，它包含了一系列的 SQL 语句和逻辑，可以在数据库中被保存并多次重复调用。\n\n特点：\n\n 1. 预编译：存储过程在第一次被创建时会被编译，而不是在每次调用时解析和编译。这样可以提高存储过程的执行效率。\n 2. 可重用：存储过程可以在数据库中被保存并多次调用，提供了代码的复用性，减少了重复编写相同功能的SQL语句。\n 3. 安全性：存储过程可以定义权限，只有具有足够权限的用户才能调用和执行存储过程，增加了数据库的安全性。\n 4. 事务控制：存储过程可以包含多个SQL语句，可以在一个事务中执行，保证数据库操作的原子性和一致性。\n 5. 提高性能：存储过程的预编译和缓存机制可以减少数据库服务器的负载，提高数据库的性能。\n\n使用场景：\n\n 1. 复杂业务逻辑：存储过程适用于包含复杂业务逻辑的操作，可以将复杂的数据处理和计算交给数据库服务器处理，减轻应用程序的负担。\n 2. 数据校验和约束：存储过程可以用于数据校验和约束的实现，确保数据的有效性和完整性。\n 3. 数据库维护：存储过程可以用于数据库维护和数据迁移操作，提供数据库的管理和维护能力。\n 4. 批处理操作：存储过程适用于批量数据处理和操作，可以提高数据处理的效率。\n\n\n# drop、delete 与 truncate 区别？\n\n> 用法不同\n\n * DROP 用于删除整个表，包括结构和数据，是最彻底的删除操作。\n * DELETE 用于删除表中的数据，但保留表的结构，可以指定条件删除部分数据。（可以回滚事务和记录日志）\n * TRUNCATE 用于删除表中的数据，但保留表的结构，删除整个表的数据，效率比 DELETE 高。\n\n> 属于不同的数据库语言\n\n * truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。\n * 而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。\n\nDML 语句和 DDL 语句区别：\n\n * DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。\n * DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。\n\n另外，由于 select 不会对表进行破坏，所以有的地方也会把 select 单独区分开叫做数据库查询语言 DQL（Data Query Language）。\n\n> 执行速度不同\n\ndrop > truncate > delete\n\n原因：\n\n * delete 命令执行的时候会产生数据库的 binlog 日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。\n * truncate 命令执行的时候不会产生数据库日志，因此比 delete 要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。\n * drop 命令会把表占用的空间全部释放掉。\n\n总结：\n\n * 如果需要删除整个表的数据并且不需要记录日志和触发触发器，TRUNCATE 是最快的选择。\n * 如果需要按条件逐行删除数据并且需要记录日志和触发触发器，使用 DELETE。\n * 如果需要彻底删除整个表及其数据，可以使用 DROP。\n\n\n# 数据库设计通常分为哪几步？\n\n 1. 需求分析 : 分析用户的需求，包括数据、功能和性能需求。\n 2. 概念结构设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图。\n 3. 逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。\n 4. 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。\n 5. 数据库实施 : 包括编程、测试和试运行。\n 6. 数据库的运行和维护 : 系统的运行与数据库的日常维护。\n\n\n# 参考\n\n数据库基础知识总结",normalizedContent:"# 数据库基础知识小结\n\n\n# 什么是数据库，数据库管理员，数据库管理员，数据库系统？\n\n数据库: 数据库(database 简称 db)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。\n\n数据库管理系统: 数据库管理系统(database management system 简称 dbms)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。\n\n数据库管理员: 数据库管理员(database administrator, 简称 dba)负责全面管理和控制数据库系统。\n\n数据库系统: 数据库系统(database system，简称 dbs)通常由软件、数据库和数据管理员(dba)组成。\n\n\n# 什么是元组，码，候选码，主码，外码，主属性，非主属性？\n\n * 元组：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。在二维表里，元组也称为行。\n * 码：码就是能唯一标识实体的属性，对应表中的列。\n * 候选码：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。\n * 主码: 主码也叫主键。主码是从候选码中选出来的。一个实体集中只能有一个主码，但可以有多个候选码。\n * 外码: 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。\n * 主属性：候选码中出现过的属性称为主属性。比如工人表（工号，身份证号，姓名，性别，部门），显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。\n * 非主属性：不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。\n\n关系 -- 表，行 -- 行，属性 -- 列\n\n\n# 什么是 er 图？\n\ner 图 全称是 entity relationship diagram（实体联系图），提供了表示实体类型、属性和联系的方法。\n\ner 图由下面 3 个要素组成：\n\n * 实体：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 er 图中，实体使用矩形框表示。\n * 属性：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 er 图中，属性使用椭圆形表示。\n * 联系：即实体与实体之间的关系，在 er 图中用菱形表示，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。（一对多关系）\n\ner 图示例：学生选课\n\n每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（m: n）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1:n）。\n\n\n\n\n# 讲讲数据库范式\n\n数据库范式是用于规范化数据库设计的一组规则，旨在消除数据冗余、提高数据存储效率和数据完整性。\n\n数据库范式有 3 种：\n\n * 1nf(第一范式)：属性不可再分。\n * 2nf(第二范式)：1nf 的基础之上，消除了非主属性对于码的部分函数依赖。\n * 3nf(第三范式)：3nf 在 2nf 的基础之上，消除了非主属性对于码的传递函数依赖。\n\n重要概念详解：\n\n> 函数依赖（functional dependency）：\n\n函数依赖是指在一个关系（表）中，一个或多个属性的值可以唯一确定其他属性的值。在关系中，一个属性（或属性组合）称为决定因素（determinant），其他属性称为依赖因素（dependent）。如果在关系 r 中，x 是决定因素，y 是依赖因素，并且对于任意两个元组 t1 和 t2，如果 t1 的 x 值相等于 t2 的 x 值，则它们的 y 值也必须相等，那么我们可以说 y 函数依赖于 x，用符号表示为 x -> y。\n\n> 部分函数依赖（partial functional dependency）：\n\n部分函数依赖是指在一个关系中，一个属性（或属性组合）依赖于另一个属性（或属性组合），但是该属性（或属性组合）只依赖于决定因素的一部分而不是全部。换句话说，存在非主属性依赖于候选码的一部分。\n\n例如，考虑一个关系 r (学号, 姓名, 班级, 年龄)，假设学号是主属性（候选码），姓名和班级依赖于学号，但是年龄只依赖于班级，而不是学号，那么年龄对于班级是部分函数依赖。\n\n> 完全函数依赖（full functional dependency）：\n\n完全函数依赖是指在一个关系中，一个属性（或属性组合）依赖于另一个属性（或属性组合），且该属性（或属性组合）对于决定因素是完全依赖的，没有部分依赖。换句话说，所有的非主属性都完全依赖于候选码。\n\n继续上述例子，如果年龄只依赖于学号，而不依赖于班级，那么年龄对于学号就是完全函数依赖。\n\n> 传递函数依赖（transitive functional dependency）：\n\n传递函数依赖是指在一个关系中，如果 x -> y 且 y -> z，则可以推导出 x -> z。换句话说，如果存在函数依赖 x -> y 和 y -> z，那么就存在传递函数依赖 x -> z。\n\n例如，考虑一个关系 r (学号, 姓名, 班级, 学校)，假设学号决定了姓名，姓名决定了班级，那么就存在传递函数依赖 学号 -> 班级。\n\n\n# 主键和外键有什么区别?\n\n * 主键(主码)：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。\n * 外键(外码)：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。\n\n\n# 为什么不推荐使用外键与级联？\n\n阿里巴巴开发手册：\n\n> 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n> \n> 说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风险; 外键影响数据库的插入速度\n\n原因：\n\n 1. 数据库性能：使用外键和级联操作可能会导致数据库性能下降。级联操作会引起多表之间的复杂关联和更新操作，可能增加数据库的负担，特别是在大规模数据库和高并发情况下。\n 2. 数据库复杂性：外键和级联操作会增加数据库的复杂性。当数据库结构涉及多个表之间的关联关系时，外键和级联操作可能增加数据管理和维护的复杂性，不适用于简单的数据库结构。\n 3. 数据库死锁：使用级联操作时，可能会引发数据库死锁问题。如果多个表之间存在循环级联更新或删除操作，可能导致死锁情况，影响数据库的正常运行。\n 4. 数据一致性：级联操作可能导致数据一致性问题。当使用级联操作时，可能会导致意外删除或更新关联的数据，从而影响数据库的数据一致性。\n 5. 增加了复杂性（每次做 delete 或者 update 都必须考虑外键约束）\n 6. 对分库分表不友好（因为分库分表下外键是无法生效的）\n\n使用外键的好处：\n\n * 数据完整性：外键可以确保数据库中的数据完整性。通过在一个表中引用另一个表的主键作为外键，可以确保两个表之间的关联关系是有效的。这样可以防止数据不一致和无效数据的插入，保持数据库的一致性。\n * 数据一致性：外键可以帮助维护数据库中的数据一致性。当对主表的数据进行更新或删除操作时，有了外键约束，数据库会自动检查关联的从表是否有相应的数据，并执行相应的操作，避免了数据的不一致性。\n * 数据查询和连接：使用外键可以更方便地进行数据查询和连接操作。通过外键，可以简化多表之间的数据查询，避免了复杂的嵌套查询和多表连接操作，提高查询效率。\n * 数据库性能：外键可以提高数据库的性能。通过外键，数据库优化器可以更好地理解表之间的关联关系，从而优化查询计划，提高查询效率。\n * 索引使用：外键通常会自动创建索引，提高数据查询的速度。通过在外键字段上创建索引，可以加速表之间的关联查询。\n * 约束管理：使用外键可以更好地管理数据库中的约束。通过外键，可以明确定义表之间的关系，简化数据管理，减少数据错误和异常情况的发生。\n\n\n# 什么是存储过程？\n\n存储过程（stored procedure）是一种预先编译的数据库操作代码块，它包含了一系列的 sql 语句和逻辑，可以在数据库中被保存并多次重复调用。\n\n特点：\n\n 1. 预编译：存储过程在第一次被创建时会被编译，而不是在每次调用时解析和编译。这样可以提高存储过程的执行效率。\n 2. 可重用：存储过程可以在数据库中被保存并多次调用，提供了代码的复用性，减少了重复编写相同功能的sql语句。\n 3. 安全性：存储过程可以定义权限，只有具有足够权限的用户才能调用和执行存储过程，增加了数据库的安全性。\n 4. 事务控制：存储过程可以包含多个sql语句，可以在一个事务中执行，保证数据库操作的原子性和一致性。\n 5. 提高性能：存储过程的预编译和缓存机制可以减少数据库服务器的负载，提高数据库的性能。\n\n使用场景：\n\n 1. 复杂业务逻辑：存储过程适用于包含复杂业务逻辑的操作，可以将复杂的数据处理和计算交给数据库服务器处理，减轻应用程序的负担。\n 2. 数据校验和约束：存储过程可以用于数据校验和约束的实现，确保数据的有效性和完整性。\n 3. 数据库维护：存储过程可以用于数据库维护和数据迁移操作，提供数据库的管理和维护能力。\n 4. 批处理操作：存储过程适用于批量数据处理和操作，可以提高数据处理的效率。\n\n\n# drop、delete 与 truncate 区别？\n\n> 用法不同\n\n * drop 用于删除整个表，包括结构和数据，是最彻底的删除操作。\n * delete 用于删除表中的数据，但保留表的结构，可以指定条件删除部分数据。（可以回滚事务和记录日志）\n * truncate 用于删除表中的数据，但保留表的结构，删除整个表的数据，效率比 delete 高。\n\n> 属于不同的数据库语言\n\n * truncate 和 drop 属于 ddl(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。\n * 而 delete 语句是 dml (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。\n\ndml 语句和 ddl 语句区别：\n\n * dml 是数据库操作语言（data manipulation language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。\n * ddl （data definition language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 dml 语言的最大区别是 dml 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。ddl 语句更多的被数据库管理员（dba）所使用，一般的开发人员很少使用。\n\n另外，由于 select 不会对表进行破坏，所以有的地方也会把 select 单独区分开叫做数据库查询语言 dql（data query language）。\n\n> 执行速度不同\n\ndrop > truncate > delete\n\n原因：\n\n * delete 命令执行的时候会产生数据库的 binlog 日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。\n * truncate 命令执行的时候不会产生数据库日志，因此比 delete 要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。\n * drop 命令会把表占用的空间全部释放掉。\n\n总结：\n\n * 如果需要删除整个表的数据并且不需要记录日志和触发触发器，truncate 是最快的选择。\n * 如果需要按条件逐行删除数据并且需要记录日志和触发触发器，使用 delete。\n * 如果需要彻底删除整个表及其数据，可以使用 drop。\n\n\n# 数据库设计通常分为哪几步？\n\n 1. 需求分析 : 分析用户的需求，包括数据、功能和性能需求。\n 2. 概念结构设计 : 主要采用 e-r 模型进行设计，包括画 e-r 图。\n 3. 逻辑结构设计 : 通过将 e-r 图转换成表，实现从 e-r 模型到关系模型的转换。\n 4. 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。\n 5. 数据库实施 : 包括编程、测试和试运行。\n 6. 数据库的运行和维护 : 系统的运行与数据库的日常维护。\n\n\n# 参考\n\n数据库基础知识总结",charsets:{cjk:!0}},{title:"字符集详解",frontmatter:{title:"字符集详解",date:"2023-07-24T11:11:40.000Z",permalink:"/pages/126a5a/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E5%9F%BA%E7%A1%80/03.%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AF%A6%E8%A7%A3.html",relativePath:"03.数据库/01.基础/03.字符集详解.md",key:"v-5242031b",path:"/pages/126a5a/",headers:[{level:2,title:"什么是字符集？",slug:"什么是字符集",normalizedTitle:"什么是字符集？",charIndex:281},{level:2,title:"常见的字符集",slug:"常见的字符集",normalizedTitle:"常见的字符集",charIndex:467},{level:3,title:"ASCII 码",slug:"ascii-码",normalizedTitle:"ascii 码",charIndex:478},{level:3,title:"Unicode",slug:"unicode",normalizedTitle:"unicode",charIndex:645},{level:3,title:"UTF-8",slug:"utf-8",normalizedTitle:"utf-8",charIndex:27},{level:3,title:"GBK 和 GB2312",slug:"gbk-和-gb2312",normalizedTitle:"gbk 和 gb2312",charIndex:956},{level:3,title:"BIG5",slug:"big5",normalizedTitle:"big5",charIndex:1079},{level:3,title:"ANSI",slug:"ansi",normalizedTitle:"ansi",charIndex:1121},{level:2,title:"在线编码和解码",slug:"在线编码和解码",normalizedTitle:"在线编码和解码",charIndex:1275},{level:2,title:"MySQL 字符集",slug:"mysql-字符集",normalizedTitle:"mysql 字符集",charIndex:1361},{level:3,title:"查看支持的字符集",slug:"查看支持的字符集",normalizedTitle:"查看支持的字符集",charIndex:1375},{level:3,title:"默认字符集",slug:"默认字符集",normalizedTitle:"默认字符集",charIndex:1413},{level:3,title:"字符集的层次级别",slug:"字符集的层次级别",normalizedTitle:"字符集的层次级别",charIndex:1480},{level:3,title:"5.x 版本和 8.x 版本都兼容的字符集与排序规则",slug:"_5-x-版本和-8-x-版本都兼容的字符集与排序规则",normalizedTitle:"5.x 版本和 8.x 版本都兼容的字符集与排序规则",charIndex:1576}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.065,time:63900,words:213},headersStr:"什么是字符集？ 常见的字符集 ASCII 码 Unicode UTF-8 GBK 和 GB2312 BIG5 ANSI 在线编码和解码 MySQL 字符集 查看支持的字符集 默认字符集 字符集的层次级别 5.x 版本和 8.x 版本都兼容的字符集与排序规则",content:"# 字符集详解\n\n> MySQL 字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4。\n> \n> 如果使用 utf8 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。\n> \n>  * utf8：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。\n>  * utf8mb4：UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。\n\n\n# 什么是字符集？\n\n字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。\n\n字符集 就是一系列字符的集合（编码规则）。\n\n每个字符在字符集中都有一个唯一的编码，计算机根据这个编码来识别和处理字符。不同的字符集支持不同的字符范围和编码方式。\n\n * 字符 转换成 二进制数据的过程称为 字符编码\n * 二进制数据 解析成 字符的过程称为 字符解码\n\n\n# 常见的字符集\n\n\n# ASCII 码\n\nASCII（American Standard Code for Information Interchange）是最早的字符集之一，它使用 7 位二进制数表示 128 个字符，包括英文字母、数字、标点符号和控制字符等。ASCII 码是计算机系统最基本的字符集之一，它为文本数据提供了最基本的编码方式。\n\n\n\n\n# Unicode\n\n随着计算机技术的发展，对于国际化和多语言支持的需求不断增加，ASCII 码已经不能满足各种语言字符的表示需求。于是，Unicode 字符集应运而生。Unicode 采用更多的位数来表示字符，常见的有 16 位的 UCS-2 和 32 位的 UCS-4。\n\n\n# UTF-8\n\nUTF-8（Unicode Transformation Format-8）是一种对 Unicode 进行编码的变长字符集，它可以使用 1 到 4 个字节表示一个字符，根据字符的不同范围自动选择合适的编码长度。UTF-8 是目前互联网上广泛使用的字符集之一，它既能表示 ASCII 字符，又能表示任意国家和地区的字符。\n\n\n# GBK 和 GB2312\n\nGBK 和 GB2312 是中文字符集，用于表示中文字符。GBK 扩展了 GB2312 字符集，支持更多的中文字符，包括繁体字和生僻字。GBK 和 GB2312在中国大陆广泛使用，是中文文本处理的基本字符集。\n\n\n# BIG5\n\nBIG5 主要针对的是繁体中文，收录了 13000 多个汉字。\n\n\n# ANSI\n\nANSI（American National Standards Institute）是一种字符集标准的通用名称，它实际上不是一个具体的字符集，而是指各种不同的字符集标准。在不同的操作系统和编程环境中，ANSI 可能对应不同的字符集，因此在使用 ANSI 字符集时需要注意平台的兼容性。\n\n\n# 在线编码和解码\n\nutf-8转utf-8、Unicode (UTF-8)转Unicode (UTF-8)、utf-8转utf-8编码 (haomeili.net)\n\n\n# MySQL 字符集\n\n\n# 查看支持的字符集\n\n可以通过 SHOW CHARSET 命令来查看\n\n\n# 默认字符集\n\n在 MySQL5.7 中，默认字符集是 latin1 ；在 MySQL8.0 中，默认字符集是 utf8mb4\n\n\n# 字符集的层次级别\n\n * server（MySQL 实例级别）\n * database（库级别）\n * table（表级别）\n * column（字段级别）\n\n优先级从上往下依次增大\n\n\n# 5.x 版本和 8.x 版本都兼容的字符集与排序规则\n\n字符集：utf8mb4\n\n排序规则：utf8mb4_general_ci\n\n解析\n\n 1. 字符集：utf8mb4 是 MySQL 5.x 和 8.x 版本都兼容的字符集。它是支持四字节的 UTF-8 编码，可以用于存储包含 Emoji 表情等特殊字符的文本数据。\n 2. 排序规则：在 MySQL 5.x 版本中，默认的排序规则是 utf8mb4_general_ci，而在 MySQL 8.x 版本中，默认的排序规则是 utf8mb4_0900_ai_ci。这是因为 MySQL 8.x 引入了新的排序规则算法 utf8mb4_0900_ai_ci，它在一些情况下（例如对特殊字符的排序）表现更为准确和符合语言习惯。\n\n所以，如果希望在 MySQL 5.x 和 8.x 版本中都兼容，并且不需要新的排序规则算法，可以使用 utf8mb4 字符集和 utf8mb4_general_ci 排序规则。但如果需要更准确的排序和对特殊字符的支持，可以考虑使用 utf8mb4 字符集和 utf8mb4_0900_ai_ci 排序规则。",normalizedContent:"# 字符集详解\n\n> mysql 字符编码集中有两套 utf-8 编码实现：utf8 和 utf8mb4。\n> \n> 如果使用 utf8 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。\n> \n>  * utf8：utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。\n>  * utf8mb4：utf-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。\n\n\n# 什么是字符集？\n\n字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。\n\n字符集 就是一系列字符的集合（编码规则）。\n\n每个字符在字符集中都有一个唯一的编码，计算机根据这个编码来识别和处理字符。不同的字符集支持不同的字符范围和编码方式。\n\n * 字符 转换成 二进制数据的过程称为 字符编码\n * 二进制数据 解析成 字符的过程称为 字符解码\n\n\n# 常见的字符集\n\n\n# ascii 码\n\nascii（american standard code for information interchange）是最早的字符集之一，它使用 7 位二进制数表示 128 个字符，包括英文字母、数字、标点符号和控制字符等。ascii 码是计算机系统最基本的字符集之一，它为文本数据提供了最基本的编码方式。\n\n\n\n\n# unicode\n\n随着计算机技术的发展，对于国际化和多语言支持的需求不断增加，ascii 码已经不能满足各种语言字符的表示需求。于是，unicode 字符集应运而生。unicode 采用更多的位数来表示字符，常见的有 16 位的 ucs-2 和 32 位的 ucs-4。\n\n\n# utf-8\n\nutf-8（unicode transformation format-8）是一种对 unicode 进行编码的变长字符集，它可以使用 1 到 4 个字节表示一个字符，根据字符的不同范围自动选择合适的编码长度。utf-8 是目前互联网上广泛使用的字符集之一，它既能表示 ascii 字符，又能表示任意国家和地区的字符。\n\n\n# gbk 和 gb2312\n\ngbk 和 gb2312 是中文字符集，用于表示中文字符。gbk 扩展了 gb2312 字符集，支持更多的中文字符，包括繁体字和生僻字。gbk 和 gb2312在中国大陆广泛使用，是中文文本处理的基本字符集。\n\n\n# big5\n\nbig5 主要针对的是繁体中文，收录了 13000 多个汉字。\n\n\n# ansi\n\nansi（american national standards institute）是一种字符集标准的通用名称，它实际上不是一个具体的字符集，而是指各种不同的字符集标准。在不同的操作系统和编程环境中，ansi 可能对应不同的字符集，因此在使用 ansi 字符集时需要注意平台的兼容性。\n\n\n# 在线编码和解码\n\nutf-8转utf-8、unicode (utf-8)转unicode (utf-8)、utf-8转utf-8编码 (haomeili.net)\n\n\n# mysql 字符集\n\n\n# 查看支持的字符集\n\n可以通过 show charset 命令来查看\n\n\n# 默认字符集\n\n在 mysql5.7 中，默认字符集是 latin1 ；在 mysql8.0 中，默认字符集是 utf8mb4\n\n\n# 字符集的层次级别\n\n * server（mysql 实例级别）\n * database（库级别）\n * table（表级别）\n * column（字段级别）\n\n优先级从上往下依次增大\n\n\n# 5.x 版本和 8.x 版本都兼容的字符集与排序规则\n\n字符集：utf8mb4\n\n排序规则：utf8mb4_general_ci\n\n解析\n\n 1. 字符集：utf8mb4 是 mysql 5.x 和 8.x 版本都兼容的字符集。它是支持四字节的 utf-8 编码，可以用于存储包含 emoji 表情等特殊字符的文本数据。\n 2. 排序规则：在 mysql 5.x 版本中，默认的排序规则是 utf8mb4_general_ci，而在 mysql 8.x 版本中，默认的排序规则是 utf8mb4_0900_ai_ci。这是因为 mysql 8.x 引入了新的排序规则算法 utf8mb4_0900_ai_ci，它在一些情况下（例如对特殊字符的排序）表现更为准确和符合语言习惯。\n\n所以，如果希望在 mysql 5.x 和 8.x 版本中都兼容，并且不需要新的排序规则算法，可以使用 utf8mb4 字符集和 utf8mb4_general_ci 排序规则。但如果需要更准确的排序和对特殊字符的支持，可以考虑使用 utf8mb4 字符集和 utf8mb4_0900_ai_ci 排序规则。",charsets:{cjk:!0}},{title:"SQL语法基础小结",frontmatter:{title:"SQL语法基础小结",date:"2023-07-24T16:05:47.000Z",permalink:"/pages/ed0fa0/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E5%9F%BA%E7%A1%80/04.SQL/01.SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93.html",relativePath:"03.数据库/01.基础/04.SQL/01.SQL语法基础小结.md",key:"v-aab2f91e",path:"/pages/ed0fa0/",headers:[{level:2,title:"一、基本概念",slug:"一、基本概念",normalizedTitle:"一、基本概念",charIndex:17},{level:3,title:"数据库术语",slug:"数据库术语",normalizedTitle:"数据库术语",charIndex:28},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:6},{level:4,title:"语法结构",slug:"语法结构",normalizedTitle:"语法结构",charIndex:414},{level:4,title:"语法要点",slug:"语法要点",normalizedTitle:"语法要点",charIndex:657},{level:4,title:"分类",slug:"分类",normalizedTitle:"分类",charIndex:1042},{level:4,title:"数据定义语言（DDL）",slug:"数据定义语言-ddl",normalizedTitle:"数据定义语言（ddl）",charIndex:1048},{level:4,title:"数据操纵语言（DML）",slug:"数据操纵语言-dml",normalizedTitle:"数据操纵语言（dml）",charIndex:1178},{level:4,title:"事务控制语言（TCL）",slug:"事务控制语言-tcl",normalizedTitle:"事务控制语言（tcl）",charIndex:1391},{level:4,title:"数据控制语言（DCL）",slug:"数据控制语言-dcl",normalizedTitle:"数据控制语言（dcl）",charIndex:1527},{level:2,title:"二、增删改查",slug:"二、增删改查",normalizedTitle:"二、增删改查",charIndex:1871},{level:3,title:"插入数据",slug:"插入数据",normalizedTitle:"插入数据",charIndex:1914},{level:3,title:"更新数据",slug:"更新数据",normalizedTitle:"更新数据",charIndex:2211},{level:3,title:"删除数据",slug:"删除数据",normalizedTitle:"删除数据",charIndex:2332},{level:3,title:"查询数据",slug:"查询数据",normalizedTitle:"查询数据",charIndex:2501},{level:2,title:"三、子查询",slug:"三、子查询",normalizedTitle:"三、子查询",charIndex:3084},{level:3,title:"WHERE",slug:"where",normalizedTitle:"where",charIndex:866},{level:3,title:"IN 和 BETWEEN",slug:"in-和-between",normalizedTitle:"in 和 between",charIndex:4428},{level:3,title:"AND、OR、NOT",slug:"and、or、not",normalizedTitle:"and、or、not",charIndex:4689},{level:3,title:"LIKE",slug:"like",normalizedTitle:"like",charIndex:4103},{level:2,title:"四、连接和组合",slug:"四、连接和组合",normalizedTitle:"四、连接和组合",charIndex:5523},{level:3,title:"连接（JOIN）",slug:"连接-join",normalizedTitle:"连接（join）",charIndex:5535},{level:4,title:"内连接（INNER JOIN）",slug:"内连接-inner-join",normalizedTitle:"内连接（inner join）",charIndex:6166},{level:4,title:"自连接",slug:"自连接",normalizedTitle:"自连接",charIndex:5828},{level:4,title:"自然连接（NATURAL JOIN）",slug:"自然连接-natural-join",normalizedTitle:"自然连接（natural join）",charIndex:6476},{level:4,title:"左连接（LEFT JOIN）",slug:"左连接-left-join",normalizedTitle:"左连接（left join）",charIndex:6555},{level:4,title:"右连接（RIGHT JOIN）",slug:"右连接-right-join",normalizedTitle:"右连接（right join）",charIndex:6697},{level:3,title:"组合（UNION）",slug:"组合-union",normalizedTitle:"组合（union）",charIndex:6842},{level:3,title:"JOIN vs UNION",slug:"join-vs-union",normalizedTitle:"join vs union",charIndex:7384},{level:2,title:"五、函数",slug:"五、函数",normalizedTitle:"五、函数",charIndex:7535},{level:3,title:"文本处理",slug:"文本处理",normalizedTitle:"文本处理",charIndex:7591},{level:3,title:"日期和时间处理",slug:"日期和时间处理",normalizedTitle:"日期和时间处理",charIndex:7866},{level:3,title:"数值处理",slug:"数值处理",normalizedTitle:"数值处理",charIndex:8456},{level:3,title:"汇总",slug:"汇总",normalizedTitle:"汇总",charIndex:8590},{level:2,title:"六、排序和分组",slug:"六、排序和分组",normalizedTitle:"六、排序和分组",charIndex:8811},{level:3,title:"ORDER BY",slug:"order-by",normalizedTitle:"order by",charIndex:7077},{level:3,title:"GROUP BY",slug:"group-by",normalizedTitle:"group by",charIndex:9035},{level:3,title:"HAVING",slug:"having",normalizedTitle:"having",charIndex:9435},{level:2,title:"七、数据定义",slug:"七、数据定义",normalizedTitle:"七、数据定义",charIndex:9892},{level:3,title:"数据库（DATABASE）",slug:"数据库-database",normalizedTitle:"数据库（database）",charIndex:9943},{level:4,title:"创建数据库",slug:"创建数据库",normalizedTitle:"创建数据库",charIndex:9960},{level:4,title:"删除数据库",slug:"删除数据库",normalizedTitle:"删除数据库",charIndex:9997},{level:4,title:"选择数据库",slug:"选择数据库",normalizedTitle:"选择数据库",charIndex:10032},{level:3,title:"数据表（TABLE）",slug:"数据表-table",normalizedTitle:"数据表（table）",charIndex:10058},{level:4,title:"创建数据表",slug:"创建数据表",normalizedTitle:"创建数据表",charIndex:10072},{level:4,title:"删除数据表",slug:"删除数据表",normalizedTitle:"删除数据表",charIndex:10439},{level:4,title:"修改数据表",slug:"修改数据表",normalizedTitle:"修改数据表",charIndex:10471},{level:3,title:"视图（VIEW）",slug:"视图-view",normalizedTitle:"视图（view）",charIndex:10735},{level:4,title:"创建视图",slug:"创建视图",normalizedTitle:"创建视图",charIndex:10940},{level:4,title:"删除视图",slug:"删除视图",normalizedTitle:"删除视图",charIndex:11037},{level:3,title:"索引（INDEX）",slug:"索引-index",normalizedTitle:"索引（index）",charIndex:11080},{level:4,title:"创建索引",slug:"创建索引",normalizedTitle:"创建索引",charIndex:11240},{level:4,title:"创建唯一索引",slug:"创建唯一索引",normalizedTitle:"创建唯一索引",charIndex:11348},{level:4,title:"删除索引",slug:"删除索引",normalizedTitle:"删除索引",charIndex:11411},{level:3,title:"约束",slug:"约束",normalizedTitle:"约束",charIndex:11468},{level:2,title:"八、事务处理",slug:"八、事务处理",normalizedTitle:"八、事务处理",charIndex:12362},{level:2,title:"九、权限控制",slug:"九、权限控制",normalizedTitle:"九、权限控制",charIndex:13212},{level:3,title:"创建账户",slug:"创建账户",normalizedTitle:"创建账户",charIndex:13585},{level:3,title:"修改账户名",slug:"修改账户名",normalizedTitle:"修改账户名",charIndex:13647},{level:3,title:"删除账户",slug:"删除账户",normalizedTitle:"删除账户",charIndex:13735},{level:3,title:"查看权限",slug:"查看权限",normalizedTitle:"查看权限",charIndex:13768},{level:3,title:"授予权限",slug:"授予权限",normalizedTitle:"授予权限",charIndex:13807},{level:3,title:"删除权限",slug:"删除权限",normalizedTitle:"删除权限",charIndex:13861},{level:3,title:"更改密码",slug:"更改密码",normalizedTitle:"更改密码",charIndex:13918},{level:2,title:"十、存储过程",slug:"十、存储过程",normalizedTitle:"十、存储过程",charIndex:13969},{level:3,title:"创建存储过程",slug:"创建存储过程",normalizedTitle:"创建存储过程",charIndex:14086},{level:3,title:"使用存储过程",slug:"使用存储过程",normalizedTitle:"使用存储过程",charIndex:14009},{level:2,title:"十一、游标",slug:"十一、游标",normalizedTitle:"十一、游标",charIndex:14701},{level:2,title:"十二、触发器",slug:"十二、触发器",normalizedTitle:"十二、触发器",charIndex:15688},{level:3,title:"创建触发器",slug:"创建触发器",normalizedTitle:"创建触发器",charIndex:16497},{level:3,title:"查看触发器",slug:"查看触发器",normalizedTitle:"查看触发器",charIndex:17229},{level:3,title:"删除触发器",slug:"删除触发器",normalizedTitle:"删除触发器",charIndex:17260},{level:2,title:"实际运用",slug:"实际运用",normalizedTitle:"实际运用",charIndex:17320},{level:3,title:"实际开发中，为什么要替换和避免 SQL 中的 IN 查询？",slug:"实际开发中-为什么要替换和避免-sql-中的-in-查询",normalizedTitle:"实际开发中，为什么要替换和避免 sql 中的 in 查询？",charIndex:17329},{level:3,title:"为什么可以用 EXISTS 子查询？",slug:"为什么可以用-exists-子查询",normalizedTitle:"为什么可以用 exists 子查询？",charIndex:18143},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:18612}],readingTime:{text:"13 min read",minutes:12.75,time:765e3,words:2550},headersStr:"一、基本概念 数据库术语 语法 语法结构 语法要点 分类 数据定义语言（DDL） 数据操纵语言（DML） 事务控制语言（TCL） 数据控制语言（DCL） 二、增删改查 插入数据 更新数据 删除数据 查询数据 三、子查询 WHERE IN 和 BETWEEN AND、OR、NOT LIKE 四、连接和组合 连接（JOIN） 内连接（INNER JOIN） 自连接 自然连接（NATURAL JOIN） 左连接（LEFT JOIN） 右连接（RIGHT JOIN） 组合（UNION） JOIN vs UNION 五、函数 文本处理 日期和时间处理 数值处理 汇总 六、排序和分组 ORDER BY GROUP BY HAVING 七、数据定义 数据库（DATABASE） 创建数据库 删除数据库 选择数据库 数据表（TABLE） 创建数据表 删除数据表 修改数据表 视图（VIEW） 创建视图 删除视图 索引（INDEX） 创建索引 创建唯一索引 删除索引 约束 八、事务处理 九、权限控制 创建账户 修改账户名 删除账户 查看权限 授予权限 删除权限 更改密码 十、存储过程 创建存储过程 使用存储过程 十一、游标 十二、触发器 创建触发器 查看触发器 删除触发器 实际运用 实际开发中，为什么要替换和避免 SQL 中的 IN 查询？ 为什么可以用 EXISTS 子查询？ 参考文献",content:"# SQL 语法基础小结\n\n\n# 一、基本概念\n\n\n# 数据库术语\n\n * 数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。\n * 数据表（table） - 某种特定类型数据的结构化清单。\n * 模式（schema） - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。\n * 列（column） - 表中的一个字段。所有表都是由一个或多个列组成的。\n * 行（row） - 表中的一个记录。\n * 主键（primary key） - 一列（或一组列），其值能够唯一标识表中每一行。\n\n\n# 语法\n\n> （Structured Query Language)，标准 由 ANSI 标准委员会管理，从而称为 ANSI 。各个 DBMS 都有自己的实现，如 PL/、Transact- 等。\n\n# 语法结构\n\n\n\n语法结构包括：\n\n * 子句 - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）\n * 表达式 - 可以产生任何标量值，或由列和行的数据库表\n * 谓词 - 给需要评估的 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。\n * 查询 - 基于特定条件检索数据。这是 的一个重要组成部分。\n * 语句 - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。\n\n# 语法要点\n\n * 语句不区分大小写，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。\n\n例如：SELECT 与 select 、Select 是相同的。\n\n * 多条 语句必须以分号（;）分隔。\n * 处理 语句时，所有空格都被忽略。 语句可以写成一行，也可以分写为多行。\n\n-- 一行  语句\nUPDATE user SET username='robot', password='robot' WHERE username = 'root';\n\n-- 多行  语句\nUPDATE user\nSET username='robot', password='robot'\nWHERE username = 'root';\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 支持三种注释\n\n## 注释1\n-- 注释2\n/* 注释3 */\n\n\n1\n2\n3\n\n\n# 分类\n\n# 数据定义语言（DDL）\n\n数据定义语言（Data Definition Language，DDL）是 语言集中负责数据结构定义与数据库对象定义的语言。\n\nDDL 的主要功能是定义数据库对象。\n\nDDL 的核心指令是 CREATE、ALTER、DROP。\n\n# 数据操纵语言（DML）\n\n数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。\n\nDML 的主要功能是 访问数据，因此其语法都是以读写数据库为主。\n\nDML 的核心指令是 INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。\n\n# 事务控制语言（TCL）\n\n事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。\n\nTCL 的核心指令是 COMMIT、ROLLBACK。\n\n# 数据控制语言（DCL）\n\n数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。\n\nDCL 的核心指令是 GRANT、REVOKE。\n\nDCL 以控制用户的访问权限为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。\n\n根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。\n\n----------------------------------------\n\n（以下为 DML 语句用法）\n\n\n# 二、增删改查\n\n> 增删改查，又称为 CRUD，数据库基本操作中的基本操作。\n\n\n# 插入数据\n\n>  * INSERT INTO 语句用于向表中插入新记录。\n\n插入完整的行\n\nINSERT INTO user\nVALUES (10, 'root', 'root', 'xxxx@163.com');\n\n\n1\n2\n\n\n插入行的一部分\n\nINSERT INTO user(username, password, email)\nVALUES ('admin', 'admin', 'xxxx@163.com');\n\n\n1\n2\n\n\n插入查询出来的数据\n\nINSERT INTO user(username)\nSELECT name\nFROM account;\n\n\n1\n2\n3\n\n\n\n# 更新数据\n\n>  * UPDATE 语句用于更新表中的记录。\n\nUPDATE user\nSET username='robot', password='robot'\nWHERE username = 'root';\n\n\n1\n2\n3\n\n\n\n# 删除数据\n\n>  * DELETE 语句用于删除表中的记录。\n>  * TRUNCATE TABLE 可以清空表，也就是删除所有行。\n\n删除表中的指定数据\n\nDELETE FROM user\nWHERE username = 'robot';\n\n\n1\n2\n\n\n清空表中的数据\n\nTRUNCATE TABLE user;\n\n\n1\n\n\n\n# 查询数据\n\n>  * SELECT 语句用于从数据库中查询数据。\n> \n>  * DISTINCT 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。\n> \n>  * LIMIT\n>    \n>    \n>    1\n>    \n>    \n>    限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\n>    \n>    * ASC ：升序（默认）\n>    * DESC ：降序\n\n查询单列\n\nSELECT prod_name\nFROM products;\n\n\n1\n2\n\n\n查询多列\n\nSELECT prod_id, prod_name, prod_price\nFROM products;\n\n\n1\n2\n\n\n查询所有列\n\nSELECT *\nFROM products;\n\n\n1\n2\n\n\n查询不同的值\n\nSELECT DISTINCT\nvend_id FROM products;\n\n\n1\n2\n\n\n限制查询结果\n\n-- 返回前 5 行\nSELECT * FROM mytable LIMIT 5;\nSELECT * FROM mytable LIMIT 0, 5;\n-- 返回第 3 ~ 5 行\nSELECT * FROM mytable LIMIT 2, 3;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 三、子查询\n\n> 子查询是嵌套在较大查询中的 查询。子查询也称为内部查询或内部选择，而包含子查询的语句也称为外部查询或外部选择。\n\n * 子查询可以嵌套在 SELECT，INSERT，UPDATE 或 DELETE 语句内或另一个子查询中。\n\n * 子查询通常会在另一个 SELECT 语句的 WHERE 子句中添加。\n\n * 您可以使用比较运算符，如 >，<，或 =。比较运算符也可以是多行运算符，如 IN，ANY 或 ALL。\n\n * 子查询必须被圆括号 () 括起来。\n\n * 内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：\n   \n   \n\n子查询的子查询\n\nSELECT\n    cust_name,\n    cust_contact\nFROM\n    customers\nWHERE\n    cust_id IN (\n        SELECT\n            cust_id\n        FROM\n            orders\n        WHERE\n            order_num IN (\n                SELECT\n                    order_num\n                FROM\n                    orderitems\n                WHERE\n                    prod_id = 'RGAN01'\n            )\n    );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# WHERE\n\n * WHERE 子句用于过滤记录，即缩小访问数据的范围。\n * WHERE 后跟一个返回 true 或 false 的条件。\n * WHERE 可以与 SELECT，UPDATE 和 DELETE 一起使用。\n * 可以在 WHERE 子句中使用的操作符\n\n运算符       描述\n=         等于\n<>        不等于。注释：在 的一些版本中，该操作符可被写成 !=\n>         大于\n<         小于\n>=        大于等于\n<=        小于等于\nBETWEEN   在某个范围内\nLIKE      搜索某种模式\nIN        指定针对某个列的多个可能值\n\nSELECT 语句中的 WHERE 子句\n\nSELECT * FROM Customers\nWHERE cust_name = 'Kids Place';\n\n\n1\n2\n\n\nUPDATE 语句中的 WHERE 子句\n\nUPDATE Customers\nSET cust_name = 'Jack Jones'\nWHERE cust_name = 'Kids Place';\n\n\n1\n2\n3\n\n\nDELETE 语句中的 WHERE 子句\n\nDELETE FROM Customers\nWHERE cust_name = 'Kids Place';\n\n\n1\n2\n\n\n\n# IN 和 BETWEEN\n\n * IN 操作符在 WHERE 子句中使用，作用是在指定的几个特定值中任选一个值。\n * BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于某个范围内的值。\n\nIN 示例\n\nSELECT *\nFROM products\nWHERE vend_id IN ('DLL01', 'BRS01');\n\n\n1\n2\n3\n\n\nBETWEEN 示例\n\nSELECT *\nFROM products\nWHERE prod_price BETWEEN 3 AND 5;\n\n\n1\n2\n3\n\n\n\n# AND、OR、NOT\n\n * AND、OR、NOT 是用于对过滤条件的逻辑处理指令。\n * AND 优先级高于 OR，为了明确处理顺序，可以使用 ()。\n * AND 操作符表示左右条件都要满足。\n * OR 操作符表示左右条件满足任意一个即可。\n * NOT 操作符用于否定一个条件。\n\nAND 示例\n\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' AND prod_price <= 4;\n\n\n1\n2\n3\n\n\nOR 示例\n\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE vend_id = 'DLL01' OR vend_id = 'BRS01';\n\n\n1\n2\n3\n\n\nNOT 示例\n\nSELECT *\nFROM products\nWHERE prod_price NOT BETWEEN 3 AND 5;\n\n\n1\n2\n3\n\n\n\n# LIKE\n\n * LIKE 操作符在 WHERE 子句中使用，作用是确定字符串是否匹配模式。\n * 只有字段是文本值时才使用 LIKE。\n * LIKE 支持两个通配符匹配选项：% 和 _。\n * 不要滥用通配符，通配符位于开头处匹配会非常慢。\n * % 表示任何字符出现任意次数。\n * _ 表示任何字符出现一次。\n\n% 示例\n\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '%bean bag%';\n\n\n1\n2\n3\n\n\n_ 示例\n\nSELECT prod_id, prod_name, prod_price\nFROM products\nWHERE prod_name LIKE '__ inch teddy bear';\n\n\n1\n2\n3\n\n\n\n# 四、连接和组合\n\n\n# 连接（JOIN）\n\n>  * 如果一个 JOIN 至少有一个公共字段并且它们之间存在关系，则该 JOIN 可以在两个或多个表上工作。\n> \n>  * 连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。\n> \n>  * JOIN 保持基表（结构和数据）不变。\n> \n>  * JOIN 有两种连接类型：内连接和外连接。\n> \n>  * 内连接又称等值连接，使用 INNER\n>    \n>    JOIN\n>    \n>    \n>    1\n>    \n>    \n>    关键字。在没有条件语句的情况下返回笛卡尔积。\n>    \n>    * 自连接可以看成内连接的一种，只是连接的表是自身而已。\n> \n>  * 自然连接是把同名列通过 = 测试连接起来的，同名列可以有多个。\n> \n>  * 内连接 vs 自然连接\n>    \n>    * 内连接提供连接的列，而自然连接自动连接所有同名列。\n> \n>  * 外连接返回一个表中的所有行，并且仅返回来自次表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（My 不支持）。\n>    \n>    * 左外连接就是保留左表没有关联的行。\n>    * 右外连接就是保留右表没有关联的行。\n> \n>  * 连接 vs 子查询\n>    \n>    * 连接可以替换子查询，并且比子查询的效率一般会更快。\n>    \n>    \n\n# 内连接（INNER JOIN）\n\nSELECT vend_name, prod_name, prod_price\nFROM vendors INNER JOIN products\nON vendors.vend_id = products.vend_id;\n\n\n1\n2\n3\n\n\n# 自连接\n\nSELECT c1.cust_id, c1.cust_name, c1.cust_contact\nFROM customers c1, customers c2\nWHERE c1.cust_name = c2.cust_name\nAND c2.cust_contact = 'Jim Jones';\n\n\n1\n2\n3\n4\n\n\n# 自然连接（NATURAL JOIN）\n\nSELECT *\nFROM Products\nNATURAL JOIN Customers;\n\n\n1\n2\n3\n\n\n# 左连接（LEFT JOIN）\n\nSELECT customers.cust_id, orders.order_num\nFROM customers LEFT JOIN orders\nON customers.cust_id = orders.cust_id;\n\n\n1\n2\n3\n\n\n# 右连接（RIGHT JOIN）\n\nSELECT customers.cust_id, orders.order_num\nFROM customers RIGHT JOIN orders\nON customers.cust_id = orders.cust_id;\n\n\n1\n2\n3\n\n\n\n# 组合（UNION）\n\n * UNION 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 UNION 中参与查询的提取行。\n\n * UNION\n   \n   \n   1\n   \n   \n   基本规则\n   \n   * 所有查询的列数和列顺序必须相同。\n   * 每个查询中涉及表的列的数据类型必须相同或兼容。\n   * 通常返回的列名取自第一个查询。\n\n * 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。\n\n * 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。\n\n * 应用场景\n   \n   * 在一个查询中从不同的表返回结构数据。\n   * 对一个表执行多个查询，按一个查询返回数据。\n\n组合查询\n\nSELECT cust_name, cust_contact, cust_email\nFROM customers\nWHERE cust_state IN ('IL', 'IN', 'MI')\nUNION\nSELECT cust_name, cust_contact, cust_email\nFROM customers\nWHERE cust_name = 'Fun4All';\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# JOIN vs UNION\n\n * JOIN vs UNION\n   * JOIN 中连接表的列可能不同，但在 UNION 中，所有查询的列数和列顺序必须相同。\n   * UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。\n\n\n# 五、函数\n\n> 🔔 注意：不同数据库的函数往往各不相同，因此不可移植。本节主要以 My 的函数为例。\n\n\n# 文本处理\n\n函数                说明\nLEFT()、RIGHT()    左边或者右边的字符\nLOWER()、UPPER()   转换为小写或者大写\nLTRIM()、RTIM()    去除左边或者右边的空格\nLENGTH()          长度\nSOUNDEX()         转换为语音值\n\n其中，SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。\n\nSELECT *\nFROM mytable\nWHERE SOUNDEX(col1) = SOUNDEX('apple')\n\n\n1\n2\n3\n\n\n\n# 日期和时间处理\n\n * 日期格式：YYYY-MM-DD\n * 时间格式：HH:MM:SS\n\n函 数             说 明\nAddDate()       增加一个日期（天、周等）\nAddTime()       增加一个时间（时、分等）\nCurDate()       返回当前日期\nCurTime()       返回当前时间\nDate()          返回日期时间的日期部分\nDateDiff()      计算两个日期之差\nDate_Add()      高度灵活的日期运算函数\nDate_Format()   返回一个格式化的日期或时间串\nDay()           返回一个日期的天数部分\nDayOfWeek()     对于一个日期，返回对应的星期几\nHour()          返回一个时间的小时部分\nMinute()        返回一个时间的分钟部分\nMonth()         返回一个日期的月份部分\nNow()           返回当前日期和时间\nSecond()        返回一个时间的秒部分\nTime()          返回一个日期时间的时间部分\nYear()          返回一个日期的年份部分\n\nmy> SELECT NOW();\n\n\n1\n\n\n2018-4-14 20:25:11\n\n\n1\n\n\n\n# 数值处理\n\n函数       说明\nSIN()    正弦\nCOS()    余弦\nTAN()    正切\nABS()    绝对值\nSQRT()   平方根\nMOD()    余数\nEXP()    指数\nPI()     圆周率\nRAND()   随机数\n\n\n# 汇总\n\n函 数       说 明\nAVG()     返回某列的平均值\nCOUNT()   返回某列的行数\nMAX()     返回某列的最大值\nMIN()     返回某列的最小值\nSUM()     返回某列值之和\n\nAVG() 会忽略 NULL 行。\n\n使用 DISTINCT 可以让汇总函数值汇总不同的值。\n\nSELECT AVG(DISTINCT col1) AS avg_col\nFROM mytable\n\n\n1\n2\n\n\n\n# 六、排序和分组\n\n\n# ORDER BY\n\n * ORDER BY\n   \n   \n   1\n   \n   \n   用于对结果集进行排序。\n   \n   * ASC ：升序（默认）\n   * DESC ：降序\n\n * 可以按多个列进行排序，并且为每个列指定不同的排序方式\n\n指定多个列的排序方向\n\nSELECT * FROM products\nORDER BY prod_price DESC, prod_name ASC;\n\n\n1\n2\n\n\n\n# GROUP BY\n\n * GROUP BY 子句将记录分组到汇总行中。\n * GROUP BY 为每个组返回一个记录。\n * GROUP BY 通常还涉及聚合：COUNT，MAX，SUM，AVG 等。\n * GROUP BY 可以按一列或多列进行分组。\n * GROUP BY 按分组字段进行排序后，ORDER BY 可以以汇总字段来进行排序。\n\n分组\n\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name;\n\n\n1\n2\n\n\n分组后排序\n\nSELECT cust_name, COUNT(cust_address) AS addr_num\nFROM Customers GROUP BY cust_name\nORDER BY cust_name DESC;\n\n\n1\n2\n3\n\n\n\n# HAVING\n\n * HAVING 用于对汇总的 GROUP BY 结果进行过滤。\n\n * HAVING 要求存在一个 GROUP BY 子句。\n\n * WHERE 和 HAVING 可以在相同的查询中。\n\n * HAVING\n   \n   \n   1\n   \n   \n   vs\n   \n   WHERE\n   \n   \n   1\n   \n   * WHERE 和 HAVING 都是用于过滤。\n   * HAVING 适用于汇总的组记录；而 WHERE 适用于单个记录。\n\n使用 WHERE 和 HAVING 过滤数据\n\nSELECT cust_name, COUNT(*) AS num\nFROM Customers\nWHERE cust_email IS NOT NULL\nGROUP BY cust_name\nHAVING COUNT(*) >= 1;\n\n\n1\n2\n3\n4\n5\n\n\n----------------------------------------\n\n（以下为 DDL 语句用法）\n\n\n# 七、数据定义\n\n> DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）。\n\n\n# 数据库（DATABASE）\n\n# 创建数据库\n\nCREATE DATABASE test;\n\n\n1\n\n\n# 删除数据库\n\nDROP DATABASE test;\n\n\n1\n\n\n# 选择数据库\n\nUSE test;\n\n\n1\n\n\n\n# 数据表（TABLE）\n\n# 创建数据表\n\n普通创建\n\nCREATE TABLE user (\n  id int(10) unsigned NOT NULL COMMENT 'Id',\n  username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',\n  password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',\n  email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'\n) COMMENT='用户表';\n\n\n1\n2\n3\n4\n5\n6\n\n\n根据已有的表创建新表\n\nCREATE TABLE vip_user AS\nSELECT * FROM user;\n\n\n1\n2\n\n\n# 删除数据表\n\nDROP TABLE user;\n\n\n1\n\n\n# 修改数据表\n\n添加列\n\nALTER TABLE user\nADD age int(3);\n\n\n1\n2\n\n\n删除列\n\nALTER TABLE user\nDROP COLUMN age;\n\n\n1\n2\n\n\n修改列\n\nALTER TABLE `user`\nMODIFY COLUMN age tinyint;\n\n\n1\n2\n\n\n添加主键\n\nALTER TABLE user\nADD PRIMARY KEY (id);\n\n\n1\n2\n\n\n删除主键\n\nALTER TABLE user\nDROP PRIMARY KEY;\n\n\n1\n2\n\n\n\n# 视图（VIEW）\n\n>  * 定义\n>    * 视图是基于 语句的结果集的可视化的表。\n>    * 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。\n>  * 作用\n>    * 简化复杂的 操作，比如复杂的联结；\n>    * 只使用实际表的一部分数据；\n>    * 通过只给用户访问视图的权限，保证数据的安全性；\n>    * 更改数据格式和表示。\n\n# 创建视图\n\nCREATE VIEW top_10_user_view AS\nSELECT id, username\nFROM user\nWHERE id < 10;\n\n\n1\n2\n3\n4\n\n\n# 删除视图\n\nDROP VIEW top_10_user_view;\n\n\n1\n\n\n\n# 索引（INDEX）\n\n>  * 作用\n>    * 通过索引可以更加快速高效地查询数据。\n>    * 用户无法看到索引，它们只能被用来加速查询。\n>  * 注意\n>    * 更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。\n>  * 唯一索引\n>    * 唯一索引表明此索引的每一个索引值只对应唯一的数据记录。\n\n# 创建索引\n\nCREATE INDEX user_index\nON user (id);\n\n\n1\n2\n\n\n# 创建唯一索引\n\nCREATE UNIQUE INDEX user_index\nON user (id);\n\n\n1\n2\n\n\n# 删除索引\n\nALTER TABLE user\nDROP INDEX user_index;\n\n\n1\n2\n\n\n\n# 约束\n\n> 约束用于规定表中的数据规则。\n\n * 如果存在违反约束的数据行为，行为会被约束终止。\n * 约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。\n * 约束类型\n   * NOT NULL - 指示某列不能存储 NULL 值。\n   * UNIQUE - 保证某列的每行必须有唯一的值。\n   * PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。\n   * FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。\n   * CHECK - 保证列中的值符合指定的条件。\n   * DEFAULT - 规定没有给列赋值时的默认值。\n\n创建表时使用约束条件：\n\nCREATE TABLE Users (\n  Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id',\n  Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名',\n  Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码',\n  Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址',\n  Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效',\n  PRIMARY KEY (Id)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n（以下为 TCL 语句用法）\n\n\n# 八、事务处理\n\n>  * 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。\n>  * My 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。\n>  * 通过 set autocommit=0 可以取消自动提交，直到 set autocommit=1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。\n>  * 指令\n>    * START TRANSACTION - 指令用于标记事务的起始点。\n>    * SAVEPOINT - 指令用于创建保留点。\n>    * ROLLBACK TO - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 START TRANSACTION 语句处。\n>    * COMMIT - 提交事务。\n\n-- 开始事务\nSTART TRANSACTION;\n\n-- 插入操作 A\nINSERT INTO `user`\nVALUES (1, 'root1', 'root1', 'xxxx@163.com');\n\n-- 创建保留点 updateA\nSAVEPOINT updateA;\n\n-- 插入操作 B\nINSERT INTO `user`\nVALUES (2, 'root2', 'root2', 'xxxx@163.com');\n\n-- 回滚到保留点 updateA\nROLLBACK TO updateA;\n\n-- 提交事务，只有操作 A 生效\nCOMMIT;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n----------------------------------------\n\n（以下为 DCL 语句用法）\n\n\n# 九、权限控制\n\n>  * GRANT 和 REVOKE 可在几个层次上控制访问权限：\n>    \n>    * 整个服务器，使用 GRANT ALL 和 REVOKE ALL；\n>    * 整个数据库，使用 ON database.*；\n>    * 特定的表，使用 ON database.table；\n>    * 特定的列；\n>    * 特定的存储过程。\n> \n>  * 新创建的账户没有任何权限。\n> \n>  * 账户用 username@host 的形式定义，username@% 使用的是默认主机名。\n> \n>  * My 的账户信息保存在 my 这个数据库中。\n>    \n>    USE my;\n>    SELECT user FROM user;\n>    \n>    \n>    1\n>    2\n>    \n\n\n# 创建账户\n\nCREATE USER myuser IDENTIFIED BY 'mypassword';\n\n\n1\n\n\n\n# 修改账户名\n\nUPDATE user SET user='newuser' WHERE user='myuser';\nFLUSH PRIVILEGES;\n\n\n1\n2\n\n\n\n# 删除账户\n\nDROP USER myuser;\n\n\n1\n\n\n\n# 查看权限\n\nSHOW GRANTS FOR myuser;\n\n\n1\n\n\n\n# 授予权限\n\nGRANT SELECT, INSERT ON *.* TO myuser;\n\n\n1\n\n\n\n# 删除权限\n\nREVOKE SELECT, INSERT ON *.* FROM myuser;\n\n\n1\n\n\n\n# 更改密码\n\nSET PASSWORD FOR myuser = 'mypass';\n\n\n1\n\n\n\n# 十、存储过程\n\n>  * 存储过程可以看成是对一系列 操作的批处理；\n>  * 使用存储过程的好处\n>    * 代码封装，保证了一定的安全性；\n>    * 代码复用；\n>    * 由于是预先编译，因此具有很高的性能。\n>  * 创建存储过程\n>    * 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。\n>    * 包含 in、out 和 inout 三种参数。\n>    * 给变量赋值都需要用 select into 语句。\n>    * 每次只能给一个变量赋值，不支持集合的操作。\n\n\n# 创建存储过程\n\nDROP PROCEDURE IF EXISTS `proc_adder`;\nDELIMITER ;;\nCREATE DEFINER=`root`@`localhost` PROCEDURE `proc_adder`(IN a int, IN b int, OUT sum int)\nBEGIN\n    DECLARE c int;\n    if a is null then set a = 0;\n    end if;\n\n    if b is null then set b = 0;\n    end if;\n\n    set sum  = a + b;\nEND\n;;\nDELIMITER ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 使用存储过程\n\nnginxset @b=5;\ncall proc_adder(2,@b,@s);\nselect @s as sum;\n\n\n1\n2\n3\n\n\n\n# 十一、游标\n\n>  * 游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。\n>  * 在存储过程中使用游标可以对一个结果集进行移动遍历。\n>  * 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。\n>  * 使用游标的四个步骤：\n>    * 声明游标，这个过程没有实际检索出数据；\n>    * 打开游标；\n>    * 取出数据；\n>    * 关闭游标；\n\nDELIMITER $\nCREATE  PROCEDURE getTotal()\nBEGIN\n    DECLARE total INT;\n    -- 创建接收游标数据的变量\n    DECLARE sid INT;\n    DECLARE sname VARCHAR(10);\n    -- 创建总数变量\n    DECLARE sage INT;\n    -- 创建结束标志变量\n    DECLARE done INT DEFAULT false;\n    -- 创建游标\n    DECLARE cur CURSOR FOR SELECT id,name,age from cursor_table where age>30;\n    -- 指定游标循环结束时的返回值\n    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true;\n    SET total = 0;\n    OPEN cur;\n    FETCH cur INTO sid, sname, sage;\n    WHILE(NOT done)\n    DO\n        SET total = total + 1;\n        FETCH cur INTO sid, sname, sage;\n    END WHILE;\n\n    CLOSE cur;\n    SELECT total;\nEND $\nDELIMITER ;\n\n-- 调用存储过程\ncall getTotal();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十二、触发器\n\n> 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。\n\n可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。\n\nMy 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。\n\nBEGIN 和 END\n\n当触发器的触发条件满足时，将会执行 BEGIN 和 END 之间的触发器执行动作。\n\n> 🔔 注意：在 My 中，分号 ; 是语句结束的标识符，遇到分号表示该段语句已经结束，My 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。\n> \n> 这时就会用到 DELIMITER 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：DELIMITER new_delemiter。new_delemiter 可以设为 1 个或多个长度的符号，默认的是分号 ;，我们可以把它修改为其他符号，如 $ - DELIMITER $ 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 $，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。\n\nNEW 和 OLD\n\n * My 中定义了 NEW 和 OLD 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。\n * 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；\n * 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；\n * 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；\n * 使用方法：NEW.columnName（columnName 为相应数据表某一列名）\n\n\n# 创建触发器\n\n> 提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。\n\nCREATE TRIGGER 指令用于创建触发器。\n\n语法：\n\nCREATE TRIGGER trigger_name\ntrigger_time\ntrigger_event\nON table_name\nFOR EACH ROW\nBEGIN\n  trigger_statements\nEND;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明：\n\n * trigger_name：触发器名\n * trigger_time: 触发器的触发时机。取值为 BEFORE 或 AFTER。\n * trigger_event: 触发器的监听事件。取值为 INSERT、UPDATE 或 DELETE。\n * table_name: 触发器的监听目标。指定在哪张表上建立触发器。\n * FOR EACH ROW: 行级监视，My 固定写法，其他 DBMS 不同。\n * trigger_statements: 触发器执行动作。是一条或多条 语句的列表，列表内的每条语句都必须用分号 ; 来结尾。\n\n示例：\n\nDELIMITER $\nCREATE TRIGGER `trigger_insert_user`\nAFTER INSERT ON `user`\nFOR EACH ROW\nBEGIN\n    INSERT INTO `user_history`(user_id, operate_type, operate_time)\n    VALUES (NEW.id, 'add a user',  now());\nEND $\nDELIMITER ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 查看触发器\n\nSHOW TRIGGERS;\n\n\n1\n\n\n\n# 删除触发器\n\nDROP TRIGGER IF EXISTS trigger_insert_user;\n\n\n1\n\n\n\n# 实际运用\n\n\n# 实际开发中，为什么要替换和避免 SQL 中的 IN 查询？\n\n在实际开发中，替换和避免 SQL 中的 IN 查询有以下几个主要原因：\n\n 1. 性能问题： IN 查询在某些情况下可能会导致性能问题。当 IN 中的值过多时，数据库需要逐个匹配，可能会导致全表扫描，造成性能瓶颈。尤其是当 IN 列表中的值很多，数据库需要不断进行多次查询，增加了数据库的负担。\n 2. 查询优化问题： 数据库优化器在处理 IN 查询时可能会出现问题。不同数据库系统对 IN 查询的优化方式不同，某些情况下可能无法正确优化，导致查询效率下降。\n 3. 内存占用问题： IN 查询中的值需要在内存中进行匹配，当 IN 列表中的值过多时，会占用大量的内存资源，可能导致内存不足的问题。\n 4. 维护问题： 使用 IN 查询时，如果需要修改查询条件中的值，需要手动修改 IN 列表中的值，这在维护过程中可能会引入错误。而且，当需要添加或删除值时，也需要相应地修改查询语句。\n\n为了避免这些问题，开发中可以考虑以下方法：\n\n 1. 使用连接查询： 对于 IN 查询，有时可以使用连接查询（JOIN）来代替。连接查询的优化器通常能更好地处理大量数据，并且可以避免 IN 查询的性能问题。\n 2. 分页查询： 如果 IN 查询的目的是为了分页显示数据，可以考虑使用分页查询，将数据分批加载，避免一次性查询过多数据。\n 3. 使用索引： 在 IN 查询中，确保被查询的字段上有适当的索引，以加快查询速度。索引可以帮助数据库快速定位匹配的数据。\n 4. 使用 EXISTS 或子查询： 对于某些情况，可以使用 EXISTS 或子查询来代替 IN 查询。这种方式在某些情况下可能会更加高效。\n\n总之，在开发中应该根据具体的情况来选择是否使用 IN 查询以及如何优化查询性能。合理地使用连接查询、分页查询、索引等方法，可以避免 IN 查询带来的性能和维护问题。\n\n\n# 为什么可以用 EXISTS 子查询？\n\nEXISTS 是一种用于判断子查询结果是否存在的 SQL 关键字。它通常与主查询一起使用，以确定子查询是否返回了任何行。在某些情况下，使用 EXISTS 可以替代 IN 查询，具有一些优势：\n\n 1. 性能优化：EXISTS 查询通常可以通过使用索引等优化手段来提高查询性能。数据库优化器可以更好地处理 EXISTS 查询，从而避免了一些 IN 查询可能出现的性能问题。\n 2. 避免重复数据：IN 查询在列表中包含重复值时可能会出现重复的查询结果。而 EXISTS 查询则不会出现这个问题，它只关心是否存在满足条件的记录，而不考虑具体的记录内容。\n 3. 适用范围广：EXISTS 查询更加灵活，可以用于更多不同的查询场景，包括子查询中的聚合操作、连接查询等。\n 4. 内存占用更小：EXISTS 查询不需要加载全部的列表值到内存中进行匹配，因此在处理大量数据时，内存占用相对较小。\n\n总结\n\n * in 查询是会加载全部列表值，所以性能低\n * exists 只是会判断列表值是否存在\n\n\n# 参考文献\n\n * SQL语法基础知识总结)\n * SQL 语法速成手册\n * MySQL 教程",normalizedContent:"# sql 语法基础小结\n\n\n# 一、基本概念\n\n\n# 数据库术语\n\n * 数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。\n * 数据表（table） - 某种特定类型数据的结构化清单。\n * 模式（schema） - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。\n * 列（column） - 表中的一个字段。所有表都是由一个或多个列组成的。\n * 行（row） - 表中的一个记录。\n * 主键（primary key） - 一列（或一组列），其值能够唯一标识表中每一行。\n\n\n# 语法\n\n> （structured query language)，标准 由 ansi 标准委员会管理，从而称为 ansi 。各个 dbms 都有自己的实现，如 pl/、transact- 等。\n\n# 语法结构\n\n\n\n语法结构包括：\n\n * 子句 - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）\n * 表达式 - 可以产生任何标量值，或由列和行的数据库表\n * 谓词 - 给需要评估的 三值逻辑（3vl）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。\n * 查询 - 基于特定条件检索数据。这是 的一个重要组成部分。\n * 语句 - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。\n\n# 语法要点\n\n * 语句不区分大小写，但是数据库表名、列名和值是否区分，依赖于具体的 dbms 以及配置。\n\n例如：select 与 select 、select 是相同的。\n\n * 多条 语句必须以分号（;）分隔。\n * 处理 语句时，所有空格都被忽略。 语句可以写成一行，也可以分写为多行。\n\n-- 一行  语句\nupdate user set username='robot', password='robot' where username = 'root';\n\n-- 多行  语句\nupdate user\nset username='robot', password='robot'\nwhere username = 'root';\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 支持三种注释\n\n## 注释1\n-- 注释2\n/* 注释3 */\n\n\n1\n2\n3\n\n\n# 分类\n\n# 数据定义语言（ddl）\n\n数据定义语言（data definition language，ddl）是 语言集中负责数据结构定义与数据库对象定义的语言。\n\nddl 的主要功能是定义数据库对象。\n\nddl 的核心指令是 create、alter、drop。\n\n# 数据操纵语言（dml）\n\n数据操纵语言（data manipulation language, dml）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。\n\ndml 的主要功能是 访问数据，因此其语法都是以读写数据库为主。\n\ndml 的核心指令是 insert、update、delete、select。这四个指令合称 crud(create, read, update, delete)，即增删改查。\n\n# 事务控制语言（tcl）\n\n事务控制语言 (transaction control language, tcl) 用于管理数据库中的事务。这些用于管理由 dml 语句所做的更改。它还允许将语句分组为逻辑事务。\n\ntcl 的核心指令是 commit、rollback。\n\n# 数据控制语言（dcl）\n\n数据控制语言 (data control language, dcl) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。\n\ndcl 的核心指令是 grant、revoke。\n\ndcl 以控制用户的访问权限为主，因此其指令作法并不复杂，可利用 dcl 控制的权限有：connect、select、insert、update、delete、execute、usage、references。\n\n根据不同的 dbms 以及不同的安全性实体，其支持的权限控制也有所不同。\n\n----------------------------------------\n\n（以下为 dml 语句用法）\n\n\n# 二、增删改查\n\n> 增删改查，又称为 crud，数据库基本操作中的基本操作。\n\n\n# 插入数据\n\n>  * insert into 语句用于向表中插入新记录。\n\n插入完整的行\n\ninsert into user\nvalues (10, 'root', 'root', 'xxxx@163.com');\n\n\n1\n2\n\n\n插入行的一部分\n\ninsert into user(username, password, email)\nvalues ('admin', 'admin', 'xxxx@163.com');\n\n\n1\n2\n\n\n插入查询出来的数据\n\ninsert into user(username)\nselect name\nfrom account;\n\n\n1\n2\n3\n\n\n\n# 更新数据\n\n>  * update 语句用于更新表中的记录。\n\nupdate user\nset username='robot', password='robot'\nwhere username = 'root';\n\n\n1\n2\n3\n\n\n\n# 删除数据\n\n>  * delete 语句用于删除表中的记录。\n>  * truncate table 可以清空表，也就是删除所有行。\n\n删除表中的指定数据\n\ndelete from user\nwhere username = 'robot';\n\n\n1\n2\n\n\n清空表中的数据\n\ntruncate table user;\n\n\n1\n\n\n\n# 查询数据\n\n>  * select 语句用于从数据库中查询数据。\n> \n>  * distinct 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。\n> \n>  * limit\n>    \n>    \n>    1\n>    \n>    \n>    限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\n>    \n>    * asc ：升序（默认）\n>    * desc ：降序\n\n查询单列\n\nselect prod_name\nfrom products;\n\n\n1\n2\n\n\n查询多列\n\nselect prod_id, prod_name, prod_price\nfrom products;\n\n\n1\n2\n\n\n查询所有列\n\nselect *\nfrom products;\n\n\n1\n2\n\n\n查询不同的值\n\nselect distinct\nvend_id from products;\n\n\n1\n2\n\n\n限制查询结果\n\n-- 返回前 5 行\nselect * from mytable limit 5;\nselect * from mytable limit 0, 5;\n-- 返回第 3 ~ 5 行\nselect * from mytable limit 2, 3;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 三、子查询\n\n> 子查询是嵌套在较大查询中的 查询。子查询也称为内部查询或内部选择，而包含子查询的语句也称为外部查询或外部选择。\n\n * 子查询可以嵌套在 select，insert，update 或 delete 语句内或另一个子查询中。\n\n * 子查询通常会在另一个 select 语句的 where 子句中添加。\n\n * 您可以使用比较运算符，如 >，<，或 =。比较运算符也可以是多行运算符，如 in，any 或 all。\n\n * 子查询必须被圆括号 () 括起来。\n\n * 内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：\n   \n   \n\n子查询的子查询\n\nselect\n    cust_name,\n    cust_contact\nfrom\n    customers\nwhere\n    cust_id in (\n        select\n            cust_id\n        from\n            orders\n        where\n            order_num in (\n                select\n                    order_num\n                from\n                    orderitems\n                where\n                    prod_id = 'rgan01'\n            )\n    );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# where\n\n * where 子句用于过滤记录，即缩小访问数据的范围。\n * where 后跟一个返回 true 或 false 的条件。\n * where 可以与 select，update 和 delete 一起使用。\n * 可以在 where 子句中使用的操作符\n\n运算符       描述\n=         等于\n<>        不等于。注释：在 的一些版本中，该操作符可被写成 !=\n>         大于\n<         小于\n>=        大于等于\n<=        小于等于\nbetween   在某个范围内\nlike      搜索某种模式\nin        指定针对某个列的多个可能值\n\nselect 语句中的 where 子句\n\nselect * from customers\nwhere cust_name = 'kids place';\n\n\n1\n2\n\n\nupdate 语句中的 where 子句\n\nupdate customers\nset cust_name = 'jack jones'\nwhere cust_name = 'kids place';\n\n\n1\n2\n3\n\n\ndelete 语句中的 where 子句\n\ndelete from customers\nwhere cust_name = 'kids place';\n\n\n1\n2\n\n\n\n# in 和 between\n\n * in 操作符在 where 子句中使用，作用是在指定的几个特定值中任选一个值。\n * between 操作符在 where 子句中使用，作用是选取介于某个范围内的值。\n\nin 示例\n\nselect *\nfrom products\nwhere vend_id in ('dll01', 'brs01');\n\n\n1\n2\n3\n\n\nbetween 示例\n\nselect *\nfrom products\nwhere prod_price between 3 and 5;\n\n\n1\n2\n3\n\n\n\n# and、or、not\n\n * and、or、not 是用于对过滤条件的逻辑处理指令。\n * and 优先级高于 or，为了明确处理顺序，可以使用 ()。\n * and 操作符表示左右条件都要满足。\n * or 操作符表示左右条件满足任意一个即可。\n * not 操作符用于否定一个条件。\n\nand 示例\n\nselect prod_id, prod_name, prod_price\nfrom products\nwhere vend_id = 'dll01' and prod_price <= 4;\n\n\n1\n2\n3\n\n\nor 示例\n\nselect prod_id, prod_name, prod_price\nfrom products\nwhere vend_id = 'dll01' or vend_id = 'brs01';\n\n\n1\n2\n3\n\n\nnot 示例\n\nselect *\nfrom products\nwhere prod_price not between 3 and 5;\n\n\n1\n2\n3\n\n\n\n# like\n\n * like 操作符在 where 子句中使用，作用是确定字符串是否匹配模式。\n * 只有字段是文本值时才使用 like。\n * like 支持两个通配符匹配选项：% 和 _。\n * 不要滥用通配符，通配符位于开头处匹配会非常慢。\n * % 表示任何字符出现任意次数。\n * _ 表示任何字符出现一次。\n\n% 示例\n\nselect prod_id, prod_name, prod_price\nfrom products\nwhere prod_name like '%bean bag%';\n\n\n1\n2\n3\n\n\n_ 示例\n\nselect prod_id, prod_name, prod_price\nfrom products\nwhere prod_name like '__ inch teddy bear';\n\n\n1\n2\n3\n\n\n\n# 四、连接和组合\n\n\n# 连接（join）\n\n>  * 如果一个 join 至少有一个公共字段并且它们之间存在关系，则该 join 可以在两个或多个表上工作。\n> \n>  * 连接用于连接多个表，使用 join 关键字，并且条件语句使用 on 而不是 where。\n> \n>  * join 保持基表（结构和数据）不变。\n> \n>  * join 有两种连接类型：内连接和外连接。\n> \n>  * 内连接又称等值连接，使用 inner\n>    \n>    join\n>    \n>    \n>    1\n>    \n>    \n>    关键字。在没有条件语句的情况下返回笛卡尔积。\n>    \n>    * 自连接可以看成内连接的一种，只是连接的表是自身而已。\n> \n>  * 自然连接是把同名列通过 = 测试连接起来的，同名列可以有多个。\n> \n>  * 内连接 vs 自然连接\n>    \n>    * 内连接提供连接的列，而自然连接自动连接所有同名列。\n> \n>  * 外连接返回一个表中的所有行，并且仅返回来自次表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（my 不支持）。\n>    \n>    * 左外连接就是保留左表没有关联的行。\n>    * 右外连接就是保留右表没有关联的行。\n> \n>  * 连接 vs 子查询\n>    \n>    * 连接可以替换子查询，并且比子查询的效率一般会更快。\n>    \n>    \n\n# 内连接（inner join）\n\nselect vend_name, prod_name, prod_price\nfrom vendors inner join products\non vendors.vend_id = products.vend_id;\n\n\n1\n2\n3\n\n\n# 自连接\n\nselect c1.cust_id, c1.cust_name, c1.cust_contact\nfrom customers c1, customers c2\nwhere c1.cust_name = c2.cust_name\nand c2.cust_contact = 'jim jones';\n\n\n1\n2\n3\n4\n\n\n# 自然连接（natural join）\n\nselect *\nfrom products\nnatural join customers;\n\n\n1\n2\n3\n\n\n# 左连接（left join）\n\nselect customers.cust_id, orders.order_num\nfrom customers left join orders\non customers.cust_id = orders.cust_id;\n\n\n1\n2\n3\n\n\n# 右连接（right join）\n\nselect customers.cust_id, orders.order_num\nfrom customers right join orders\non customers.cust_id = orders.cust_id;\n\n\n1\n2\n3\n\n\n\n# 组合（union）\n\n * union 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 union 中参与查询的提取行。\n\n * union\n   \n   \n   1\n   \n   \n   基本规则\n   \n   * 所有查询的列数和列顺序必须相同。\n   * 每个查询中涉及表的列的数据类型必须相同或兼容。\n   * 通常返回的列名取自第一个查询。\n\n * 默认会去除相同行，如果需要保留相同行，使用 union all。\n\n * 只能包含一个 order by 子句，并且必须位于语句的最后。\n\n * 应用场景\n   \n   * 在一个查询中从不同的表返回结构数据。\n   * 对一个表执行多个查询，按一个查询返回数据。\n\n组合查询\n\nselect cust_name, cust_contact, cust_email\nfrom customers\nwhere cust_state in ('il', 'in', 'mi')\nunion\nselect cust_name, cust_contact, cust_email\nfrom customers\nwhere cust_name = 'fun4all';\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# join vs union\n\n * join vs union\n   * join 中连接表的列可能不同，但在 union 中，所有查询的列数和列顺序必须相同。\n   * union 将查询之后的行放在一起（垂直放置），但 join 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。\n\n\n# 五、函数\n\n> 🔔 注意：不同数据库的函数往往各不相同，因此不可移植。本节主要以 my 的函数为例。\n\n\n# 文本处理\n\n函数                说明\nleft()、right()    左边或者右边的字符\nlower()、upper()   转换为小写或者大写\nltrim()、rtim()    去除左边或者右边的空格\nlength()          长度\nsoundex()         转换为语音值\n\n其中，soundex() 可以将一个字符串转换为描述其语音表示的字母数字模式。\n\nselect *\nfrom mytable\nwhere soundex(col1) = soundex('apple')\n\n\n1\n2\n3\n\n\n\n# 日期和时间处理\n\n * 日期格式：yyyy-mm-dd\n * 时间格式：hh:mm:ss\n\n函 数             说 明\nadddate()       增加一个日期（天、周等）\naddtime()       增加一个时间（时、分等）\ncurdate()       返回当前日期\ncurtime()       返回当前时间\ndate()          返回日期时间的日期部分\ndatediff()      计算两个日期之差\ndate_add()      高度灵活的日期运算函数\ndate_format()   返回一个格式化的日期或时间串\nday()           返回一个日期的天数部分\ndayofweek()     对于一个日期，返回对应的星期几\nhour()          返回一个时间的小时部分\nminute()        返回一个时间的分钟部分\nmonth()         返回一个日期的月份部分\nnow()           返回当前日期和时间\nsecond()        返回一个时间的秒部分\ntime()          返回一个日期时间的时间部分\nyear()          返回一个日期的年份部分\n\nmy> select now();\n\n\n1\n\n\n2018-4-14 20:25:11\n\n\n1\n\n\n\n# 数值处理\n\n函数       说明\nsin()    正弦\ncos()    余弦\ntan()    正切\nabs()    绝对值\nsqrt()   平方根\nmod()    余数\nexp()    指数\npi()     圆周率\nrand()   随机数\n\n\n# 汇总\n\n函 数       说 明\navg()     返回某列的平均值\ncount()   返回某列的行数\nmax()     返回某列的最大值\nmin()     返回某列的最小值\nsum()     返回某列值之和\n\navg() 会忽略 null 行。\n\n使用 distinct 可以让汇总函数值汇总不同的值。\n\nselect avg(distinct col1) as avg_col\nfrom mytable\n\n\n1\n2\n\n\n\n# 六、排序和分组\n\n\n# order by\n\n * order by\n   \n   \n   1\n   \n   \n   用于对结果集进行排序。\n   \n   * asc ：升序（默认）\n   * desc ：降序\n\n * 可以按多个列进行排序，并且为每个列指定不同的排序方式\n\n指定多个列的排序方向\n\nselect * from products\norder by prod_price desc, prod_name asc;\n\n\n1\n2\n\n\n\n# group by\n\n * group by 子句将记录分组到汇总行中。\n * group by 为每个组返回一个记录。\n * group by 通常还涉及聚合：count，max，sum，avg 等。\n * group by 可以按一列或多列进行分组。\n * group by 按分组字段进行排序后，order by 可以以汇总字段来进行排序。\n\n分组\n\nselect cust_name, count(cust_address) as addr_num\nfrom customers group by cust_name;\n\n\n1\n2\n\n\n分组后排序\n\nselect cust_name, count(cust_address) as addr_num\nfrom customers group by cust_name\norder by cust_name desc;\n\n\n1\n2\n3\n\n\n\n# having\n\n * having 用于对汇总的 group by 结果进行过滤。\n\n * having 要求存在一个 group by 子句。\n\n * where 和 having 可以在相同的查询中。\n\n * having\n   \n   \n   1\n   \n   \n   vs\n   \n   where\n   \n   \n   1\n   \n   * where 和 having 都是用于过滤。\n   * having 适用于汇总的组记录；而 where 适用于单个记录。\n\n使用 where 和 having 过滤数据\n\nselect cust_name, count(*) as num\nfrom customers\nwhere cust_email is not null\ngroup by cust_name\nhaving count(*) >= 1;\n\n\n1\n2\n3\n4\n5\n\n\n----------------------------------------\n\n（以下为 ddl 语句用法）\n\n\n# 七、数据定义\n\n> ddl 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）。\n\n\n# 数据库（database）\n\n# 创建数据库\n\ncreate database test;\n\n\n1\n\n\n# 删除数据库\n\ndrop database test;\n\n\n1\n\n\n# 选择数据库\n\nuse test;\n\n\n1\n\n\n\n# 数据表（table）\n\n# 创建数据表\n\n普通创建\n\ncreate table user (\n  id int(10) unsigned not null comment 'id',\n  username varchar(64) not null default 'default' comment '用户名',\n  password varchar(64) not null default 'default' comment '密码',\n  email varchar(64) not null default 'default' comment '邮箱'\n) comment='用户表';\n\n\n1\n2\n3\n4\n5\n6\n\n\n根据已有的表创建新表\n\ncreate table vip_user as\nselect * from user;\n\n\n1\n2\n\n\n# 删除数据表\n\ndrop table user;\n\n\n1\n\n\n# 修改数据表\n\n添加列\n\nalter table user\nadd age int(3);\n\n\n1\n2\n\n\n删除列\n\nalter table user\ndrop column age;\n\n\n1\n2\n\n\n修改列\n\nalter table `user`\nmodify column age tinyint;\n\n\n1\n2\n\n\n添加主键\n\nalter table user\nadd primary key (id);\n\n\n1\n2\n\n\n删除主键\n\nalter table user\ndrop primary key;\n\n\n1\n2\n\n\n\n# 视图（view）\n\n>  * 定义\n>    * 视图是基于 语句的结果集的可视化的表。\n>    * 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。\n>  * 作用\n>    * 简化复杂的 操作，比如复杂的联结；\n>    * 只使用实际表的一部分数据；\n>    * 通过只给用户访问视图的权限，保证数据的安全性；\n>    * 更改数据格式和表示。\n\n# 创建视图\n\ncreate view top_10_user_view as\nselect id, username\nfrom user\nwhere id < 10;\n\n\n1\n2\n3\n4\n\n\n# 删除视图\n\ndrop view top_10_user_view;\n\n\n1\n\n\n\n# 索引（index）\n\n>  * 作用\n>    * 通过索引可以更加快速高效地查询数据。\n>    * 用户无法看到索引，它们只能被用来加速查询。\n>  * 注意\n>    * 更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。\n>  * 唯一索引\n>    * 唯一索引表明此索引的每一个索引值只对应唯一的数据记录。\n\n# 创建索引\n\ncreate index user_index\non user (id);\n\n\n1\n2\n\n\n# 创建唯一索引\n\ncreate unique index user_index\non user (id);\n\n\n1\n2\n\n\n# 删除索引\n\nalter table user\ndrop index user_index;\n\n\n1\n2\n\n\n\n# 约束\n\n> 约束用于规定表中的数据规则。\n\n * 如果存在违反约束的数据行为，行为会被约束终止。\n * 约束可以在创建表时规定（通过 create table 语句），或者在表创建之后规定（通过 alter table 语句）。\n * 约束类型\n   * not null - 指示某列不能存储 null 值。\n   * unique - 保证某列的每行必须有唯一的值。\n   * primary key - not null 和 unique 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。\n   * foreign key - 保证一个表中的数据匹配另一个表中的值的参照完整性。\n   * check - 保证列中的值符合指定的条件。\n   * default - 规定没有给列赋值时的默认值。\n\n创建表时使用约束条件：\n\ncreate table users (\n  id int(10) unsigned not null auto_increment comment '自增id',\n  username varchar(64) not null unique default 'default' comment '用户名',\n  password varchar(64) not null default 'default' comment '密码',\n  email varchar(64) not null default 'default' comment '邮箱地址',\n  enabled tinyint(4) default null comment '是否有效',\n  primary key (id)\n) engine=innodb auto_increment=2 default charset=utf8mb4 comment='用户表';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n----------------------------------------\n\n（以下为 tcl 语句用法）\n\n\n# 八、事务处理\n\n>  * 不能回退 select 语句，回退 select 语句也没意义；也不能回退 create 和 drop 语句。\n>  * my 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 start transaction 语句时，会关闭隐式提交；当 commit 或 rollback 语句执行后，事务会自动关闭，重新恢复隐式提交。\n>  * 通过 set autocommit=0 可以取消自动提交，直到 set autocommit=1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。\n>  * 指令\n>    * start transaction - 指令用于标记事务的起始点。\n>    * savepoint - 指令用于创建保留点。\n>    * rollback to - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 start transaction 语句处。\n>    * commit - 提交事务。\n\n-- 开始事务\nstart transaction;\n\n-- 插入操作 a\ninsert into `user`\nvalues (1, 'root1', 'root1', 'xxxx@163.com');\n\n-- 创建保留点 updatea\nsavepoint updatea;\n\n-- 插入操作 b\ninsert into `user`\nvalues (2, 'root2', 'root2', 'xxxx@163.com');\n\n-- 回滚到保留点 updatea\nrollback to updatea;\n\n-- 提交事务，只有操作 a 生效\ncommit;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n----------------------------------------\n\n（以下为 dcl 语句用法）\n\n\n# 九、权限控制\n\n>  * grant 和 revoke 可在几个层次上控制访问权限：\n>    \n>    * 整个服务器，使用 grant all 和 revoke all；\n>    * 整个数据库，使用 on database.*；\n>    * 特定的表，使用 on database.table；\n>    * 特定的列；\n>    * 特定的存储过程。\n> \n>  * 新创建的账户没有任何权限。\n> \n>  * 账户用 username@host 的形式定义，username@% 使用的是默认主机名。\n> \n>  * my 的账户信息保存在 my 这个数据库中。\n>    \n>    use my;\n>    select user from user;\n>    \n>    \n>    1\n>    2\n>    \n\n\n# 创建账户\n\ncreate user myuser identified by 'mypassword';\n\n\n1\n\n\n\n# 修改账户名\n\nupdate user set user='newuser' where user='myuser';\nflush privileges;\n\n\n1\n2\n\n\n\n# 删除账户\n\ndrop user myuser;\n\n\n1\n\n\n\n# 查看权限\n\nshow grants for myuser;\n\n\n1\n\n\n\n# 授予权限\n\ngrant select, insert on *.* to myuser;\n\n\n1\n\n\n\n# 删除权限\n\nrevoke select, insert on *.* from myuser;\n\n\n1\n\n\n\n# 更改密码\n\nset password for myuser = 'mypass';\n\n\n1\n\n\n\n# 十、存储过程\n\n>  * 存储过程可以看成是对一系列 操作的批处理；\n>  * 使用存储过程的好处\n>    * 代码封装，保证了一定的安全性；\n>    * 代码复用；\n>    * 由于是预先编译，因此具有很高的性能。\n>  * 创建存储过程\n>    * 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。\n>    * 包含 in、out 和 inout 三种参数。\n>    * 给变量赋值都需要用 select into 语句。\n>    * 每次只能给一个变量赋值，不支持集合的操作。\n\n\n# 创建存储过程\n\ndrop procedure if exists `proc_adder`;\ndelimiter ;;\ncreate definer=`root`@`localhost` procedure `proc_adder`(in a int, in b int, out sum int)\nbegin\n    declare c int;\n    if a is null then set a = 0;\n    end if;\n\n    if b is null then set b = 0;\n    end if;\n\n    set sum  = a + b;\nend\n;;\ndelimiter ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 使用存储过程\n\nnginxset @b=5;\ncall proc_adder(2,@b,@s);\nselect @s as sum;\n\n\n1\n2\n3\n\n\n\n# 十一、游标\n\n>  * 游标（cursor）是一个存储在 dbms 服务器上的数据库查询，它不是一条 select 语句，而是被该语句检索出来的结果集。\n>  * 在存储过程中使用游标可以对一个结果集进行移动遍历。\n>  * 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。\n>  * 使用游标的四个步骤：\n>    * 声明游标，这个过程没有实际检索出数据；\n>    * 打开游标；\n>    * 取出数据；\n>    * 关闭游标；\n\ndelimiter $\ncreate  procedure gettotal()\nbegin\n    declare total int;\n    -- 创建接收游标数据的变量\n    declare sid int;\n    declare sname varchar(10);\n    -- 创建总数变量\n    declare sage int;\n    -- 创建结束标志变量\n    declare done int default false;\n    -- 创建游标\n    declare cur cursor for select id,name,age from cursor_table where age>30;\n    -- 指定游标循环结束时的返回值\n    declare continue handler for not found set done = true;\n    set total = 0;\n    open cur;\n    fetch cur into sid, sname, sage;\n    while(not done)\n    do\n        set total = total + 1;\n        fetch cur into sid, sname, sage;\n    end while;\n\n    close cur;\n    select total;\nend $\ndelimiter ;\n\n-- 调用存储过程\ncall gettotal();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十二、触发器\n\n> 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。\n\n可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。\n\nmy 不允许在触发器中使用 call 语句 ，也就是不能调用存储过程。\n\nbegin 和 end\n\n当触发器的触发条件满足时，将会执行 begin 和 end 之间的触发器执行动作。\n\n> 🔔 注意：在 my 中，分号 ; 是语句结束的标识符，遇到分号表示该段语句已经结束，my 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 begin 匹配的 end。\n> \n> 这时就会用到 delimiter 命令（delimiter 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：delimiter new_delemiter。new_delemiter 可以设为 1 个或多个长度的符号，默认的是分号 ;，我们可以把它修改为其他符号，如 $ - delimiter $ 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 $，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。\n\nnew 和 old\n\n * my 中定义了 new 和 old 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。\n * 在 insert 型触发器中，new 用来表示将要（before）或已经（after）插入的新数据；\n * 在 update 型触发器中，old 用来表示将要或已经被修改的原数据，new 用来表示将要或已经修改为的新数据；\n * 在 delete 型触发器中，old 用来表示将要或已经被删除的原数据；\n * 使用方法：new.columnname（columnname 为相应数据表某一列名）\n\n\n# 创建触发器\n\n> 提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。\n\ncreate trigger 指令用于创建触发器。\n\n语法：\n\ncreate trigger trigger_name\ntrigger_time\ntrigger_event\non table_name\nfor each row\nbegin\n  trigger_statements\nend;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说明：\n\n * trigger_name：触发器名\n * trigger_time: 触发器的触发时机。取值为 before 或 after。\n * trigger_event: 触发器的监听事件。取值为 insert、update 或 delete。\n * table_name: 触发器的监听目标。指定在哪张表上建立触发器。\n * for each row: 行级监视，my 固定写法，其他 dbms 不同。\n * trigger_statements: 触发器执行动作。是一条或多条 语句的列表，列表内的每条语句都必须用分号 ; 来结尾。\n\n示例：\n\ndelimiter $\ncreate trigger `trigger_insert_user`\nafter insert on `user`\nfor each row\nbegin\n    insert into `user_history`(user_id, operate_type, operate_time)\n    values (new.id, 'add a user',  now());\nend $\ndelimiter ;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 查看触发器\n\nshow triggers;\n\n\n1\n\n\n\n# 删除触发器\n\ndrop trigger if exists trigger_insert_user;\n\n\n1\n\n\n\n# 实际运用\n\n\n# 实际开发中，为什么要替换和避免 sql 中的 in 查询？\n\n在实际开发中，替换和避免 sql 中的 in 查询有以下几个主要原因：\n\n 1. 性能问题： in 查询在某些情况下可能会导致性能问题。当 in 中的值过多时，数据库需要逐个匹配，可能会导致全表扫描，造成性能瓶颈。尤其是当 in 列表中的值很多，数据库需要不断进行多次查询，增加了数据库的负担。\n 2. 查询优化问题： 数据库优化器在处理 in 查询时可能会出现问题。不同数据库系统对 in 查询的优化方式不同，某些情况下可能无法正确优化，导致查询效率下降。\n 3. 内存占用问题： in 查询中的值需要在内存中进行匹配，当 in 列表中的值过多时，会占用大量的内存资源，可能导致内存不足的问题。\n 4. 维护问题： 使用 in 查询时，如果需要修改查询条件中的值，需要手动修改 in 列表中的值，这在维护过程中可能会引入错误。而且，当需要添加或删除值时，也需要相应地修改查询语句。\n\n为了避免这些问题，开发中可以考虑以下方法：\n\n 1. 使用连接查询： 对于 in 查询，有时可以使用连接查询（join）来代替。连接查询的优化器通常能更好地处理大量数据，并且可以避免 in 查询的性能问题。\n 2. 分页查询： 如果 in 查询的目的是为了分页显示数据，可以考虑使用分页查询，将数据分批加载，避免一次性查询过多数据。\n 3. 使用索引： 在 in 查询中，确保被查询的字段上有适当的索引，以加快查询速度。索引可以帮助数据库快速定位匹配的数据。\n 4. 使用 exists 或子查询： 对于某些情况，可以使用 exists 或子查询来代替 in 查询。这种方式在某些情况下可能会更加高效。\n\n总之，在开发中应该根据具体的情况来选择是否使用 in 查询以及如何优化查询性能。合理地使用连接查询、分页查询、索引等方法，可以避免 in 查询带来的性能和维护问题。\n\n\n# 为什么可以用 exists 子查询？\n\nexists 是一种用于判断子查询结果是否存在的 sql 关键字。它通常与主查询一起使用，以确定子查询是否返回了任何行。在某些情况下，使用 exists 可以替代 in 查询，具有一些优势：\n\n 1. 性能优化：exists 查询通常可以通过使用索引等优化手段来提高查询性能。数据库优化器可以更好地处理 exists 查询，从而避免了一些 in 查询可能出现的性能问题。\n 2. 避免重复数据：in 查询在列表中包含重复值时可能会出现重复的查询结果。而 exists 查询则不会出现这个问题，它只关心是否存在满足条件的记录，而不考虑具体的记录内容。\n 3. 适用范围广：exists 查询更加灵活，可以用于更多不同的查询场景，包括子查询中的聚合操作、连接查询等。\n 4. 内存占用更小：exists 查询不需要加载全部的列表值到内存中进行匹配，因此在处理大量数据时，内存占用相对较小。\n\n总结\n\n * in 查询是会加载全部列表值，所以性能低\n * exists 只是会判断列表值是否存在\n\n\n# 参考文献\n\n * sql语法基础知识总结)\n * sql 语法速成手册\n * mysql 教程",charsets:{cjk:!0}},{title:"SQL必知必会题解",frontmatter:{title:"SQL必知必会题解",date:"2023-07-24T14:55:15.000Z",permalink:"/pages/def622/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E5%9F%BA%E7%A1%80/04.SQL/02.SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E9%A2%98%E8%A7%A3.html",relativePath:"03.数据库/01.基础/04.SQL/02.SQL必知必会题解.md",key:"v-a0b324d4",path:"/pages/def622/",headers:[{level:2,title:"检索数据",slug:"检索数据",normalizedTitle:"检索数据",charIndex:59},{level:3,title:"从 Customers 表中检索所有的 ID",slug:"从-customers-表中检索所有的-id",normalizedTitle:"从 customers 表中检索所有的 id",charIndex:68},{level:3,title:"检索并列出已订购产品的清单⭐️",slug:"检索并列出已订购产品的清单",normalizedTitle:"检索并列出已订购产品的清单⭐️",charIndex:214},{level:3,title:"检索所有列",slug:"检索所有列",normalizedTitle:"检索所有列",charIndex:421},{level:2,title:"排序检索数据",slug:"排序检索数据",normalizedTitle:"排序检索数据",charIndex:685},{level:3,title:"检索顾客名称并且排序",slug:"检索顾客名称并且排序",normalizedTitle:"检索顾客名称并且排序",charIndex:696},{level:3,title:"对顾客 ID 和日期排序",slug:"对顾客-id-和日期排序",normalizedTitle:"对顾客 id 和日期排序",charIndex:1013},{level:3,title:"按照数量和价格排序⭐️",slug:"按照数量和价格排序",normalizedTitle:"按照数量和价格排序⭐️",charIndex:1415},{level:3,title:"检查 SQL 语句",slug:"检查-sql-语句",normalizedTitle:"检查 sql 语句",charIndex:1689},{level:2,title:"过滤数据",slug:"过滤数据",normalizedTitle:"过滤数据",charIndex:1937},{level:3,title:"返回固定价格的产品",slug:"返回固定价格的产品",normalizedTitle:"返回固定价格的产品",charIndex:1946},{level:3,title:"返回更高价格的产品",slug:"返回更高价格的产品",normalizedTitle:"返回更高价格的产品",charIndex:2254},{level:3,title:"返回产品并且按照价格排序⭐️",slug:"返回产品并且按照价格排序",normalizedTitle:"返回产品并且按照价格排序⭐️",charIndex:2569},{level:3,title:"返回更多的产品⭐️",slug:"返回更多的产品",normalizedTitle:"返回更多的产品⭐️",charIndex:3039},{level:2,title:"高级数据过滤",slug:"高级数据过滤",normalizedTitle:"高级数据过滤",charIndex:3557},{level:3,title:"检索供应商名称",slug:"检索供应商名称",normalizedTitle:"检索供应商名称",charIndex:3568},{level:3,title:"检索并列出已订购产品的清单⭐️",slug:"检索并列出已订购产品的清单-2",normalizedTitle:"检索并列出已订购产品的清单⭐️",charIndex:214},{level:3,title:"返回所有价格在 3 美元到 6 美元之间的产品的名称和价格",slug:"返回所有价格在-3-美元到-6-美元之间的产品的名称和价格",normalizedTitle:"返回所有价格在 3 美元到 6 美元之间的产品的名称和价格",charIndex:4535},{level:3,title:"纠错 2",slug:"纠错-2",normalizedTitle:"纠错 2",charIndex:4903},{level:2,title:"用通配符进行过滤",slug:"用通配符进行过滤",normalizedTitle:"用通配符进行过滤",charIndex:5429},{level:3,title:"检索产品名称和描述（一）⭐️",slug:"检索产品名称和描述-一",normalizedTitle:"检索产品名称和描述（一）⭐️",charIndex:5915},{level:3,title:"检索产品名称和描述（二）⭐️",slug:"检索产品名称和描述-二",normalizedTitle:"检索产品名称和描述（二）⭐️",charIndex:6240},{level:3,title:"检索产品名称和描述（三）⭐️",slug:"检索产品名称和描述-三",normalizedTitle:"检索产品名称和描述（三）⭐️",charIndex:6641},{level:3,title:"检索产品名称和描述（四）",slug:"检索产品名称和描述-四",normalizedTitle:"检索产品名称和描述（四）",charIndex:7122},{level:2,title:"创建计算字段",slug:"创建计算字段",normalizedTitle:"创建计算字段",charIndex:7507},{level:3,title:"别名",slug:"别名",normalizedTitle:"别名",charIndex:7518},{level:3,title:"打折⭐️",slug:"打折",normalizedTitle:"打折⭐️",charIndex:8318},{level:2,title:"使用函数处理数据",slug:"使用函数处理数据",normalizedTitle:"使用函数处理数据",charIndex:8607},{level:3,title:"顾客登录名⭐️",slug:"顾客登录名",normalizedTitle:"顾客登录名⭐️",charIndex:8620},{level:3,title:"返回 2020 年 1 月的所有订单的订单号和订单日期⭐️",slug:"返回-2020-年-1-月的所有订单的订单号和订单日期",normalizedTitle:"返回 2020 年 1 月的所有订单的订单号和订单日期⭐️",charIndex:9492},{level:2,title:"汇总数据",slug:"汇总数据",normalizedTitle:"汇总数据",charIndex:10675},{level:3,title:"确定已售出产品的总数",slug:"确定已售出产品的总数",normalizedTitle:"确定已售出产品的总数",charIndex:10684},{level:3,title:"确定已售出产品项 BR01 的总数",slug:"确定已售出产品项-br01-的总数",normalizedTitle:"确定已售出产品项 br01 的总数",charIndex:10897},{level:3,title:"确定 Products 表中价格不超过 10 美元的最贵产品的价格",slug:"确定-products-表中价格不超过-10-美元的最贵产品的价格",normalizedTitle:"确定 products 表中价格不超过 10 美元的最贵产品的价格",charIndex:11192},{level:2,title:"分组数据",slug:"分组数据",normalizedTitle:"分组数据",charIndex:11440},{level:3,title:"返回每个订单号各有多少行数",slug:"返回每个订单号各有多少行数",normalizedTitle:"返回每个订单号各有多少行数",charIndex:11816},{level:3,title:"每个供应商成本最低的产品",slug:"每个供应商成本最低的产品",normalizedTitle:"每个供应商成本最低的产品",charIndex:12146},{level:3,title:"返回订单数量总和不小于 100 的所有订单的订单号",slug:"返回订单数量总和不小于-100-的所有订单的订单号",normalizedTitle:"返回订单数量总和不小于 100 的所有订单的订单号",charIndex:12538},{level:3,title:"计算总和",slug:"计算总和",normalizedTitle:"计算总和",charIndex:12925},{level:3,title:"纠错 3⭐️",slug:"纠错-3",normalizedTitle:"纠错 3⭐️",charIndex:13480},{level:2,title:"使用子查询",slug:"使用子查询",normalizedTitle:"使用子查询",charIndex:14538},{level:3,title:"返回购买价格为 10 美元或以上产品的顾客列表",slug:"返回购买价格为-10-美元或以上产品的顾客列表",normalizedTitle:"返回购买价格为 10 美元或以上产品的顾客列表",charIndex:14548},{level:3,title:"确定哪些订单购买了 prod_id 为 BR01 的产品（一）",slug:"确定哪些订单购买了-prod-id-为-br01-的产品-一",normalizedTitle:"确定哪些订单购买了 prod_id 为 br01 的产品（一）",charIndex:15298},{level:3,title:"返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一）",slug:"返回购买-prod-id-为-br01-的产品的所有顾客的电子邮件-一",normalizedTitle:"返回购买 prod_id 为 br01 的产品的所有顾客的电子邮件（一）",charIndex:16045},{level:3,title:"返回每个顾客不同订单的总金额⭐️",slug:"返回每个顾客不同订单的总金额",normalizedTitle:"返回每个顾客不同订单的总金额⭐️",charIndex:17546},{level:3,title:"从 Products 表中检索所有的产品名称以及对应的销售总数",slug:"从-products-表中检索所有的产品名称以及对应的销售总数",normalizedTitle:"从 products 表中检索所有的产品名称以及对应的销售总数",charIndex:18699},{level:2,title:"联结表",slug:"联结表",normalizedTitle:"联结表",charIndex:19546},{level:3,title:"返回顾客名称和相关订单号",slug:"返回顾客名称和相关订单号",normalizedTitle:"返回顾客名称和相关订单号",charIndex:19554},{level:3,title:"返回顾客名称和相关订单号以及每个订单的总价⭐️",slug:"返回顾客名称和相关订单号以及每个订单的总价",normalizedTitle:"返回顾客名称和相关订单号以及每个订单的总价⭐️",charIndex:20317},{level:3,title:"确定哪些订单购买了 prod_id 为 BR01 的产品（二）",slug:"确定哪些订单购买了-prod-id-为-br01-的产品-二",normalizedTitle:"确定哪些订单购买了 prod_id 为 br01 的产品（二）",charIndex:21772},{level:3,title:"返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（二）",slug:"返回购买-prod-id-为-br01-的产品的所有顾客的电子邮件-二",normalizedTitle:"返回购买 prod_id 为 br01 的产品的所有顾客的电子邮件（二）",charIndex:22541},{level:3,title:"确定最佳顾客的另一种方式（二）⭐️",slug:"确定最佳顾客的另一种方式-二",normalizedTitle:"确定最佳顾客的另一种方式（二）⭐️",charIndex:23552},{level:2,title:"创建高级联结",slug:"创建高级联结",normalizedTitle:"创建高级联结",charIndex:25267},{level:3,title:"检索每个顾客的名称和所有的订单号（一）",slug:"检索每个顾客的名称和所有的订单号-一",normalizedTitle:"检索每个顾客的名称和所有的订单号（一）",charIndex:25278},{level:3,title:"检索每个顾客的名称和所有的订单号（二）⭐️",slug:"检索每个顾客的名称和所有的订单号-二",normalizedTitle:"检索每个顾客的名称和所有的订单号（二）⭐️",charIndex:25874},{level:3,title:"返回产品名称和与之相关的订单号",slug:"返回产品名称和与之相关的订单号",normalizedTitle:"返回产品名称和与之相关的订单号",charIndex:26646},{level:3,title:"返回产品名称和每一项产品的总订单数",slug:"返回产品名称和每一项产品的总订单数",normalizedTitle:"返回产品名称和每一项产品的总订单数",charIndex:27208},{level:3,title:"列出供应商及其可供产品的数量",slug:"列出供应商及其可供产品的数量",normalizedTitle:"列出供应商及其可供产品的数量",charIndex:27935},{level:2,title:"组合查询",slug:"组合查询",normalizedTitle:"组合查询",charIndex:28512},{level:3,title:"将两个 SELECT 语句结合起来（一）",slug:"将两个-select-语句结合起来-一",normalizedTitle:"将两个 select 语句结合起来（一）",charIndex:28521},{level:3,title:"将两个 SELECT 语句结合起来（二）",slug:"将两个-select-语句结合起来-二",normalizedTitle:"将两个 select 语句结合起来（二）",charIndex:29089},{level:3,title:"组合 Products 表中的产品名称和 Customers 表中的顾客名称⭐️",slug:"组合-products-表中的产品名称和-customers-表中的顾客名称",normalizedTitle:"组合 products 表中的产品名称和 customers 表中的顾客名称⭐️",charIndex:29663},{level:3,title:"纠错 4",slug:"纠错-4",normalizedTitle:"纠错 4",charIndex:30110}],readingTime:{text:"26 min read",minutes:25.945,time:1556700,words:5189},headersStr:"检索数据 从 Customers 表中检索所有的 ID 检索并列出已订购产品的清单⭐️ 检索所有列 排序检索数据 检索顾客名称并且排序 对顾客 ID 和日期排序 按照数量和价格排序⭐️ 检查 SQL 语句 过滤数据 返回固定价格的产品 返回更高价格的产品 返回产品并且按照价格排序⭐️ 返回更多的产品⭐️ 高级数据过滤 检索供应商名称 检索并列出已订购产品的清单⭐️ 返回所有价格在 3 美元到 6 美元之间的产品的名称和价格 纠错 2 用通配符进行过滤 检索产品名称和描述（一）⭐️ 检索产品名称和描述（二）⭐️ 检索产品名称和描述（三）⭐️ 检索产品名称和描述（四） 创建计算字段 别名 打折⭐️ 使用函数处理数据 顾客登录名⭐️ 返回 2020 年 1 月的所有订单的订单号和订单日期⭐️ 汇总数据 确定已售出产品的总数 确定已售出产品项 BR01 的总数 确定 Products 表中价格不超过 10 美元的最贵产品的价格 分组数据 返回每个订单号各有多少行数 每个供应商成本最低的产品 返回订单数量总和不小于 100 的所有订单的订单号 计算总和 纠错 3⭐️ 使用子查询 返回购买价格为 10 美元或以上产品的顾客列表 确定哪些订单购买了 prod_id 为 BR01 的产品（一） 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一） 返回每个顾客不同订单的总金额⭐️ 从 Products 表中检索所有的产品名称以及对应的销售总数 联结表 返回顾客名称和相关订单号 返回顾客名称和相关订单号以及每个订单的总价⭐️ 确定哪些订单购买了 prod_id 为 BR01 的产品（二） 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（二） 确定最佳顾客的另一种方式（二）⭐️ 创建高级联结 检索每个顾客的名称和所有的订单号（一） 检索每个顾客的名称和所有的订单号（二）⭐️ 返回产品名称和与之相关的订单号 返回产品名称和每一项产品的总订单数 列出供应商及其可供产品的数量 组合查询 将两个 SELECT 语句结合起来（一） 将两个 SELECT 语句结合起来（二） 组合 Products 表中的产品名称和 Customers 表中的顾客名称⭐️ 纠错 4",content:"# SQL 必知必会题解\n\n> 地址：牛客网在线编程_SQL篇_SQL必知必会 (nowcoder.com)\n\n\n# 检索数据\n\n\n# 从 Customers 表中检索所有的 ID\n\n现有表 Customers 如下：\n\nCUST_ID\nA\nB\nC\n\n【问题】编写 SQL 语句，从 Customers 表中检索所有的 cust_id\n\n答案：\n\nselect cust_id from Customers;\n\n\n1\n\n\n\n# 检索并列出已订购产品的清单⭐️\n\n表 OrderItems 含有非空的列 prod_id 代表商品 id，包含了所有已订购的商品（有些已被订购多次）。\n\nPROD_ID\na1\na2\na3\na4\na5\na6\na7\n\n【问题】编写 SQL 语句，检索并列出所有已订购商品（prod_id）的去重后的清单。\n\n答案：\n\nselect distinct prod_id from OrderItems;\n\n\n1\n\n\n\n# 检索所有列\n\n现在有 Customers 表（表中含有列 cust_id 代表客户 id，cust_name 代表客户姓名）\n\nCUST_ID   CUST_NAME\na1        andy\na2        ben\na3        tony\na4        tom\na5        an\na6        lee\na7        hex\n\n【问题】需要编写 SQL 语句，检索所有列。\n\n答案：\n\nselect cust_id, cust_name from Customers;\n\n\n1\n\n\n\n# 排序检索数据\n\n\n# 检索顾客名称并且排序\n\n有表 Customers，cust_id 代表客户 id，cust_name 代表客户姓名。\n\nCUST_ID   CUST_NAME\na1        andy\na2        ben\na3        tony\na4        tom\na5        an\na6        lee\na7        hex\n\n【问题】从 Customers 中检索所有的顾客名称（cust_name），并按从 Z 到 A 的顺序显示结果。(其实就是降序)\n\n答案：\n\nselect cust_name from Customers order by cust_name desc;\n\n\n1\n\n\n\n# 对顾客 ID 和日期排序\n\n有 Orders 表\n\nCUST_ID   ORDER_NUM   ORDER_DATE\nandy      aaaa        2021-01-01 00:00:00\nandy      bbbb        2021-01-01 12:00:00\nbob       cccc        2021-01-10 12:00:00\ndick      dddd        2021-01-11 00:00:00\n\n【问题】编写 SQL 语句，从 Orders 表中检索顾客 ID（cust_id）和订单号（order_num），并先按顾客 ID 对结果进行排序，再按订单日期倒序排列。\n\n答案：\n\nselect cust_id, order_num from Orders order by cust_id, order_date desc;\n\n\n1\n\n\n\n# 按照数量和价格排序⭐️\n\n假设有一个 OrderItems 表\n\nQUANTITY   ITEM_PRICE\n1          100\n10         1003\n2          500\n\n【问题】编写 SQL 语句，显示 OrderItems 表中的数量（quantity）和价格（item_price），并按数量由多到少、价格由高到低排序。\n\nselect quantity, item_price from OrderItems order by quantity desc,item_price desc;\n\n\n1\n\n\n\n# 检查 SQL 语句\n\n有 Vendors 表\n\nVEND_NAME\n海底捞\n小龙坎\n大龙燚\n\n【问题】下面的 SQL 语句有问题吗？尝试将它改正确，使之能够正确运行，并且返回结果根据 vend_name 逆序排列\n\nSELECT vend_name, \nFROM Vendors \nORDER vend_name DESC;\n\n\n1\n2\n3\n\n\n答案：少了个 by\n\nselect vend_name from Vendors order by vend_name desc;\n\n\n1\n\n\n\n# 过滤数据\n\n\n# 返回固定价格的产品\n\n有表 Products\n\nPROD_ID   PROD_NAME        PROD_PRICE\na0018     sockets          9.49\na0019     iphone13         600\nb0018     gucci t-shirts   1000\n\n【问题】从 Products 表中检索产品 ID（prod_id）和产品名称（prod_name），只返回价格为 9.49 美元的产品。\n\n答案：\n\nselect prod_id, prod_name from Products where prod_price = 9.49; \n\n\n1\n\n\n\n# 返回更高价格的产品\n\nProducts 表\n\nPROD_ID   PROD_NAME        PROD_PRICE\na0018     sockets          9.49\na0019     iphone13         600\nb0019     gucci t-shirts   1000\n\n【问题】编写 SQL 语句，从 Products 表中检索产品 ID（prod_id）和产品名称（prod_name），只返回价格为 9 美元或更高的产品。\n\n答案：\n\nselect prod_id, prod_name from Products where prod_price >= 9; \n\n\n1\n\n\n\n# 返回产品并且按照价格排序⭐️\n\n有 Products 表\n\nPROD_ID   PROD_NAME   PROD_PRICE\na0011     egg         3\na0019     sockets     4\nb0019     coffee      15\n\n【问题】编写 SQL 语句，返回 Products 表中所有价格在 3 美元到 6 美元之间的产品的名称（prod_name）和价格（prod_price），然后按价格对结果进行排序\n\n答案：\n\nSELECT prod_name, prod_price\nFROM Products\nWHERE prod_price BETWEEN 3 AND 6\nORDER BY prod_price\n\n# 或者\nSELECT prod_name, prod_price\nFROM Products\nWHERE prod_price >= 3 AND prod_price <= 6\nORDER BY prod_price\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 返回更多的产品⭐️\n\nOrderItems 表含有：订单号 order_num，quantity 产品数量\n\nORDER_NUM   QUANTITY\na1          105\na2          1100\na2          200\na4          1121\na5          10\na2          19\na7          5\n\n【问题】从 OrderItems 表中检索出所有不同且不重复的订单号（order_num），其中每个订单都要包含 100 个或更多的产品。\n\n答案：\n\nSELECT order_num\nFROM OrderItems\nGROUP BY order_num\nHAVING SUM(quantity) >= 100\n\n\n1\n2\n3\n4\n\n\n知识点：\n\n * group by: 字段进行分组可以实现不同且不重复的结果。\n\n * HAVING 子句：用于过滤分组后的结果，只返回满足条件的分组，这里是筛选满足 SUM(quantity) >= 100 条件的分组。\n\n * SUM() 函数：用于计算指定字段的总和，这里是计算 quantity 字段的总和。\n\n\n# 高级数据过滤\n\n\n# 检索供应商名称\n\nVendors 表有字段供应商名称（vend_name）、供应商国家（vend_country）、供应商州（vend_state）\n\nVEND_NAME   VEND_COUNTRY   VEND_STATE\napple       USA            CA\nvivo        CNA            shenzhen\nhuawei      CNA            xian\n\n【问题】编写 SQL 语句，从 Vendors 表中检索供应商名称（vend_name），仅返回加利福尼亚州的供应商（这需要按国家[USA]和州[CA]进行过滤，没准其他国家也存在一个[CA]）\n\n答案：\n\nselect vend_name from Vendors where vend_country = 'USA' AND vend_state = 'CA'\n\n\n1\n\n\n注意：\n\n * 字符串需要使用 单引号 或 双引号 包裹\n\n\n# 检索并列出已订购产品的清单⭐️\n\nOrderItems 表包含了所有已订购的产品（有些已被订购多次）。\n\nPROD_ID   ORDER_NUM   QUANTITY\nBR01      a1          105\nBR02      a2          1100\nBR02      a2          200\nBR03      a4          1121\nBR017     a5          10\nBR02      a2          19\nBR017     a7          5\n\n【问题】编写 SQL 语句，查找所有订购了数量至少 100 个的 BR01、BR02 或BR03 的订单。你需要返回 OrderItems 表的订单号（order_num）、产品 ID（prod_id）和数量（quantity），并按产品 ID 和数量进行过滤。\n\n答案：\n\nselect order_num, prod_id, quantity \nfrom OrderItems \nwhere prod_id in ('BR01', 'BR02','BR03') and quantity >= 100;\n\n\n1\n2\n3\n\n\n\n# 返回所有价格在 3 美元到 6 美元之间的产品的名称和价格\n\n有表 Products\n\nPROD_ID   PROD_NAME   PROD_PRICE\na0011     egg         3\na0019     sockets     4\nb0019     coffee      15\n\n【问题】编写 SQL 语句，返回所有价格在 3 美元到 6 美元之间的产品的名称（prod_name）和价格（prod_price），使用 AND 操作符，然后按价格对结果进行升序排序\n\n答案：\n\nselect prod_name, prod_price \nfrom Products \nwhere prod_price between 3 and 6 \norder by prod_price asc\n\n\n1\n2\n3\n4\n\n\n\n# 纠错 2\n\n供应商表 Vendors 有字段供应商名称 vend_name、供应商国家 vend_country、供应商省份 vend_state\n\nVEND_NAME   VEND_COUNTRY   VEND_STATE\napple       USA            CA\nvivo        CNA            shenzhen\nhuawei      CNA            xian\n\n【问题】修改正确下面 sql，使之正确返回\n\nSELECT vend_name \nFROM Vendors \nORDER BY vend_name\nWHERE vend_country = 'USA' AND vend_state = 'CA';\n\n\n1\n2\n3\n4\n\n\n答案：\n\nSELECT vend_name \nFROM Vendors \nWHERE vend_country = 'USA' AND vend_state = 'CA'\nORDER BY vend_name \n\n\n1\n2\n3\n4\n\n\n知识点：考察 sql 关键词的顺序。\n\norder by 的位置位于所有语句的倒数第二，倒数第一是 limit\n\n\n# 用通配符进行过滤\n\nSQL 通配符必须与 LIKE 运算符一起使用\n\n通配符    说明\n%      用于表示零个或多个字符，可以匹配任意长度的字符串。例如，'abc%' 可以匹配\n       'abc'、'abcd'、'abcxyz' 等。\n_      用于表示单个字符，可以匹配任意单个字符。例如，'a_c' 可以匹配 'abc'、'adc'、'axc' 等，但不能匹配\n       'abcd'、'abcde' 等。\n[ ]    用于表示字符范围，可以匹配指定范围内的任意一个字符。例如，'[a-z]' 可以匹配任意小写字母。\n[^ ]   用于表示字符集的补集，可以匹配不在指定字符集中的任意一个字符。例如，'[^aeiou]' 可以匹配任意非元音字母。\n\n * [^abc]：表示匹配除了 a、b、c 以外的任意一个字符。\n * [^a-z]：表示匹配除了小写字母a到z以外的任意一个字符。\n * [^0-9]：表示匹配除了数字0到9以外的任意一个字符。\n * [^aeiou]：表示匹配除了元音字母 a、e、i、o、u 以外的任意一个字母。\n\n\n# 检索产品名称和描述（一）⭐️\n\nProducts 表\n\nPROD_NAME   PROD_DESC\na0011       usb\na0019       iphone13\nb0019       gucci t-shirts\nc0019       gucci toy\nd0019       lego toy\n\n【问题】编写 SQL 语句，从 Products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中包含 toy 一词的产品名称\n\nselect prod_name, prod_desc \nfrom Products \nwhere prod_desc like '%toy%'\n\n\n1\n2\n3\n\n\n\n# 检索产品名称和描述（二）⭐️\n\nProducts 表\n\nPROD_NAME   PROD_DESC\na0011       usb\na0019       iphone13\nb0019       gucci t-shirts\nc0019       gucci toy\nd0019       lego toy\n\n【问题】编写 SQL 语句，从 Products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中未出现 toy 一词的产品，最后按【产品名称】对结果进行排序（默认升序）。\n\n答案：\n\nselect prod_name, prod_desc \nfrom Products \nwhere prod_desc not like '%toy%'\norder by prod_name\n\n\n1\n2\n3\n4\n\n\n知识点：\n\n * not like 不包含\n\n\n# 检索产品名称和描述（三）⭐️\n\nProducts 表\n\nPROD_NAME   PROD_DESC\na0011       usb\na0019       iphone13\nb0019       gucci t-shirts\nc0019       gucci toy\nd0019       lego carrots toy\n\n【问题】编写 SQL 语句，从 Products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中同时出现 toy 和 carrots 的产品。有好几种方法可以执行此操作，但对于这个挑战题，请使用 AND 和两个 LIKE 比较。\n\n答案：\n\nselect prod_name, prod_desc \nfrom Products \n# where prod_desc like '%carrots%toy%'\nwhere prod_desc like '%toy%' and prod_desc like '%carrots%'\n\n\n1\n2\n3\n4\n\n\n注意：and 的两边都要写上字段名\n\n\n# 检索产品名称和描述（四）\n\nProducts 表\n\nPROD_NAME   PROD_DESC\na0011       usb\na0019       iphone13\nb0019       gucci t-shirts\nc0019       gucci toy\nd0019       lego toy carrots\n\n【问题】编写 SQL 语句，从 Products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回在描述中以先后顺序同时出现 toy 和 carrots 的产品。提示：只需要用带有三个 % 符号的 LIKE 即可。\n\n答案：\n\nselect prod_name, prod_desc \nfrom Products \nwhere prod_desc like '%toy%carrots%'\n\n\n1\n2\n3\n\n\n\n# 创建计算字段\n\n\n# 别名\n\n别名的常见用法是在检索出的结果中重命名表的列字段（为了符合特定的报表要求或客户需求）。有表 Vendors 代表供应商信息，vend_id 供应商 id、vend_name 供应商名称、vend_address 供应商地址、vend_city 供应商城市。\n\nVEND_ID   VEND_NAME       VEND_ADDRESS   VEND_CITY\na001      tencent cloud   address1       shenzhen\na002      huawei cloud    address2       dongguan\na003      aliyun cloud    address3       hangzhou\na003      netease cloud   address4       guangzhou\n\n【问题】编写 SQL 语句，从 Vendors 表中检索 vend_id、vend_name、vend_address 和 vend_city，将 vend_name 重命名为 vname，将 vend_city 重命名为 vcity，将 vend_address 重命名为 vaddress，按供应商名称对结果进行升序排序。\n\n答案：\n\nselect vend_id, vend_name as vname, vend_address as vaddress, vend_city as vcity\nfrom Vendors\norder by vname\n\n# as 可以省略\nSELECT vend_id, vend_name vname, vend_address vaddress, vend_city vcity\nFROM Vendors\nORDER BY vname\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 打折⭐️\n\n我们的示例商店正在进行打折促销，所有产品均降价 10%。Products 表包含 prod_id 产品 id、prod_price 产品价格\n\n【问题】编写 SQL 语句，从 Products 表中返回 prod_id、prod_price 和 sale_price。sale_price 是一个包含促销价格的计算字段。提示：可以乘以 0.9，得到原价的 90%（即 10% 的折扣）\n\n答案：\n\nselect prod_id, prod_price, prod_price * 0.9 as sale_price\nfrom Products\n\n\n1\n2\n\n\n\n# 使用函数处理数据\n\n\n# 顾客登录名⭐️\n\n我们的商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。\n\n给出 Customers 表如下：\n\nCUST_ID   CUST_NAME   CUST_CONTACT   CUST_CITY\na1        Andy Li     Andy Li        Oak Park\na2        Ben Liu     Ben Liu        Oak Park\na3        Tony Dai    Tony Dai       Oak Park\na4        Tom Chen    Tom Chen       Oak Park\na5        An Li       An Li          Oak Park\na6        Lee Chen    Lee Chen       Oak Park\na7        Hex Liu     Hex Liu        Oak Park\n\n【问题】编写 SQL 语句，返回顾客 ID（cust_id）、顾客名称（cust_name）和登录名（user_login），其中登录名全部为大写字母，并由顾客联系人的前两个字符（cust_contact）和其所在城市的前三个字符（cust_city）组成。提示：需要使用函数、拼接和别名。\n\n答案：\n\nselect cust_id, cust_name, upper(concat(substring(cust_contact, 1, 2), substring(cust_city, 1, 3))) as user_login\nfrom Customers\n\n\n1\n2\n\n\n知识点：\n\n关键词：substing,concat,upper\n\n用法：\n\n * 字符串的截取：substring(字符串，起始位置，截取字符数）\n * 字符串的拼接：concat(字符串1，字符串2，字符串3,...)\n * 字母大写：upper(字符串）\n\n\n# 返回 2020 年 1 月的所有订单的订单号和订单日期⭐️\n\nOrders 订单表\n\nORDER_NUM   ORDER_DATE\na0001       2020-01-01 00:00:00\na0002       2020-01-02 00:00:00\na0003       2020-01-01 12:00:00\na0004       2020-02-01 00:00:00\na0005       2020-03-01 00:00:00\n\n【问题】编写 SQL 语句，返回 2020 年 1 月的所有订单的订单号（order_num）和订单日期（order_date），并按订单日期升序排序\n\n答案：\n\nselect order_num, order_date\nfrom Orders\nwhere month(order_date) = '01' and year(order_date) = '2020'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n知识点：\n\nSQL语法基础小结 | 日期和时间处理\n\n> 其他解法\n\n字符串匹配（近似查找法）\n\n用 like 来查找\n\nselect order_num, order_date \nfrom Orders\nwhere order_date like '2020-01%'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n切割字符串\n\nselect order_num, order_date \nfrom Orders\nwhere left(order_date, 7) = '2020-01'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n字符串比较\n\nselect *\nfrom Orders\nwhere order_date >= '2020-01-01 00:00:00' and order_date <= '2020-01-31 23:59:59'\norder by order_date;\n\n\n1\n2\n3\n4\n\n\n用正则来查找（效率不如 like，能用 like 就用 like）\n\nselect order_num, order_date \nfrom Orders\nwhere order_date regexp '2020-01'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n时间函数匹配\n\n利用date_format函数 （参考其中的匹配规则进行匹配）\n\nselect order_num, order_date \nfrom Orders\nwhere date_format(order_date, '%Y-%m')='2020-01'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n\n# 汇总数据\n\n\n# 确定已售出产品的总数\n\nOrderItems 表代表售出的产品，quantity 代表售出商品数量。\n\nQUANTITY\n10\n100\n1000\n10001\n2\n15\n\n【问题】编写 SQL 语句，确定已售出产品的总数。返回 items_ordered 列名，表示已售出商品的总数。\n\n答案：\n\nselect sum(quantity) as items_ordered\nfrom OrderItems\n\n\n1\n2\n\n\n\n# 确定已售出产品项 BR01 的总数\n\nOrderItems 表代表售出的产品，quantity 代表售出商品数量，产品项为 prod_item。\n\nQUANTITY   PROD_ID\n10         AR01\n100        AR10\n1000       BR01\n10001      BR010\n\n【问题】修改创建的语句，确定已售出产品项（prod_item）为 \"BR01\" 的总数。\n\nselect sum(quantity) as items_ordered\nfrom OrderItems\nwhere prod_id = 'BR01'\n\n\n1\n2\n3\n\n\n\n# 确定 Products 表中价格不超过 10 美元的最贵产品的价格\n\nProducts 表\n\nPROD_PRICE\n9.49\n600\n1000\n\n【问题】编写 SQL 语句，确定 Products 表中价格不超过 10 美元的最贵产品的价格（prod_price）。将计算所得的字段命名为 max_price。\n\n答案：\n\nselect max(prod_price) as max_price\nfrom Products\nwhere prod_price <= 10\n\n\n1\n2\n3\n\n\n\n# 分组数据\n\nGROUP BY：\n\n * GROUP BY 子句将记录分组到汇总行中。\n * GROUP BY 为每个组返回一个记录。\n * GROUP BY 通常还涉及聚合COUNT，MAX，SUM，AVG 等。\n * GROUP BY 可以按一列或多列进行分组。\n * GROUP BY 按分组字段进行排序后，ORDER BY 可以以汇总字段来进行排序。\n\nHAVING：\n\n * HAVING 用于对汇总的 GROUP BY 结果进行过滤。\n * HAVING 必须要与 GROUP BY 连用。\n * WHERE 和 HAVING 可以在相同的查询中。\n\nHAVING vs WHERE：\n\n * WHERE：过滤指定的行，后面不能加聚合函数（分组函数）。\n * HAVING：过滤分组，必须要与 GROUP BY 连用，不能单独使用。\n\n\n# 返回每个订单号各有多少行数\n\nOrderItems 表包含每个订单的每个产品\n\nORDER_NUM\na002\na002\na002\na004\na007\n\n【问题】编写 SQL 语句，返回每个订单号（order_num）各有多少行数（order_lines），并按 order_lines 对结果进行升序排序。\n\nselect order_num, count(order_num) as order_lines\nfrom OrderItems\ngroup by order_num\norder by order_lines\n\n\n1\n2\n3\n4\n\n\ncount(*),count(列名) 都可以，区别在于：count(列名) 是统计非 NULL 的行数；\n\n\n# 每个供应商成本最低的产品\n\n有 Products 表，含有字段 prod_price 代表产品价格，vend_id 代表供应商 id\n\nVEND_ID   PROD_PRICE\na0011     100\na0019     0.1\nb0019     1000\nb0019     6980\nb0019     20\n\n【问题】编写 SQL 语句，返回名为 cheapest_item 的字段，该字段包含每个供应商成本最低的产品（使用 Products 表中的 prod_price），然后从最低成本到最高成本对结果进行升序排序。\n\n答案：\n\nselect vend_id, min(prod_price) as cheapest_item \nfrom Products\ngroup by vend_id\norder by cheapest_item\n\n\n1\n2\n3\n4\n\n\n\n# 返回订单数量总和不小于 100 的所有订单的订单号\n\nOrderItems 代表订单商品表，包括：订单号 order_num 和订单数量 quantity。\n\nORDER_NUM   QUANTITY\na1          105\na2          1100\na2          200\na4          1121\na5          10\na2          19\na7          5\n\n【问题】请编写 SQL 语句，返回订单数量总和不小于 100 的所有订单号，最后结果按照订单号升序排序。\n\n答案：\n\nselect order_num\nfrom OrderItems\ngroup by order_num\nhaving sum(quantity) >= 100\norder by order_num\n\n\n1\n2\n3\n4\n5\n\n\n\n# 计算总和\n\nOrderItems 表代表订单信息，包括字段：订单号 order_num 和 item_price 商品售出价格、 quantity 商品数量。\n\nORDER_NUM   ITEM_PRICE   QUANTITY\na1          10           105\na2          1            1100\na2          1            200\na4          2            1121\na5          5            10\na2          1            19\na7          7            5\n\n【问题】编写 SQL 语句，根据订单号聚合，返回订单总价不小于 1000 的所有订单号，最后的结果按订单号进行升序排序。\n\nselect order_num, sum(item_price * quantity) as total_priceice\nfrom OrderItems\ngroup by order_num\nhaving sum(item_price * quantity) >= 1000\norder by order_num\n\n\n1\n2\n3\n4\n5\n\n\n\n# 纠错 3⭐️\n\nOrderItems 表含有 order_num 订单号\n\nORDER_NUM\na002\na002\na002\na004\na007\n\n【问题】将下面代码修改正确后执行\n\nSELECT order_num, COUNT(*) AS items \nFROM OrderItems \nGROUP BY items \nHAVING COUNT(*) >= 3 \nORDER BY items, order_num;\n\n\n1\n2\n3\n4\n5\n\n\n答案：\n\nSELECT order_num, COUNT(*) AS items \nFROM OrderItems \nGROUP BY order_num \n# HAVING COUNT(*) >= 3 这个也可\nHAVING items >= 3\nORDER BY items, order_num;\n\n\n1\n2\n3\n4\n5\n6\n\n\n知识点：执行顺序问题，别名的使用规则\n\n 1. SQL 查询的执行顺序是先执行 FROM、WHERE、GROUP BY、HAVING 和最后是 SELECT。\n\nSELECT order_num, COUNT(*) AS items FROM OrderItems GROUP BY order_num HAVING items >= 3 ORDER BY items, order_num; 这个使用别名不报错；\n\nselect order_num, sum(item_price * quantity) as total_price from OrderItems group by order_num having total_price >= 1000 order by order_num 但为什么这个使用别名就会报错\n\n 2. 在 SQL 查询中，使用别名通常分为两种情况：\n\n * 使用别名在 SELECT 子句中展示计算结果：这种情况下，别名可以直接在其他子句中使用，如在 GROUP BY、HAVING、ORDER BY 等子句中使用别名进行条件过滤或排序。这就是为什么你的第一个查询中使用别名 items 在 HAVING 子句中不会报错的原因。\n * 使用别名在 HAVING 子句中进行条件过滤：这种情况下，数据库管理系统不会识别别名，因为 HAVING 子句是在 GROUP BY 子句之后执行的，此时数据库还没有计算别名对应的结果。所以在 HAVING 子句中使用别名进行条件过滤是会报错的。\n\n\n# 使用子查询\n\n\n# 返回购买价格为 10 美元或以上产品的顾客列表\n\nOrderItems 表示订单商品表，含有字段订单号：order_num、订单价格：item_price；Orders表代表订单信息表，含有顾客id：cust_id 和订单号：order_num\n\nOrderItems 表\n\nORDER_NUM   ITEM_PRICE\na1          10\na2          1\na2          1\na4          2\na5          5\na2          1\na7          7\n\nOrders 表\n\nORDER_NUM   CUST_ID\na1          cust10\na2          cust1\na2          cust1\na4          cust2\na5          cust5\na2          cust1\na7          cust7\n\n【问题】使用子查询，返回购买价格为 10 美元或以上产品的顾客列表，结果无需排序。 注意：你需要使用 OrderItems 表查找匹配的订单号（order_num），然后使用 Order 表检索这些匹配订单的顾客 ID（cust_id）。\n\n答案：\n\nselect cust_id\nfrom Orders\nwhere order_num in (select order_num\n                   from OrderItems\n                   group by order_num\n                   having sum(item_price) >= 10)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 确定哪些订单购买了 prod_id 为 BR01 的产品（一）\n\n表 OrderItems 代表订单商品信息表，prod_id 为产品 id；Orders 表代表订单表有 cust_id 代表顾客 id 和订单日期 order_date\n\nOrderItems 表\n\nPROD_ID   ORDER_NUM\nBR01      a0001\nBR01      a0002\nBR02      a0003\nBR02      a0013\n\nOrders 表\n\nORDER_NUM   CUST_ID   ORDER_DATE\na0001       cust10    2022-01-01 00:00:00\na0002       cust1     2022-01-01 00:01:00\na0003       cust1     2022-01-02 00:00:00\na0013       cust2     2022-01-01 00:20:00\n\n【问题】\n\n编写 SQL 语句，使用子查询来确定哪些订单（在 OrderItems 中）购买了 prod_id 为 \"BR01\" 的产品，然后从 Orders 表中返回每个产品对应的顾客 ID（cust_id）和订单日期（order_date），按订购日期对结果进行升序排序。\n\n答案：\n\nselect cust_id, order_date\nfrom Orders\nwhere order_num in (select order_num\n                   from OrderItems\n                   where prod_id = 'BR01')\n\n\n1\n2\n3\n4\n5\n\n\n\n# 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（一）\n\n你想知道订购 BR01 产品的日期，有表 OrderItems 代表订单商品信息表，prod_id 为产品 id；Orders 表代表订单表有 cust_id 代表顾客 id 和订单日期 order_date；Customers 表含有 cust_email 顾客邮件和 cust_id 顾客 id\n\nOrderItems 表\n\nPROD_ID   ORDER_NUM\nBR01      a0001\nBR01      a0002\nBR02      a0003\nBR02      a0013\n\nOrders 表\n\nORDER_NUM   CUST_ID   ORDER_DATE\na0001       cust10    2022-01-01 00:00:00\na0002       cust1     2022-01-01 00:01:00\na0003       cust1     2022-01-02 00:00:00\na0013       cust2     2022-01-01 00:20:00\n\nCustomers 表代表顾客信息，cust_id 为顾客 id，cust_email 为顾客 email\n\n【问题】返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（Customers 表中的 cust_email），结果无需排序。\n\n提示：这涉及 SELECT 语句，最内层的从 OrderItems 表返回 order_num，中间的从 Customers 表返回 cust_id。\n\n答案：\n\n# 写法 1：子查询\nselect cust_email\nfrom Customers \nwhere cust_id in (select cust_id\n                   from Orders\n                   where order_num in (select order_num\n                                       from OrderItems\n                                       where prod_id = 'BR01'))                                                                          \n# 写法 2: 连接表（inner join）\nSELECT c.cust_email\nFROM OrderItems a,Orders b,Customers c\nWHERE a.order_num = b.order_num AND b.cust_id = c.cust_id AND a.prod_id = 'BR01'\n\n# 写法 3：连接表（left join）\nSELECT c.cust_email\nFROM Orders a LEFT JOIN\n  OrderItems b ON a.order_num = b.order_num LEFT JOIN\n  Customers c ON a.cust_id = c.cust_id\nWHERE b.prod_id = 'BR01'                             \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 返回每个顾客不同订单的总金额⭐️\n\n我们需要一个顾客 ID 列表，其中包含他们已订购的总金额。\n\nOrderItems 表代表订单信息，OrderItems 表有订单号：order_num 和商品售出价格：item_price、商品数量：quantity。\n\nORDER_NUM   ITEM_PRICE   QUANTITY\na0001       10           105\na0002       1            1100\na0002       1            200\na0013       2            1121\na0003       5            10\na0003       1            19\na0003       7            5\n\nOrders 表订单号：order_num、顾客 id：cust_id\n\nORDER_NUM   CUST_ID\na0001       cust10\na0002       cust1\na0003       cust1\na0013       cust2\n\n【问题】\n\n编写 SQL 语句，返回顾客 ID（Orders 表中的 cust_id），并使用子查询返回 total_ordered 以便返回每个顾客的订单总数，将结果按金额从大到小排序。\n\n提示：你之前已经使用 SUM() 计算订单总数。\n\n答案：\n\n# 写法 1：子查询\nselect o.cust_id as cust_id, tb.total_ordered as total_ordered\nfrom (select order_num, sum(item_price * quantity) as total_ordered\n    from OrderItems \n    group by order_num) as tb,\n  Orders  o\nwhere tb.order_num = o.order_num\norder by total_ordered desc\n\n# 写法 2：连接表\nselect b.cust_id, sum(a.quantity * a.item_price) as total_ordered\nfrom OrderItems a, Orders b\nwhere a.order_num = b.order_num\ngroup by cust_id\norder by total_ordered desc\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n知识点：\n\n * 隐式内连接用 where\n * 显示内连接用 on\n\n\n# 从 Products 表中检索所有的产品名称以及对应的销售总数\n\nProducts 表中检索所有的产品名称：prod_name、产品 id：prod_id\n\nPROD_ID   PROD_NAME\na0001     egg\na0002     sockets\na0013     coffee\na0003     cola\n\nOrderItems 代表订单商品表，订单产品：prod_id、售出数量：quantity\n\nPROD_ID   QUANTITY\na0001     105\na0002     1100\na0002     200\na0013     1121\na0003     10\na0003     19\na0003     5\n\n【问题】\n\n编写 SQL 语句，从 Products 表中检索所有的产品名称（prod_name），以及名为 quant_sold 的计算列，其中包含所售产品的总数（在 OrderItems 表上使用子查询和 SUM(quantity) 检索）。\n\n答案：\n\n# 写法 1：子查询\nSELECT p.prod_name, tb.quant_sold\nFROM (SELECT prod_id, Sum(quantity) AS quant_sold\n    FROM OrderItems\n    GROUP BY prod_id) AS tb,\n  Products p\nWHERE tb.prod_id = p.prod_id\n\n# 写法 2：连接表\nSELECT p.prod_name, Sum(o.quantity) AS quant_sold\nFROM Products p,\n  OrderItems o\nWHERE p.prod_id = o.prod_id\nGROUP BY p.prod_name（这里不能用 p.prod_id，会报错）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 联结表\n\n\n# 返回顾客名称和相关订单号\n\nCustomers 表有字段顾客名称cust_name、顾客id cust_id\n\nCUST_ID    CUST_NAME\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\n\nOrders订单信息表，含有字段order_num订单号、cust_id顾客id\n\nORDER_NUM   CUST_ID\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\n【问题】\n\n编写 SQL 语句，返回 Customers 表中的顾客名称（cust_name）和 Orders 表中的相关订单号（order_num），并按顾客名称再按订单号对结果进行升序排序。你可以尝试用两个不同的写法，一个使用简单的等联结语法，另外一个使用 INNER JOIN。\n\n# 方法一\nselect c.cust_name, o.order_num\nfrom Customers c, Orders o\nwhere c.cust_id = o.cust_id\norder by c.cust_name\n\n# 方法二：inner join\nselect c.cust_name, o.order_num\nfrom Customers c join Orders o\non c.cust_id = o.cust_id\norder by c.cust_name\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 返回顾客名称和相关订单号以及每个订单的总价⭐️\n\nCustomers 表有字段，顾客名称：cust_name、顾客 id：cust_id\n\nCUST_ID    CUST_NAME\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\n\nOrders 订单信息表，含有字段，订单号：order_num、顾客 id：cust_id\n\nORDER_NUM   CUST_ID\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\nOrderItems 表有字段，商品订单号：order_num、商品数量：quantity、商品价格：item_price\n\nORDER_NUM   QUANTITY   ITEM_PRICE\na1          1000       10\na2          200        10\na3          10         15\na4          25         50\na5          15         25\na7          7          7\n\n【问题】除了返回顾客名称和订单号，返回 Customers 表中的顾客名称（cust_name）和 Orders 表中的相关订单号（order_num），添加第三列 OrderTotal，其中包含每个订单的总价，并按顾客名称再按订单号对结果进行升序排序。\n\n答案：\n\n# 等连接语法\nselect c.cust_name, o.order_num, sum(o2.quantity * o2.item_price) as OrderTotal\nfrom Customers c, Orders o, OrderItems o2\nwhere c.cust_id = o.cust_id and o.order_num = o2.order_num\ngroup by c.cust_name, o.order_num\norder by c.cust_name, o.order_num\n\n\n1\n2\n3\n4\n5\n6\n\n\n知识点：\n\n * 分组：通过在 GROUP BY 子句中使用 c.cust_name, o.order_num 来指定按 Customers 表中的 cust_name 和 Orders 表中的 order_num 对查询结果进行分组。这样，查询结果将按照顾客姓名和订单号进行分组，每个分组对应一个顾客的一个订单。（唯一的）\n\n分组的目的是将具有相同 cust_name 和 order_num 字段值的数据行归为一组，并对每个组内的数据进行聚合操作。\n\n> 一句话，select 中的字段要么都聚类，要么都不聚类\n\n是否要分组取决于查询的需求。\n\n如果不需要对数据进行聚合操作或按照某些字段进行统计计算，那么可以不使用分组。但在这个查询中，由于需要计算每个订单的总金额，所以需要按照 cust_name 和 order_num 字段进行分组。如果不使用 GROUP BY，查询结果将会是没有经过聚合计算的所有数据行，而不是按订单进行汇总后的结果。\n\n\n# 确定哪些订单购买了 prod_id 为 BR01 的产品（二）\n\n表 OrderItems 代表订单商品信息表，prod_id 为产品 id；Orders 表代表订单表有 cust_id 代表顾客 id 和订单日期 order_date\n\nOrderItems 表\n\nPROD_ID   ORDER_NUM\nBR01      a0001\nBR01      a0002\nBR02      a0003\nBR02      a0013\n\nOrders 表\n\nORDER_NUM   CUST_ID   ORDER_DATE\na0001       cust10    2022-01-01 00:00:00\na0002       cust1     2022-01-01 00:01:00\na0003       cust1     2022-01-02 00:00:00\na0013       cust2     2022-01-01 00:20:00\n\n【问题】编写 SQL 语句，使用子查询来确定哪些订单（在 OrderItems 中）购买了 prod_id 为 \"BR01\" 的产品，然后从 Orders 表中返回每个产品对应的顾客 ID（cust_id）和订单日期（order_date），按订购日期对结果进行升序排序。\n\n答案：\n\nselect cust_id, order_date\nfrom Orders\nwhere order_num in (select order_num\n                    from OrderItems\n                    where prod_id = 'BR01')\norder by order_date\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（二）\n\n有表 OrderItems 代表订单商品信息表，prod_id 为产品 id；Orders 表代表订单表有 cust_id 代表顾客 id 和订单日期 order_date；Customers 表含有 cust_email 顾客邮件和 cust_id 顾客 id\n\nOrderItems 表\n\nPROD_ID   ORDER_NUM\nBR01      a0001\nBR01      a0002\nBR02      a0003\nBR02      a0013\n\nOrders表\n\nORDER_NUM   CUST_ID   ORDER_DATE\na0001       cust10    2022-01-01 00:00:00\na0002       cust1     2022-01-01 00:01:00\na0003       cust1     2022-01-02 00:00:00\na0013       cust2     2022-01-01 00:20:00\n\nCustomers 表代表顾客信息，cust_id 为顾客 id，cust_email 为顾客 email\n\n【问题】返回购买 prod_id 为 BR01 的产品的所有顾客的电子邮件（Customers 表中的 cust_email），结果无需排序。\n\n提示：涉及到 SELECT 语句，最内层的从 OrderItems 表返回 order_num，中间的从 Customers 表返回 cust_id，但是必须使用 INNER JOIN 语法。(我看未必)\n\nselect cust_email\nfrom Customers \nwhere cust_id in (select cust_id\n                    from Orders\n                    where order_num in (select order_num\n                                        from OrderItems\n                                        where prod_id = 'BR01'))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 确定最佳顾客的另一种方式（二）⭐️\n\nOrderItems 表代表订单信息，确定最佳顾客的另一种方式是看他们花了多少钱，OrderItems 表有订单号 order_num 和 item_price 商品售出价格、quantity 商品数量\n\nORDER_NUM   ITEM_PRICE   QUANTITY\na1          10           105\na2          1            1100\na2          1            200\na4          2            1121\na5          5            10\na2          1            19\na7          7            5\n\nOrders 表含有字段 order_num 订单号、cust_id 顾客 id\n\nORDER_NUM   CUST_ID\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\n顾客表 Customers 有字段 cust_id 客户 id、cust_name 客户姓名\n\nCUST_ID    CUST_NAME\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\n\n【问题】编写 SQL 语句，返回订单总价不小于1000 的客户名称和总额（OrderItems 表中的order_num）。\n\n提示：需要计算总和（item_price 乘以 quantity）。按总额对结果进行排序，请使用 INNER JOIN 语法。\n\n答案：\n\nselect cust_name, sum(item_price * quantity) as total_price\nfrom Customers\ninner join Orders using(cust_id)\ninner join OrderItems using(order_num)\ngroup by cust_name\nhaving total_price >= 1000\norder by total_price\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n知识点：\n\n通过 using 关键字，根据 cust_id 将 Customers 表和 Orders 表连接，根据 order_num 将 Orders 表和 OrderItems 表连接。\n\nusing 与 on 区别\n\nusing 和 on 是在 SQL 中用于连接表的两种不同方式。\n\n 1. using：\n\n * using 是一种简化的连接语法，用于连接两个表，并指定连接条件的字段。它适用于连接那些具有相同名称的字段的表。\n * 在使用 using 进行连接时，只需在连接的表名之间使用 using 关键字，并在后面紧跟需要进行连接的字段名，这些字段必须在两个表中都存在且名称相同。\n * 例如：INNER JOIN table2 using(column_name)。\n\n 2. on：\n\n * on 是一种更灵活的连接语法，用于连接两个表，并指定连接条件的具体条件。它适用于连接那些具有不同名称或者复杂条件的字段的表。\n * 在使用 on 进行连接时，需要在 on 关键字后面写入连接条件，连接条件可以是简单的等值条件，也可以是更复杂的逻辑条件。\n * 例如：INNER JOIN table2 on table1.column_name = table2.column_name。\n\n总结：\n\n * using 适用于连接具有相同名称的字段的表，它简洁且适用于某些特定场景。\n * on 更灵活，适用于连接具有不同名称或复杂条件的字段的表，它提供了更多的连接方式和条件控制。\n\n\n# 创建高级联结\n\n\n# 检索每个顾客的名称和所有的订单号（一）\n\nCustomers 表代表顾客信息含有顾客 id cust_id 和 顾客名称 cust_name\n\nCUST_ID    CUST_NAME\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\n\nOrders表代表订单信息含有订单号order_num和顾客id cust_id\n\nORDER_NUM   CUST_ID\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\n【问题】使用 INNER JOIN 编写 SQL 语句，检索每个顾客的名称（Customers 表中的 cust_name）和所有的订单号（Orders 表中的 order_num），最后根据顾客姓名 cust_name 升序返回。\n\n答案：\n\nselect cust_name, order_num\nfrom Customers\ninner join Orders using(cust_id)\norder by cust_name\n\n\n1\n2\n3\n4\n\n\n\n# 检索每个顾客的名称和所有的订单号（二）⭐️\n\nOrders 表代表订单信息含有订单号 order_num 和顾客 id：cust_id\n\nORDER_NUM   CUST_ID\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\nCustomers 表代表顾客信息含有顾客 id cust_id 和顾客名称 cust_name\n\nCUST_ID    CUST_NAME\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\ncust40     ace\n\n【问题】检索每个顾客的名称（Customers 表中的 cust_name）和所有的订单号（Orders 表中的 order_num），列出所有的顾客，即使他们没有下过订单。最后根据顾客姓名 cust_name 升序返回。\n\nselect cust_name,order_num\nfrom Customers\nleft join Orders using(cust_id)\norder by cust_name;\n\n\n1\n2\n3\n4\n\n\n知识点：\n\n 1. 内联结：inner join。取两列的交集。\n\n 2. 外联结：\n    \n    * left join。左连接，以左边表的列为主，取两列的交集，对于不在右边列存在的名称取 null。\n    \n    * right join。右连接，以右边表的列为主，取两列的交集，对于不在左边列存在的名称取 null。\n\n\n# 返回产品名称和与之相关的订单号\n\nProducts 表为产品信息表含有字段 prod_id 产品 id、prod_name 产品名称\n\nPROD_ID   PROD_NAME\na0001     egg\na0002     sockets\na0013     coffee\na0003     cola\na0023     soda\n\nOrderItems 表为订单信息表含有字段 order_num 订单号和产品 id prod_id\n\nPROD_ID   ORDER_NUM\na0001     a105\na0002     a1100\na0002     a200\na0013     a1121\na0003     a10\na0003     a19\na0003     a5\n\n【问题】使用 OUTER JOIN 联结 Products 表和 OrderItems 表，返回产品名称（prod_name）和与之相关的订单号（order_num）的列表，并按照产品名称升序排序。\n\n答案：\n\nselect prod_name,order_num\nfrom Products\nleft join OrderItems using(prod_id)\norder by prod_name;\n\n\n1\n2\n3\n4\n\n\n\n# 返回产品名称和每一项产品的总订单数\n\nProducts 表为产品信息表含有字段 prod_id 产品 id、prod_name 产品名称\n\nPROD_ID   PROD_NAME\na0001     egg\na0002     sockets\na0013     coffee\na0003     cola\na0023     soda\n\nOrderItems 表为订单信息表含有字段 order_num 订单号和产品 id prod_id\n\nPROD_ID   ORDER_NUM\na0001     a105\na0002     a1100\na0002     a200\na0013     a1121\na0003     a10\na0003     a19\na0003     a5\n\n【问题】使用 OUTER JOIN 联结 Products 表和 OrderItems 表，返回产品名称（prod_name）和每一项产品的总订单数（不是订单号），并按产品名称升序排序。\n\n答案：\n\n# select prod_name, count(order_num) as orders\nselect prod_name, count(o.prod_id) as orders\nfrom Products\nleft join OrderItems o using(prod_id)\ngroup by prod_name\norder by prod_name;\n\n\n1\n2\n3\n4\n5\n6\n\n\n知识点：\n\n * 使用 COUNT() 聚合函数计算每个产品的总订单数，并将结果作为 total_orders 列的值返回。\n\n * 有聚合函数就要分组。\n\n\n# 列出供应商及其可供产品的数量\n\n有 Vendors 表含有 vend_id 供应商 id.\n\nVEND_ID\na0002\na0013\na0003\na0010\n\n有 Products 表含有供应商 id 和供应产品 id\n\nVEND_ID   PROD_ID\na0001     egg\na0002     prod_id_iphone\na00113    prod_id_tea\na0003     prod_id_vivo phone\na0010     prod_id_huawei phone\n\n【问题】\n\n列出供应商（Vendors 表中的 vend_id）及其可供产品的数量，包括没有产品的供应商。你需要使用 OUTER JOIN 和 COUNT() 聚合函数来计算 Products 表中每种产品的数量，最后根据 vend_id 升序排序。\n\n注意：vend_id 列会显示在多个表中，因此在每次引用它时都需要完全限定它。\n\n答案：\n\nselect v.vend_id, count(p.prod_id) as prod_id\nfrom Vendors v\nleft join Products p using(vend_id)\ngroup by v.vend_id\norder by v.vend_id;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 组合查询\n\n\n# 将两个 SELECT 语句结合起来（一）\n\n表 OrderItems 包含订单产品信息，字段 prod_id 代表产品 id、quantity 代表产品数量\n\nPROD_ID   QUANTITY\na0001     105\na0002     100\na0002     200\na0013     1121\na0003     10\na0003     19\na0003     5\nBNBG      10002\n\n【问题】将两个 SELECT 语句结合起来，以便从 OrderItems 表中检索产品 id（prod_id）和 quantity。其中，一个 SELECT 语句过滤数量为 100 的行，另一个 SELECT 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。\n\n答案：\n\nselect prod_id, quantity\nfrom OrderItems\nwhere quantity = 100\nunion\nselect prod_id, quantity\nfrom OrderItems\nwhere prod_id like 'BNBG%'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n知识点：\n\nUNION 组合 | DreamRain (cmty256.github.io)\n\n\n# 将两个 SELECT 语句结合起来（二）\n\n表 OrderItems 包含订单产品信息，字段 prod_id 代表产品 id、quantity 代表产品数量。\n\nPROD_ID   QUANTITY\na0001     105\na0002     100\na0002     200\na0013     1121\na0003     10\na0003     19\na0003     5\nBNBG      10002\n\n【问题】将两个 SELECT 语句结合起来，以便从 OrderItems 表中检索产品 id（prod_id）和 quantity。其中，一个 SELECT 语句过滤数量为 100 的行，另一个 SELECT 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序。 注意：这次仅使用单个 SELECT 语句。\n\n【示例结果】\n\n返回产品id prod_id 和产品数量 quantity\n\nPROD_ID   QUANTITY\na0002     100\nBNBG      10002\n\n答案：\n\nselect prod_id, quantity\nfrom OrderItems\nwhere quantity = 100 or prod_id like 'BNBG%'\n\n\n1\n2\n3\n\n\n\n# 组合 Products 表中的产品名称和 Customers 表中的顾客名称⭐️\n\nProducts 表含有字段 prod_name 代表产品名称\n\nPROD_NAME\nflower\nrice\nring\numbrella\n\nCustomers 表代表顾客信息，cust_name 代表顾客名称\n\nCUST_NAME\nandy\nben\ntony\ntom\nan\nlee\nhex\n\n【问题】\n\n编写 SQL 语句，组合 Products 表中的产品名称（prod_name）和 Customers 表中的顾客名称（cust_name）并返回，然后按产品名称对结果进行升序排序。\n\n答案：\n\n# UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名.\nselect prod_name\nfrom Products\nunion\nselect cust_name\nfrom Customers\norder by prod_name\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 纠错 4\n\n表 Customers 含有字段 cust_name 顾客名、cust_contact 顾客联系方式、cust_state 顾客州、cust_email 顾客 email\n\n\n\n【问题】修正下面错误的 SQL\n\nSELECT cust_name, cust_contact, cust_email \nFROM Customers \nWHERE cust_state = 'MI' \nORDER BY cust_name; \nUNION \nSELECT cust_name, cust_contact, cust_email \nFROM Customers \nWHERE cust_state = 'IL' ORDER BY cust_name;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n答案：\n\nSELECT cust_name, cust_contact, cust_email \nFROM Customers \nWHERE cust_state = 'MI' \nUNION \nSELECT cust_name, cust_contact, cust_email \nFROM Customers \nWHERE cust_state = 'IL' \nORDER BY cust_name;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n错误点：写了两个 order by\n\n知识点：\n\n使用 union 组合查询时，只能使用一条 order by 子句，他必须位于最后一条 select 语句之后，因为对于【结果集】不存在对于一部分数据进行排序，而另一部分用另一种排序规则的情况。",normalizedContent:"# sql 必知必会题解\n\n> 地址：牛客网在线编程_sql篇_sql必知必会 (nowcoder.com)\n\n\n# 检索数据\n\n\n# 从 customers 表中检索所有的 id\n\n现有表 customers 如下：\n\ncust_id\na\nb\nc\n\n【问题】编写 sql 语句，从 customers 表中检索所有的 cust_id\n\n答案：\n\nselect cust_id from customers;\n\n\n1\n\n\n\n# 检索并列出已订购产品的清单⭐️\n\n表 orderitems 含有非空的列 prod_id 代表商品 id，包含了所有已订购的商品（有些已被订购多次）。\n\nprod_id\na1\na2\na3\na4\na5\na6\na7\n\n【问题】编写 sql 语句，检索并列出所有已订购商品（prod_id）的去重后的清单。\n\n答案：\n\nselect distinct prod_id from orderitems;\n\n\n1\n\n\n\n# 检索所有列\n\n现在有 customers 表（表中含有列 cust_id 代表客户 id，cust_name 代表客户姓名）\n\ncust_id   cust_name\na1        andy\na2        ben\na3        tony\na4        tom\na5        an\na6        lee\na7        hex\n\n【问题】需要编写 sql 语句，检索所有列。\n\n答案：\n\nselect cust_id, cust_name from customers;\n\n\n1\n\n\n\n# 排序检索数据\n\n\n# 检索顾客名称并且排序\n\n有表 customers，cust_id 代表客户 id，cust_name 代表客户姓名。\n\ncust_id   cust_name\na1        andy\na2        ben\na3        tony\na4        tom\na5        an\na6        lee\na7        hex\n\n【问题】从 customers 中检索所有的顾客名称（cust_name），并按从 z 到 a 的顺序显示结果。(其实就是降序)\n\n答案：\n\nselect cust_name from customers order by cust_name desc;\n\n\n1\n\n\n\n# 对顾客 id 和日期排序\n\n有 orders 表\n\ncust_id   order_num   order_date\nandy      aaaa        2021-01-01 00:00:00\nandy      bbbb        2021-01-01 12:00:00\nbob       cccc        2021-01-10 12:00:00\ndick      dddd        2021-01-11 00:00:00\n\n【问题】编写 sql 语句，从 orders 表中检索顾客 id（cust_id）和订单号（order_num），并先按顾客 id 对结果进行排序，再按订单日期倒序排列。\n\n答案：\n\nselect cust_id, order_num from orders order by cust_id, order_date desc;\n\n\n1\n\n\n\n# 按照数量和价格排序⭐️\n\n假设有一个 orderitems 表\n\nquantity   item_price\n1          100\n10         1003\n2          500\n\n【问题】编写 sql 语句，显示 orderitems 表中的数量（quantity）和价格（item_price），并按数量由多到少、价格由高到低排序。\n\nselect quantity, item_price from orderitems order by quantity desc,item_price desc;\n\n\n1\n\n\n\n# 检查 sql 语句\n\n有 vendors 表\n\nvend_name\n海底捞\n小龙坎\n大龙燚\n\n【问题】下面的 sql 语句有问题吗？尝试将它改正确，使之能够正确运行，并且返回结果根据 vend_name 逆序排列\n\nselect vend_name, \nfrom vendors \norder vend_name desc;\n\n\n1\n2\n3\n\n\n答案：少了个 by\n\nselect vend_name from vendors order by vend_name desc;\n\n\n1\n\n\n\n# 过滤数据\n\n\n# 返回固定价格的产品\n\n有表 products\n\nprod_id   prod_name        prod_price\na0018     sockets          9.49\na0019     iphone13         600\nb0018     gucci t-shirts   1000\n\n【问题】从 products 表中检索产品 id（prod_id）和产品名称（prod_name），只返回价格为 9.49 美元的产品。\n\n答案：\n\nselect prod_id, prod_name from products where prod_price = 9.49; \n\n\n1\n\n\n\n# 返回更高价格的产品\n\nproducts 表\n\nprod_id   prod_name        prod_price\na0018     sockets          9.49\na0019     iphone13         600\nb0019     gucci t-shirts   1000\n\n【问题】编写 sql 语句，从 products 表中检索产品 id（prod_id）和产品名称（prod_name），只返回价格为 9 美元或更高的产品。\n\n答案：\n\nselect prod_id, prod_name from products where prod_price >= 9; \n\n\n1\n\n\n\n# 返回产品并且按照价格排序⭐️\n\n有 products 表\n\nprod_id   prod_name   prod_price\na0011     egg         3\na0019     sockets     4\nb0019     coffee      15\n\n【问题】编写 sql 语句，返回 products 表中所有价格在 3 美元到 6 美元之间的产品的名称（prod_name）和价格（prod_price），然后按价格对结果进行排序\n\n答案：\n\nselect prod_name, prod_price\nfrom products\nwhere prod_price between 3 and 6\norder by prod_price\n\n# 或者\nselect prod_name, prod_price\nfrom products\nwhere prod_price >= 3 and prod_price <= 6\norder by prod_price\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 返回更多的产品⭐️\n\norderitems 表含有：订单号 order_num，quantity 产品数量\n\norder_num   quantity\na1          105\na2          1100\na2          200\na4          1121\na5          10\na2          19\na7          5\n\n【问题】从 orderitems 表中检索出所有不同且不重复的订单号（order_num），其中每个订单都要包含 100 个或更多的产品。\n\n答案：\n\nselect order_num\nfrom orderitems\ngroup by order_num\nhaving sum(quantity) >= 100\n\n\n1\n2\n3\n4\n\n\n知识点：\n\n * group by: 字段进行分组可以实现不同且不重复的结果。\n\n * having 子句：用于过滤分组后的结果，只返回满足条件的分组，这里是筛选满足 sum(quantity) >= 100 条件的分组。\n\n * sum() 函数：用于计算指定字段的总和，这里是计算 quantity 字段的总和。\n\n\n# 高级数据过滤\n\n\n# 检索供应商名称\n\nvendors 表有字段供应商名称（vend_name）、供应商国家（vend_country）、供应商州（vend_state）\n\nvend_name   vend_country   vend_state\napple       usa            ca\nvivo        cna            shenzhen\nhuawei      cna            xian\n\n【问题】编写 sql 语句，从 vendors 表中检索供应商名称（vend_name），仅返回加利福尼亚州的供应商（这需要按国家[usa]和州[ca]进行过滤，没准其他国家也存在一个[ca]）\n\n答案：\n\nselect vend_name from vendors where vend_country = 'usa' and vend_state = 'ca'\n\n\n1\n\n\n注意：\n\n * 字符串需要使用 单引号 或 双引号 包裹\n\n\n# 检索并列出已订购产品的清单⭐️\n\norderitems 表包含了所有已订购的产品（有些已被订购多次）。\n\nprod_id   order_num   quantity\nbr01      a1          105\nbr02      a2          1100\nbr02      a2          200\nbr03      a4          1121\nbr017     a5          10\nbr02      a2          19\nbr017     a7          5\n\n【问题】编写 sql 语句，查找所有订购了数量至少 100 个的 br01、br02 或br03 的订单。你需要返回 orderitems 表的订单号（order_num）、产品 id（prod_id）和数量（quantity），并按产品 id 和数量进行过滤。\n\n答案：\n\nselect order_num, prod_id, quantity \nfrom orderitems \nwhere prod_id in ('br01', 'br02','br03') and quantity >= 100;\n\n\n1\n2\n3\n\n\n\n# 返回所有价格在 3 美元到 6 美元之间的产品的名称和价格\n\n有表 products\n\nprod_id   prod_name   prod_price\na0011     egg         3\na0019     sockets     4\nb0019     coffee      15\n\n【问题】编写 sql 语句，返回所有价格在 3 美元到 6 美元之间的产品的名称（prod_name）和价格（prod_price），使用 and 操作符，然后按价格对结果进行升序排序\n\n答案：\n\nselect prod_name, prod_price \nfrom products \nwhere prod_price between 3 and 6 \norder by prod_price asc\n\n\n1\n2\n3\n4\n\n\n\n# 纠错 2\n\n供应商表 vendors 有字段供应商名称 vend_name、供应商国家 vend_country、供应商省份 vend_state\n\nvend_name   vend_country   vend_state\napple       usa            ca\nvivo        cna            shenzhen\nhuawei      cna            xian\n\n【问题】修改正确下面 sql，使之正确返回\n\nselect vend_name \nfrom vendors \norder by vend_name\nwhere vend_country = 'usa' and vend_state = 'ca';\n\n\n1\n2\n3\n4\n\n\n答案：\n\nselect vend_name \nfrom vendors \nwhere vend_country = 'usa' and vend_state = 'ca'\norder by vend_name \n\n\n1\n2\n3\n4\n\n\n知识点：考察 sql 关键词的顺序。\n\norder by 的位置位于所有语句的倒数第二，倒数第一是 limit\n\n\n# 用通配符进行过滤\n\nsql 通配符必须与 like 运算符一起使用\n\n通配符    说明\n%      用于表示零个或多个字符，可以匹配任意长度的字符串。例如，'abc%' 可以匹配\n       'abc'、'abcd'、'abcxyz' 等。\n_      用于表示单个字符，可以匹配任意单个字符。例如，'a_c' 可以匹配 'abc'、'adc'、'axc' 等，但不能匹配\n       'abcd'、'abcde' 等。\n[ ]    用于表示字符范围，可以匹配指定范围内的任意一个字符。例如，'[a-z]' 可以匹配任意小写字母。\n[^ ]   用于表示字符集的补集，可以匹配不在指定字符集中的任意一个字符。例如，'[^aeiou]' 可以匹配任意非元音字母。\n\n * [^abc]：表示匹配除了 a、b、c 以外的任意一个字符。\n * [^a-z]：表示匹配除了小写字母a到z以外的任意一个字符。\n * [^0-9]：表示匹配除了数字0到9以外的任意一个字符。\n * [^aeiou]：表示匹配除了元音字母 a、e、i、o、u 以外的任意一个字母。\n\n\n# 检索产品名称和描述（一）⭐️\n\nproducts 表\n\nprod_name   prod_desc\na0011       usb\na0019       iphone13\nb0019       gucci t-shirts\nc0019       gucci toy\nd0019       lego toy\n\n【问题】编写 sql 语句，从 products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中包含 toy 一词的产品名称\n\nselect prod_name, prod_desc \nfrom products \nwhere prod_desc like '%toy%'\n\n\n1\n2\n3\n\n\n\n# 检索产品名称和描述（二）⭐️\n\nproducts 表\n\nprod_name   prod_desc\na0011       usb\na0019       iphone13\nb0019       gucci t-shirts\nc0019       gucci toy\nd0019       lego toy\n\n【问题】编写 sql 语句，从 products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中未出现 toy 一词的产品，最后按【产品名称】对结果进行排序（默认升序）。\n\n答案：\n\nselect prod_name, prod_desc \nfrom products \nwhere prod_desc not like '%toy%'\norder by prod_name\n\n\n1\n2\n3\n4\n\n\n知识点：\n\n * not like 不包含\n\n\n# 检索产品名称和描述（三）⭐️\n\nproducts 表\n\nprod_name   prod_desc\na0011       usb\na0019       iphone13\nb0019       gucci t-shirts\nc0019       gucci toy\nd0019       lego carrots toy\n\n【问题】编写 sql 语句，从 products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回描述中同时出现 toy 和 carrots 的产品。有好几种方法可以执行此操作，但对于这个挑战题，请使用 and 和两个 like 比较。\n\n答案：\n\nselect prod_name, prod_desc \nfrom products \n# where prod_desc like '%carrots%toy%'\nwhere prod_desc like '%toy%' and prod_desc like '%carrots%'\n\n\n1\n2\n3\n4\n\n\n注意：and 的两边都要写上字段名\n\n\n# 检索产品名称和描述（四）\n\nproducts 表\n\nprod_name   prod_desc\na0011       usb\na0019       iphone13\nb0019       gucci t-shirts\nc0019       gucci toy\nd0019       lego toy carrots\n\n【问题】编写 sql 语句，从 products 表中检索产品名称（prod_name）和描述（prod_desc），仅返回在描述中以先后顺序同时出现 toy 和 carrots 的产品。提示：只需要用带有三个 % 符号的 like 即可。\n\n答案：\n\nselect prod_name, prod_desc \nfrom products \nwhere prod_desc like '%toy%carrots%'\n\n\n1\n2\n3\n\n\n\n# 创建计算字段\n\n\n# 别名\n\n别名的常见用法是在检索出的结果中重命名表的列字段（为了符合特定的报表要求或客户需求）。有表 vendors 代表供应商信息，vend_id 供应商 id、vend_name 供应商名称、vend_address 供应商地址、vend_city 供应商城市。\n\nvend_id   vend_name       vend_address   vend_city\na001      tencent cloud   address1       shenzhen\na002      huawei cloud    address2       dongguan\na003      aliyun cloud    address3       hangzhou\na003      netease cloud   address4       guangzhou\n\n【问题】编写 sql 语句，从 vendors 表中检索 vend_id、vend_name、vend_address 和 vend_city，将 vend_name 重命名为 vname，将 vend_city 重命名为 vcity，将 vend_address 重命名为 vaddress，按供应商名称对结果进行升序排序。\n\n答案：\n\nselect vend_id, vend_name as vname, vend_address as vaddress, vend_city as vcity\nfrom vendors\norder by vname\n\n# as 可以省略\nselect vend_id, vend_name vname, vend_address vaddress, vend_city vcity\nfrom vendors\norder by vname\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 打折⭐️\n\n我们的示例商店正在进行打折促销，所有产品均降价 10%。products 表包含 prod_id 产品 id、prod_price 产品价格\n\n【问题】编写 sql 语句，从 products 表中返回 prod_id、prod_price 和 sale_price。sale_price 是一个包含促销价格的计算字段。提示：可以乘以 0.9，得到原价的 90%（即 10% 的折扣）\n\n答案：\n\nselect prod_id, prod_price, prod_price * 0.9 as sale_price\nfrom products\n\n\n1\n2\n\n\n\n# 使用函数处理数据\n\n\n# 顾客登录名⭐️\n\n我们的商店已经上线了，正在创建顾客账户。所有用户都需要登录名，默认登录名是其名称和所在城市的组合。\n\n给出 customers 表如下：\n\ncust_id   cust_name   cust_contact   cust_city\na1        andy li     andy li        oak park\na2        ben liu     ben liu        oak park\na3        tony dai    tony dai       oak park\na4        tom chen    tom chen       oak park\na5        an li       an li          oak park\na6        lee chen    lee chen       oak park\na7        hex liu     hex liu        oak park\n\n【问题】编写 sql 语句，返回顾客 id（cust_id）、顾客名称（cust_name）和登录名（user_login），其中登录名全部为大写字母，并由顾客联系人的前两个字符（cust_contact）和其所在城市的前三个字符（cust_city）组成。提示：需要使用函数、拼接和别名。\n\n答案：\n\nselect cust_id, cust_name, upper(concat(substring(cust_contact, 1, 2), substring(cust_city, 1, 3))) as user_login\nfrom customers\n\n\n1\n2\n\n\n知识点：\n\n关键词：substing,concat,upper\n\n用法：\n\n * 字符串的截取：substring(字符串，起始位置，截取字符数）\n * 字符串的拼接：concat(字符串1，字符串2，字符串3,...)\n * 字母大写：upper(字符串）\n\n\n# 返回 2020 年 1 月的所有订单的订单号和订单日期⭐️\n\norders 订单表\n\norder_num   order_date\na0001       2020-01-01 00:00:00\na0002       2020-01-02 00:00:00\na0003       2020-01-01 12:00:00\na0004       2020-02-01 00:00:00\na0005       2020-03-01 00:00:00\n\n【问题】编写 sql 语句，返回 2020 年 1 月的所有订单的订单号（order_num）和订单日期（order_date），并按订单日期升序排序\n\n答案：\n\nselect order_num, order_date\nfrom orders\nwhere month(order_date) = '01' and year(order_date) = '2020'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n知识点：\n\nsql语法基础小结 | 日期和时间处理\n\n> 其他解法\n\n字符串匹配（近似查找法）\n\n用 like 来查找\n\nselect order_num, order_date \nfrom orders\nwhere order_date like '2020-01%'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n切割字符串\n\nselect order_num, order_date \nfrom orders\nwhere left(order_date, 7) = '2020-01'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n字符串比较\n\nselect *\nfrom orders\nwhere order_date >= '2020-01-01 00:00:00' and order_date <= '2020-01-31 23:59:59'\norder by order_date;\n\n\n1\n2\n3\n4\n\n\n用正则来查找（效率不如 like，能用 like 就用 like）\n\nselect order_num, order_date \nfrom orders\nwhere order_date regexp '2020-01'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n时间函数匹配\n\n利用date_format函数 （参考其中的匹配规则进行匹配）\n\nselect order_num, order_date \nfrom orders\nwhere date_format(order_date, '%y-%m')='2020-01'\norder by order_date\n\n\n1\n2\n3\n4\n\n\n\n# 汇总数据\n\n\n# 确定已售出产品的总数\n\norderitems 表代表售出的产品，quantity 代表售出商品数量。\n\nquantity\n10\n100\n1000\n10001\n2\n15\n\n【问题】编写 sql 语句，确定已售出产品的总数。返回 items_ordered 列名，表示已售出商品的总数。\n\n答案：\n\nselect sum(quantity) as items_ordered\nfrom orderitems\n\n\n1\n2\n\n\n\n# 确定已售出产品项 br01 的总数\n\norderitems 表代表售出的产品，quantity 代表售出商品数量，产品项为 prod_item。\n\nquantity   prod_id\n10         ar01\n100        ar10\n1000       br01\n10001      br010\n\n【问题】修改创建的语句，确定已售出产品项（prod_item）为 \"br01\" 的总数。\n\nselect sum(quantity) as items_ordered\nfrom orderitems\nwhere prod_id = 'br01'\n\n\n1\n2\n3\n\n\n\n# 确定 products 表中价格不超过 10 美元的最贵产品的价格\n\nproducts 表\n\nprod_price\n9.49\n600\n1000\n\n【问题】编写 sql 语句，确定 products 表中价格不超过 10 美元的最贵产品的价格（prod_price）。将计算所得的字段命名为 max_price。\n\n答案：\n\nselect max(prod_price) as max_price\nfrom products\nwhere prod_price <= 10\n\n\n1\n2\n3\n\n\n\n# 分组数据\n\ngroup by：\n\n * group by 子句将记录分组到汇总行中。\n * group by 为每个组返回一个记录。\n * group by 通常还涉及聚合count，max，sum，avg 等。\n * group by 可以按一列或多列进行分组。\n * group by 按分组字段进行排序后，order by 可以以汇总字段来进行排序。\n\nhaving：\n\n * having 用于对汇总的 group by 结果进行过滤。\n * having 必须要与 group by 连用。\n * where 和 having 可以在相同的查询中。\n\nhaving vs where：\n\n * where：过滤指定的行，后面不能加聚合函数（分组函数）。\n * having：过滤分组，必须要与 group by 连用，不能单独使用。\n\n\n# 返回每个订单号各有多少行数\n\norderitems 表包含每个订单的每个产品\n\norder_num\na002\na002\na002\na004\na007\n\n【问题】编写 sql 语句，返回每个订单号（order_num）各有多少行数（order_lines），并按 order_lines 对结果进行升序排序。\n\nselect order_num, count(order_num) as order_lines\nfrom orderitems\ngroup by order_num\norder by order_lines\n\n\n1\n2\n3\n4\n\n\ncount(*),count(列名) 都可以，区别在于：count(列名) 是统计非 null 的行数；\n\n\n# 每个供应商成本最低的产品\n\n有 products 表，含有字段 prod_price 代表产品价格，vend_id 代表供应商 id\n\nvend_id   prod_price\na0011     100\na0019     0.1\nb0019     1000\nb0019     6980\nb0019     20\n\n【问题】编写 sql 语句，返回名为 cheapest_item 的字段，该字段包含每个供应商成本最低的产品（使用 products 表中的 prod_price），然后从最低成本到最高成本对结果进行升序排序。\n\n答案：\n\nselect vend_id, min(prod_price) as cheapest_item \nfrom products\ngroup by vend_id\norder by cheapest_item\n\n\n1\n2\n3\n4\n\n\n\n# 返回订单数量总和不小于 100 的所有订单的订单号\n\norderitems 代表订单商品表，包括：订单号 order_num 和订单数量 quantity。\n\norder_num   quantity\na1          105\na2          1100\na2          200\na4          1121\na5          10\na2          19\na7          5\n\n【问题】请编写 sql 语句，返回订单数量总和不小于 100 的所有订单号，最后结果按照订单号升序排序。\n\n答案：\n\nselect order_num\nfrom orderitems\ngroup by order_num\nhaving sum(quantity) >= 100\norder by order_num\n\n\n1\n2\n3\n4\n5\n\n\n\n# 计算总和\n\norderitems 表代表订单信息，包括字段：订单号 order_num 和 item_price 商品售出价格、 quantity 商品数量。\n\norder_num   item_price   quantity\na1          10           105\na2          1            1100\na2          1            200\na4          2            1121\na5          5            10\na2          1            19\na7          7            5\n\n【问题】编写 sql 语句，根据订单号聚合，返回订单总价不小于 1000 的所有订单号，最后的结果按订单号进行升序排序。\n\nselect order_num, sum(item_price * quantity) as total_priceice\nfrom orderitems\ngroup by order_num\nhaving sum(item_price * quantity) >= 1000\norder by order_num\n\n\n1\n2\n3\n4\n5\n\n\n\n# 纠错 3⭐️\n\norderitems 表含有 order_num 订单号\n\norder_num\na002\na002\na002\na004\na007\n\n【问题】将下面代码修改正确后执行\n\nselect order_num, count(*) as items \nfrom orderitems \ngroup by items \nhaving count(*) >= 3 \norder by items, order_num;\n\n\n1\n2\n3\n4\n5\n\n\n答案：\n\nselect order_num, count(*) as items \nfrom orderitems \ngroup by order_num \n# having count(*) >= 3 这个也可\nhaving items >= 3\norder by items, order_num;\n\n\n1\n2\n3\n4\n5\n6\n\n\n知识点：执行顺序问题，别名的使用规则\n\n 1. sql 查询的执行顺序是先执行 from、where、group by、having 和最后是 select。\n\nselect order_num, count(*) as items from orderitems group by order_num having items >= 3 order by items, order_num; 这个使用别名不报错；\n\nselect order_num, sum(item_price * quantity) as total_price from orderitems group by order_num having total_price >= 1000 order by order_num 但为什么这个使用别名就会报错\n\n 2. 在 sql 查询中，使用别名通常分为两种情况：\n\n * 使用别名在 select 子句中展示计算结果：这种情况下，别名可以直接在其他子句中使用，如在 group by、having、order by 等子句中使用别名进行条件过滤或排序。这就是为什么你的第一个查询中使用别名 items 在 having 子句中不会报错的原因。\n * 使用别名在 having 子句中进行条件过滤：这种情况下，数据库管理系统不会识别别名，因为 having 子句是在 group by 子句之后执行的，此时数据库还没有计算别名对应的结果。所以在 having 子句中使用别名进行条件过滤是会报错的。\n\n\n# 使用子查询\n\n\n# 返回购买价格为 10 美元或以上产品的顾客列表\n\norderitems 表示订单商品表，含有字段订单号：order_num、订单价格：item_price；orders表代表订单信息表，含有顾客id：cust_id 和订单号：order_num\n\norderitems 表\n\norder_num   item_price\na1          10\na2          1\na2          1\na4          2\na5          5\na2          1\na7          7\n\norders 表\n\norder_num   cust_id\na1          cust10\na2          cust1\na2          cust1\na4          cust2\na5          cust5\na2          cust1\na7          cust7\n\n【问题】使用子查询，返回购买价格为 10 美元或以上产品的顾客列表，结果无需排序。 注意：你需要使用 orderitems 表查找匹配的订单号（order_num），然后使用 order 表检索这些匹配订单的顾客 id（cust_id）。\n\n答案：\n\nselect cust_id\nfrom orders\nwhere order_num in (select order_num\n                   from orderitems\n                   group by order_num\n                   having sum(item_price) >= 10)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 确定哪些订单购买了 prod_id 为 br01 的产品（一）\n\n表 orderitems 代表订单商品信息表，prod_id 为产品 id；orders 表代表订单表有 cust_id 代表顾客 id 和订单日期 order_date\n\norderitems 表\n\nprod_id   order_num\nbr01      a0001\nbr01      a0002\nbr02      a0003\nbr02      a0013\n\norders 表\n\norder_num   cust_id   order_date\na0001       cust10    2022-01-01 00:00:00\na0002       cust1     2022-01-01 00:01:00\na0003       cust1     2022-01-02 00:00:00\na0013       cust2     2022-01-01 00:20:00\n\n【问题】\n\n编写 sql 语句，使用子查询来确定哪些订单（在 orderitems 中）购买了 prod_id 为 \"br01\" 的产品，然后从 orders 表中返回每个产品对应的顾客 id（cust_id）和订单日期（order_date），按订购日期对结果进行升序排序。\n\n答案：\n\nselect cust_id, order_date\nfrom orders\nwhere order_num in (select order_num\n                   from orderitems\n                   where prod_id = 'br01')\n\n\n1\n2\n3\n4\n5\n\n\n\n# 返回购买 prod_id 为 br01 的产品的所有顾客的电子邮件（一）\n\n你想知道订购 br01 产品的日期，有表 orderitems 代表订单商品信息表，prod_id 为产品 id；orders 表代表订单表有 cust_id 代表顾客 id 和订单日期 order_date；customers 表含有 cust_email 顾客邮件和 cust_id 顾客 id\n\norderitems 表\n\nprod_id   order_num\nbr01      a0001\nbr01      a0002\nbr02      a0003\nbr02      a0013\n\norders 表\n\norder_num   cust_id   order_date\na0001       cust10    2022-01-01 00:00:00\na0002       cust1     2022-01-01 00:01:00\na0003       cust1     2022-01-02 00:00:00\na0013       cust2     2022-01-01 00:20:00\n\ncustomers 表代表顾客信息，cust_id 为顾客 id，cust_email 为顾客 email\n\n【问题】返回购买 prod_id 为 br01 的产品的所有顾客的电子邮件（customers 表中的 cust_email），结果无需排序。\n\n提示：这涉及 select 语句，最内层的从 orderitems 表返回 order_num，中间的从 customers 表返回 cust_id。\n\n答案：\n\n# 写法 1：子查询\nselect cust_email\nfrom customers \nwhere cust_id in (select cust_id\n                   from orders\n                   where order_num in (select order_num\n                                       from orderitems\n                                       where prod_id = 'br01'))                                                                          \n# 写法 2: 连接表（inner join）\nselect c.cust_email\nfrom orderitems a,orders b,customers c\nwhere a.order_num = b.order_num and b.cust_id = c.cust_id and a.prod_id = 'br01'\n\n# 写法 3：连接表（left join）\nselect c.cust_email\nfrom orders a left join\n  orderitems b on a.order_num = b.order_num left join\n  customers c on a.cust_id = c.cust_id\nwhere b.prod_id = 'br01'                             \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 返回每个顾客不同订单的总金额⭐️\n\n我们需要一个顾客 id 列表，其中包含他们已订购的总金额。\n\norderitems 表代表订单信息，orderitems 表有订单号：order_num 和商品售出价格：item_price、商品数量：quantity。\n\norder_num   item_price   quantity\na0001       10           105\na0002       1            1100\na0002       1            200\na0013       2            1121\na0003       5            10\na0003       1            19\na0003       7            5\n\norders 表订单号：order_num、顾客 id：cust_id\n\norder_num   cust_id\na0001       cust10\na0002       cust1\na0003       cust1\na0013       cust2\n\n【问题】\n\n编写 sql 语句，返回顾客 id（orders 表中的 cust_id），并使用子查询返回 total_ordered 以便返回每个顾客的订单总数，将结果按金额从大到小排序。\n\n提示：你之前已经使用 sum() 计算订单总数。\n\n答案：\n\n# 写法 1：子查询\nselect o.cust_id as cust_id, tb.total_ordered as total_ordered\nfrom (select order_num, sum(item_price * quantity) as total_ordered\n    from orderitems \n    group by order_num) as tb,\n  orders  o\nwhere tb.order_num = o.order_num\norder by total_ordered desc\n\n# 写法 2：连接表\nselect b.cust_id, sum(a.quantity * a.item_price) as total_ordered\nfrom orderitems a, orders b\nwhere a.order_num = b.order_num\ngroup by cust_id\norder by total_ordered desc\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n知识点：\n\n * 隐式内连接用 where\n * 显示内连接用 on\n\n\n# 从 products 表中检索所有的产品名称以及对应的销售总数\n\nproducts 表中检索所有的产品名称：prod_name、产品 id：prod_id\n\nprod_id   prod_name\na0001     egg\na0002     sockets\na0013     coffee\na0003     cola\n\norderitems 代表订单商品表，订单产品：prod_id、售出数量：quantity\n\nprod_id   quantity\na0001     105\na0002     1100\na0002     200\na0013     1121\na0003     10\na0003     19\na0003     5\n\n【问题】\n\n编写 sql 语句，从 products 表中检索所有的产品名称（prod_name），以及名为 quant_sold 的计算列，其中包含所售产品的总数（在 orderitems 表上使用子查询和 sum(quantity) 检索）。\n\n答案：\n\n# 写法 1：子查询\nselect p.prod_name, tb.quant_sold\nfrom (select prod_id, sum(quantity) as quant_sold\n    from orderitems\n    group by prod_id) as tb,\n  products p\nwhere tb.prod_id = p.prod_id\n\n# 写法 2：连接表\nselect p.prod_name, sum(o.quantity) as quant_sold\nfrom products p,\n  orderitems o\nwhere p.prod_id = o.prod_id\ngroup by p.prod_name（这里不能用 p.prod_id，会报错）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 联结表\n\n\n# 返回顾客名称和相关订单号\n\ncustomers 表有字段顾客名称cust_name、顾客id cust_id\n\ncust_id    cust_name\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\n\norders订单信息表，含有字段order_num订单号、cust_id顾客id\n\norder_num   cust_id\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\n【问题】\n\n编写 sql 语句，返回 customers 表中的顾客名称（cust_name）和 orders 表中的相关订单号（order_num），并按顾客名称再按订单号对结果进行升序排序。你可以尝试用两个不同的写法，一个使用简单的等联结语法，另外一个使用 inner join。\n\n# 方法一\nselect c.cust_name, o.order_num\nfrom customers c, orders o\nwhere c.cust_id = o.cust_id\norder by c.cust_name\n\n# 方法二：inner join\nselect c.cust_name, o.order_num\nfrom customers c join orders o\non c.cust_id = o.cust_id\norder by c.cust_name\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 返回顾客名称和相关订单号以及每个订单的总价⭐️\n\ncustomers 表有字段，顾客名称：cust_name、顾客 id：cust_id\n\ncust_id    cust_name\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\n\norders 订单信息表，含有字段，订单号：order_num、顾客 id：cust_id\n\norder_num   cust_id\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\norderitems 表有字段，商品订单号：order_num、商品数量：quantity、商品价格：item_price\n\norder_num   quantity   item_price\na1          1000       10\na2          200        10\na3          10         15\na4          25         50\na5          15         25\na7          7          7\n\n【问题】除了返回顾客名称和订单号，返回 customers 表中的顾客名称（cust_name）和 orders 表中的相关订单号（order_num），添加第三列 ordertotal，其中包含每个订单的总价，并按顾客名称再按订单号对结果进行升序排序。\n\n答案：\n\n# 等连接语法\nselect c.cust_name, o.order_num, sum(o2.quantity * o2.item_price) as ordertotal\nfrom customers c, orders o, orderitems o2\nwhere c.cust_id = o.cust_id and o.order_num = o2.order_num\ngroup by c.cust_name, o.order_num\norder by c.cust_name, o.order_num\n\n\n1\n2\n3\n4\n5\n6\n\n\n知识点：\n\n * 分组：通过在 group by 子句中使用 c.cust_name, o.order_num 来指定按 customers 表中的 cust_name 和 orders 表中的 order_num 对查询结果进行分组。这样，查询结果将按照顾客姓名和订单号进行分组，每个分组对应一个顾客的一个订单。（唯一的）\n\n分组的目的是将具有相同 cust_name 和 order_num 字段值的数据行归为一组，并对每个组内的数据进行聚合操作。\n\n> 一句话，select 中的字段要么都聚类，要么都不聚类\n\n是否要分组取决于查询的需求。\n\n如果不需要对数据进行聚合操作或按照某些字段进行统计计算，那么可以不使用分组。但在这个查询中，由于需要计算每个订单的总金额，所以需要按照 cust_name 和 order_num 字段进行分组。如果不使用 group by，查询结果将会是没有经过聚合计算的所有数据行，而不是按订单进行汇总后的结果。\n\n\n# 确定哪些订单购买了 prod_id 为 br01 的产品（二）\n\n表 orderitems 代表订单商品信息表，prod_id 为产品 id；orders 表代表订单表有 cust_id 代表顾客 id 和订单日期 order_date\n\norderitems 表\n\nprod_id   order_num\nbr01      a0001\nbr01      a0002\nbr02      a0003\nbr02      a0013\n\norders 表\n\norder_num   cust_id   order_date\na0001       cust10    2022-01-01 00:00:00\na0002       cust1     2022-01-01 00:01:00\na0003       cust1     2022-01-02 00:00:00\na0013       cust2     2022-01-01 00:20:00\n\n【问题】编写 sql 语句，使用子查询来确定哪些订单（在 orderitems 中）购买了 prod_id 为 \"br01\" 的产品，然后从 orders 表中返回每个产品对应的顾客 id（cust_id）和订单日期（order_date），按订购日期对结果进行升序排序。\n\n答案：\n\nselect cust_id, order_date\nfrom orders\nwhere order_num in (select order_num\n                    from orderitems\n                    where prod_id = 'br01')\norder by order_date\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 返回购买 prod_id 为 br01 的产品的所有顾客的电子邮件（二）\n\n有表 orderitems 代表订单商品信息表，prod_id 为产品 id；orders 表代表订单表有 cust_id 代表顾客 id 和订单日期 order_date；customers 表含有 cust_email 顾客邮件和 cust_id 顾客 id\n\norderitems 表\n\nprod_id   order_num\nbr01      a0001\nbr01      a0002\nbr02      a0003\nbr02      a0013\n\norders表\n\norder_num   cust_id   order_date\na0001       cust10    2022-01-01 00:00:00\na0002       cust1     2022-01-01 00:01:00\na0003       cust1     2022-01-02 00:00:00\na0013       cust2     2022-01-01 00:20:00\n\ncustomers 表代表顾客信息，cust_id 为顾客 id，cust_email 为顾客 email\n\n【问题】返回购买 prod_id 为 br01 的产品的所有顾客的电子邮件（customers 表中的 cust_email），结果无需排序。\n\n提示：涉及到 select 语句，最内层的从 orderitems 表返回 order_num，中间的从 customers 表返回 cust_id，但是必须使用 inner join 语法。(我看未必)\n\nselect cust_email\nfrom customers \nwhere cust_id in (select cust_id\n                    from orders\n                    where order_num in (select order_num\n                                        from orderitems\n                                        where prod_id = 'br01'))\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 确定最佳顾客的另一种方式（二）⭐️\n\norderitems 表代表订单信息，确定最佳顾客的另一种方式是看他们花了多少钱，orderitems 表有订单号 order_num 和 item_price 商品售出价格、quantity 商品数量\n\norder_num   item_price   quantity\na1          10           105\na2          1            1100\na2          1            200\na4          2            1121\na5          5            10\na2          1            19\na7          7            5\n\norders 表含有字段 order_num 订单号、cust_id 顾客 id\n\norder_num   cust_id\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\n顾客表 customers 有字段 cust_id 客户 id、cust_name 客户姓名\n\ncust_id    cust_name\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\n\n【问题】编写 sql 语句，返回订单总价不小于1000 的客户名称和总额（orderitems 表中的order_num）。\n\n提示：需要计算总和（item_price 乘以 quantity）。按总额对结果进行排序，请使用 inner join 语法。\n\n答案：\n\nselect cust_name, sum(item_price * quantity) as total_price\nfrom customers\ninner join orders using(cust_id)\ninner join orderitems using(order_num)\ngroup by cust_name\nhaving total_price >= 1000\norder by total_price\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n知识点：\n\n通过 using 关键字，根据 cust_id 将 customers 表和 orders 表连接，根据 order_num 将 orders 表和 orderitems 表连接。\n\nusing 与 on 区别\n\nusing 和 on 是在 sql 中用于连接表的两种不同方式。\n\n 1. using：\n\n * using 是一种简化的连接语法，用于连接两个表，并指定连接条件的字段。它适用于连接那些具有相同名称的字段的表。\n * 在使用 using 进行连接时，只需在连接的表名之间使用 using 关键字，并在后面紧跟需要进行连接的字段名，这些字段必须在两个表中都存在且名称相同。\n * 例如：inner join table2 using(column_name)。\n\n 2. on：\n\n * on 是一种更灵活的连接语法，用于连接两个表，并指定连接条件的具体条件。它适用于连接那些具有不同名称或者复杂条件的字段的表。\n * 在使用 on 进行连接时，需要在 on 关键字后面写入连接条件，连接条件可以是简单的等值条件，也可以是更复杂的逻辑条件。\n * 例如：inner join table2 on table1.column_name = table2.column_name。\n\n总结：\n\n * using 适用于连接具有相同名称的字段的表，它简洁且适用于某些特定场景。\n * on 更灵活，适用于连接具有不同名称或复杂条件的字段的表，它提供了更多的连接方式和条件控制。\n\n\n# 创建高级联结\n\n\n# 检索每个顾客的名称和所有的订单号（一）\n\ncustomers 表代表顾客信息含有顾客 id cust_id 和 顾客名称 cust_name\n\ncust_id    cust_name\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\n\norders表代表订单信息含有订单号order_num和顾客id cust_id\n\norder_num   cust_id\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\n【问题】使用 inner join 编写 sql 语句，检索每个顾客的名称（customers 表中的 cust_name）和所有的订单号（orders 表中的 order_num），最后根据顾客姓名 cust_name 升序返回。\n\n答案：\n\nselect cust_name, order_num\nfrom customers\ninner join orders using(cust_id)\norder by cust_name\n\n\n1\n2\n3\n4\n\n\n\n# 检索每个顾客的名称和所有的订单号（二）⭐️\n\norders 表代表订单信息含有订单号 order_num 和顾客 id：cust_id\n\norder_num   cust_id\na1          cust10\na2          cust1\na3          cust2\na4          cust22\na5          cust221\na7          cust2217\n\ncustomers 表代表顾客信息含有顾客 id cust_id 和顾客名称 cust_name\n\ncust_id    cust_name\ncust10     andy\ncust1      ben\ncust2      tony\ncust22     tom\ncust221    an\ncust2217   hex\ncust40     ace\n\n【问题】检索每个顾客的名称（customers 表中的 cust_name）和所有的订单号（orders 表中的 order_num），列出所有的顾客，即使他们没有下过订单。最后根据顾客姓名 cust_name 升序返回。\n\nselect cust_name,order_num\nfrom customers\nleft join orders using(cust_id)\norder by cust_name;\n\n\n1\n2\n3\n4\n\n\n知识点：\n\n 1. 内联结：inner join。取两列的交集。\n\n 2. 外联结：\n    \n    * left join。左连接，以左边表的列为主，取两列的交集，对于不在右边列存在的名称取 null。\n    \n    * right join。右连接，以右边表的列为主，取两列的交集，对于不在左边列存在的名称取 null。\n\n\n# 返回产品名称和与之相关的订单号\n\nproducts 表为产品信息表含有字段 prod_id 产品 id、prod_name 产品名称\n\nprod_id   prod_name\na0001     egg\na0002     sockets\na0013     coffee\na0003     cola\na0023     soda\n\norderitems 表为订单信息表含有字段 order_num 订单号和产品 id prod_id\n\nprod_id   order_num\na0001     a105\na0002     a1100\na0002     a200\na0013     a1121\na0003     a10\na0003     a19\na0003     a5\n\n【问题】使用 outer join 联结 products 表和 orderitems 表，返回产品名称（prod_name）和与之相关的订单号（order_num）的列表，并按照产品名称升序排序。\n\n答案：\n\nselect prod_name,order_num\nfrom products\nleft join orderitems using(prod_id)\norder by prod_name;\n\n\n1\n2\n3\n4\n\n\n\n# 返回产品名称和每一项产品的总订单数\n\nproducts 表为产品信息表含有字段 prod_id 产品 id、prod_name 产品名称\n\nprod_id   prod_name\na0001     egg\na0002     sockets\na0013     coffee\na0003     cola\na0023     soda\n\norderitems 表为订单信息表含有字段 order_num 订单号和产品 id prod_id\n\nprod_id   order_num\na0001     a105\na0002     a1100\na0002     a200\na0013     a1121\na0003     a10\na0003     a19\na0003     a5\n\n【问题】使用 outer join 联结 products 表和 orderitems 表，返回产品名称（prod_name）和每一项产品的总订单数（不是订单号），并按产品名称升序排序。\n\n答案：\n\n# select prod_name, count(order_num) as orders\nselect prod_name, count(o.prod_id) as orders\nfrom products\nleft join orderitems o using(prod_id)\ngroup by prod_name\norder by prod_name;\n\n\n1\n2\n3\n4\n5\n6\n\n\n知识点：\n\n * 使用 count() 聚合函数计算每个产品的总订单数，并将结果作为 total_orders 列的值返回。\n\n * 有聚合函数就要分组。\n\n\n# 列出供应商及其可供产品的数量\n\n有 vendors 表含有 vend_id 供应商 id.\n\nvend_id\na0002\na0013\na0003\na0010\n\n有 products 表含有供应商 id 和供应产品 id\n\nvend_id   prod_id\na0001     egg\na0002     prod_id_iphone\na00113    prod_id_tea\na0003     prod_id_vivo phone\na0010     prod_id_huawei phone\n\n【问题】\n\n列出供应商（vendors 表中的 vend_id）及其可供产品的数量，包括没有产品的供应商。你需要使用 outer join 和 count() 聚合函数来计算 products 表中每种产品的数量，最后根据 vend_id 升序排序。\n\n注意：vend_id 列会显示在多个表中，因此在每次引用它时都需要完全限定它。\n\n答案：\n\nselect v.vend_id, count(p.prod_id) as prod_id\nfrom vendors v\nleft join products p using(vend_id)\ngroup by v.vend_id\norder by v.vend_id;\n\n\n1\n2\n3\n4\n5\n\n\n\n# 组合查询\n\n\n# 将两个 select 语句结合起来（一）\n\n表 orderitems 包含订单产品信息，字段 prod_id 代表产品 id、quantity 代表产品数量\n\nprod_id   quantity\na0001     105\na0002     100\na0002     200\na0013     1121\na0003     10\na0003     19\na0003     5\nbnbg      10002\n\n【问题】将两个 select 语句结合起来，以便从 orderitems 表中检索产品 id（prod_id）和 quantity。其中，一个 select 语句过滤数量为 100 的行，另一个 select 语句过滤 id 以 bnbg 开头的产品，最后按产品 id 对结果进行升序排序。\n\n答案：\n\nselect prod_id, quantity\nfrom orderitems\nwhere quantity = 100\nunion\nselect prod_id, quantity\nfrom orderitems\nwhere prod_id like 'bnbg%'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n知识点：\n\nunion 组合 | dreamrain (cmty256.github.io)\n\n\n# 将两个 select 语句结合起来（二）\n\n表 orderitems 包含订单产品信息，字段 prod_id 代表产品 id、quantity 代表产品数量。\n\nprod_id   quantity\na0001     105\na0002     100\na0002     200\na0013     1121\na0003     10\na0003     19\na0003     5\nbnbg      10002\n\n【问题】将两个 select 语句结合起来，以便从 orderitems 表中检索产品 id（prod_id）和 quantity。其中，一个 select 语句过滤数量为 100 的行，另一个 select 语句过滤 id 以 bnbg 开头的产品，最后按产品 id 对结果进行升序排序。 注意：这次仅使用单个 select 语句。\n\n【示例结果】\n\n返回产品id prod_id 和产品数量 quantity\n\nprod_id   quantity\na0002     100\nbnbg      10002\n\n答案：\n\nselect prod_id, quantity\nfrom orderitems\nwhere quantity = 100 or prod_id like 'bnbg%'\n\n\n1\n2\n3\n\n\n\n# 组合 products 表中的产品名称和 customers 表中的顾客名称⭐️\n\nproducts 表含有字段 prod_name 代表产品名称\n\nprod_name\nflower\nrice\nring\numbrella\n\ncustomers 表代表顾客信息，cust_name 代表顾客名称\n\ncust_name\nandy\nben\ntony\ntom\nan\nlee\nhex\n\n【问题】\n\n编写 sql 语句，组合 products 表中的产品名称（prod_name）和 customers 表中的顾客名称（cust_name）并返回，然后按产品名称对结果进行升序排序。\n\n答案：\n\n# union 结果集中的列名总是等于 union 中第一个 select 语句中的列名.\nselect prod_name\nfrom products\nunion\nselect cust_name\nfrom customers\norder by prod_name\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 纠错 4\n\n表 customers 含有字段 cust_name 顾客名、cust_contact 顾客联系方式、cust_state 顾客州、cust_email 顾客 email\n\n\n\n【问题】修正下面错误的 sql\n\nselect cust_name, cust_contact, cust_email \nfrom customers \nwhere cust_state = 'mi' \norder by cust_name; \nunion \nselect cust_name, cust_contact, cust_email \nfrom customers \nwhere cust_state = 'il' order by cust_name;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n答案：\n\nselect cust_name, cust_contact, cust_email \nfrom customers \nwhere cust_state = 'mi' \nunion \nselect cust_name, cust_contact, cust_email \nfrom customers \nwhere cust_state = 'il' \norder by cust_name;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n错误点：写了两个 order by\n\n知识点：\n\n使用 union 组合查询时，只能使用一条 order by 子句，他必须位于最后一条 select 语句之后，因为对于【结果集】不存在对于一部分数据进行排序，而另一部分用另一种排序规则的情况。",charsets:{cjk:!0}},{title:"MySQL基础小结",frontmatter:{title:"MySQL基础小结",date:"2023-06-22T07:37:52.000Z",permalink:"/pages/ccc445/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Mysql/01.MySQL%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93.html",relativePath:"03.数据库/02.Mysql/01.MySQL基础小结.md",key:"v-202a2426",path:"/pages/ccc445/",headers:[{level:2,title:"非关系型数据库和关系型数据库的区别？",slug:"非关系型数据库和关系型数据库的区别",normalizedTitle:"非关系型数据库和关系型数据库的区别？",charIndex:17},{level:2,title:"有哪些常见的关系型数据库？",slug:"有哪些常见的关系型数据库",normalizedTitle:"有哪些常见的关系型数据库？",charIndex:322},{level:2,title:"什么是 SQL？",slug:"什么是-sql",normalizedTitle:"什么是 sql？",charIndex:408},{level:2,title:"事务的四大特性了解么?",slug:"事务的四大特性了解么",normalizedTitle:"事务的四大特性了解么?",charIndex:502},{level:2,title:"MySQL 事务隔离级别？默认是什么级别？",slug:"mysql-事务隔离级别-默认是什么级别",normalizedTitle:"mysql 事务隔离级别？默认是什么级别？",charIndex:1020},{level:2,title:"乐观锁与悲观锁的区别?",slug:"乐观锁与悲观锁的区别",normalizedTitle:"乐观锁与悲观锁的区别?",charIndex:2197},{level:2,title:"MySQL 数据库两种存储引擎的区别?",slug:"mysql-数据库两种存储引擎的区别",normalizedTitle:"mysql 数据库两种存储引擎的区别?",charIndex:2737},{level:2,title:"什么是 MVCC?",slug:"什么是-mvcc",normalizedTitle:"什么是 mvcc?",charIndex:3636},{level:2,title:"为什么 MVCC 可以解决幻读问题？",slug:"为什么-mvcc-可以解决幻读问题",normalizedTitle:"为什么 mvcc 可以解决幻读问题？",charIndex:4168}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.355,time:81300,words:271},headersStr:"非关系型数据库和关系型数据库的区别？ 有哪些常见的关系型数据库？ 什么是 SQL？ 事务的四大特性了解么? MySQL 事务隔离级别？默认是什么级别？ 乐观锁与悲观锁的区别? MySQL 数据库两种存储引擎的区别? 什么是 MVCC? 为什么 MVCC 可以解决幻读问题？",content:"# MySQL 基础小结\n\n\n# 非关系型数据库和关系型数据库的区别？\n\n非关系型数据库和关系型数据库的最大区别是它们的数据模型和数据存储方式。\n\n * 关系型数据库使用表格的方式来存储数据，每个表格都包含多个列和行。表格之间可以通过主键和外键建立关联。使用 SQL 作为查询语言，适用于需要高度一致性和事务处理的应用，\n   \n   例如银行系统、电子商务等。\n\n * 而非关系型数据库使用键值对、文档、图形或列族等方式来存储数据，不支持 SQL 查询语言，用的是使用各种编程语言的 API 来操作数据。优势在于它们可以提供更高的扩展性和灵活性，适用于需要高可用性、高性能和分布式部署的应用，\n   \n   例如社交网络、大数据等。\n\n\n# 有哪些常见的关系型数据库？\n\nMySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite）\n\n\n# 什么是 SQL？\n\nSQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。\n\n\n# 事务的四大特性了解么?\n\n了解，它们通常被称为 ACID【 英文缩写 】 特性，分别是：\n\n 1. 原子性（Atomicity）：第一个是原子性，指整个事务中的所有操作要么全部完成，要么全部不完成。事务中任何一项操作失败，事务就会回滚到开始前的状态，保证数据的一致性。\n 2. 一致性（Consistency）：第二个是一致性，指事务执行前后，数据库保持一致。例如，在转账的事务中，如果 A 账户的余额减少 100 元，则 B 账户的余额必须增加 100 元，以保证总金额不变。\n 3. 隔离性（Isolation）：第三个是隔离性，指一个事务的执行不能被其他事务干扰，也就是说一个事务内部的操作对其他事务是隔离的，并发执行的多个事务之间不能互相干扰。这样就可以避免数据的不一致性和并发问题。\n 4. 持久性（Durability）：第四个是持久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，即使系统崩溃也不会丢失。数据库会将事务的操作结果持久化到磁盘上，以确保即使系统发生故障，数据也不会丢失。\n\n这四大特性是事务的基本要求，数据库管理系统必须保证每个事务都具有这四个特性，以保证数据的一致性、完整性和可靠性。\n\n\n# MySQL 事务隔离级别？默认是什么级别？\n\nMySQL 支持四种事务隔离级别，\n\n 1. 读未提交（Read Uncommitted）：第一个是读未提交，是最低的隔离级别，允许事务读取未提交的数据，可能会出现脏读问题。\n 2. 读已提交（Read Committed）：第二个是读已提交，允许事务读取已经提交的数据，可以避免脏读问题，但是可能会出现不可重复读和幻读问题。\n 3. 可重复读（Repeatable Read）：第三个是可重复读，保证在同一事务中多次读取同一数据时，其结果是一致的，可以避免脏读问题和不可重复读的问题，但是仍然可能出现幻读问题。\n 4. 串行化（Serializable）：第四个是串行化，是最高的隔离级别，强制所有事务按顺序执行，可以避免脏读、不可重复读和幻读问题，但是会降低并发性能。\n\nMySQL 的默认事务隔离级别是可重复读（Repeatable Read）\n\n> 什么是脏读问题？\n\n脏读（Dirty Read）指的是一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据。（脏读问题是数据一致性的一种破坏，可能会导致应用程序的错误行为或者数据不一致的情况。）\n\n例如，事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。\n\n为了避免脏读问题，可以使用事务或者加锁机制来保证数据的一致性。在事务中，读取的数据必须是已经提交的，这样就可以避免脏读问题。在加锁机制中，可以通过加锁来阻止其他事务修改数据，保证数据的一致性。\n\n> 什么是不可重复读问题？\n\n不可重复读是一种数据并发性的问题，指在一个事务中，多次执行同一查询语句，但是返回的结果不同。这是因为在事务执行期间，其他事务修改了数据，导致原本的查询结果发生了变化。（重在原有的基础上修改数据）\n\n例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取得到 A=19，此时读取的结果和第一次读取的结果不同。\n\n> 什么是幻读问题？\n\n幻读问题也是一种数据并发性的问题，指在一个事务中，同样的查询语句在事务执行期间返回了不同的结果集，像发生了幻觉一样。这是因为在同一事务中，有其他事务插入了新的数据，导致原本的查询结果集合发生了变化。（重在原有的基础上新增数据）\n\n例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。\n\n\n# 乐观锁与悲观锁的区别?\n\n乐观锁和悲观锁是两种不同的并发控制方式，它们的主要区别在于对数据的锁定和释放策略不同。\n\n悲观锁：\n\n先讲下悲观锁，它是一种悲观的控制方式，总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。**因此，在悲观锁的机制下，并发性能较低。\n\n典型代表是数据库中的行锁和表锁。\n\n> 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行.\n\n乐观锁：\n\n再讲下乐观锁，乐观锁是一种乐观的并发控制方式，总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，因此不会对数据进行加锁。但在提交数据时，系统会根据数据版本号等信息判断数据是否被修改过，如果数据被修改过则会回滚该事务，从而保证数据的一致性。\n\n乐观锁的典型代表是 CAS 算法、版本控制等。\n\n总之，如果并发量较低，可以采用悲观锁，如果并发量较高，可以考虑使用乐观锁。\n\n\n# MySQL 数据库两种存储引擎的区别?\n\nMySQL 有两种存储引擎：InnoDB 和 MyISAM。它们之间的区别主要体现在以下 7 个方面：\n\n 1. 事务支持方面：\n    * InnoDB 支持事务处理。\n    * 而 MyISAM 不支持事务处理。\n 2. 表锁和行锁方面：\n    * InnoDB 是支持行级锁定的存储引擎，它可以锁定单独的行，避免了锁定整张表时对并发性能的影响。\n    * 而 MyISAM 是基于表锁定的存储引擎，它在对表进行读写操作时会锁定整张表\n 3. 外键支持方面：\n    * InnoDB 支持外键，\n    * 而 MyISAM 不支持外键。\n 4. 数据库异常崩溃后的安全恢复方面：\n    * InnoDB 支持，\n    * MyISAM 不支持。\n 5. 是否支持 MVCC：\n    * InnoDB 支持 MVCC，\n    * 而 MyISAM 不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。\n 6. 索引方面：\n    * MyISAM 支持全文索引，\n    * 而 InnoDB 在 MySQL 5.6 及之前版本不支持全文索引，只在 MySQL 5.6 及之后版本提供了全文索引功能。\n 7. 性能方面：\n    * MyISAM 存储引擎的读取速度较快，适合于读取频繁，写入不频繁的应用，\n    * 而 InnoDB 存储引擎的写入速度较快，适合于更新频繁的应用。\n\n总之：如果需要支持事务处理、外键约束等高级特性，可以选择 InnoDB 存储引擎；如果对数据的读取频繁，写入不频繁，可以选择 MyISAM 存储引擎。\n\n> MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。\n> \n> 虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。\n> \n> MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。\n\n\n# 什么是 MVCC?\n\nMVCC，全称为 Multi-Version Concurrency Control（多版本并发控制），是数据库系统中一种用于实现并发控制的技术。它主要用于保证在多个并发事务同时读取和修改数据库中的数据时，能够获得一致性和隔离性，避免数据读写冲突和不一致性。\n\nMVCC 的核心思想是对数据库中的每条记录维护多个版本，每个事务在读取数据时，可以看到该事务开始之前的数据库状态（即之前提交的事务所修改的数据）。这样，即使有其他事务正在修改同一条记录，读操作也不会受到影响，因为它们读取的是不同版本的数据。\n\n在 MVCC 中，每个事务都有一个唯一的事务 ID，数据库记录中的每个版本都有一个时间戳（或类似的版本号）来标识其创建时间。当一个事务要修改某条记录时，会先在内部生成该记录的一个新版本，并将新版本的时间戳设置为当前事务的 ID。其他事务在读取数据时，可以根据事务 ID 和时间戳来决定读取哪个版本的数据，从而实现并发的读写操作，而不会互相干扰。\n\nMVCC 可以提高数据库的并发性能和事务隔离性，减少锁竞争，降低死锁的可能性。许多流行的数据库系统，如 MySQL、PostgreSQL 等，都采用了 MVCC 来实现并发控制。\n\n\n# 为什么 MVCC 可以解决幻读问题？\n\n因为使用 MVCC 时，数据库中的每条记录都会有多个版本，每个版本都有一个时间戳或版本号，记录了创建该版本的事务 ID 或时间。\n\n当一个事务开始执行时，它会获得一个唯一的事务 ID。在执行查询操作时，该事务只会读取在其开始之前已提交的事务所创建的版本，而不会读取在它开始之后其他事务所创建的版本，从而避免了幻读问题。（只能避免不能完全",normalizedContent:"# mysql 基础小结\n\n\n# 非关系型数据库和关系型数据库的区别？\n\n非关系型数据库和关系型数据库的最大区别是它们的数据模型和数据存储方式。\n\n * 关系型数据库使用表格的方式来存储数据，每个表格都包含多个列和行。表格之间可以通过主键和外键建立关联。使用 sql 作为查询语言，适用于需要高度一致性和事务处理的应用，\n   \n   例如银行系统、电子商务等。\n\n * 而非关系型数据库使用键值对、文档、图形或列族等方式来存储数据，不支持 sql 查询语言，用的是使用各种编程语言的 api 来操作数据。优势在于它们可以提供更高的扩展性和灵活性，适用于需要高可用性、高性能和分布式部署的应用，\n   \n   例如社交网络、大数据等。\n\n\n# 有哪些常见的关系型数据库？\n\nmysql、postgresql、oracle、sql server、sqlite（微信本地的聊天记录的存储就是用的 sqlite）\n\n\n# 什么是 sql？\n\nsql 是一种结构化查询语言(structured query language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。\n\n\n# 事务的四大特性了解么?\n\n了解，它们通常被称为 acid【 英文缩写 】 特性，分别是：\n\n 1. 原子性（atomicity）：第一个是原子性，指整个事务中的所有操作要么全部完成，要么全部不完成。事务中任何一项操作失败，事务就会回滚到开始前的状态，保证数据的一致性。\n 2. 一致性（consistency）：第二个是一致性，指事务执行前后，数据库保持一致。例如，在转账的事务中，如果 a 账户的余额减少 100 元，则 b 账户的余额必须增加 100 元，以保证总金额不变。\n 3. 隔离性（isolation）：第三个是隔离性，指一个事务的执行不能被其他事务干扰，也就是说一个事务内部的操作对其他事务是隔离的，并发执行的多个事务之间不能互相干扰。这样就可以避免数据的不一致性和并发问题。\n 4. 持久性（durability）：第四个是持久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，即使系统崩溃也不会丢失。数据库会将事务的操作结果持久化到磁盘上，以确保即使系统发生故障，数据也不会丢失。\n\n这四大特性是事务的基本要求，数据库管理系统必须保证每个事务都具有这四个特性，以保证数据的一致性、完整性和可靠性。\n\n\n# mysql 事务隔离级别？默认是什么级别？\n\nmysql 支持四种事务隔离级别，\n\n 1. 读未提交（read uncommitted）：第一个是读未提交，是最低的隔离级别，允许事务读取未提交的数据，可能会出现脏读问题。\n 2. 读已提交（read committed）：第二个是读已提交，允许事务读取已经提交的数据，可以避免脏读问题，但是可能会出现不可重复读和幻读问题。\n 3. 可重复读（repeatable read）：第三个是可重复读，保证在同一事务中多次读取同一数据时，其结果是一致的，可以避免脏读问题和不可重复读的问题，但是仍然可能出现幻读问题。\n 4. 串行化（serializable）：第四个是串行化，是最高的隔离级别，强制所有事务按顺序执行，可以避免脏读、不可重复读和幻读问题，但是会降低并发性能。\n\nmysql 的默认事务隔离级别是可重复读（repeatable read）\n\n> 什么是脏读问题？\n\n脏读（dirty read）指的是一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据。（脏读问题是数据一致性的一种破坏，可能会导致应用程序的错误行为或者数据不一致的情况。）\n\n例如，事务 1 读取某表中的数据 a=20，事务 1 修改 a=a-1，事务 2 读取到 a = 19,事务 1 回滚导致对 a 的修改并为提交到数据库， a 的值还是 20。\n\n为了避免脏读问题，可以使用事务或者加锁机制来保证数据的一致性。在事务中，读取的数据必须是已经提交的，这样就可以避免脏读问题。在加锁机制中，可以通过加锁来阻止其他事务修改数据，保证数据的一致性。\n\n> 什么是不可重复读问题？\n\n不可重复读是一种数据并发性的问题，指在一个事务中，多次执行同一查询语句，但是返回的结果不同。这是因为在事务执行期间，其他事务修改了数据，导致原本的查询结果发生了变化。（重在原有的基础上修改数据）\n\n例如：事务 1 读取某表中的数据 a=20，事务 2 也读取 a=20，事务 1 修改 a=a-1，事务 2 再次读取得到 a=19，此时读取的结果和第一次读取的结果不同。\n\n> 什么是幻读问题？\n\n幻读问题也是一种数据并发性的问题，指在一个事务中，同样的查询语句在事务执行期间返回了不同的结果集，像发生了幻觉一样。这是因为在同一事务中，有其他事务插入了新的数据，导致原本的查询结果集合发生了变化。（重在原有的基础上新增数据）\n\n例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。\n\n\n# 乐观锁与悲观锁的区别?\n\n乐观锁和悲观锁是两种不同的并发控制方式，它们的主要区别在于对数据的锁定和释放策略不同。\n\n悲观锁：\n\n先讲下悲观锁，它是一种悲观的控制方式，总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。**因此，在悲观锁的机制下，并发性能较低。\n\n典型代表是数据库中的行锁和表锁。\n\n> 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行.\n\n乐观锁：\n\n再讲下乐观锁，乐观锁是一种乐观的并发控制方式，总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，因此不会对数据进行加锁。但在提交数据时，系统会根据数据版本号等信息判断数据是否被修改过，如果数据被修改过则会回滚该事务，从而保证数据的一致性。\n\n乐观锁的典型代表是 cas 算法、版本控制等。\n\n总之，如果并发量较低，可以采用悲观锁，如果并发量较高，可以考虑使用乐观锁。\n\n\n# mysql 数据库两种存储引擎的区别?\n\nmysql 有两种存储引擎：innodb 和 myisam。它们之间的区别主要体现在以下 7 个方面：\n\n 1. 事务支持方面：\n    * innodb 支持事务处理。\n    * 而 myisam 不支持事务处理。\n 2. 表锁和行锁方面：\n    * innodb 是支持行级锁定的存储引擎，它可以锁定单独的行，避免了锁定整张表时对并发性能的影响。\n    * 而 myisam 是基于表锁定的存储引擎，它在对表进行读写操作时会锁定整张表\n 3. 外键支持方面：\n    * innodb 支持外键，\n    * 而 myisam 不支持外键。\n 4. 数据库异常崩溃后的安全恢复方面：\n    * innodb 支持，\n    * myisam 不支持。\n 5. 是否支持 mvcc：\n    * innodb 支持 mvcc，\n    * 而 myisam 不支持。mvcc 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。\n 6. 索引方面：\n    * myisam 支持全文索引，\n    * 而 innodb 在 mysql 5.6 及之前版本不支持全文索引，只在 mysql 5.6 及之后版本提供了全文索引功能。\n 7. 性能方面：\n    * myisam 存储引擎的读取速度较快，适合于读取频繁，写入不频繁的应用，\n    * 而 innodb 存储引擎的写入速度较快，适合于更新频繁的应用。\n\n总之：如果需要支持事务处理、外键约束等高级特性，可以选择 innodb 存储引擎；如果对数据的读取频繁，写入不频繁，可以选择 myisam 存储引擎。\n\n> mysql 5.5 之前，myisam 引擎是 mysql 的默认存储引擎，可谓是风光一时。\n> \n> 虽然，myisam 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，myisam 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。\n> \n> mysql 5.5 版本之后，innodb 是 mysql 的默认存储引擎。\n\n\n# 什么是 mvcc?\n\nmvcc，全称为 multi-version concurrency control（多版本并发控制），是数据库系统中一种用于实现并发控制的技术。它主要用于保证在多个并发事务同时读取和修改数据库中的数据时，能够获得一致性和隔离性，避免数据读写冲突和不一致性。\n\nmvcc 的核心思想是对数据库中的每条记录维护多个版本，每个事务在读取数据时，可以看到该事务开始之前的数据库状态（即之前提交的事务所修改的数据）。这样，即使有其他事务正在修改同一条记录，读操作也不会受到影响，因为它们读取的是不同版本的数据。\n\n在 mvcc 中，每个事务都有一个唯一的事务 id，数据库记录中的每个版本都有一个时间戳（或类似的版本号）来标识其创建时间。当一个事务要修改某条记录时，会先在内部生成该记录的一个新版本，并将新版本的时间戳设置为当前事务的 id。其他事务在读取数据时，可以根据事务 id 和时间戳来决定读取哪个版本的数据，从而实现并发的读写操作，而不会互相干扰。\n\nmvcc 可以提高数据库的并发性能和事务隔离性，减少锁竞争，降低死锁的可能性。许多流行的数据库系统，如 mysql、postgresql 等，都采用了 mvcc 来实现并发控制。\n\n\n# 为什么 mvcc 可以解决幻读问题？\n\n因为使用 mvcc 时，数据库中的每条记录都会有多个版本，每个版本都有一个时间戳或版本号，记录了创建该版本的事务 id 或时间。\n\n当一个事务开始执行时，它会获得一个唯一的事务 id。在执行查询操作时，该事务只会读取在其开始之前已提交的事务所创建的版本，而不会读取在它开始之后其他事务所创建的版本，从而避免了幻读问题。（只能避免不能完全",charsets:{cjk:!0}},{title:"索引篇",frontmatter:{title:"索引篇",date:"2023-06-22T07:49:56.000Z",permalink:"/pages/0b5aee/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Mysql/02.%E7%B4%A2%E5%BC%95%E7%AF%87.html",relativePath:"03.数据库/02.Mysql/02.索引篇.md",key:"v-1c9fad02",path:"/pages/0b5aee/",headers:[{level:2,title:"讲一下什么是索引？",slug:"讲一下什么是索引",normalizedTitle:"讲一下什么是索引？",charIndex:17},{level:2,title:"了解索引的底层数据结构吗？",slug:"了解索引的底层数据结构吗",normalizedTitle:"了解索引的底层数据结构吗？",charIndex:86},{level:2,title:"索引的优缺点了解吗？",slug:"索引的优缺点了解吗",normalizedTitle:"索引的优缺点了解吗？",charIndex:203},{level:2,title:"使用索引一定能提高查询性能吗？",slug:"使用索引一定能提高查询性能吗",normalizedTitle:"使用索引一定能提高查询性能吗？",charIndex:412},{level:2,title:"索引底层数据结构选型",slug:"索引底层数据结构选型",normalizedTitle:"索引底层数据结构选型",charIndex:539},{level:3,title:"Hash 表",slug:"hash-表",normalizedTitle:"hash 表",charIndex:138},{level:3,title:"二叉查找树（BST）",slug:"二叉查找树-bst",normalizedTitle:"二叉查找树（bst）",charIndex:906},{level:3,title:"ALV 树",slug:"alv-树",normalizedTitle:"alv 树",charIndex:1322},{level:3,title:"红黑树",slug:"红黑树",normalizedTitle:"红黑树",charIndex:145},{level:3,title:"B树和 B+树",slug:"b树和-b-树",normalizedTitle:"b树和 b+树",charIndex:2176},{level:2,title:"索引类型总结",slug:"索引类型总结",normalizedTitle:"索引类型总结",charIndex:2919},{level:2,title:"最左前缀匹配原则",slug:"最左前缀匹配原则",normalizedTitle:"最左前缀匹配原则",charIndex:4045}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.985,time:119100.00000000001,words:397},headersStr:"讲一下什么是索引？ 了解索引的底层数据结构吗？ 索引的优缺点了解吗？ 使用索引一定能提高查询性能吗？ 索引底层数据结构选型 Hash 表 二叉查找树（BST） ALV 树 红黑树 B树和 B+树 索引类型总结 最左前缀匹配原则",content:"# MySQL 索引详解\n\n\n# 讲一下什么是索引？\n\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n\n作用相当于书的目录。\n\n\n# 了解索引的底层数据结构吗？\n\n索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash 表、红黑树。\n\n在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了【B+树】作为索引结构。\n\n\n# 索引的优缺点了解吗？\n\n优点：\n\n * 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。\n * 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n缺点：\n\n * 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。\n * 索引需要使用物理文件存储，也会耗费一定空间。\n\n\n# 使用索引一定能提高查询性能吗？\n\n不一定。使用索引可以提高查询速度，但并不是一定能提高查询速度。\n\n * 在大多数情况下，索引查询都是比全表扫描要快的。\n * 但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升，甚至降低查询速率。\n\n\n# 索引底层数据结构选型\n\n\n# Hash 表\n\n哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。\n\n> 为何能够通过 key 快速取出 value 呢？\n\n原因在于 哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。\n\nhash = hashfunc(key)\nindex = hash % array_size\n\n\n1\n2\n\n\n> 既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？\n\n主要是因为 Hash 索引不支持顺序和范围查询。\n\n假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。\n\n\n# 二叉查找树（BST）\n\n二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：\n\n 1. 左子树所有节点的值均小于根节点的值。（左 < 根 < 右）\n 2. 右子树所有节点的值均大于根节点的值。\n 3. 左右子树也分别为二叉查找树。\n\n * 当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 O(log2(N))，具有比较高的效率。\n * 然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 O(N)。\n\n\n\n也就是说，二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。\n\n为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等\n\n\n# ALV 树\n\nALV 树是计算机科学中最早被发明的自平衡二叉查找树。\n\n特点是：保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。\n\n> 是节点的左右【子树高度】不超过 1\n\n\n\n> AVL 树是如何保持平衡的？\n\nAVL 树采用了旋转操作来保持平衡。\n\n主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。\n\n其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。\n\n> MySQL 没有选择 ALV 树的原因？\n\n * 由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。\n * 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO，这非常耗时。\n\n> 磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。\n> \n> 实际应用中，AVL 树使用的并不多。\n\n\n# 红黑树\n\n红黑树也是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：\n\n 1. 每个节点非红即黑；\n 2. 根节点总是黑色的；\n 3. 每个叶子节点都是黑色的空节点（NIL 节点）；\n 4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；\n 5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\n\n\n\n> MySQL 没有选择红黑树的原因?\n\n因为红黑树追求的是大致的平衡（AVL 树追求的是严格的平衡），所以红黑树的平衡性相对较弱，可能会导致树的高度较高，进而会导致一些数据需要进行多次磁盘 IO 操作才能查询到，也就意味着查询效率会稍有下降。\n\n\n# B树和 B+树\n\nB 树和 B+树中的 B 是 Balanced （平衡）的意思。\n\n * B 树也称 B-树,全称为 多路平衡查找树，\n\n * B+ 树是 B 树的一种变体。\n\n目前大部分数据库系统及文件系统都采用【B-树】或其变种【B+树】 作为索引结构。\n\n> 【B树】和【B+树】有何异同呢？\n\n 1. 存放问题\n    * B 树的所有节点既存放键(key) 也存放数据(data)；\n    * 而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。\n 2. 叶子节点\n    * B 树的叶子节点都是独立的；\n    * B+树的叶子节点有一条引用链指向与它相邻的叶子节点。\n 3. 检索过程\n    * B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。\n    * 而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。\n 4. 范围查询\n    * 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；\n    * 而 B+树的范围查询，只需要对链表进行遍历即可。\n\n总结：【B+树】与【B树】相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询的优势。\n\n> 在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。\n\n * MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。实现的是 非聚集索引。\n * 而 InnoDB 引擎中，其数据文件本身就是索引文件。实现的是 聚集索引。\n\n\n# 索引类型总结\n\n> 按照数据结构维度划分\n\n 1. BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。\n 2. 哈希索引：类似键值对的形式，一次即可定位。\n 3. RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。\n 4. 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。\n\n> 按照底层存储方式角度划分\n\n * 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。\n * 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n> 按照应用维度划分\n\n 1. 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。\n\n 2. 普通索引：仅加速查询。\n\n 3. 唯一索引：加速查询 + 列值唯一（可以有 NULL）。\n\n 4. 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。\n\n 5. 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n    \n    ALTER TABLE `cus_order` ADD INDEX id_score_name(score, name);\n    \n    \n    1\n    \n\n 6. 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。\n\n> MySQL 8.x 中实现的索引新特性\n\n * 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会在软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。\n * 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引（不指定的情况下，默认升序）。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。\n * 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式\n\n\n# 最左前缀匹配原则\n\n最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 >、<）才会停止匹配。对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。\n\n所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n举个例子，如果有一个联合索引包含两个字段 A 和 B，需要进行查询时，如果只使用字段 B 作为查询条件，那么查询时将无法充分利用索引，需要遍历整个索引才能找到匹配的记录，这样查询效率会非常低。而如果使用字段 A 作为查询条件，那么可以直接定位到索引中对应的位置，然后再在这个范围内使用 B 进行匹配，从而快速找到匹配的记录，查询效率将会大大提高。",normalizedContent:"# mysql 索引详解\n\n\n# 讲一下什么是索引？\n\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n\n作用相当于书的目录。\n\n\n# 了解索引的底层数据结构吗？\n\n索引底层数据结构存在很多种类型，常见的索引结构有: b 树， b+树 和 hash 表、红黑树。\n\n在 mysql 中，无论是 innodb 还是 myisam，都使用了【b+树】作为索引结构。\n\n\n# 索引的优缺点了解吗？\n\n优点：\n\n * 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。\n * 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n\n缺点：\n\n * 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 sql 执行效率。\n * 索引需要使用物理文件存储，也会耗费一定空间。\n\n\n# 使用索引一定能提高查询性能吗？\n\n不一定。使用索引可以提高查询速度，但并不是一定能提高查询速度。\n\n * 在大多数情况下，索引查询都是比全表扫描要快的。\n * 但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升，甚至降低查询速率。\n\n\n# 索引底层数据结构选型\n\n\n# hash 表\n\n哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 o（1））。\n\n> 为何能够通过 key 快速取出 value 呢？\n\n原因在于 哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。\n\nhash = hashfunc(key)\nindex = hash % array_size\n\n\n1\n2\n\n\n> 既然哈希表这么快，为什么 mysql 没有使用其作为索引的数据结构呢？\n\n主要是因为 hash 索引不支持顺序和范围查询。\n\n假如我们要对表中的数据进行排序或者进行范围查询，那 hash 索引可就不行了。并且，每次 io 只能取一个。\n\n\n# 二叉查找树（bst）\n\n二叉查找树（binary search tree）是一种基于二叉树的数据结构，它具有以下特点：\n\n 1. 左子树所有节点的值均小于根节点的值。（左 < 根 < 右）\n 2. 右子树所有节点的值均大于根节点的值。\n 3. 左右子树也分别为二叉查找树。\n\n * 当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 o(log2(n))，具有比较高的效率。\n * 然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 o(n)。\n\n\n\n也就是说，二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 mysql 底层索引的数据结构。\n\n为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、b-tree、b+tree 等\n\n\n# alv 树\n\nalv 树是计算机科学中最早被发明的自平衡二叉查找树。\n\n特点是：保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 o(logn)。\n\n> 是节点的左右【子树高度】不超过 1\n\n\n\n> avl 树是如何保持平衡的？\n\navl 树采用了旋转操作来保持平衡。\n\n主要有四种旋转操作：ll 旋转、rr 旋转、lr 旋转和 rl 旋转。\n\n其中 ll 旋转和 rr 旋转分别用于处理左左和右右失衡，而 lr 旋转和 rl 旋转则用于处理左右和右左失衡。\n\n> mysql 没有选择 alv 树的原因？\n\n * 由于 avl 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。\n * 在使用 avl 树时，每个树节点仅存储一个数据，而每次进行磁盘 io 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 io，这非常耗时。\n\n> 磁盘 io 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 io 操作的次数。\n> \n> 实际应用中，avl 树使用的并不多。\n\n\n# 红黑树\n\n红黑树也是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：\n\n 1. 每个节点非红即黑；\n 2. 根节点总是黑色的；\n 3. 每个叶子节点都是黑色的空节点（nil 节点）；\n 4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；\n 5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\n\n\n\n> mysql 没有选择红黑树的原因?\n\n因为红黑树追求的是大致的平衡（avl 树追求的是严格的平衡），所以红黑树的平衡性相对较弱，可能会导致树的高度较高，进而会导致一些数据需要进行多次磁盘 io 操作才能查询到，也就意味着查询效率会稍有下降。\n\n\n# b树和 b+树\n\nb 树和 b+树中的 b 是 balanced （平衡）的意思。\n\n * b 树也称 b-树,全称为 多路平衡查找树，\n\n * b+ 树是 b 树的一种变体。\n\n目前大部分数据库系统及文件系统都采用【b-树】或其变种【b+树】 作为索引结构。\n\n> 【b树】和【b+树】有何异同呢？\n\n 1. 存放问题\n    * b 树的所有节点既存放键(key) 也存放数据(data)；\n    * 而 b+树只有叶子节点存放 key 和 data，其他内节点只存放 key。\n 2. 叶子节点\n    * b 树的叶子节点都是独立的；\n    * b+树的叶子节点有一条引用链指向与它相邻的叶子节点。\n 3. 检索过程\n    * b 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。\n    * 而 b+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。\n 4. 范围查询\n    * 在 b 树中进行范围查询时，首先找到要查找的下限，然后对 b 树进行中序遍历，直到找到查找的上限；\n    * 而 b+树的范围查询，只需要对链表进行遍历即可。\n\n总结：【b+树】与【b树】相比，具备更少的 io 次数、更稳定的查询效率和更适于范围查询的优势。\n\n> 在 mysql 中，myisam 引擎和 innodb 引擎都是使用 b+tree 作为索引结构，但是，两者的实现方式不太一样。\n\n * myisam 引擎中，b+tree 叶节点的 data 域存放的是数据记录的地址。实现的是 非聚集索引。\n * 而 innodb 引擎中，其数据文件本身就是索引文件。实现的是 聚集索引。\n\n\n# 索引类型总结\n\n> 按照数据结构维度划分\n\n 1. btree 索引：mysql 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。\n 2. 哈希索引：类似键值对的形式，一次即可定位。\n 3. rtree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 elasticsearch 代替。\n 4. 全文索引：对文本的内容进行分词，进行搜索。目前只有 char、varchar ，text 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 elasticsearch 代替。\n\n> 按照底层存储方式角度划分\n\n * 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，innodb 中的主键索引就属于聚簇索引。\n * 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。mysql 的 myisam 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n\n> 按照应用维度划分\n\n 1. 主键索引：加速查询 + 列值唯一（不可以有 null）+ 表中只有一个。\n\n 2. 普通索引：仅加速查询。\n\n 3. 唯一索引：加速查询 + 列值唯一（可以有 null）。\n\n 4. 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。\n\n 5. 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。\n    \n    alter table `cus_order` add index id_score_name(score, name);\n    \n    \n    1\n    \n\n 6. 全文索引：对文本的内容进行分词，进行搜索。目前只有 char、varchar ，text 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 elasticsearch 代替。\n\n> mysql 8.x 中实现的索引新特性\n\n * 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会在软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。\n * 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引（不指定的情况下，默认升序）。直到 mysql 8.x 版本才开始真正支持降序索引。另外，在 mysql 8.x 版本中，不再对 group by 语句进行隐式排序。\n * 函数索引：从 mysql 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式\n\n\n# 最左前缀匹配原则\n\n最左前缀匹配原则指的是，在使用联合索引时，mysql 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 >、<）才会停止匹配。对于 >=、<=、between、like 前缀匹配的范围查询，并不会停止匹配。\n\n所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n\n举个例子，如果有一个联合索引包含两个字段 a 和 b，需要进行查询时，如果只使用字段 b 作为查询条件，那么查询时将无法充分利用索引，需要遍历整个索引才能找到匹配的记录，这样查询效率会非常低。而如果使用字段 a 作为查询条件，那么可以直接定位到索引中对应的位置，然后再在这个范围内使用 b 进行匹配，从而快速找到匹配的记录，查询效率将会大大提高。",charsets:{cjk:!0}},{title:"思维导图",frontmatter:{title:"思维导图",date:"2023-08-05T14:24:35.000Z",permalink:"/pages/db8ded/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Mysql/10.%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"03.数据库/02.Mysql/10.思维导图.md",key:"v-32cb5a16",path:"/pages/db8ded/",headers:[{level:2,title:"锁",slug:"锁",normalizedTitle:"锁",charIndex:17},{level:2,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:25}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.045,time:2699.9999999999995,words:9},headersStr:"锁 事务",content:"# MySQL 思维导图\n\n\n# 锁\n\n\n\n\n# 事务\n\n",normalizedContent:"# mysql 思维导图\n\n\n# 锁\n\n\n\n\n# 事务\n\n",charsets:{cjk:!0}},{title:"Redis小记",frontmatter:{title:"Redis小记",date:"2023-07-31T20:29:37.000Z",permalink:"/pages/163cf9/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Redis/02.Redis%E5%B0%8F%E8%AE%B0.html",relativePath:"03.数据库/03.Redis/02.Redis小记.md",key:"v-20d2ed7d",path:"/pages/163cf9/",headers:[{level:4,title:"在 redis 中，存储序列化后的对象，为什么 String 相比较于 Hash 存储更节省内存？",slug:"在-redis-中-存储序列化后的对象-为什么-string-相比较于-hash-存储更节省内存",normalizedTitle:"在 redis 中，存储序列化后的对象，为什么 string 相比较于 hash 存储更节省内存？",charIndex:2},{level:4,title:"利用 SETNX key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。为什么？",slug:"利用-setnx-key-value-命令可以实现一个最简易的分布式锁-存在一些缺陷-通常不建议这样实现分布式锁-。为什么",normalizedTitle:"利用 setnx key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。为什么？",charIndex:485},{level:2,title:"三种缓存读写（更新）策略",slug:"三种缓存读写-更新-策略",normalizedTitle:"三种缓存读写（更新）策略",charIndex:733},{level:3,title:"旁路缓存策略",slug:"旁路缓存策略",normalizedTitle:"旁路缓存策略",charIndex:750},{level:3,title:"读写穿透策略",slug:"读写穿透策略",normalizedTitle:"读写穿透策略",charIndex:1751},{level:3,title:"写回策略（异步写入）",slug:"写回策略-异步写入",normalizedTitle:"写回策略（异步写入）",charIndex:1988},{level:3,title:"三者谁的线程安全度更高？",slug:"三者谁的线程安全度更高",normalizedTitle:"三者谁的线程安全度更高？",charIndex:2212}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.025,time:61499.99999999999,words:205},headersStr:"在 redis 中，存储序列化后的对象，为什么 String 相比较于 Hash 存储更节省内存？ 利用 SETNX key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。为什么？ 三种缓存读写（更新）策略 旁路缓存策略 读写穿透策略 写回策略（异步写入） 三者谁的线程安全度更高？",content:"# 在 redis 中，存储序列化后的对象，为什么 String 相比较于 Hash 存储更节省内存？\n\n在内存存储方面，String 相比于 Hash 存储更节省内存的原因是因为 String 使用了字符数组（char[]）来存储字符串的内容，而 Hash 存储通常是使用一个哈希表来存储键值对。\n\n 1. String 使用字符数组存储：在 Java 中，String 对象使用字符数组来存储字符串的内容，每个字符占用两个字节（16 位）。对于较短的字符串，字符数组可以直接存储整个字符串内容，没有额外的开销。\n 2. Hash 存储使用哈希表：哈希表是一种数据结构，它由一系列的桶（bucket）组成，每个桶中存储一个键值对。对于较小的哈希表，每个桶可能只存储一个键值对，这样会有一定的空间开销。而对于较大的哈希表，可能会有较多的桶未被使用，也会造成一定的空间浪费。\n\n因此，对于存储较短的字符串或者只包含单个字符的字符串，使用 String 存储相对更节省内存。而对于存储大量的键值对，使用 Hash 存储可能更合适，因为它可以支持快速的查找和插入操作。\n\n# 利用 SETNX key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。为什么？\n\n 1. 还应该加个过期时间，比如 SET lock_key unique_value NX PX 10000\n 2. 使用更成熟、稳定的分布式锁算法，比如基于 Redlock（红锁）或者 Redisson 等开源分布式锁实现库。\n\n红锁算法要求满足两个条件：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功\n\n\n# 三种缓存读写（更新）策略\n\n\n# 旁路缓存策略\n\n> 写：\n\n * 先更新 db\n * 然后删除 cache\n\n> 读：\n\n * 先从 cache 中读取数据，命中就返回\n * cache 中读取不到的话，就从 db 中读取数据返回，然后(db)再把数据写入 cache 中\n\n> 问题：\n\n1、在写数据的过程中，可以先删除 cache，后更新 db 么？\n\n答：不可以，因为这样会导致数据库和缓存数据不一致的问题。\n\n举例：请求 1 先写数据 A，请求 2 随后读数据 A 的情况。\n\n假设请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 db 中读取数据并写入 cache 中 -> 请求 1 再把 db 中的 A 数据更新，此时就会产生数据库和缓存数据不一致的问题。\n\ndb 的是新数据，cache 的是旧数据。\n\n2、在写数据的过程中，先更新 db，后删除 cache 就没有问题了吗？\n\n答：可能会有问题，但出现的概率非常小，因为【缓存】的写入速度比【数据库】的写入速度快很多。\n\n举例：\n\n请求 A 更新完数据库，但还未删除缓存，此时请求 B 命中了缓存并返回，就导致了数据不一致。\n\n出现的概率低：是因为缓存的写入非常快，中间的时间差非常短，通常只有几毫秒或者几十毫秒。\n\n> 缺陷：\n\n1、首次请求数据一定不在 cache 的问题\n\n解决方法：将热点数据提前放入 cache 中。\n\n2、写操作比较频繁的话导致 cache 中的数据会被频繁被删除，会影响缓存命中率\n\n解决方法：\n\n * 更新数据的时候同样更新缓存，只是在更新缓存前需要先加一个分布式锁，从而保证线程安全。（强一致场景）\n * 给缓存加一个较短的过期时间。（可以短暂允许数据不一致场景）\n\n为什么会线程不安全？\n\n因为在多线程或分布式环境下，对数据的并发更新可能会导致线程不安全的情况。当多个线程同时尝试更新缓存的数据时，如果没有进行同步控制，就会产生以下问题：\n\n 1. 竞态条件：多个线程同时读取缓存数据，并在此基础上进行更新，但由于读取和写入操作不是原子性的，可能导致数据的不一致性。\n 2. 脏数据：在并发情况下，多个线程同时更新缓存，其中一个线程的更新可能会覆盖其他线程的更新，导致数据出现错误。\n 3. 缓存不一致：由于缓存的失效机制或其他原因，缓存中的数据可能落后于数据库中的数据，这样读取到的数据就会是旧数据。\n\n\n# 读写穿透策略\n\n原则：应用程序只和缓存交互，不再和数据库交互。\n\n比较少见，因为常用的分布式缓存组件都不提供【写入数据库】和【自动加载数据库中的数据】的功能。\n\n> 写：\n\n * 先查 cache，如果数据不存在，（缓存组件）直接更新 db，然后返回。\n * 如果数据存在，则先更新 cache，然后缓存组件同步更新 db。\n\n> 读：\n\n * 从 cache 中读取数据，读取到就返回。\n * 读取不到，就由缓存组件先从数据库查数据并写入缓存组件，最后返回响应。\n\n\n# 写回策略（异步写入）\n\n读写的情况\n\n与【读写穿透策略】相似，都是由 cache 服务（组件）来负责 cache 和 db 的读写。\n\n不同点\n\n原则：只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。\n\nWrite Back（写回）策略：在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。\n\n适合【写多】的场景。（比如浏览量，点赞量）\n\n\n# 三者谁的线程安全度更高？\n\n读写穿透策略。\n\nWrite Through 策略在写操作时，会先更新数据库，然后再更新缓存。这样做的好处是确保了数据库和缓存的数据始终保持一致，避免了数据不一致的问题。在并发情况下，当多个线程同时写入数据时，由于先更新数据库再更新缓存，可以保证不会出现数据不一致的情况。\n\n另一方面，Write Back（写回）策略在写操作时，只更新缓存而不更新数据库，然后通过批量异步更新的方式来更新数据库。虽然 Write Back 策略在高并发场景下可以提高写入性能，但是由于在更新缓存时不更新数据库，可能会导致数据库和缓存之间的数据不一致。这种情况下，如果多个线程同时写入数据，可能会出现数据覆盖或者丢失的情况，从而降低了线程安全度。",normalizedContent:"# 在 redis 中，存储序列化后的对象，为什么 string 相比较于 hash 存储更节省内存？\n\n在内存存储方面，string 相比于 hash 存储更节省内存的原因是因为 string 使用了字符数组（char[]）来存储字符串的内容，而 hash 存储通常是使用一个哈希表来存储键值对。\n\n 1. string 使用字符数组存储：在 java 中，string 对象使用字符数组来存储字符串的内容，每个字符占用两个字节（16 位）。对于较短的字符串，字符数组可以直接存储整个字符串内容，没有额外的开销。\n 2. hash 存储使用哈希表：哈希表是一种数据结构，它由一系列的桶（bucket）组成，每个桶中存储一个键值对。对于较小的哈希表，每个桶可能只存储一个键值对，这样会有一定的空间开销。而对于较大的哈希表，可能会有较多的桶未被使用，也会造成一定的空间浪费。\n\n因此，对于存储较短的字符串或者只包含单个字符的字符串，使用 string 存储相对更节省内存。而对于存储大量的键值对，使用 hash 存储可能更合适，因为它可以支持快速的查找和插入操作。\n\n# 利用 setnx key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。为什么？\n\n 1. 还应该加个过期时间，比如 set lock_key unique_value nx px 10000\n 2. 使用更成熟、稳定的分布式锁算法，比如基于 redlock（红锁）或者 redisson 等开源分布式锁实现库。\n\n红锁算法要求满足两个条件：如果有超过半数的 redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功\n\n\n# 三种缓存读写（更新）策略\n\n\n# 旁路缓存策略\n\n> 写：\n\n * 先更新 db\n * 然后删除 cache\n\n> 读：\n\n * 先从 cache 中读取数据，命中就返回\n * cache 中读取不到的话，就从 db 中读取数据返回，然后(db)再把数据写入 cache 中\n\n> 问题：\n\n1、在写数据的过程中，可以先删除 cache，后更新 db 么？\n\n答：不可以，因为这样会导致数据库和缓存数据不一致的问题。\n\n举例：请求 1 先写数据 a，请求 2 随后读数据 a 的情况。\n\n假设请求 1 先把 cache 中的 a 数据删除 -> 请求 2 从 db 中读取数据并写入 cache 中 -> 请求 1 再把 db 中的 a 数据更新，此时就会产生数据库和缓存数据不一致的问题。\n\ndb 的是新数据，cache 的是旧数据。\n\n2、在写数据的过程中，先更新 db，后删除 cache 就没有问题了吗？\n\n答：可能会有问题，但出现的概率非常小，因为【缓存】的写入速度比【数据库】的写入速度快很多。\n\n举例：\n\n请求 a 更新完数据库，但还未删除缓存，此时请求 b 命中了缓存并返回，就导致了数据不一致。\n\n出现的概率低：是因为缓存的写入非常快，中间的时间差非常短，通常只有几毫秒或者几十毫秒。\n\n> 缺陷：\n\n1、首次请求数据一定不在 cache 的问题\n\n解决方法：将热点数据提前放入 cache 中。\n\n2、写操作比较频繁的话导致 cache 中的数据会被频繁被删除，会影响缓存命中率\n\n解决方法：\n\n * 更新数据的时候同样更新缓存，只是在更新缓存前需要先加一个分布式锁，从而保证线程安全。（强一致场景）\n * 给缓存加一个较短的过期时间。（可以短暂允许数据不一致场景）\n\n为什么会线程不安全？\n\n因为在多线程或分布式环境下，对数据的并发更新可能会导致线程不安全的情况。当多个线程同时尝试更新缓存的数据时，如果没有进行同步控制，就会产生以下问题：\n\n 1. 竞态条件：多个线程同时读取缓存数据，并在此基础上进行更新，但由于读取和写入操作不是原子性的，可能导致数据的不一致性。\n 2. 脏数据：在并发情况下，多个线程同时更新缓存，其中一个线程的更新可能会覆盖其他线程的更新，导致数据出现错误。\n 3. 缓存不一致：由于缓存的失效机制或其他原因，缓存中的数据可能落后于数据库中的数据，这样读取到的数据就会是旧数据。\n\n\n# 读写穿透策略\n\n原则：应用程序只和缓存交互，不再和数据库交互。\n\n比较少见，因为常用的分布式缓存组件都不提供【写入数据库】和【自动加载数据库中的数据】的功能。\n\n> 写：\n\n * 先查 cache，如果数据不存在，（缓存组件）直接更新 db，然后返回。\n * 如果数据存在，则先更新 cache，然后缓存组件同步更新 db。\n\n> 读：\n\n * 从 cache 中读取数据，读取到就返回。\n * 读取不到，就由缓存组件先从数据库查数据并写入缓存组件，最后返回响应。\n\n\n# 写回策略（异步写入）\n\n读写的情况\n\n与【读写穿透策略】相似，都是由 cache 服务（组件）来负责 cache 和 db 的读写。\n\n不同点\n\n原则：只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。\n\nwrite back（写回）策略：在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。\n\n适合【写多】的场景。（比如浏览量，点赞量）\n\n\n# 三者谁的线程安全度更高？\n\n读写穿透策略。\n\nwrite through 策略在写操作时，会先更新数据库，然后再更新缓存。这样做的好处是确保了数据库和缓存的数据始终保持一致，避免了数据不一致的问题。在并发情况下，当多个线程同时写入数据时，由于先更新数据库再更新缓存，可以保证不会出现数据不一致的情况。\n\n另一方面，write back（写回）策略在写操作时，只更新缓存而不更新数据库，然后通过批量异步更新的方式来更新数据库。虽然 write back 策略在高并发场景下可以提高写入性能，但是由于在更新缓存时不更新数据库，可能会导致数据库和缓存之间的数据不一致。这种情况下，如果多个线程同时写入数据，可能会出现数据覆盖或者丢失的情况，从而降低了线程安全度。",charsets:{cjk:!0}},{title:"Redis总结",frontmatter:{title:"Redis总结",date:"2023-05-23T21:08:21.000Z",permalink:"/pages/54616e/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Redis/01.Redis%E6%80%BB%E7%BB%93.html",relativePath:"03.数据库/03.Redis/01.Redis总结.md",key:"v-52f9c0bc",path:"/pages/54616e/",headers:[{level:2,title:"认识 Redis",slug:"认识-redis",normalizedTitle:"认识 redis",charIndex:15},{level:3,title:"什么是 Redis？",slug:"什么是-redis",normalizedTitle:"什么是 redis？",charIndex:28},{level:3,title:"Redis 为什么这么快？",slug:"redis-为什么这么快",normalizedTitle:"redis 为什么这么快？",charIndex:477},{level:3,title:"为什么要用分布式缓存？",slug:"为什么要用分布式缓存",normalizedTitle:"为什么要用分布式缓存？",charIndex:656},{level:3,title:"分布式缓存常见的技术选型方案有哪些？",slug:"分布式缓存常见的技术选型方案有哪些",normalizedTitle:"分布式缓存常见的技术选型方案有哪些？",charIndex:1027},{level:3,title:"为什么腾讯开源的Tendis比较少公司使用",slug:"为什么腾讯开源的tendis比较少公司使用",normalizedTitle:"为什么腾讯开源的tendis比较少公司使用",charIndex:1290},{level:3,title:"Redis 和 Memcached 有什么区别？",slug:"redis-和-memcached-有什么区别",normalizedTitle:"redis 和 memcached 有什么区别？",charIndex:1425},{level:3,title:"为什么用 Redis 作为 MySQL 的缓存？",slug:"为什么用-redis-作为-mysql-的缓存",normalizedTitle:"为什么用 redis 作为 mysql 的缓存？",charIndex:1819},{level:2,title:"Redis 数据结构",slug:"redis-数据结构",normalizedTitle:"redis 数据结构",charIndex:2316},{level:3,title:"Redis 数据类型以及使用场景分别是什么？",slug:"redis-数据类型以及使用场景分别是什么",normalizedTitle:"redis 数据类型以及使用场景分别是什么？",charIndex:2331},{level:3,title:"五种常见的 Redis 数据类型是怎么实现？",slug:"五种常见的-redis-数据类型是怎么实现",normalizedTitle:"五种常见的 redis 数据类型是怎么实现？",charIndex:2984},{level:4,title:"String 类型的内部实现",slug:"string-类型的内部实现",normalizedTitle:"string 类型的内部实现",charIndex:3010},{level:4,title:"List 类型的内部实现",slug:"list-类型的内部实现",normalizedTitle:"list 类型的内部实现",charIndex:3554},{level:4,title:"Hash 类型的内部实现：",slug:"hash-类型的内部实现",normalizedTitle:"hash 类型的内部实现：",charIndex:3850},{level:4,title:"Set 类型的内部实现",slug:"set-类型的内部实现",normalizedTitle:"set 类型的内部实现",charIndex:4061},{level:4,title:"Zset 类型的内部实现",slug:"zset-类型的内部实现",normalizedTitle:"zset 类型的内部实现",charIndex:4217},{level:2,title:"Redis 线程模型",slug:"redis-线程模型",normalizedTitle:"redis 线程模型",charIndex:4451},{level:3,title:"Redis 是单线程吗？",slug:"redis-是单线程吗",normalizedTitle:"redis 是单线程吗？",charIndex:4466},{level:3,title:"Redis 单线程模式是怎样的？",slug:"redis-单线程模式是怎样的",normalizedTitle:"redis 单线程模式是怎样的？",charIndex:5068},{level:3,title:"Redis 采用单线程为什么还这么快？",slug:"redis-采用单线程为什么还这么快",normalizedTitle:"redis 采用单线程为什么还这么快？",charIndex:5351},{level:3,title:"Redis 6.0 之前为什么使用单线程？",slug:"redis-6-0-之前为什么使用单线程",normalizedTitle:"redis 6.0 之前为什么使用单线程？",charIndex:6176},{level:3,title:"Redis 6.0 之后为什么引入了多线程？",slug:"redis-6-0-之后为什么引入了多线程",normalizedTitle:"redis 6.0 之后为什么引入了多线程？",charIndex:6480},{level:2,title:"Redis 持久化",slug:"redis-持久化",normalizedTitle:"redis 持久化",charIndex:6727},{level:3,title:"Redis 如何实现数据不丢失？",slug:"redis-如何实现数据不丢失",normalizedTitle:"redis 如何实现数据不丢失？",charIndex:6741},{level:3,title:"AOF 日志是如何实现的？",slug:"aof-日志是如何实现的",normalizedTitle:"aof 日志是如何实现的？",charIndex:6980},{level:4,title:"为什么先执行命令，再把数据写入日志呢？",slug:"为什么先执行命令-再把数据写入日志呢",normalizedTitle:"为什么先执行命令，再把数据写入日志呢？",charIndex:7287},{level:4,title:"Redis 写入 AOF 日志的过程",slug:"redis-写入-aof-日志的过程",normalizedTitle:"redis 写入 aof 日志的过程",charIndex:7693},{level:4,title:"AOF 写回策略有几种？",slug:"aof-写回策略有几种",normalizedTitle:"aof 写回策略有几种？",charIndex:7909},{level:4,title:"AOF 日志过大，会触发什么机制？",slug:"aof-日志过大-会触发什么机制",normalizedTitle:"aof 日志过大，会触发什么机制？",charIndex:8299},{level:4,title:"重写 AOF 日志的过程是怎样的？",slug:"重写-aof-日志的过程是怎样的",normalizedTitle:"重写 aof 日志的过程是怎样的？",charIndex:8913},{level:3,title:"什么是 RDB 快照？",slug:"什么是-rdb-快照",normalizedTitle:"什么是 rdb 快照？",charIndex:9880},{level:4,title:"为什么需要 RDB 快照？",slug:"为什么需要-rdb-快照",normalizedTitle:"为什么需要 rdb 快照？",charIndex:10048},{level:4,title:"有了 RDB，为什么还需要 AOF？",slug:"有了-rdb-为什么还需要-aof",normalizedTitle:"有了 rdb，为什么还需要 aof？",charIndex:10184},{level:4,title:"RDB 是如何实现的？会阻塞线程吗？",slug:"rdb-是如何实现的-会阻塞线程吗",normalizedTitle:"rdb 是如何实现的？会阻塞线程吗？",charIndex:10619},{level:4,title:"RDB 在执行快照的时候，数据能修改吗？",slug:"rdb-在执行快照的时候-数据能修改吗",normalizedTitle:"rdb 在执行快照的时候，数据能修改吗？",charIndex:11230},{level:3,title:"为什么会有混合持久化？",slug:"为什么会有混合持久化",normalizedTitle:"为什么会有混合持久化？",charIndex:11811},{level:4,title:"混合持久化是如何实现的？",slug:"混合持久化是如何实现的",normalizedTitle:"混合持久化是如何实现的？",charIndex:12026},{level:4,title:"这种实现方式有什么好处？",slug:"这种实现方式有什么好处",normalizedTitle:"这种实现方式有什么好处？",charIndex:12299},{level:4,title:"混合持久化的优缺点是什么？",slug:"混合持久化的优缺点是什么",normalizedTitle:"混合持久化的优缺点是什么？",charIndex:12485},{level:2,title:"Redis 集群",slug:"redis-集群",normalizedTitle:"redis 集群",charIndex:12740},{level:3,title:"Redis 是如何实现高服务高可用的？",slug:"redis-是如何实现高服务高可用的",normalizedTitle:"redis 是如何实现高服务高可用的？",charIndex:12753},{level:4,title:"主从复制",slug:"主从复制",normalizedTitle:"主从复制",charIndex:376},{level:5,title:"实现方案",slug:"实现方案",normalizedTitle:"实现方案",charIndex:12881},{level:5,title:"主服务器和从服务器的区别",slug:"主服务器和从服务器的区别",normalizedTitle:"主服务器和从服务器的区别",charIndex:12965},{level:5,title:"具体来说",slug:"具体来说",normalizedTitle:"具体来说",charIndex:7713},{level:4,title:"哨兵模式 Sentinel",slug:"哨兵模式-sentinel",normalizedTitle:"哨兵模式 sentinel",charIndex:13350},{level:5,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:2092},{level:5,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:5483},{level:5,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:8},{level:4,title:"切片集群模式 Cluster",slug:"切片集群模式-cluster",normalizedTitle:"切片集群模式 cluster",charIndex:14497},{level:5,title:"场景",slug:"场景",normalizedTitle:"场景",charIndex:114},{level:5,title:"Redis Cluster 方案",slug:"redis-cluster-方案",normalizedTitle:"redis cluster 方案",charIndex:14642},{level:5,title:"哈希槽是如何被映射到具体的 Redis 节点上的？",slug:"哈希槽是如何被映射到具体的-redis-节点上的",normalizedTitle:"哈希槽是如何被映射到具体的 redis 节点上的？",charIndex:14933},{level:5,title:"数据、哈希槽，以及节点三者的映射分布关系",slug:"数据、哈希槽-以及节点三者的映射分布关系",normalizedTitle:"数据、哈希槽，以及节点三者的映射分布关系",charIndex:15212},{level:3,title:"集群脑裂导致数据丢失怎么办？",slug:"集群脑裂导致数据丢失怎么办",normalizedTitle:"集群脑裂导致数据丢失怎么办？",charIndex:15510},{level:4,title:"什么是脑裂？",slug:"什么是脑裂",normalizedTitle:"什么是脑裂？",charIndex:15528},{level:4,title:"解决方案",slug:"解决方案-2",normalizedTitle:"解决方案",charIndex:5483},{level:2,title:"Redis 过期删除与内存淘汰",slug:"redis-过期删除与内存淘汰",normalizedTitle:"redis 过期删除与内存淘汰",charIndex:17009},{level:3,title:"Redis 给缓存数据设置过期时间有啥用？",slug:"redis-给缓存数据设置过期时间有啥用",normalizedTitle:"redis 给缓存数据设置过期时间有啥用？",charIndex:17029},{level:3,title:"Redis 使用过的过期删除策略是什么？",slug:"redis-使用过的过期删除策略是什么",normalizedTitle:"redis 使用过的过期删除策略是什么？",charIndex:17417},{level:3,title:"什么是惰性删除策略？",slug:"什么是惰性删除策略",normalizedTitle:"什么是惰性删除策略？",charIndex:17677},{level:3,title:"什么是定期删除策略？",slug:"什么是定期删除策略",normalizedTitle:"什么是定期删除策略？",charIndex:18015},{level:3,title:"Redis 持久化时，对过期键会如何处理？",slug:"redis-持久化时-对过期键会如何处理",normalizedTitle:"redis 持久化时，对过期键会如何处理？",charIndex:18580},{level:3,title:"Redis 主从模式中，对过期键会如何处理？",slug:"redis-主从模式中-对过期键会如何处理",normalizedTitle:"redis 主从模式中，对过期键会如何处理？",charIndex:19336},{level:3,title:"Redis 内存满了，会发生什么？",slug:"redis-内存满了-会发生什么",normalizedTitle:"redis 内存满了，会发生什么？",charIndex:19561},{level:3,title:"Redis 内存淘汰策略有哪些？",slug:"redis-内存淘汰策略有哪些",normalizedTitle:"redis 内存淘汰策略有哪些？",charIndex:19671},{level:4,title:"1、不进行数据淘汰的策略",slug:"_1、不进行数据淘汰的策略",normalizedTitle:"1、不进行数据淘汰的策略",charIndex:19756},{level:4,title:"2、进行数据淘汰的策略",slug:"_2、进行数据淘汰的策略",normalizedTitle:"2、进行数据淘汰的策略",charIndex:19849},{level:5,title:"在设置了过期时间的数据中进行淘汰：",slug:"在设置了过期时间的数据中进行淘汰",normalizedTitle:"在设置了过期时间的数据中进行淘汰：",charIndex:19927},{level:5,title:"在所有数据范围内进行淘汰：",slug:"在所有数据范围内进行淘汰",normalizedTitle:"在所有数据范围内进行淘汰：",charIndex:20143},{level:3,title:"LRU 算法和 LFU 算法有什么区别？",slug:"lru-算法和-lfu-算法有什么区别",normalizedTitle:"lru 算法和 lfu 算法有什么区别？",charIndex:20275},{level:4,title:"什么是 LRU 算法？",slug:"什么是-lru-算法",normalizedTitle:"什么是 lru 算法？",charIndex:20299},{level:4,title:"Redis 是如何实现 LRU 算法的？",slug:"redis-是如何实现-lru-算法的",normalizedTitle:"redis 是如何实现 lru 算法的？",charIndex:20647},{level:4,title:"什么是缓存污染问题？",slug:"什么是缓存污染问题",normalizedTitle:"什么是缓存污染问题？",charIndex:21032},{level:4,title:"什么是 LFU 算法？",slug:"什么是-lfu-算法",normalizedTitle:"什么是 lfu 算法？",charIndex:21205},{level:4,title:"Redis 是如何实现 LFU 算法的？",slug:"redis-是如何实现-lfu-算法的",normalizedTitle:"redis 是如何实现 lfu 算法的？",charIndex:21432},{level:2,title:"Redis 缓存设计（生产问题）",slug:"redis-缓存设计-生产问题",normalizedTitle:"redis 缓存设计（生产问题）",charIndex:22025},{level:3,title:"缓存雪崩",slug:"缓存雪崩",normalizedTitle:"缓存雪崩",charIndex:22046},{level:4,title:"什么是缓存雪崩？",slug:"什么是缓存雪崩",normalizedTitle:"什么是缓存雪崩？",charIndex:22054},{level:4,title:"如何解决缓存雪崩？",slug:"如何解决缓存雪崩",normalizedTitle:"如何解决缓存雪崩？",charIndex:22196},{level:3,title:"缓存击穿",slug:"缓存击穿",normalizedTitle:"缓存击穿",charIndex:22387},{level:4,title:"什么是缓存击穿？",slug:"什么是缓存击穿",normalizedTitle:"什么是缓存击穿？",charIndex:22395},{level:4,title:"如何解决缓存击穿？",slug:"如何解决缓存击穿",normalizedTitle:"如何解决缓存击穿？",charIndex:22590},{level:3,title:"缓存穿透",slug:"缓存穿透",normalizedTitle:"缓存穿透",charIndex:22809},{level:4,title:"什么是缓存穿透？",slug:"什么是缓存穿透",normalizedTitle:"什么是缓存穿透？",charIndex:22817},{level:4,title:"产生的原因？",slug:"产生的原因",normalizedTitle:"产生的原因？",charIndex:22938},{level:4,title:"如何应对缓存穿透？",slug:"如何应对缓存穿透",normalizedTitle:"如何应对缓存穿透？",charIndex:23027},{level:3,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:8},{level:3,title:"如何设计一个缓存策略，可以动态缓存热点数据呢？",slug:"如何设计一个缓存策略-可以动态缓存热点数据呢",normalizedTitle:"如何设计一个缓存策略，可以动态缓存热点数据呢？",charIndex:23834},{level:4,title:"为什么需要设计？",slug:"为什么需要设计",normalizedTitle:"为什么需要设计？",charIndex:23861},{level:4,title:"设计思路",slug:"设计思路",normalizedTitle:"设计思路",charIndex:23944},{level:3,title:"说说常见的缓存更新策略？",slug:"说说常见的缓存更新策略",normalizedTitle:"说说常见的缓存更新策略？",charIndex:24310},{level:4,title:"Cache Aside（旁路缓存）策略",slug:"cache-aside-旁路缓存-策略",normalizedTitle:"cache aside（旁路缓存）策略",charIndex:24344},{level:5,title:"为什么是删除缓存，而不是更新缓存呢？",slug:"为什么是删除缓存-而不是更新缓存呢",normalizedTitle:"为什么是删除缓存，而不是更新缓存呢？",charIndex:24768},{level:5,title:"为什么「先更新数据库再删除缓存」不会有数据不一致的问题？",slug:"为什么「先更新数据库再删除缓存」不会有数据不一致的问题",normalizedTitle:"为什么「先更新数据库再删除缓存」不会有数据不一致的问题？",charIndex:25130},{level:5,title:"适合场景？",slug:"适合场景",normalizedTitle:"适合场景？",charIndex:25496},{level:4,title:"Read/Write Through（读穿 / 写穿）策略",slug:"read-write-through-读穿-写穿-策略",normalizedTitle:"read/write through（读穿 / 写穿）策略",charIndex:24369},{level:5,title:"特点以及适合场景是什么？",slug:"特点以及适合场景是什么",normalizedTitle:"特点以及适合场景是什么？",charIndex:26151},{level:4,title:"Write Back（写回）策略",slug:"write-back-写回-策略",normalizedTitle:"write back（写回）策略",charIndex:24404},{level:5,title:"适合什么场景？",slug:"适合什么场景",normalizedTitle:"适合什么场景？",charIndex:26520},{level:3,title:"如何保证缓存和数据库数据的一致性？",slug:"如何保证缓存和数据库数据的一致性",normalizedTitle:"如何保证缓存和数据库数据的一致性？",charIndex:26840},{level:3,title:"哪些情况可能会导致 Redis 阻塞？",slug:"哪些情况可能会导致-redis-阻塞",normalizedTitle:"哪些情况可能会导致 redis 阻塞？",charIndex:27534},{level:2,title:"Redis 性能优化",slug:"redis-性能优化",normalizedTitle:"redis 性能优化",charIndex:27708},{level:3,title:"大量 key 集中过期问题",slug:"大量-key-集中过期问题",normalizedTitle:"大量 key 集中过期问题",charIndex:27723},{level:3,title:"Redis 大 key？",slug:"redis-大-key",normalizedTitle:"redis 大 key？",charIndex:27854},{level:4,title:"什么是 Redis 大 key？",slug:"什么是-redis-大-key",normalizedTitle:"什么是 redis 大 key？",charIndex:27870},{level:4,title:"大 key 会造成什么问题？",slug:"大-key-会造成什么问题",normalizedTitle:"大 key 会造成什么问题？",charIndex:28021},{level:4,title:"如何找到大 key ？",slug:"如何找到大-key",normalizedTitle:"如何找到大 key ？",charIndex:28443},{level:4,title:"如何删除大 key？",slug:"如何删除大-key",normalizedTitle:"如何删除大 key？",charIndex:28560},{level:4,title:"如何处理 bigkey？",slug:"如何处理-bigkey",normalizedTitle:"如何处理 bigkey？",charIndex:28664},{level:3,title:"Redis hotkey（热 Key）",slug:"redis-hotkey-热-key",normalizedTitle:"redis hotkey（热 key）",charIndex:28997},{level:4,title:"什么是 hotkey？",slug:"什么是-hotkey",normalizedTitle:"什么是 hotkey？",charIndex:29020},{level:4,title:"hotkey 有什么危害？",slug:"hotkey-有什么危害",normalizedTitle:"hotkey 有什么危害？",charIndex:29142},{level:4,title:"如何找到 hotkey？",slug:"如何找到-hotkey",normalizedTitle:"如何找到 hotkey？",charIndex:29346},{level:4,title:"如何解决 hotkey？",slug:"如何解决-hotkey",normalizedTitle:"如何解决 hotkey？",charIndex:29814},{level:3,title:"慢查询命令",slug:"慢查询命令",normalizedTitle:"慢查询命令",charIndex:30060},{level:4,title:"什么是慢查询命令？",slug:"什么是慢查询命令",normalizedTitle:"什么是慢查询命令？",charIndex:30069},{level:4,title:"为什么会有慢查询命令？",slug:"为什么会有慢查询命令",normalizedTitle:"为什么会有慢查询命令？",charIndex:30313},{level:4,title:"如何找到慢查询命令？",slug:"如何找到慢查询命令",normalizedTitle:"如何找到慢查询命令？",charIndex:30441},{level:3,title:"Redis 内存碎片",slug:"redis-内存碎片",normalizedTitle:"redis 内存碎片",charIndex:30814},{level:4,title:"什么是内存碎片?",slug:"什么是内存碎片",normalizedTitle:"什么是内存碎片?",charIndex:30828},{level:4,title:"为什么会有 Redis 内存碎片?",slug:"为什么会有-redis-内存碎片",normalizedTitle:"为什么会有 redis 内存碎片?",charIndex:31019},{level:4,title:"如何查看 Redis 内存碎片的信息？",slug:"如何查看-redis-内存碎片的信息",normalizedTitle:"如何查看 redis 内存碎片的信息？",charIndex:31243},{level:4,title:"如何清理 Redis 内存碎片？",slug:"如何清理-redis-内存碎片",normalizedTitle:"如何清理 redis 内存碎片？",charIndex:31304},{level:2,title:"Redis 实战",slug:"redis-实战",normalizedTitle:"redis 实战",charIndex:31582},{level:3,title:"延迟队列",slug:"延迟队列",normalizedTitle:"延迟队列",charIndex:31595},{level:4,title:"什么是延迟队列？",slug:"什么是延迟队列",normalizedTitle:"什么是延迟队列？",charIndex:31603},{level:4,title:"Redis 如何实现延迟队列？",slug:"redis-如何实现延迟队列",normalizedTitle:"redis 如何实现延迟队列？",charIndex:31778},{level:3,title:"Redis 管道有什么用？",slug:"redis-管道有什么用",normalizedTitle:"redis 管道有什么用？",charIndex:31955},{level:3,title:"Redis 事务",slug:"redis-事务",normalizedTitle:"redis 事务",charIndex:32129},{level:4,title:"Redis 事务支持回滚吗？",slug:"redis-事务支持回滚吗",normalizedTitle:"redis 事务支持回滚吗？",charIndex:32141},{level:4,title:"为什么 Redis 不支持事务回滚？",slug:"为什么-redis-不支持事务回滚",normalizedTitle:"为什么 redis 不支持事务回滚？",charIndex:32392},{level:3,title:"Redis 分布式锁",slug:"redis-分布式锁",normalizedTitle:"redis 分布式锁",charIndex:32610},{level:4,title:"如何用 Redis 实现分布式锁的？",slug:"如何用-redis-实现分布式锁的",normalizedTitle:"如何用 redis 实现分布式锁的？",charIndex:32624},{level:4,title:"基于 Redis 实现分布式锁有什么优缺点？",slug:"基于-redis-实现分布式锁有什么优缺点",normalizedTitle:"基于 redis 实现分布式锁有什么优缺点？",charIndex:33624},{level:4,title:"Redis 如何解决集群情况下分布式锁的可靠性？",slug:"redis-如何解决集群情况下分布式锁的可靠性",normalizedTitle:"redis 如何解决集群情况下分布式锁的可靠性？",charIndex:34313},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:34688}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"15 min read",minutes:14.525,time:871500,words:2905},headersStr:"认识 Redis 什么是 Redis？ Redis 为什么这么快？ 为什么要用分布式缓存？ 分布式缓存常见的技术选型方案有哪些？ 为什么腾讯开源的Tendis比较少公司使用 Redis 和 Memcached 有什么区别？ 为什么用 Redis 作为 MySQL 的缓存？ Redis 数据结构 Redis 数据类型以及使用场景分别是什么？ 五种常见的 Redis 数据类型是怎么实现？ String 类型的内部实现 List 类型的内部实现 Hash 类型的内部实现： Set 类型的内部实现 Zset 类型的内部实现 Redis 线程模型 Redis 是单线程吗？ Redis 单线程模式是怎样的？ Redis 采用单线程为什么还这么快？ Redis 6.0 之前为什么使用单线程？ Redis 6.0 之后为什么引入了多线程？ Redis 持久化 Redis 如何实现数据不丢失？ AOF 日志是如何实现的？ 为什么先执行命令，再把数据写入日志呢？ Redis 写入 AOF 日志的过程 AOF 写回策略有几种？ AOF 日志过大，会触发什么机制？ 重写 AOF 日志的过程是怎样的？ 什么是 RDB 快照？ 为什么需要 RDB 快照？ 有了 RDB，为什么还需要 AOF？ RDB 是如何实现的？会阻塞线程吗？ RDB 在执行快照的时候，数据能修改吗？ 为什么会有混合持久化？ 混合持久化是如何实现的？ 这种实现方式有什么好处？ 混合持久化的优缺点是什么？ Redis 集群 Redis 是如何实现高服务高可用的？ 主从复制 实现方案 主服务器和从服务器的区别 具体来说 哨兵模式 Sentinel 问题 解决方案 总结 切片集群模式 Cluster 场景 Redis Cluster 方案 哈希槽是如何被映射到具体的 Redis 节点上的？ 数据、哈希槽，以及节点三者的映射分布关系 集群脑裂导致数据丢失怎么办？ 什么是脑裂？ 解决方案 Redis 过期删除与内存淘汰 Redis 给缓存数据设置过期时间有啥用？ Redis 使用过的过期删除策略是什么？ 什么是惰性删除策略？ 什么是定期删除策略？ Redis 持久化时，对过期键会如何处理？ Redis 主从模式中，对过期键会如何处理？ Redis 内存满了，会发生什么？ Redis 内存淘汰策略有哪些？ 1、不进行数据淘汰的策略 2、进行数据淘汰的策略 在设置了过期时间的数据中进行淘汰： 在所有数据范围内进行淘汰： LRU 算法和 LFU 算法有什么区别？ 什么是 LRU 算法？ Redis 是如何实现 LRU 算法的？ 什么是缓存污染问题？ 什么是 LFU 算法？ Redis 是如何实现 LFU 算法的？ Redis 缓存设计（生产问题） 缓存雪崩 什么是缓存雪崩？ 如何解决缓存雪崩？ 缓存击穿 什么是缓存击穿？ 如何解决缓存击穿？ 缓存穿透 什么是缓存穿透？ 产生的原因？ 如何应对缓存穿透？ 总结 如何设计一个缓存策略，可以动态缓存热点数据呢？ 为什么需要设计？ 设计思路 说说常见的缓存更新策略？ Cache Aside（旁路缓存）策略 为什么是删除缓存，而不是更新缓存呢？ 为什么「先更新数据库再删除缓存」不会有数据不一致的问题？ 适合场景？ Read/Write Through（读穿 / 写穿）策略 特点以及适合场景是什么？ Write Back（写回）策略 适合什么场景？ 如何保证缓存和数据库数据的一致性？ 哪些情况可能会导致 Redis 阻塞？ Redis 性能优化 大量 key 集中过期问题 Redis 大 key？ 什么是 Redis 大 key？ 大 key 会造成什么问题？ 如何找到大 key ？ 如何删除大 key？ 如何处理 bigkey？ Redis hotkey（热 Key） 什么是 hotkey？ hotkey 有什么危害？ 如何找到 hotkey？ 如何解决 hotkey？ 慢查询命令 什么是慢查询命令？ 为什么会有慢查询命令？ 如何找到慢查询命令？ Redis 内存碎片 什么是内存碎片? 为什么会有 Redis 内存碎片? 如何查看 Redis 内存碎片的信息？ 如何清理 Redis 内存碎片？ Redis 实战 延迟队列 什么是延迟队列？ Redis 如何实现延迟队列？ Redis 管道有什么用？ Redis 事务 Redis 事务支持回滚吗？ 为什么 Redis 不支持事务回滚？ Redis 分布式锁 如何用 Redis 实现分布式锁的？ 基于 Redis 实现分布式锁有什么优缺点？ Redis 如何解决集群情况下分布式锁的可靠性？ 参考",content:"# Redis 总结\n\n\n# 认识 Redis\n\n\n# 什么是 Redis？\n\nRedis 是一个由 C 语言开发并且基于内存的键值型数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。\n\n有以下几个特征：\n\n 1. 为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String(字符串)、Hash(哈希)、 List (列表)、Set(无序集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流））。\n 2. 执行命令由单线程负责，每个命令具备原子性。\n 3. 低延迟，速度快（基于内存、IO 多路复用、良好的编码）。 -- 什么是 IO 多路复用？\n 4. 支持事务 、数据持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等。\n 5. 没有外部依赖，官方推荐生产环境使用 Linux 部署 Redis。\n 6. 支持多语言客户端。\n\n\n# Redis 为什么这么快？\n\n因为 Redis 内部做了非常多的性能优化，比如：\n\n 1. Redis 基于内存，内存的访问速度是硬盘的上千倍；\n 2. Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用；\n 3. Redis 内置了多种优化过后的数据结构实现（比如...），性能非常高。\n\n\n# 为什么要用分布式缓存？\n\n 1. 提高系统性能：将部分数据存储在缓存中，可以减少系统对于数据库的访问次数，提高系统的性能。通过使用分布式缓存，可以将缓存分布在多个节点上，从而进一步提高系统的吞吐量和并发性能。\n 2. 提高系统可用性：通过使用分布式缓存，可以将缓存数据复制到多个节点上，从而提高系统的可用性。当某个节点出现故障时，可以自动切换到其他节点，保证系统的正常运行。\n 3. 提高系统扩展性：通过使用分布式缓存，可以将缓存数据分散到多个节点上，从而支持系统的水平扩展。当系统负载增加时，可以通过添加节点来扩展系统的容量，从而保证系统的稳定运行。\n 4. 降低成本：通过使用分布式缓存，可以减少系统对于数据库的访问次数，从而降低数据库的负载和成本。在一些应用场景下，使用分布式缓存可以替代部分数据库的功能，从而进一步降低成本。\n\n\n# 分布式缓存常见的技术选型方案有哪些？\n\n主要有三种。\n\n 1. 第一种是 Memcacheed，比较老牌的技术，随着 Redis 的发展，已经逐渐被淘汰了。\n 2. 第二种是 Tendis，一款由腾讯开源的的类似 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 RocksDBopen in new window 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，但是其关注度并不高，使用的公司也比较少。\n 3. 第三种就是 Redis，目前主流的分布式缓存技术。\n\n\n# 为什么腾讯开源的Tendis比较少公司使用\n\n因为 Tendis 出现的时间较短，相对于其他成熟的分布式 KV 存储系统，Tendis 的用户基数和社区规模相对较小，因此目前比较少公司使用。此外，Tendis 的文档和资料相对较少，不太方便开发人员学习和使用。\n\n\n# Redis 和 Memcached 有什么区别？\n\n先讲下两者的共同点：\n\n 1. 它们都是基于内存的数据库，一般都用来当做缓存使用；\n 2. 都有过期策略；\n 3. 两者的性能都非常高。\n\n再分析一下两者的区别：\n\n 1. Redis 支持的数据类型更丰富，而 Memcached 只支持最简单的 key-value 数据类型；\n 2. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，Redis 重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉之后，数据就没了；\n 3. Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；\n 4. Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。\n\n\n# 为什么用 Redis 作为 MySQL 的缓存？\n\n主要是因为 Redis 具备 【高性能】 和 【高并发】 两种特性。\n\n1、Redis 具备高性能\n\n例如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。而将该用户访问的数据缓存在 Redis 中，下一次再访问这些数据的时候就可以直接从缓存中获取了（缓存命中），操作 Redis 缓存就是直接操作内存，速度会非常快。\n\n如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题。\n\n2、Redis 具备高并发\n\n单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。\n\n所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。\n\n\n# Redis 数据结构\n\n\n# Redis 数据类型以及使用场景分别是什么？\n\n常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。\n\n后续随着版本的更新，又支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。\n\n分别对应的应用场景是：\n\n 1. String 对应：缓存对象、常规计数、分布式锁、共享 session 信息等。\n\n 2. List 对应：消息队列\n    \n    但是有两个问题：生产者需要自行实现全局唯一 ID，不能以消费组形式消费数据。\n\n 3. Hash 对应：缓存对象、购物车等。\n\n 4. Set 对应：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。\n\n 5. Zset 对应：排序场景，比如排行榜、电话和姓名排序等。\n\n 6. BitMap（位图）对应：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；\n\n 7. HyperLogLog（基数统计）对应：海量数据基数统计的场景，比如百万级网页 UV 计数等；\n\n 8. GEO（地理信息）对应：存储地理位置信息的场景，比如滴滴打车；\n\n 9. Stream（流）对应：消息队列，\n    \n    相比于基于 List 类型实现的消息队列，\n    \n    有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。\n\n\n\n\n# 五种常见的 Redis 数据类型是怎么实现？\n\n# String 类型的内部实现\n\nString 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。之所以没有使用 C 语言的字符串表示，是因为 SDS 相比于 C 的原生字符串：\n\n 1. SDS 不仅可以保存文本数据，还可以保存二进制数据。\n    \n    * 这是因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，\n    \n    * 并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。\n    \n    * 所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。\n\n 2. SDS 获取字符串长度的时间复杂度是 O(1)。\n    \n    * 这是因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；\n    * 而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。\n\n 3. Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。\n    \n    * 这是因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，\n    * 如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。\n\n# List 类型的内部实现\n\n3.2 之前，List 类型的底层数据结构是由双向链表或压缩列表实现的：\n\n * 如果列表的元素个数小于 512 个，列表每个元素的值都小于 64 字节，Redis 会使用压缩列表作为 List 类型的底层数据结构；\n   \n   > 上面的 512，64 都是默认值，可由 list-max-ziplist-entries 配置\n\n * 其他情况的话，Redis 会使用双向链表作为 List 类型的底层数据结构；\n\n注意：但是在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。\n\n# Hash 类型的内部实现：\n\nHash 类型的底层数据结构是由压缩列表或哈希表实现的：\n\n * 如果哈希类型元素个数小于 512 个，所有值小于 64 字节的话，Redis 会使用压缩列表作为 Hash 类型的底层数据结构；\n * 其他情况的话，Redis 会使用哈希表作为 Hash 类型的底层数据结构。\n\n注意：在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。\n\n# Set 类型的内部实现\n\nSet 类型的底层数据结构是由整数集合或哈希表实现的：\n\n * 如果集合中的元素都是整数且元素个数小于 512 个，Redis 会使用整数集合作为 Set 类型的底层数据结构；\n * 如果集合中的元素不满足上面条件，则 Redis 会使用哈希表作为 Set 类型的底层数据结构。\n\n# Zset 类型的内部实现\n\n在 7.0 之前，Zset 类型的底层数据结构是由压缩列表或跳表实现的：\n\n * 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；\n * 如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；\n\n注意：在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。\n\n\n# Redis 线程模型\n\n\n# Redis 是单线程吗？\n\n是。但是，Redis 程序不是单线程的，因为 Redis 在启动的时候。会启动后台线程（BIO）：\n\n * Redis 在 2.6 版本，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；\n\n * 在 4.0 版本之后，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。\n   \n   例如执行 unlink key、 flushdb async、 flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大 key。\n\n为什么 Redis 要为「关闭文件、AOF 刷盘、释放内存」这些任务启动后台线程？\n\n是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。\n\n> Redis 单线程指的是:\n> \n> 【 接收客户端请求 -> 解析请求 -> 进行数据读写等操作 -> 发送数据给客户端 】\n> \n> 这个过程是由一个线程（主线程）来完成的，所以我们常说 Redis 是单线程的。\n\n\n# Redis 单线程模式是怎样的？\n\nRedis 单线程模式是指：\n\nRedis 服务器在运行时只使用一个线程来处理客户端的请求和所有的数据操作，这个线程同时也负责了网络 I/O、内存管理、磁盘同步等操作，因此 Redis 的性能非常高。在单线程模式下，Redis 使用了多路复用技术来实现非阻塞 I/O，从而避免了线程切换和线程同步所带来的性能消耗。此外，Redis 通过对数据的操作进行批量化和异步化来进一步提高性能。需要注意的是，虽然 Redis 是单线程模式，但是它可以通过多个进程或者多个实例的方式来进行横向扩展，从而提高整个系统的性能和可伸缩性。\n\n\n# Redis 采用单线程为什么还这么快？\n\n主要有以下三个原因：\n\n 1. Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 性能表现的瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；\n 2. Redis 采用单线程模型避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。\n 3. Redis 采用了 I/O 多路复用机制来处理大量的客户端 Socket 请求。IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。\n\n> 什么是客户端 Socket 请求？\n> \n> 客户端 Socket 请求指的是客户端通过建立 Socket 连接向服务器发送请求的过程。在网络编程中，Socket 是一种通信机制，它提供了一种通过网络进行进程间通信的方式。 在客户端Socket 请求中，客户端首先需要创建一个 Socket 对象，并指定要连接的服务器的IP地址和端口号。然后，客户端可以向服务器发送请求，请求可以是任何形式的数据，例如HTTP请求、FTP请求等。 客户端发送请求后，服务器收到请求后会进行处理，并返回响应给客户端。客户端接收到服务器返回的响应后，可以对响应进行处理，例如解析HTML页面、保存文件等。最后，客户端关闭Socket连接，释放资源。 客户端Socket请求是网络编程中非常常见的一种操作，它可以实现各种网络应用程序，例如网页浏览器、聊天工具、文件下载器等。\n\n\n# Redis 6.0 之前为什么使用单线程？\n\n众所周知，Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，而单线程的程序是无法利用服务器的多核 CPU 的，但是 CPU 并不是制约 Redis 性能表现的瓶颈所在，所以 Redis 核心网络模型使用单线程并没有什么问题，如果想要使用服务的多核 CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。\n\n还有一点就是，使用单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，比如：增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。\n\n\n# Redis 6.0 之后为什么引入了多线程？\n\n这是因为在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上。\n\n所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解 Redis 有多线程同时执行命令。\n\n简单来说就是为了提升性能，采用多线程来处理 网络 I/O\n\n\n# Redis 持久化\n\n\n# Redis 如何实现数据不丢失？\n\nRedis 通过实现数据持久化的机制来保证数据不丢失，这个机制会把数据存储到磁盘，这样在 Redis 重启后就能够从磁盘中恢复原有的数据。\n\nRedis 共有三种数据持久化的方式：\n\n 1. AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；\n 2. RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；\n 3. 混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；\n\n\n# AOF 日志是如何实现的？\n\nRedis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。\n\n> 简单来说就是：客服端 发送请求到 Redis 中，然后会记录命令到 AOF 文件中\n\n流程如下图：\n\n\n\n文件内容解释如下：\n\n文件先是用 [*3] 表示当前命令有三个部分，每部分都是以 [$+数字] 开头，后面紧跟着具体的命令、键或值。然后，这里的 [数字] 表示这部分中的命令、键或值一共有多少字节。\n\n例如，[$3 set] 表示这部分有 3 个字节，也就是 [set] 命令这个字符串的长度。\n\n# 为什么先执行命令，再把数据写入日志呢？\n\n因为这么做有两个好处：\n\n 1. 避免额外的检查开销：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，并且不进行命令语法检查的话，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。\n 2. 不会阻塞当前写操作命令的执行：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。\n\n当然，这样做也会带来风险：\n\n * 数据可能会丢失：执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。\n * 可能阻塞其他操作：由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。\n\n# Redis 写入 AOF 日志的过程\n\n具体来说就是：\n\n 1. Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；\n 2. 然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；\n 3. 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。\n\n如图：\n\n\n\n# AOF 写回策略有几种？\n\nRedis 提供了 3 种写回硬盘的策略，控制的就是具体内核缓冲区的数据什么时候写入到硬盘的过程。\n\n在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：\n\n * Always：这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；\n * Everysec（默认）：这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；\n * No：意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。\n\n这 3 个写回策略的优缺点如下：\n\n\n\n# AOF 日志过大，会触发什么机制？\n\n会触发 AOF 重写机制。\n\n因为 AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小也会越来越大，相应的也就会带来性能问题。比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。\n\n所以为了避免 AOF 文件越写越大，Redis 提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。\n\n> AOF 重写机制是怎么实现的？\n\nAOF 重写机制：是在重写时，读取当前数据库的所有键值对（即数据），然后将每一个键值对转换成一条命令记录到一个新的 AOF 文件，等到全部记录完后，就会将新的 AOF 文件替换掉现有的 AOF 文件。相当于去掉了历史命令，压缩 AOF 文件。\n\n举个例子，在没有使用重写机制前，假设前后执行了 set name xiaolin 和 set name xiaolincoding 这两个命令的话，就会将这两个命令记录到 AOF 文件。但是在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 set name xiaolincoding 命令记录到新的 AOF 文件，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。\n\n# 重写 AOF 日志的过程是怎样的？\n\nRedis 的重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的，由子进程来完成有两个好处：\n\n 1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；\n\n 2. 子进程带有主进程的数据副本，这里使用子进程而不是线程，不会降低性能。\n    \n    因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。\n    \n    而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。\n\n触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。\n\n> 如果主进程修改了已经存在键值对，会产生什么问题？\n\n在重写过程中，主进程依然可以正常处理命令，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？\n\n为了解决这种数据不一致问题，Redis 设置了一个 AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。\n\n在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」。\n\n当子进程完成 AOF 重写工作后，会向主进程发送一条信号，主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：\n\n * 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；\n * 将新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。\n\n信号函数执行完后，主进程就可以继续像往常一样处理命令了。\n\n具体过程如下图：\n\n\n\n\n# 什么是 RDB 快照？\n\nRDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。\n\n因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。\n\n# 为什么需要 RDB 快照？\n\n因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。\n\n为了解决这个问题，Redis 增加了 RDB 快照。\n\n# 有了 RDB，为什么还需要 AOF？\n\n在 Redis 中，RDB 和 AOF 都是持久化的方式，用于将内存中的数据保存到磁盘中，以便在 Redis 重启时能够重新加载数据。\n\n * RDB 持久化方式是将 Redis 在某个时间点上的数据集以快照的形式写入磁盘中，因此 RDB 的优点是备份和恢复速度比较快，且生成的文件比 AOF 文件小，比较适合用于备份和灾难恢复。\n * AOF 持久化方式是通过记录 Redis 服务器所执行的所有写命令来记录数据变化，可以将每个写命令都写入日志文件中，当 Redis 重启时，通过读取 AOF 文件中的命令来重建原始数据，因此 AOF 的优点是数据的安全性更好，且适合用于数据的持久化存储。\n\n综上所述，尽管 RDB 可以提供快速备份和恢复的功能，但 AOF 持久化方式可以提供更高级别的数据保护，因此在一些关键业务场景下（金融、电商），我们需要同时使用 RDB 和 AOF 两种持久化方式，以确保数据的完整性和可靠性。\n\n# RDB 是如何实现的？会阻塞线程吗？\n\nRedis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：\n\n * 执行 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程；\n * 执行 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞；\n\nRedis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：\n\n// 只要满足下面条件的任意一个，就会执行 bgsave\nsave 900 1    // 900 秒之内，对数据库进行了至少 1 次修改\nsave 300 10   // 300 秒之内，对数据库进行了至少 10 次修改\nsave 60 10000 // 60 秒之内，对数据库进行了至少 1万 次修改。\n\n\n1\n2\n3\n4\n\n\n这里的选项名虽然叫 save，但实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。\n\n> 这里提一点，Redis 的快照是全量快照，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。\n\n# RDB 在执行快照的时候，数据能修改吗？\n\n可以，在执行 bgsave 过程中，Redis 依然可以继续处理操作命令，也就是数据是能被修改的，关键的技术就在于写时复制技术。\n\n> 什么是写时复制技术？\n> \n> 写时复制（Copy-On-Write，简称为COW）是一种常见的内存管理技术，也被广泛应用于数据库系统中，包括 Redis。\n> \n> 在 Redis 中，写时复制是指当父进程复制自己创建的子进程时，子进程与父进程共享相同的内存空间，只有在子进程需要修改某个内存页面时，才会将该页面复制一份到子进程的独立内存空间中，从而实现了父子进程之间的内存隔离，避免了频繁的内存复制，提高了内存的使用效率。Redis 使用写时复制来实现主从复制和 Sentinel 高可用性，以及 AOF 持久化中的 fork 操作。\n\n因为在执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。\n\n\n\n如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。\n\n\n\n\n# 为什么会有混合持久化？\n\n是为了集成 AOF 和 RDB 的优点，Redis 4.0 提出了混合使用 AOF 日志和内存快照，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。\n\n先分析下 AOF 和 RDB 的优缺点：\n\n * RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。\n\n * AOF 优点是丢失数据少，安全性高，但是数据恢复不快。\n\n# 混合持久化是如何实现的？\n\n混合持久化工作在 AOF 日志重写过程。\n\n当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。\n\n也就是说，使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数。\n\n# 这种实现方式有什么好处？\n\n这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快。\n\n加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得数据更少的丢失。\n\n> 简单来说：就是既可以加快加载速度，又可以减少数据的丢失。\n\n# 混合持久化的优缺点是什么？\n\n优点：\n\n * **结合了 RDB 和 AOF 持久化的优点，**开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，又减低了大量数据丢失的风险。\n\n缺点：\n\n * **可读性差：**因为在 AOF 文件中添加了 RDB 格式的内容，会使得 AOF 文件的可读性变得很差；\n * **兼容性差：**因为混合持久化机制是 Redis 4.0 版本之后才有的，如果开启了混合持久化 AOF 文件，就不能用在 Redis 4.0 之前的版本了。\n\n\n# Redis 集群\n\n\n# Redis 是如何实现高服务高可用的？\n\n> 要想设计一个高可用的 Redis 服务，一定要从 Redis 的多服务节点来考虑，比如 Redis 的主从复制、哨兵模式、切片集群。\n\n# 主从复制\n\n主从复制是 Redis 高可用服务的最基础的保证。\n\n# 实现方案\n\n就是将从前的一台 Redis 服务器，同步数据到多台 Redis 从服务器上，即一主多从的模式，且主从服务器之间采用的是**「读写分离」**的方式。\n\n# 主服务器和从服务器的区别\n\n【主服务器】可以进行读写操作，当发生写操作时自动将写操作同步给【从服务器】，而【从服务器】一般是只读，并接受【主服务器】同步过来写操作命令，然后执行这条命令。\n\n\n\n也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的（但不是强一致性）。\n\n> 注意，主从服务器之间的命令复制是异步进行的。\n\n# 具体来说\n\n在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。\n\n如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。\n\n所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。\n\n# 哨兵模式 Sentinel\n\n# 问题\n\n在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。\n\n# 解决方案\n\n为了解决这个问题，Redis 增加了哨兵模式（Redis Sentinel），因为哨兵模式做到了可以监控主从服务器，并且提供主从节点故障转移的功能。\n\n# 总结\n\n哨兵（Sentinel）机制是 Redis 在 2.8 版本以后提供的。\n\n它的作用是实现主从节点故障转移。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。\n\n哨兵一般是以集群的方式部署，至少需要 3 个哨兵节点，哨兵集群主要负责三件事情：监控、选主、通知。\n\n哨兵节点通过 Redis 的发布者/订阅者机制，哨兵之间可以相互感知，相互连接，然后组成哨兵集群，同时哨兵又通过 INFO 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。\n\n\n\n1、第一轮投票：判断主节点下线\n\n当哨兵集群中的某个哨兵判定主节点下线（主观下线）后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。\n\n当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。\n\n2、第二轮投票：选出哨兵leader\n\n某个哨兵判定主节点客观下线后，该哨兵就会发起投票，告诉其他哨兵，它想成为 leader，想成为 leader 的哨兵节点，要满足两个条件：\n\n * 第一，拿到半数以上的赞成票；\n * 第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。\n\n3、由哨兵 leader 进行主从故障转移\n\n选举出了哨兵 leader 后，就可以进行主从故障转移的过程了。该操作包含以下四个步骤：\n\n * 第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：\n   * 过滤掉已经离线的从节点；\n   * 过滤掉历史网络连接状态不好的从节点；\n   * 将剩下的从节点，进行三轮考察：优先级、复制进度、ID 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。\n * 第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；\n * 第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；\n * 第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；\n\n> 思考：哨兵是怎么实现的？\n\n# 切片集群模式 Cluster\n\n# 场景\n\n当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群（Redis Cluster）方案。\n\n实现方式：\n\n它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。\n\n# Redis Cluster 方案\n\n * Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。\n\n * 在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。\n   \n   具体执行过程分为两大步：\n   \n   1. 根据键值对的 key，按照 CRC16 算法 计算一个 16 bit 的值。\n   2. 再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。\n\n# 哈希槽是如何被映射到具体的 Redis 节点上的？\n\n有两种方式：\n\n * 平均分配： 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。\n * 手动分配： 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。\n\n> 注意：在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。\n\n# 数据、哈希槽，以及节点三者的映射分布关系\n\n\n\n通过命令手动分配哈希槽，比如节点 1 保存哈希槽 0 和 1，节点 2 保存哈希槽 2 和 3，如下所示：\n\nredis-cli -h 192.168.1.10 –p 6379 cluster addslots 0,1\nredis-cli -h 192.168.1.11 –p 6379 cluster addslots 2,3\n\n\n1\n2\n\n\n在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 4 进行取模，再根据各自的模数结果，就可以被映射到哈希槽 1（对应节点1） 和 哈希槽 2（对应节点2）。\n\n\n# 集群脑裂导致数据丢失怎么办？\n\n# 什么是脑裂？\n\n就好比一个人有两个大脑，不知道受谁控制。\n\n比如出现了两个主节点的情况。\n\n那么在 Redis 中，集群脑裂产生数据丢失的现象是怎样的呢？\n\n在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。\n\n这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在「从节点」中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— 也就是脑裂出现了。\n\n然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题。\n\n总结一句话就是：由于网络问题，集群节点之间失去联系。主从数据不同步；哨兵重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。\n\n# 解决方案\n\n当主节点发现从节点下线或者通信超时的总数量小于阈值时，就禁止主节点进行写数据，直接把错误返回给客户端。\n\n在 Redis 的配置文件中有两个参数我们可以设置：\n\n * min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。\n\n * min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。\n\n我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。\n\n这两个配置项组合后的要求是：主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK （确认字符）消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。\n\n即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了。\n\n等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。\n\n总结来说就是：\n\n解决方案是通过某种限制条件来禁止主节点进行写数据。\n\n在 Redis 的配置文件中设置两个参数，指明主节点至少要连接的从节点个数 N 以及主从数据复制和同步的延迟不能超过 T 秒，一旦达不到这个组合要求就限制主节点接收客户端的写请求，不再写入新数据，等哨兵主从切换完成后，新写的数据就会被直接写到新主节点上，从而避免避免了闹裂现象的发生，也就不会发生数据丢失了。\n\n\n# Redis 过期删除与内存淘汰\n\n\n# Redis 给缓存数据设置过期时间有啥用？\n\n主要有三个作用：\n\n 1. 释放空间：当缓存中的数据过期后，Redis 会自动将其删除，从而释放空间。这样可以避免缓存中存储过多的过期数据，占用过多的内存空间，导致缓存性能下降。\n 2. 提高缓存命中率：设置合理的缓存过期时间可以使得缓存中存储的数据都是最新的，有效的数据。这样可以提高缓存命中率，减少请求直接访问后端数据库的次数，从而提高系统的性能。\n 3. 避免缓存污染问题：过期时间可以避免缓存污染问题，即缓存中存储了过期、损坏或者恶意的数据。当缓存中的数据过期后，Redis 会自动将其删除，从而避免应用程序获取到错误的数据。\n\n> 如果过期时间设置得太短，可能会导致缓存命中率降低，请求直接访问后端数据库的次数增多；\n> \n> 如果过期时间设置得太长，可能会导致缓存中存储的数据不是最新的，从而影响系统的性能。\n\n\n# Redis 使用过的过期删除策略是什么？\n\nRedis 使用的过期删除策略是「惰性删除+定期删除」这两种策略配和使用。负责删除已过期的键值对。\n\n每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个过期字典中。\n\n当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：\n\n * 如果不在，则正常读取键值；\n * 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。\n\n\n# 什么是惰性删除策略？\n\n惰性删除策略的做法是：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key，返回 null 给客户端。\n\n惰性删除策略的优点：\n\n * 因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。\n\n惰性删除策略的缺点：\n\n * 如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。\n\n总结来说就是：\n\n占用的系统资源少，对 CPU 时间友好；但会浪费一定的内存空间，对内存不友好。以空间换时间。\n\n\n# 什么是定期删除策略？\n\n定期删除策略的做法是：每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。\n\n具体流程是：\n\n 1. 从过期字典中随机抽取 20 个 key；\n\n 2. 检查这 20 个 key 是否过期，并删除已过期的 key；\n\n 3. 如果本轮检查的已过期 key 的数量，超过 5 个（抽取的个数*25%），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；\n    \n    如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。\n\n定期抽取 => 检查并删除 => 判断过期 key 是否超过 25%\n\n定期删除策略的优点：\n\n * 通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。\n\n定期删除策略的缺点：\n\n * 难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。\n\n定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性/懒汉式删除 。\n\n\n# Redis 持久化时，对过期键会如何处理？\n\nRedis 持久化文件有两种格式：RDB 和 AOF。\n\n下面来说下过期键在这两种格式中的呈现状态。\n\n先讲下 RDB，RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。\n\n * **RDB 文件生成阶段：**从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，过期的键「不会」被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。\n * **RDB 加载阶段：**RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：\n   * 如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中。所以过期键不会对载入 RDB 文件的主服务器造成影响；\n   * 如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。\n\n再讲下 AOF 的情况，AOF 文件也分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。\n\n * AOF 文件写入阶段：当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。\n * AOF 重写阶段：执行 AOF 重写时，会对 Redis 中的键值对进行检查，已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响。\n\n\n# Redis 主从模式中，对过期键会如何处理？\n\n当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的（依赖于主库）。也就是说即使从库中的 key 过期了，如果有客户端访问从库，依然可以得到 key 对应的值，像未过期的键值对一样返回。\n\n从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。\n\n\n# Redis 内存满了，会发生什么？\n\n在 Redis 的运行内存达到了某个阀值，就会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。\n\n\n# Redis 内存淘汰策略有哪些？\n\nRedis 内存淘汰策略一共有八种，而这八种策略大体可分为「不进行数据淘汰」和「进行数据淘汰」两类策略。\n\n1 - 4 - 7\n\n# 1、不进行数据淘汰的策略\n\nnoeviction（Redis3.0之后，默认的内存淘汰策略）：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。\n\n# 2、进行数据淘汰的策略\n\n针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。\n\n# 在设置了过期时间的数据中进行淘汰：\n\n * volatile-random：随机淘汰设置了过期时间的任意键值；\n * volatile-ttl：优先淘汰更早过期的键值。\n * volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；\n * volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；\n\n# 在所有数据范围内进行淘汰：\n\n * allkeys-random：随机淘汰任意键值;\n * allkeys-lru：淘汰整个键值中最久未使用的键值；\n * allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。\n\n\n# LRU 算法和 LFU 算法有什么区别？\n\n# 什么是 LRU 算法？\n\nLRU 全称是 Least Recently Used(lru) 翻译为最近最少使用，会选择淘汰最近最少使用的数据。（最久未使用 -- 时间）\n\n传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。\n\n但是 Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：\n\n * 需要用链表管理所有的缓存数据，这会带来额外的空间开销；\n * 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。\n\n# Redis 是如何实现 LRU 算法的？\n\nRedis 实现的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。\n\n当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。\n\nRedis 实现的 LRU 算法的优点：\n\n * 不用为所有的数据维护一个大链表，节省了空间占用；\n * 不用在每次数据访问时都移动链表项，提升了缓存的性能；\n\n但是 LRU 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。\n\n因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。\n\n# 什么是缓存污染问题？\n\n缓存污染问题是指：缓存中存储了错误的数据，导致应用程序获取到的数据不正确。**通常是由于缓存中存储了过期的、损坏的或者恶意的数据造成的。**当应用程序从缓存中获取到错误的数据时，可能会导致程序异常或者返回不正确的结果。为了避免缓存污染问题，需要定期清理过期数据、设置合理的缓存过期时间、使用合法的缓存数据源等措施。\n\n# 什么是 LFU 算法？\n\nLFU 全称是 Least Frequently Used 翻译为最不经常使用，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。（最少使用 -- 次数）\n\n所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。\n\n# Redis 是如何实现 LFU 算法的？\n\nLFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。\n\n> 高 16bit -- 记录 key 的访问时间戳；低 8bit -- 记录 key 的访问频次\n\nRedis 对象的结构如下：\n\ntypedef struct redisObject {\n    ...\n      \n    // 24 bits，用于记录对象的访问信息\n    unsigned lru:24;  \n    ...\n} robj;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nRedis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。\n\n在 LRU 算法中，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。\n\n在 LFU 算法中，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。\n\n如下图所示：\n\n\n\n\n# Redis 缓存设计（生产问题）\n\n\n# 缓存雪崩\n\n# 什么是缓存雪崩？\n\n缓存雪崩就是：当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，同时又有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。\n\n# 如何解决缓存雪崩？\n\n对于缓存雪崩问题，我们可以采用两种方案解决。\n\n 1. 将缓存失效时间随机打散：我们可以在原有的失效时间基础上增加一个随机值（比如 1 到 10 分钟）这样每个缓存的过期时间都不重复了，也就降低了缓存集体失效的概率。\n 2. 设置缓存不过期：我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。\n\n\n# 缓存击穿\n\n# 什么是缓存击穿？\n\n我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。\n\n如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。\n\n> 可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。（缓存数据 包含 热点数据）\n\n# 如何解决缓存击穿？\n\n应对缓存击穿可以采取前面说到两种方案：\n\n 1. 互斥锁方案：（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。\n 2. 不让热点数据过期： 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间。\n\n\n# 缓存穿透\n\n# 什么是缓存穿透？\n\n简单来说，缓存穿透就是：大量请求的 key 是不合理的，既不存在于缓存中，也不存在于数据库中。\n\n导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，甚至可能直接就被这么多请求弄宕机了。\n\n# 产生的原因？\n\n * 业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；\n * 黑客恶意攻击，故意大量访问某些读取不存在数据的业务；\n\n# 如何应对缓存穿透？\n\n最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。\n\n应对缓存穿透的方案，常见的方案有三种。\n\n * 非法请求的限制（参数校验）：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误给客户端，避免进一步访问缓存和数据库。\n * 设置空值或者默认值：当我们线上业务发现缓存穿透的现象时（缓存和数据库都不存在），可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。\n * 使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。\n\n\n# 总结\n\n缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。\n\n其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。\n\n而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。\n\n\n\n\n# 如何设计一个缓存策略，可以动态缓存热点数据呢？\n\n# 为什么需要设计？\n\n由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而只是将其中一部分热点数据缓存起来，所以我们要设计一个热点数据动态缓存的策略。\n\n# 设计思路\n\n热点数据动态缓存的策略总体思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。\n\n以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：\n\n * 先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；\n * 同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；\n * 这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。\n\n在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。\n\n\n# 说说常见的缓存更新策略？\n\n常见的缓存更新策略共有3种：\n\n 1. Cache Aside（旁路缓存）策略；\n 2. Read/Write Through（读穿 / 写穿）策略；\n 3. Write Back（写回）策略；\n\n实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，另外两种策略应用不了。\n\n# Cache Aside（旁路缓存）策略\n\nCache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。\n\n写策略的步骤：\n\n * 先更新数据库中的数据，再删除缓存中的数据。\n\n读策略的步骤：\n\n * 如果读取的数据命中了缓存，则直接返回数据；\n * 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。\n\n> 注意：写策略的步骤的顺序不能倒过来，即不能先删除缓存再更新数据库，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。\n\n# 为什么是删除缓存，而不是更新缓存呢？\n\n因为删除一个数据，相比更新一个数据更加轻量级，出问题的概率更小。在实际业务中，缓存的数据可能不是直接来自某一张数据库表，也许来自多张底层数据表的聚合。\n\n * 比如商品详情信息，在底层可能会关联商品表、价格表、库存表等，如果更新了一个价格字段，那么就要更新整个数据库，还要关联的去查询和汇总各个周边业务系统的数据，这个操作会非常耗时。\n * 从另外一个角度，不是所有的缓存数据都是频繁访问的，更新后的缓存可能会长时间不被访问（浪费空间），所以说，从计算资源和整体性能的考虑，更新的时候删除缓存，等到下次查询命中再填充缓存，是一个更好的方案。\n\n> 系统设计中有一个思想叫 Lazy Loading，适用于那些加载代价大的操作，删除缓存而不是更新缓存，就是懒加载思想的一个应用。\n\n# 为什么「先更新数据库再删除缓存」不会有数据不一致的问题？\n\n其实先更新数据库，再删除缓存也会出现数据不一致性的问题，但是在实际中，这个问题出现的概率并不高。\n\n> 例如：请求 A 更新完数据库，但还未删除缓存，此时请求 B 命中了缓存并返回，就导致了数据不一致。\n> \n> 出现的概率低是因为 缓存的写入非常快，中间的时间差非常短，通常只有几毫秒或者几十毫秒。\n\n「先更新数据库再删除缓存」不会造成数据不一致的问题，是因为在更新数据库的同时，缓存并没有被删除，而是在接下来的读取操作中被重新写入。具体来说，当应用程序更新数据库时，会先更新数据库中的数据，然后再删除缓存中对应的数据。接着，当下一次需要访问该数据时，应用程序会重新从数据库中读取该数据，并将其写入缓存中。这样，缓存中存储的数据就是最新的，与数据库中的数据一致。\n\n# 适合场景？\n\nCache Aside 策略适合读多写少的场景，不适合写多的场景，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。\n\n如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：\n\n * 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；\n * 另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。\n\n# Read/Write Through（读穿 / 写穿）策略\n\nRead/Write Through（读穿 / 写穿）策略原则是：应用程序只和缓存交互，不再和数据库交互，然后由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。\n\n1、Read Through 读穿策略\n\n * 先查询缓存中数据是否存在，如果存在则直接返回，\n * 如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。\n\n2、Write Through 写穿策略\n\n当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：\n\n * 如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。\n * 如果缓存中数据不存在，直接更新数据库，然后返回；\n\n\n\n# 特点以及适合场景是什么？\n\nRead Through/Write Through 策略的特点是：\n\n由缓存节点而非应用程序来和数据库打交道，\n\n在我们开发过程中相比 Cache Aside 策略要少见一些，原因是我们经常使用的分布式缓存组件，无论是 Memcached 还是 Redis 都不提供写入数据库和自动加载数据库中的数据的功能。\n\n而我们在使用本地缓存的时候可以考虑使用这种策略。\n\n# Write Back（写回）策略\n\nWrite Back（写回）策略：在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。\n\nWrite Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 Redis 并没有异步更新数据库的功能。\n\n# 适合什么场景？\n\nWrite Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。\n\nWrite Back 策略特别适合写多的场景，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。\n\n写回策略会带来什么问题？\n\n带来的问题是，数据不是强一致性的，而且会有数据丢失的风险，因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。\n\n\n# 如何保证缓存和数据库数据的一致性？\n\n一共两个操作：\n\n 1. 更新数据库\n 2. 删除缓存\n\n使用 Cache Aside 旁路缓存策略，并增加**「消息队列来重试缓存的删除」或「订阅 MySQL binlog 再操作缓存」**来保证两个操作都能执行成功。\n\n1、只给缓存加上过期时间进行兜底会出现什么情况？\n\n可能会出现删除缓存操作失败的问题，从而出现缓存中的数据是旧值，数据库的是最新值，需要过一段时间才会有更新生效的现象（因为过期时间到了，缓存数据重新写入）。\n\n2、如何保证两个操作都能执行成功？\n\n有两种方法：\n\n * 重试机制。\n * 订阅 MySQL binlog，再操作缓存。\n\n这两种方法有一个共同的特点，都是采用异步操作缓存。\n\n1. 重试机制\n\n我们可以引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。\n\n * 如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。\n * 如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。\n\n2. 订阅 MySQL binlog，再操作缓存\n\n「先更新数据库，再删缓存」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。\n\n于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。\n\nCanal 的工作原理：\n\n\n\n\n# 哪些情况可能会导致 Redis 阻塞？\n\n 1. 执行时间复杂度为 O(n) 的命令时，比如 KEYS *；\n 2. 使用 save 命令生成 RDB 快照文件时；\n 3. AOF 日志记录，刷盘，重写时；\n 4. 查找或删除大 key时；\n 5. 清空数据库时；\n 6. 集群扩容时；\n 7. CPU 竞争时；\n 8. 网络环境差的时候\n\n\n# Redis 性能优化\n\n\n# 大量 key 集中过期问题\n\n有两种常见的方法：\n\n 1. 给 key 设置随机过期时间。\n 2. 开启 lazy-free（惰性删除/延迟释放），让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\n\n\n# Redis 大 key？\n\n# 什么是 Redis 大 key？\n\n大 key 并不是指 key 的值很大，而是指 key 对应的 value 很大。\n\n一般而言，下面这两种情况被称为大 key：\n\n * String 类型的值大于 10 KB；\n * Hash、List、Set、ZSet 类型的元素的个数超过 5000个；\n\n# 大 key 会造成什么问题？\n\nbigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。\n\n大 key 会带来以下四种影响：\n\n 1. 客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。\n 2. 引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。\n 3. 阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。\n 4. 内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS（每秒查询率，系统在单位时间内能够处理的请求数量） 也会比较大。\n\n# 如何找到大 key ？\n\n有三种方法：\n\n 1. 通过 redis-cli --bigkeys 命令查找大 key；\n 2. 使用 SCAN 命令查找大 key；\n 3. 使用 RdbTools 第三方开源工具查找大 key。\n\n# 如何删除大 key？\n\n有两种方法：\n\n 1. 分批次删除法，根据不同的数据类型采用不同的命令进行输出；\n 2. 异步删除法（Redis 4.0版本以上），用 unlink 命令代替 del 来删除。\n\n# 如何处理 bigkey？\n\n 1. 分割 bigkey：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。\n 2. 手动清理（删除）：Redis 4.0+ 可以使用 UNLINK 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 SCAN 命令结合 DEL 命令来分批次删除。\n 3. 采用合适的数据结构：比如使用 HyperLogLog 统计页面 UV。\n 4. 开启 lazy-free（惰性删除/延迟释放） ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\n\n\n# Redis hotkey（热 Key）\n\n# 什么是 hotkey？\n\n简单来说，如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey。\n\nhotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。\n\n# hotkey 有什么危害？\n\n处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。\n\n此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。\n\n因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。\n\n# 如何找到 hotkey？\n\n1、使用 Redis 自带的 --hotkeys 参数来查找。\n\n2、使用 MONITOR 命令。\n\nMONITOR 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。\n\n3、借助开源项目。\n\n比如京东零售的 hotkeyopen in new window 这个项目，不光支持 hotkey 的发现，还支持 hotkey 的处理。\n\n4、根据业务情况提前预估。\n\n可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。\n\n不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。\n\n5、业务代码中记录分析。\n\n在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。\n\n6、借助公有云的 Redis 分析服务。\n\n如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都有提供）。\n\n# 如何解决 hotkey？\n\nhotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：\n\n * 读写分离：主节点处理写请求，从节点处理读请求。\n * 使用 Redis Cluster：将热点数据分散存储在多个 Redis 节点上。\n * 二级缓存：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。\n\n除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。\n\n\n# 慢查询命令\n\n# 什么是慢查询命令？\n\n慢查询命令是指：执行时间超过 Redis 配置的阈值的命令。\n\n这个阈值可以通过 Redis 配置文件中的 slowlog-log-slower-than 参数进行设置，默认值是 10000，即 10 毫秒。\n\n当 Redis 执行一个命令的时间超过了这个阈值，这个命令就会被记录在 Redis 的慢查询日志中。慢查询日志会记录命令的执行时间、执行命令的客户端、命令的参数等信息。通过查看慢查询日志，可以找到执行时间较长的命令，进而优化 Redis 的性能。\n\n# 为什么会有慢查询命令？\n\n这是因为 Redis 是单线程的，如果某个命令执行时间过长，就会阻塞其他命令的执行。为了避免这种情况的发生，Redis 会记录所有执行时间超过一定阈值的命令，并将其作为慢查询命令进行记录和统计，以便开发人员进行优化和调整。\n\n# 如何找到慢查询命令？\n\n有三种常用的方法：\n\n 1. 使用 SLOWLOG 命令：SLOWLOG 命令可以查看 Redis 慢查询日志，包括执行时间、客户端地址、命令名称和参数等信息。可以使用 SLOWLOG LEN 命令查看慢查询日志的长度，使用SLOWLOG GET 命令获取指定的慢查询日志。\n 2. 使用 redis-slowlog 工具：redis-slowlog 是一个命令行工具，可以方便地查看 Redis 慢查询日志。通过运行 redis-slowlog 命令，可以列出慢查询命令的执行时间、客户端地址、命令名称和参数等信息。\n 3. 使用 Redis 监控工具：Redis 监控工具可以监控 Redis 的各种指标，包括慢查询命令的执行时间。通过监控工具，可以实时地查看 Redis 的性能指标，并及时发现慢查询命令。\n\n\n# Redis 内存碎片\n\n# 什么是内存碎片?\n\n可以将内存碎片简单地理解为那些不可用的后续没办法再被分配存储其他数据的空闲内存。\n\n比如：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。\n\nRedis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。\n\n# 为什么会有 Redis 内存碎片?\n\n有 2 个比较常见的原因：\n\n1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。\n\n因为 Redis 对内存的分配和回收采用的是 jemalloc 或 libc 等第三方库，这些库的内存分配策略可能会导致内存碎片。\n\n2、频繁修改 Redis 中的数据也会产生内存碎片。\n\n比如：当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。\n\n# 如何查看 Redis 内存碎片的信息？\n\n使用 info memory 命令即可查看 Redis 内存相关的信息。\n\n# 如何清理 Redis 内存碎片？\n\nRedis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。\n\n有两种方法：\n\n1、直接通过 config set 命令将 activedefrag 配置项设置为 yes 即可，但可能会对 Redis 的性能产生影响。\n\n> 通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响。\n> \n> 可以设置相关参数来控制具体什么时候清理以及减少对 Redis 性能的影响。\n\n2、重启 Redis 可以做到内存碎片重新整理，但是需要重启Redis服务，会导致一定的停机时间。\n\n\n# Redis 实战\n\n\n# 延迟队列\n\n# 什么是延迟队列？\n\n延迟队列是指：把当前要做的事情，往后推迟一段时间再做。\n\n延迟队列的常见使用场景有以下几种：\n\n * 在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；\n * 打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；\n * 点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单。\n\n# Redis 如何实现延迟队列？\n\n可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。\n\n * 使用 zadd score1 value1 命令就可以一直往内存中生产消息。\n * 再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。\n\n\n\n\n# Redis 管道有什么用？\n\n管道技术（Pipeline）：是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。\n\n使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。\n\n\n# Redis 事务\n\n# Redis 事务支持回滚吗？\n\n不支持。\n\nRedis 中并没有提供回滚机制，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。\n\n事务执行过程中，如果命令入队时没报错，而事务提交后，实际执行时报错了，正确的命令依然可以正常执行，所以这可以看出 Redis 并不一定保证原子性\n\n> MySQL 在执行事务时，会提供回滚机制，当事务执行发生错误时，事务中的所有操作都会撤销，已经修改的数据也会被恢复到事务执行前的状态。\n\n# 为什么 Redis 不支持事务回滚？\n\nRedis 不支持事务回滚的原因有两个：\n\n 1. 官方认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；\n 2. 不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。\n\n这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚\n\n\n# Redis 分布式锁\n\n# 如何用 Redis 实现分布式锁的？\n\n1、什么是分布式锁？\n\n分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。\n\n\n\n2、加锁\n\nRedis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：\n\n * 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；\n * 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。\n\n基于 Redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。\n\n * 加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；\n * 锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；\n * 锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；\n\n满足这三个条件的分布式命令如下：\n\nSET lock_key unique_value NX PX 10000 \n\n\n1\n\n * lock_key 就是 key 键；\n * unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；\n * NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；\n * PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。\n\n简单来说，三个条件就是：需以原子操作完成、要有过期时间和一个用于标识客户端的标识。\n\n3、解锁\n\n用 Lua 脚本来进行解锁。\n\n解锁的过程就是：将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。\n\n可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。\n\n# 基于 Redis 实现分布式锁有什么优缺点？\n\n1、优点\n\n基于 Redis 实现分布式锁的优点：\n\n 1. 性能高效（这是选择缓存实现分布式锁最核心的出发点）。\n 2. 实现方便。很多研发工程师选择使用 Redis 来实现分布式锁，很大成分上是因为 Redis 提供了 setnx 方法，实现分布式锁很方便。\n 3. 避免单点故障（因为 Redis 是跨集群部署的，自然就避免了单点故障）。\n\n2、缺点\n\n基于 Redis 实现分布式锁的缺点：\n\n * 超时时间不好设置。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。比如在有些场景中，一个线程 A 获取到了锁之后，由于业务代码执行时间可能比较长，导致超过了锁的超时时间，自动失效，注意 A 线程没执行完，后续线程 B 又意外的持有了锁，意味着可以操作共享资源，那么两个线程之间的共享资源就没办法进行保护了。\n   * 那么如何合理设置超时时间呢？ 我们可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。\n * Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\n\n# Redis 如何解决集群情况下分布式锁的可靠性？\n\n为了保证集群环境下分布式锁的可靠性，Redis 官方设计了一个分布式锁算法 Redlock（红锁）。\n\n它是基于多个 Redis 节点的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。\n\nRedlock 算法的基本思路，是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\n\n加锁失败会怎样？\n\n加锁失败后，客户端会向所有 Redis 节点发起释放锁的操作，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。\n\n\n# 参考\n\n图解Redis| 小林coding",normalizedContent:"# redis 总结\n\n\n# 认识 redis\n\n\n# 什么是 redis？\n\nredis 是一个由 c 语言开发并且基于内存的键值型数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。\n\n有以下几个特征：\n\n 1. 为了满足不同的业务场景，redis 内置了多种数据类型实现（比如 string(字符串)、hash(哈希)、 list (列表)、set(无序集合)、zset(有序集合)、bitmaps（位图）、hyperloglog（基数统计）、geo（地理信息）、stream（流））。\n 2. 执行命令由单线程负责，每个命令具备原子性。\n 3. 低延迟，速度快（基于内存、io 多路复用、良好的编码）。 -- 什么是 io 多路复用？\n 4. 支持事务 、数据持久化、lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等。\n 5. 没有外部依赖，官方推荐生产环境使用 linux 部署 redis。\n 6. 支持多语言客户端。\n\n\n# redis 为什么这么快？\n\n因为 redis 内部做了非常多的性能优化，比如：\n\n 1. redis 基于内存，内存的访问速度是硬盘的上千倍；\n 2. redis 基于 reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 io 多路复用；\n 3. redis 内置了多种优化过后的数据结构实现（比如...），性能非常高。\n\n\n# 为什么要用分布式缓存？\n\n 1. 提高系统性能：将部分数据存储在缓存中，可以减少系统对于数据库的访问次数，提高系统的性能。通过使用分布式缓存，可以将缓存分布在多个节点上，从而进一步提高系统的吞吐量和并发性能。\n 2. 提高系统可用性：通过使用分布式缓存，可以将缓存数据复制到多个节点上，从而提高系统的可用性。当某个节点出现故障时，可以自动切换到其他节点，保证系统的正常运行。\n 3. 提高系统扩展性：通过使用分布式缓存，可以将缓存数据分散到多个节点上，从而支持系统的水平扩展。当系统负载增加时，可以通过添加节点来扩展系统的容量，从而保证系统的稳定运行。\n 4. 降低成本：通过使用分布式缓存，可以减少系统对于数据库的访问次数，从而降低数据库的负载和成本。在一些应用场景下，使用分布式缓存可以替代部分数据库的功能，从而进一步降低成本。\n\n\n# 分布式缓存常见的技术选型方案有哪些？\n\n主要有三种。\n\n 1. 第一种是 memcacheed，比较老牌的技术，随着 redis 的发展，已经逐渐被淘汰了。\n 2. 第二种是 tendis，一款由腾讯开源的的类似 redis 的分布式高性能 kv 存储数据库，基于知名的开源项目 rocksdbopen in new window 作为存储引擎 ，100% 兼容 redis 协议和 redis4.0 所有数据模型，但是其关注度并不高，使用的公司也比较少。\n 3. 第三种就是 redis，目前主流的分布式缓存技术。\n\n\n# 为什么腾讯开源的tendis比较少公司使用\n\n因为 tendis 出现的时间较短，相对于其他成熟的分布式 kv 存储系统，tendis 的用户基数和社区规模相对较小，因此目前比较少公司使用。此外，tendis 的文档和资料相对较少，不太方便开发人员学习和使用。\n\n\n# redis 和 memcached 有什么区别？\n\n先讲下两者的共同点：\n\n 1. 它们都是基于内存的数据库，一般都用来当做缓存使用；\n 2. 都有过期策略；\n 3. 两者的性能都非常高。\n\n再分析一下两者的区别：\n\n 1. redis 支持的数据类型更丰富，而 memcached 只支持最简单的 key-value 数据类型；\n 2. redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，redis 重启的时候可以再次加载进行使用，而 memcached 没有持久化功能，数据全部存在内存之中，memcached 重启或者挂掉之后，数据就没了；\n 3. redis 原生支持集群模式，memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；\n 4. redis 支持发布订阅模型、lua 脚本、事务等功能，而 memcached 不支持。\n\n\n# 为什么用 redis 作为 mysql 的缓存？\n\n主要是因为 redis 具备 【高性能】 和 【高并发】 两种特性。\n\n1、redis 具备高性能\n\n例如用户第一次访问 mysql 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。而将该用户访问的数据缓存在 redis 中，下一次再访问这些数据的时候就可以直接从缓存中获取了（缓存命中），操作 redis 缓存就是直接操作内存，速度会非常快。\n\n如果 mysql 中的对应数据改变的之后，同步改变 redis 缓存中相应的数据即可，不过这里会有 redis 和 mysql 双写一致性的问题。\n\n2、redis 具备高并发\n\n单台设备的 redis 的 qps（query per second，每秒钟处理完请求的次数） 是 mysql 的 10 倍，redis 单机的 qps 能轻松破 10w，而 mysql 单机的 qps 很难破 1w。\n\n所以，直接访问 redis 能够承受的请求是远远大于直接访问 mysql 的，可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。\n\n\n# redis 数据结构\n\n\n# redis 数据类型以及使用场景分别是什么？\n\n常见的有五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）、zset（有序集合）。\n\n后续随着版本的更新，又支持了四种数据类型： bitmap（2.2 版新增）、hyperloglog（2.8 版新增）、geo（3.2 版新增）、stream（5.0 版新增）。\n\n分别对应的应用场景是：\n\n 1. string 对应：缓存对象、常规计数、分布式锁、共享 session 信息等。\n\n 2. list 对应：消息队列\n    \n    但是有两个问题：生产者需要自行实现全局唯一 id，不能以消费组形式消费数据。\n\n 3. hash 对应：缓存对象、购物车等。\n\n 4. set 对应：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。\n\n 5. zset 对应：排序场景，比如排行榜、电话和姓名排序等。\n\n 6. bitmap（位图）对应：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；\n\n 7. hyperloglog（基数统计）对应：海量数据基数统计的场景，比如百万级网页 uv 计数等；\n\n 8. geo（地理信息）对应：存储地理位置信息的场景，比如滴滴打车；\n\n 9. stream（流）对应：消息队列，\n    \n    相比于基于 list 类型实现的消息队列，\n    \n    有这两个特有的特性：自动生成全局唯一消息id，支持以消费组形式消费数据。\n\n\n\n\n# 五种常见的 redis 数据类型是怎么实现？\n\n# string 类型的内部实现\n\nstring 类型的底层的数据结构实现主要是 sds（简单动态字符串）。之所以没有使用 c 语言的字符串表示，是因为 sds 相比于 c 的原生字符串：\n\n 1. sds 不仅可以保存文本数据，还可以保存二进制数据。\n    \n    * 这是因为 sds 使用 len 属性的值而不是空字符来判断字符串是否结束，\n    \n    * 并且 sds 的所有 api 都会以处理二进制的方式来处理 sds 存放在 buf[] 数组里的数据。\n    \n    * 所以 sds 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。\n\n 2. sds 获取字符串长度的时间复杂度是 o(1)。\n    \n    * 这是因为 c 语言的字符串并不记录自身长度，所以获取长度的复杂度为 o(n)；\n    * 而 sds 结构里用 len 属性记录了字符串长度，所以复杂度为 o(1)。\n\n 3. redis 的 sds api 是安全的，拼接字符串不会造成缓冲区溢出。\n    \n    * 这是因为 sds 在拼接字符串之前会检查 sds 空间是否满足要求，\n    * 如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。\n\n# list 类型的内部实现\n\n3.2 之前，list 类型的底层数据结构是由双向链表或压缩列表实现的：\n\n * 如果列表的元素个数小于 512 个，列表每个元素的值都小于 64 字节，redis 会使用压缩列表作为 list 类型的底层数据结构；\n   \n   > 上面的 512，64 都是默认值，可由 list-max-ziplist-entries 配置\n\n * 其他情况的话，redis 会使用双向链表作为 list 类型的底层数据结构；\n\n注意：但是在 redis 3.2 版本之后，list 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。\n\n# hash 类型的内部实现：\n\nhash 类型的底层数据结构是由压缩列表或哈希表实现的：\n\n * 如果哈希类型元素个数小于 512 个，所有值小于 64 字节的话，redis 会使用压缩列表作为 hash 类型的底层数据结构；\n * 其他情况的话，redis 会使用哈希表作为 hash 类型的底层数据结构。\n\n注意：在 redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。\n\n# set 类型的内部实现\n\nset 类型的底层数据结构是由整数集合或哈希表实现的：\n\n * 如果集合中的元素都是整数且元素个数小于 512 个，redis 会使用整数集合作为 set 类型的底层数据结构；\n * 如果集合中的元素不满足上面条件，则 redis 会使用哈希表作为 set 类型的底层数据结构。\n\n# zset 类型的内部实现\n\n在 7.0 之前，zset 类型的底层数据结构是由压缩列表或跳表实现的：\n\n * 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，redis 会使用压缩列表作为 zset 类型的底层数据结构；\n * 如果有序集合的元素不满足上面的条件，redis 会使用跳表作为 zset 类型的底层数据结构；\n\n注意：在 redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。\n\n\n# redis 线程模型\n\n\n# redis 是单线程吗？\n\n是。但是，redis 程序不是单线程的，因为 redis 在启动的时候。会启动后台线程（bio）：\n\n * redis 在 2.6 版本，会启动 2 个后台线程，分别处理关闭文件、aof 刷盘这两个任务；\n\n * 在 4.0 版本之后，新增了一个新的后台线程，用来异步释放 redis 内存，也就是 lazyfree 线程。\n   \n   例如执行 unlink key、 flushdb async、 flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大 key。\n\n为什么 redis 要为「关闭文件、aof 刷盘、释放内存」这些任务启动后台线程？\n\n是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。\n\n> redis 单线程指的是:\n> \n> 【 接收客户端请求 -> 解析请求 -> 进行数据读写等操作 -> 发送数据给客户端 】\n> \n> 这个过程是由一个线程（主线程）来完成的，所以我们常说 redis 是单线程的。\n\n\n# redis 单线程模式是怎样的？\n\nredis 单线程模式是指：\n\nredis 服务器在运行时只使用一个线程来处理客户端的请求和所有的数据操作，这个线程同时也负责了网络 i/o、内存管理、磁盘同步等操作，因此 redis 的性能非常高。在单线程模式下，redis 使用了多路复用技术来实现非阻塞 i/o，从而避免了线程切换和线程同步所带来的性能消耗。此外，redis 通过对数据的操作进行批量化和异步化来进一步提高性能。需要注意的是，虽然 redis 是单线程模式，但是它可以通过多个进程或者多个实例的方式来进行横向扩展，从而提高整个系统的性能和可伸缩性。\n\n\n# redis 采用单线程为什么还这么快？\n\n主要有以下三个原因：\n\n 1. redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 redis 性能表现的瓶颈可能是机器的内存或者网络带宽，而并非 cpu，既然 cpu 不是瓶颈，那么自然就采用单线程的解决方案了；\n 2. redis 采用单线程模型避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。\n 3. redis 采用了 i/o 多路复用机制来处理大量的客户端 socket 请求。io 多路复用机制是指一个线程处理多个 io 流，就是我们经常听到的 select/epoll 机制。简单来说，在 redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 socket 和已连接 socket。内核会一直监听这些 socket 上的连接请求或数据请求。一旦有请求到达，就会交给 redis 线程处理，这就实现了一个 redis 线程处理多个 io 流的效果。\n\n> 什么是客户端 socket 请求？\n> \n> 客户端 socket 请求指的是客户端通过建立 socket 连接向服务器发送请求的过程。在网络编程中，socket 是一种通信机制，它提供了一种通过网络进行进程间通信的方式。 在客户端socket 请求中，客户端首先需要创建一个 socket 对象，并指定要连接的服务器的ip地址和端口号。然后，客户端可以向服务器发送请求，请求可以是任何形式的数据，例如http请求、ftp请求等。 客户端发送请求后，服务器收到请求后会进行处理，并返回响应给客户端。客户端接收到服务器返回的响应后，可以对响应进行处理，例如解析html页面、保存文件等。最后，客户端关闭socket连接，释放资源。 客户端socket请求是网络编程中非常常见的一种操作，它可以实现各种网络应用程序，例如网页浏览器、聊天工具、文件下载器等。\n\n\n# redis 6.0 之前为什么使用单线程？\n\n众所周知，redis 的主要工作（网络 i/o 和执行命令）一直是单线程模型，而单线程的程序是无法利用服务器的多核 cpu 的，但是 cpu 并不是制约 redis 性能表现的瓶颈所在，所以 redis 核心网络模型使用单线程并没有什么问题，如果想要使用服务的多核 cpu，可以在一台服务器上启动多个节点或者采用分片集群的方式。\n\n还有一点就是，使用单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，比如：增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。\n\n\n# redis 6.0 之后为什么引入了多线程？\n\n这是因为在 redis 6.0 版本之后，也采用了多个 i/o 线程来处理网络请求，这是因为随着网络硬件的性能提升，redis 的性能瓶颈有时会出现在网络 i/o 的处理上。\n\n所以为了提高网络 i/o 的并行度，redis 6.0 对于网络 i/o 采用多线程来处理。但是对于命令的执行，redis 仍然使用单线程来处理，所以大家不要误解 redis 有多线程同时执行命令。\n\n简单来说就是为了提升性能，采用多线程来处理 网络 i/o\n\n\n# redis 持久化\n\n\n# redis 如何实现数据不丢失？\n\nredis 通过实现数据持久化的机制来保证数据不丢失，这个机制会把数据存储到磁盘，这样在 redis 重启后就能够从磁盘中恢复原有的数据。\n\nredis 共有三种数据持久化的方式：\n\n 1. aof 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；\n 2. rdb 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；\n 3. 混合持久化方式：redis 4.0 新增的方式，集成了 aof 和 rbd 的优点；\n\n\n# aof 日志是如何实现的？\n\nredis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。\n\n> 简单来说就是：客服端 发送请求到 redis 中，然后会记录命令到 aof 文件中\n\n流程如下图：\n\n\n\n文件内容解释如下：\n\n文件先是用 [*3] 表示当前命令有三个部分，每部分都是以 [$+数字] 开头，后面紧跟着具体的命令、键或值。然后，这里的 [数字] 表示这部分中的命令、键或值一共有多少字节。\n\n例如，[$3 set] 表示这部分有 3 个字节，也就是 [set] 命令这个字符串的长度。\n\n# 为什么先执行命令，再把数据写入日志呢？\n\n因为这么做有两个好处：\n\n 1. 避免额外的检查开销：因为如果先将写操作命令记录到 aof 日志里，再执行该命令的话，如果当前的命令语法有问题，并且不进行命令语法检查的话，该错误的命令记录到 aof 日志里后，redis 在使用日志恢复数据时，就可能会出错。\n 2. 不会阻塞当前写操作命令的执行：因为当写操作命令执行成功后，才会将命令记录到 aof 日志。\n\n当然，这样做也会带来风险：\n\n * 数据可能会丢失：执行写操作命令和记录日志是两个过程，那当 redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。\n * 可能阻塞其他操作：由于写操作命令执行成功后才记录到 aof 日志，所以不会阻塞当前命令的执行，但因为 aof 日志也是在主线程中执行，所以当 redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。\n\n# redis 写入 aof 日志的过程\n\n具体来说就是：\n\n 1. redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；\n 2. 然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 aof 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；\n 3. 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。\n\n如图：\n\n\n\n# aof 写回策略有几种？\n\nredis 提供了 3 种写回硬盘的策略，控制的就是具体内核缓冲区的数据什么时候写入到硬盘的过程。\n\n在 redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：\n\n * always：这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 aof 日志数据写回硬盘；\n * everysec（默认）：这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 aof 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；\n * no：意味着不由 redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 aof 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。\n\n这 3 个写回策略的优缺点如下：\n\n\n\n# aof 日志过大，会触发什么机制？\n\n会触发 aof 重写机制。\n\n因为 aof 日志是一个文件，随着执行的写操作命令越来越多，文件的大小也会越来越大，相应的也就会带来性能问题。比如重启 redis 后，需要读 aof 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。\n\n所以为了避免 aof 文件越写越大，redis 提供了 aof 重写机制，当 aof 文件的大小超过所设定的阈值后，redis 就会启用 aof 重写机制，来压缩 aof 文件。\n\n> aof 重写机制是怎么实现的？\n\naof 重写机制：是在重写时，读取当前数据库的所有键值对（即数据），然后将每一个键值对转换成一条命令记录到一个新的 aof 文件，等到全部记录完后，就会将新的 aof 文件替换掉现有的 aof 文件。相当于去掉了历史命令，压缩 aof 文件。\n\n举个例子，在没有使用重写机制前，假设前后执行了 set name xiaolin 和 set name xiaolincoding 这两个命令的话，就会将这两个命令记录到 aof 文件。但是在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 set name xiaolincoding 命令记录到新的 aof 文件，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。\n\n# 重写 aof 日志的过程是怎样的？\n\nredis 的重写 aof 过程是由后台子进程 bgrewriteaof 来完成的，由子进程来完成有两个好处：\n\n 1. 子进程进行 aof 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；\n\n 2. 子进程带有主进程的数据副本，这里使用子进程而不是线程，不会降低性能。\n    \n    因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。\n    \n    而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。\n\n触发重写机制后，主进程就会创建重写 aof 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 aof 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 aof 文件）。\n\n> 如果主进程修改了已经存在键值对，会产生什么问题？\n\n在重写过程中，主进程依然可以正常处理命令，那问题来了，重写 aof 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？\n\n为了解决这种数据不一致问题，redis 设置了一个 aof 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。\n\n在重写 aof 期间，当 redis 执行完一个写命令之后，它会同时将这个写命令写入到 「aof 缓冲区」和 「aof 重写缓冲区」。\n\n当子进程完成 aof 重写工作后，会向主进程发送一条信号，主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：\n\n * 将 aof 重写缓冲区中的所有内容追加到新的 aof 的文件中，使得新旧两个 aof 文件所保存的数据库状态一致；\n * 将新的 aof 的文件进行改名，覆盖现有的 aof 文件。\n\n信号函数执行完后，主进程就可以继续像往常一样处理命令了。\n\n具体过程如下图：\n\n\n\n\n# 什么是 rdb 快照？\n\nrdb 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 aof 文件记录的是命令操作的日志，而不是实际的数据。\n\n因此在 redis 恢复数据时， rdb 恢复数据的效率会比 aof 高些，因为直接将 rdb 文件读入内存就可以，不需要像 aof 那样还需要额外执行操作命令的步骤才能恢复数据。\n\n# 为什么需要 rdb 快照？\n\n因为 aof 日志记录的是操作命令，不是实际的数据，所以用 aof 方法做故障恢复时，需要全量把日志都执行一遍，一旦 aof 日志非常多，势必会造成 redis 的恢复操作缓慢。\n\n为了解决这个问题，redis 增加了 rdb 快照。\n\n# 有了 rdb，为什么还需要 aof？\n\n在 redis 中，rdb 和 aof 都是持久化的方式，用于将内存中的数据保存到磁盘中，以便在 redis 重启时能够重新加载数据。\n\n * rdb 持久化方式是将 redis 在某个时间点上的数据集以快照的形式写入磁盘中，因此 rdb 的优点是备份和恢复速度比较快，且生成的文件比 aof 文件小，比较适合用于备份和灾难恢复。\n * aof 持久化方式是通过记录 redis 服务器所执行的所有写命令来记录数据变化，可以将每个写命令都写入日志文件中，当 redis 重启时，通过读取 aof 文件中的命令来重建原始数据，因此 aof 的优点是数据的安全性更好，且适合用于数据的持久化存储。\n\n综上所述，尽管 rdb 可以提供快速备份和恢复的功能，但 aof 持久化方式可以提供更高级别的数据保护，因此在一些关键业务场景下（金融、电商），我们需要同时使用 rdb 和 aof 两种持久化方式，以确保数据的完整性和可靠性。\n\n# rdb 是如何实现的？会阻塞线程吗？\n\nredis 提供了两个命令来生成 rdb 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：\n\n * 执行 save 命令，就会在主线程生成 rdb 文件，由于和执行操作命令在同一个线程，所以如果写入 rdb 文件的时间太长，会阻塞主线程；\n * 执行 bgsave 命令，会创建一个子进程来生成 rdb 文件，这样可以避免主线程的阻塞；\n\nredis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：\n\n// 只要满足下面条件的任意一个，就会执行 bgsave\nsave 900 1    // 900 秒之内，对数据库进行了至少 1 次修改\nsave 300 10   // 300 秒之内，对数据库进行了至少 10 次修改\nsave 60 10000 // 60 秒之内，对数据库进行了至少 1万 次修改。\n\n\n1\n2\n3\n4\n\n\n这里的选项名虽然叫 save，但实际上执行的是 bgsave 命令，也就是会创建子进程来生成 rdb 快照文件。\n\n> 这里提一点，redis 的快照是全量快照，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。\n\n# rdb 在执行快照的时候，数据能修改吗？\n\n可以，在执行 bgsave 过程中，redis 依然可以继续处理操作命令，也就是数据是能被修改的，关键的技术就在于写时复制技术。\n\n> 什么是写时复制技术？\n> \n> 写时复制（copy-on-write，简称为cow）是一种常见的内存管理技术，也被广泛应用于数据库系统中，包括 redis。\n> \n> 在 redis 中，写时复制是指当父进程复制自己创建的子进程时，子进程与父进程共享相同的内存空间，只有在子进程需要修改某个内存页面时，才会将该页面复制一份到子进程的独立内存空间中，从而实现了父子进程之间的内存隔离，避免了频繁的内存复制，提高了内存的使用效率。redis 使用写时复制来实现主从复制和 sentinel 高可用性，以及 aof 持久化中的 fork 操作。\n\n因为在执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。\n\n\n\n如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 rdb 文件，在这个过程中，主线程仍然可以直接修改原来的数据。\n\n\n\n\n# 为什么会有混合持久化？\n\n是为了集成 aof 和 rdb 的优点，redis 4.0 提出了混合使用 aof 日志和内存快照，也叫混合持久化，既保证了 redis 重启速度，又降低数据丢失风险。\n\n先分析下 aof 和 rdb 的优缺点：\n\n * rdb 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。\n\n * aof 优点是丢失数据少，安全性高，但是数据恢复不快。\n\n# 混合持久化是如何实现的？\n\n混合持久化工作在 aof 日志重写过程。\n\n当开启了混合持久化时，在 aof 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 rdb 方式写入到 aof 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 aof 方式写入到 aof 文件，写入完成后通知主进程将新的含有 rdb 格式和 aof 格式的 aof 文件替换旧的的 aof 文件。\n\n也就是说，使用了混合持久化，aof 文件的前半部分是 rdb 格式的全量数据，后半部分是 aof 格式的增量数。\n\n# 这种实现方式有什么好处？\n\n这样的好处在于，重启 redis 加载数据的时候，由于前半部分是 rdb 内容，这样加载的时候速度会很快。\n\n加载完 rdb 的内容后，才会加载后半部分的 aof 内容，这里的内容是 redis 后台子进程重写 aof 期间，主线程处理的操作命令，可以使得数据更少的丢失。\n\n> 简单来说：就是既可以加快加载速度，又可以减少数据的丢失。\n\n# 混合持久化的优缺点是什么？\n\n优点：\n\n * **结合了 rdb 和 aof 持久化的优点，**开头为 rdb 的格式，使得 redis 可以更快的启动，同时结合 aof 的优点，又减低了大量数据丢失的风险。\n\n缺点：\n\n * **可读性差：**因为在 aof 文件中添加了 rdb 格式的内容，会使得 aof 文件的可读性变得很差；\n * **兼容性差：**因为混合持久化机制是 redis 4.0 版本之后才有的，如果开启了混合持久化 aof 文件，就不能用在 redis 4.0 之前的版本了。\n\n\n# redis 集群\n\n\n# redis 是如何实现高服务高可用的？\n\n> 要想设计一个高可用的 redis 服务，一定要从 redis 的多服务节点来考虑，比如 redis 的主从复制、哨兵模式、切片集群。\n\n# 主从复制\n\n主从复制是 redis 高可用服务的最基础的保证。\n\n# 实现方案\n\n就是将从前的一台 redis 服务器，同步数据到多台 redis 从服务器上，即一主多从的模式，且主从服务器之间采用的是**「读写分离」**的方式。\n\n# 主服务器和从服务器的区别\n\n【主服务器】可以进行读写操作，当发生写操作时自动将写操作同步给【从服务器】，而【从服务器】一般是只读，并接受【主服务器】同步过来写操作命令，然后执行这条命令。\n\n\n\n也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的（但不是强一致性）。\n\n> 注意，主从服务器之间的命令复制是异步进行的。\n\n# 具体来说\n\n在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。\n\n如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。\n\n所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。\n\n# 哨兵模式 sentinel\n\n# 问题\n\n在使用 redis 主从服务的时候，会有一个问题，就是当 redis 的主从服务器出现故障宕机时，需要手动进行恢复。\n\n# 解决方案\n\n为了解决这个问题，redis 增加了哨兵模式（redis sentinel），因为哨兵模式做到了可以监控主从服务器，并且提供主从节点故障转移的功能。\n\n# 总结\n\n哨兵（sentinel）机制是 redis 在 2.8 版本以后提供的。\n\n它的作用是实现主从节点故障转移。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。\n\n哨兵一般是以集群的方式部署，至少需要 3 个哨兵节点，哨兵集群主要负责三件事情：监控、选主、通知。\n\n哨兵节点通过 redis 的发布者/订阅者机制，哨兵之间可以相互感知，相互连接，然后组成哨兵集群，同时哨兵又通过 info 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。\n\n\n\n1、第一轮投票：判断主节点下线\n\n当哨兵集群中的某个哨兵判定主节点下线（主观下线）后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。\n\n当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。\n\n2、第二轮投票：选出哨兵leader\n\n某个哨兵判定主节点客观下线后，该哨兵就会发起投票，告诉其他哨兵，它想成为 leader，想成为 leader 的哨兵节点，要满足两个条件：\n\n * 第一，拿到半数以上的赞成票；\n * 第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。\n\n3、由哨兵 leader 进行主从故障转移\n\n选举出了哨兵 leader 后，就可以进行主从故障转移的过程了。该操作包含以下四个步骤：\n\n * 第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：\n   * 过滤掉已经离线的从节点；\n   * 过滤掉历史网络连接状态不好的从节点；\n   * 将剩下的从节点，进行三轮考察：优先级、复制进度、id 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。\n * 第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；\n * 第三步：将新主节点的 ip 地址和信息，通过「发布者/订阅者机制」通知给客户端；\n * 第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；\n\n> 思考：哨兵是怎么实现的？\n\n# 切片集群模式 cluster\n\n# 场景\n\n当 redis 缓存数据量大到一台服务器无法缓存时，就需要使用 redis 切片集群（redis cluster）方案。\n\n实现方式：\n\n它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 redis 服务的读写性能。\n\n# redis cluster 方案\n\n * redis cluster 方案采用哈希槽（hash slot），来处理数据和节点之间的映射关系。\n\n * 在 redis cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。\n   \n   具体执行过程分为两大步：\n   \n   1. 根据键值对的 key，按照 crc16 算法 计算一个 16 bit 的值。\n   2. 再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。\n\n# 哈希槽是如何被映射到具体的 redis 节点上的？\n\n有两种方式：\n\n * 平均分配： 在使用 cluster create 命令创建 redis 集群时，redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。\n * 手动分配： 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。\n\n> 注意：在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 redis 集群无法正常工作。\n\n# 数据、哈希槽，以及节点三者的映射分布关系\n\n\n\n通过命令手动分配哈希槽，比如节点 1 保存哈希槽 0 和 1，节点 2 保存哈希槽 2 和 3，如下所示：\n\nredis-cli -h 192.168.1.10 –p 6379 cluster addslots 0,1\nredis-cli -h 192.168.1.11 –p 6379 cluster addslots 2,3\n\n\n1\n2\n\n\n在集群运行的过程中，key1 和 key2 计算完 crc16 值后，对哈希槽总个数 4 进行取模，再根据各自的模数结果，就可以被映射到哈希槽 1（对应节点1） 和 哈希槽 2（对应节点2）。\n\n\n# 集群脑裂导致数据丢失怎么办？\n\n# 什么是脑裂？\n\n就好比一个人有两个大脑，不知道受谁控制。\n\n比如出现了两个主节点的情况。\n\n那么在 redis 中，集群脑裂产生数据丢失的现象是怎样的呢？\n\n在 redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程a），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。\n\n这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在「从节点」中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— 也就是脑裂出现了。\n\n然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（a），然后从节点（a）会向新主节点请求数据同步，因为第一次同步是全量同步的方式，此时的从节点（a）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 a 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题。\n\n总结一句话就是：由于网络问题，集群节点之间失去联系。主从数据不同步；哨兵重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。\n\n# 解决方案\n\n当主节点发现从节点下线或者通信超时的总数量小于阈值时，就禁止主节点进行写数据，直接把错误返回给客户端。\n\n在 redis 的配置文件中有两个参数我们可以设置：\n\n * min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。\n\n * min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。\n\n我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 n 和 t。\n\n这两个配置项组合后的要求是：主库连接的从库中至少有 n 个从库，和主库进行数据复制时的 ack （确认字符）消息延迟不能超过 t 秒，否则，主库就不会再接收客户端的写请求了。\n\n即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ack 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了。\n\n等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。\n\n总结来说就是：\n\n解决方案是通过某种限制条件来禁止主节点进行写数据。\n\n在 redis 的配置文件中设置两个参数，指明主节点至少要连接的从节点个数 n 以及主从数据复制和同步的延迟不能超过 t 秒，一旦达不到这个组合要求就限制主节点接收客户端的写请求，不再写入新数据，等哨兵主从切换完成后，新写的数据就会被直接写到新主节点上，从而避免避免了闹裂现象的发生，也就不会发生数据丢失了。\n\n\n# redis 过期删除与内存淘汰\n\n\n# redis 给缓存数据设置过期时间有啥用？\n\n主要有三个作用：\n\n 1. 释放空间：当缓存中的数据过期后，redis 会自动将其删除，从而释放空间。这样可以避免缓存中存储过多的过期数据，占用过多的内存空间，导致缓存性能下降。\n 2. 提高缓存命中率：设置合理的缓存过期时间可以使得缓存中存储的数据都是最新的，有效的数据。这样可以提高缓存命中率，减少请求直接访问后端数据库的次数，从而提高系统的性能。\n 3. 避免缓存污染问题：过期时间可以避免缓存污染问题，即缓存中存储了过期、损坏或者恶意的数据。当缓存中的数据过期后，redis 会自动将其删除，从而避免应用程序获取到错误的数据。\n\n> 如果过期时间设置得太短，可能会导致缓存命中率降低，请求直接访问后端数据库的次数增多；\n> \n> 如果过期时间设置得太长，可能会导致缓存中存储的数据不是最新的，从而影响系统的性能。\n\n\n# redis 使用过的过期删除策略是什么？\n\nredis 使用的过期删除策略是「惰性删除+定期删除」这两种策略配和使用。负责删除已过期的键值对。\n\n每当我们对一个 key 设置了过期时间时，redis 会把该 key 带上过期时间存储到一个过期字典中。\n\n当我们查询一个 key 时，redis 首先检查该 key 是否存在于过期字典中：\n\n * 如果不在，则正常读取键值；\n * 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。\n\n\n# 什么是惰性删除策略？\n\n惰性删除策略的做法是：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key，返回 null 给客户端。\n\n惰性删除策略的优点：\n\n * 因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 cpu 时间最友好。\n\n惰性删除策略的缺点：\n\n * 如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。\n\n总结来说就是：\n\n占用的系统资源少，对 cpu 时间友好；但会浪费一定的内存空间，对内存不友好。以空间换时间。\n\n\n# 什么是定期删除策略？\n\n定期删除策略的做法是：每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。\n\n具体流程是：\n\n 1. 从过期字典中随机抽取 20 个 key；\n\n 2. 检查这 20 个 key 是否过期，并删除已过期的 key；\n\n 3. 如果本轮检查的已过期 key 的数量，超过 5 个（抽取的个数*25%），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；\n    \n    如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。\n\n定期抽取 => 检查并删除 => 判断过期 key 是否超过 25%\n\n定期删除策略的优点：\n\n * 通过限制删除操作执行的时长和频率，来减少删除操作对 cpu 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。\n\n定期删除策略的缺点：\n\n * 难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 cpu 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。\n\n定期删除对内存更加友好，惰性删除对 cpu 更加友好。两者各有千秋，所以 redis 采用的是 定期删除+惰性/懒汉式删除 。\n\n\n# redis 持久化时，对过期键会如何处理？\n\nredis 持久化文件有两种格式：rdb 和 aof。\n\n下面来说下过期键在这两种格式中的呈现状态。\n\n先讲下 rdb，rdb 文件分为两个阶段，rdb 文件生成阶段和加载阶段。\n\n * **rdb 文件生成阶段：**从内存状态持久化成 rdb（文件）的时候，会对 key 进行过期检查，过期的键「不会」被保存到新的 rdb 文件中，因此 redis 中的过期键不会对生成新 rdb 文件产生任何影响。\n * **rdb 加载阶段：**rdb 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：\n   * 如果 redis 是「主服务器」运行模式的话，在载入 rdb 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中。所以过期键不会对载入 rdb 文件的主服务器造成影响；\n   * 如果 redis 是「从服务器」运行模式的话，在载入 rdb 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 rdb 文件的从服务器也不会造成影响。\n\n再讲下 aof 的情况，aof 文件也分为两个阶段，aof 文件写入阶段和 aof 重写阶段。\n\n * aof 文件写入阶段：当 redis 以 aof 模式持久化时，如果数据库某个过期键还没被删除，那么 aof 文件会保留此过期键，当此过期键被删除后，redis 会向 aof 文件追加一条 del 命令来显式地删除该键值。\n * aof 重写阶段：执行 aof 重写时，会对 redis 中的键值对进行检查，已过期的键不会被保存到重写后的 aof 文件中，因此不会对 aof 重写造成任何影响。\n\n\n# redis 主从模式中，对过期键会如何处理？\n\n当 redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的（依赖于主库）。也就是说即使从库中的 key 过期了，如果有客户端访问从库，依然可以得到 key 对应的值，像未过期的键值对一样返回。\n\n从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 aof 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。\n\n\n# redis 内存满了，会发生什么？\n\n在 redis 的运行内存达到了某个阀值，就会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存，此值在 redis 的配置文件中可以找到，配置项为 maxmemory。\n\n\n# redis 内存淘汰策略有哪些？\n\nredis 内存淘汰策略一共有八种，而这八种策略大体可分为「不进行数据淘汰」和「进行数据淘汰」两类策略。\n\n1 - 4 - 7\n\n# 1、不进行数据淘汰的策略\n\nnoeviction（redis3.0之后，默认的内存淘汰策略）：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。\n\n# 2、进行数据淘汰的策略\n\n针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。\n\n# 在设置了过期时间的数据中进行淘汰：\n\n * volatile-random：随机淘汰设置了过期时间的任意键值；\n * volatile-ttl：优先淘汰更早过期的键值。\n * volatile-lru（redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；\n * volatile-lfu（redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；\n\n# 在所有数据范围内进行淘汰：\n\n * allkeys-random：随机淘汰任意键值;\n * allkeys-lru：淘汰整个键值中最久未使用的键值；\n * allkeys-lfu（redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。\n\n\n# lru 算法和 lfu 算法有什么区别？\n\n# 什么是 lru 算法？\n\nlru 全称是 least recently used(lru) 翻译为最近最少使用，会选择淘汰最近最少使用的数据。（最久未使用 -- 时间）\n\n传统 lru 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。\n\n但是 redis 并没有使用这样的方式实现 lru 算法，因为传统的 lru 算法存在两个问题：\n\n * 需要用链表管理所有的缓存数据，这会带来额外的空间开销；\n * 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 redis 缓存性能。\n\n# redis 是如何实现 lru 算法的？\n\nredis 实现的是一种近似 lru 算法，目的是为了更好的节约内存，它的实现方式是在 redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。\n\n当 redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。\n\nredis 实现的 lru 算法的优点：\n\n * 不用为所有的数据维护一个大链表，节省了空间占用；\n * 不用在每次数据访问时都移动链表项，提升了缓存的性能；\n\n但是 lru 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 redis 缓存中很长一段时间，造成缓存污染。\n\n因此，在 redis 4.0 之后引入了 lfu 算法来解决这个问题。\n\n# 什么是缓存污染问题？\n\n缓存污染问题是指：缓存中存储了错误的数据，导致应用程序获取到的数据不正确。**通常是由于缓存中存储了过期的、损坏的或者恶意的数据造成的。**当应用程序从缓存中获取到错误的数据时，可能会导致程序异常或者返回不正确的结果。为了避免缓存污染问题，需要定期清理过期数据、设置合理的缓存过期时间、使用合法的缓存数据源等措施。\n\n# 什么是 lfu 算法？\n\nlfu 全称是 least frequently used 翻译为最不经常使用，lfu 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。（最少使用 -- 次数）\n\n所以， lfu 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 lru 算法也更合理一些。\n\n# redis 是如何实现 lfu 算法的？\n\nlfu 算法相比于 lru 算法的实现，多记录了「数据的访问频次」的信息。\n\n> 高 16bit -- 记录 key 的访问时间戳；低 8bit -- 记录 key 的访问频次\n\nredis 对象的结构如下：\n\ntypedef struct redisobject {\n    ...\n      \n    // 24 bits，用于记录对象的访问信息\n    unsigned lru:24;  \n    ...\n} robj;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nredis 对象头中的 lru 字段，在 lru 算法下和 lfu 算法下使用方式并不相同。\n\n在 lru 算法中，redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 lru 模式下，redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。\n\n在 lfu 算法中，redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(last decrement time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(logistic counter)，用来记录 key 的访问频次。\n\n如下图所示：\n\n\n\n\n# redis 缓存设计（生产问题）\n\n\n# 缓存雪崩\n\n# 什么是缓存雪崩？\n\n缓存雪崩就是：当大量缓存数据在同一时间过期（失效）或者 redis 故障宕机时，同时又有大量的用户请求，都无法在 redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。\n\n# 如何解决缓存雪崩？\n\n对于缓存雪崩问题，我们可以采用两种方案解决。\n\n 1. 将缓存失效时间随机打散：我们可以在原有的失效时间基础上增加一个随机值（比如 1 到 10 分钟）这样每个缓存的过期时间都不重复了，也就降低了缓存集体失效的概率。\n 2. 设置缓存不过期：我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。\n\n\n# 缓存击穿\n\n# 什么是缓存击穿？\n\n我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。\n\n如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。\n\n> 可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。（缓存数据 包含 热点数据）\n\n# 如何解决缓存击穿？\n\n应对缓存击穿可以采取前面说到两种方案：\n\n 1. 互斥锁方案：（redis 中使用 setnx 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。\n 2. 不让热点数据过期： 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间。\n\n\n# 缓存穿透\n\n# 什么是缓存穿透？\n\n简单来说，缓存穿透就是：大量请求的 key 是不合理的，既不存在于缓存中，也不存在于数据库中。\n\n导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，甚至可能直接就被这么多请求弄宕机了。\n\n# 产生的原因？\n\n * 业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；\n * 黑客恶意攻击，故意大量访问某些读取不存在数据的业务；\n\n# 如何应对缓存穿透？\n\n最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。\n\n应对缓存穿透的方案，常见的方案有三种。\n\n * 非法请求的限制（参数校验）：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 api 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误给客户端，避免进一步访问缓存和数据库。\n * 设置空值或者默认值：当我们线上业务发现缓存穿透的现象时（缓存和数据库都不存在），可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。\n * 使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，redis 自身也是支持布隆过滤器的。\n\n\n# 总结\n\n缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。\n\n其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。\n\n而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。\n\n\n\n\n# 如何设计一个缓存策略，可以动态缓存热点数据呢？\n\n# 为什么需要设计？\n\n由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而只是将其中一部分热点数据缓存起来，所以我们要设计一个热点数据动态缓存的策略。\n\n# 设计思路\n\n热点数据动态缓存的策略总体思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。\n\n以电商平台场景中的例子，现在要求只缓存用户经常访问的 top 1000 的商品。具体细节如下：\n\n * 先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；\n * 同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；\n * 这样当请求每次到达的时候，会先从队列中获取商品 id，如果命中，就根据 id 再从另一个缓存数据结构中读取实际的商品信息，并返回。\n\n在 redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。\n\n\n# 说说常见的缓存更新策略？\n\n常见的缓存更新策略共有3种：\n\n 1. cache aside（旁路缓存）策略；\n 2. read/write through（读穿 / 写穿）策略；\n 3. write back（写回）策略；\n\n实际开发中，redis 和 mysql 的更新策略用的是 cache aside，另外两种策略应用不了。\n\n# cache aside（旁路缓存）策略\n\ncache aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。\n\n写策略的步骤：\n\n * 先更新数据库中的数据，再删除缓存中的数据。\n\n读策略的步骤：\n\n * 如果读取的数据命中了缓存，则直接返回数据；\n * 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。\n\n> 注意：写策略的步骤的顺序不能倒过来，即不能先删除缓存再更新数据库，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。\n\n# 为什么是删除缓存，而不是更新缓存呢？\n\n因为删除一个数据，相比更新一个数据更加轻量级，出问题的概率更小。在实际业务中，缓存的数据可能不是直接来自某一张数据库表，也许来自多张底层数据表的聚合。\n\n * 比如商品详情信息，在底层可能会关联商品表、价格表、库存表等，如果更新了一个价格字段，那么就要更新整个数据库，还要关联的去查询和汇总各个周边业务系统的数据，这个操作会非常耗时。\n * 从另外一个角度，不是所有的缓存数据都是频繁访问的，更新后的缓存可能会长时间不被访问（浪费空间），所以说，从计算资源和整体性能的考虑，更新的时候删除缓存，等到下次查询命中再填充缓存，是一个更好的方案。\n\n> 系统设计中有一个思想叫 lazy loading，适用于那些加载代价大的操作，删除缓存而不是更新缓存，就是懒加载思想的一个应用。\n\n# 为什么「先更新数据库再删除缓存」不会有数据不一致的问题？\n\n其实先更新数据库，再删除缓存也会出现数据不一致性的问题，但是在实际中，这个问题出现的概率并不高。\n\n> 例如：请求 a 更新完数据库，但还未删除缓存，此时请求 b 命中了缓存并返回，就导致了数据不一致。\n> \n> 出现的概率低是因为 缓存的写入非常快，中间的时间差非常短，通常只有几毫秒或者几十毫秒。\n\n「先更新数据库再删除缓存」不会造成数据不一致的问题，是因为在更新数据库的同时，缓存并没有被删除，而是在接下来的读取操作中被重新写入。具体来说，当应用程序更新数据库时，会先更新数据库中的数据，然后再删除缓存中对应的数据。接着，当下一次需要访问该数据时，应用程序会重新从数据库中读取该数据，并将其写入缓存中。这样，缓存中存储的数据就是最新的，与数据库中的数据一致。\n\n# 适合场景？\n\ncache aside 策略适合读多写少的场景，不适合写多的场景，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。\n\n如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：\n\n * 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；\n * 另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。\n\n# read/write through（读穿 / 写穿）策略\n\nread/write through（读穿 / 写穿）策略原则是：应用程序只和缓存交互，不再和数据库交互，然后由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。\n\n1、read through 读穿策略\n\n * 先查询缓存中数据是否存在，如果存在则直接返回，\n * 如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。\n\n2、write through 写穿策略\n\n当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：\n\n * 如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。\n * 如果缓存中数据不存在，直接更新数据库，然后返回；\n\n\n\n# 特点以及适合场景是什么？\n\nread through/write through 策略的特点是：\n\n由缓存节点而非应用程序来和数据库打交道，\n\n在我们开发过程中相比 cache aside 策略要少见一些，原因是我们经常使用的分布式缓存组件，无论是 memcached 还是 redis 都不提供写入数据库和自动加载数据库中的数据的功能。\n\n而我们在使用本地缓存的时候可以考虑使用这种策略。\n\n# write back（写回）策略\n\nwrite back（写回）策略：在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。\n\nwrite back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 redis 并没有异步更新数据库的功能。\n\n# 适合什么场景？\n\nwrite back 是计算机体系结构中的设计，比如 cpu 的缓存、操作系统中文件系统的缓存都采用了 write back（写回）策略。\n\nwrite back 策略特别适合写多的场景，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。\n\n写回策略会带来什么问题？\n\n带来的问题是，数据不是强一致性的，而且会有数据丢失的风险，因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 page cache 还没有来得及刷盘造成的。\n\n\n# 如何保证缓存和数据库数据的一致性？\n\n一共两个操作：\n\n 1. 更新数据库\n 2. 删除缓存\n\n使用 cache aside 旁路缓存策略，并增加**「消息队列来重试缓存的删除」或「订阅 mysql binlog 再操作缓存」**来保证两个操作都能执行成功。\n\n1、只给缓存加上过期时间进行兜底会出现什么情况？\n\n可能会出现删除缓存操作失败的问题，从而出现缓存中的数据是旧值，数据库的是最新值，需要过一段时间才会有更新生效的现象（因为过期时间到了，缓存数据重新写入）。\n\n2、如何保证两个操作都能执行成功？\n\n有两种方法：\n\n * 重试机制。\n * 订阅 mysql binlog，再操作缓存。\n\n这两种方法有一个共同的特点，都是采用异步操作缓存。\n\n1. 重试机制\n\n我们可以引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。\n\n * 如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。\n * 如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。\n\n2. 订阅 mysql binlog，再操作缓存\n\n「先更新数据库，再删缓存」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。\n\n于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 canal 中间件就是基于这个实现的。\n\ncanal 的工作原理：\n\n\n\n\n# 哪些情况可能会导致 redis 阻塞？\n\n 1. 执行时间复杂度为 o(n) 的命令时，比如 keys *；\n 2. 使用 save 命令生成 rdb 快照文件时；\n 3. aof 日志记录，刷盘，重写时；\n 4. 查找或删除大 key时；\n 5. 清空数据库时；\n 6. 集群扩容时；\n 7. cpu 竞争时；\n 8. 网络环境差的时候\n\n\n# redis 性能优化\n\n\n# 大量 key 集中过期问题\n\n有两种常见的方法：\n\n 1. 给 key 设置随机过期时间。\n 2. 开启 lazy-free（惰性删除/延迟释放），让 redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\n\n\n# redis 大 key？\n\n# 什么是 redis 大 key？\n\n大 key 并不是指 key 的值很大，而是指 key 对应的 value 很大。\n\n一般而言，下面这两种情况被称为大 key：\n\n * string 类型的值大于 10 kb；\n * hash、list、set、zset 类型的元素的个数超过 5000个；\n\n# 大 key 会造成什么问题？\n\nbigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。\n\n大 key 会带来以下四种影响：\n\n 1. 客户端超时阻塞。由于 redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 redis，从客户端这一视角看，就是很久很久都没有响应。\n 2. 引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 mb，每秒访问量为 1000，那么每秒会产生 1000mb 的流量，这对于普通千兆网卡的服务器来说是灾难性的。\n 3. 阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。\n 4. 内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 redis 节点占用内存多，qps（每秒查询率，系统在单位时间内能够处理的请求数量） 也会比较大。\n\n# 如何找到大 key ？\n\n有三种方法：\n\n 1. 通过 redis-cli --bigkeys 命令查找大 key；\n 2. 使用 scan 命令查找大 key；\n 3. 使用 rdbtools 第三方开源工具查找大 key。\n\n# 如何删除大 key？\n\n有两种方法：\n\n 1. 分批次删除法，根据不同的数据类型采用不同的命令进行输出；\n 2. 异步删除法（redis 4.0版本以上），用 unlink 命令代替 del 来删除。\n\n# 如何处理 bigkey？\n\n 1. 分割 bigkey：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。\n 2. 手动清理（删除）：redis 4.0+ 可以使用 unlink 命令来异步删除一个或多个指定的 key。redis 4.0 以下可以考虑使用 scan 命令结合 del 命令来分批次删除。\n 3. 采用合适的数据结构：比如使用 hyperloglog 统计页面 uv。\n 4. 开启 lazy-free（惰性删除/延迟释放） ：lazy-free 特性是 redis 4.0 开始引入的，指的是让 redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\n\n\n# redis hotkey（热 key）\n\n# 什么是 hotkey？\n\n简单来说，如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey。\n\nhotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。\n\n# hotkey 有什么危害？\n\n处理 hotkey 会占用大量的 cpu 和带宽，可能会影响 redis 实例对其他请求的正常处理。\n\n此外，如果突然访问 hotkey 的请求超出了 redis 的处理能力，redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。\n\n因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。\n\n# 如何找到 hotkey？\n\n1、使用 redis 自带的 --hotkeys 参数来查找。\n\n2、使用 monitor 命令。\n\nmonitor 命令是 redis 提供的一种实时查看 redis 的所有操作的方式，可以用于临时监控 redis 实例的操作情况，包括读写、删除等操作。\n\n3、借助开源项目。\n\n比如京东零售的 hotkeyopen in new window 这个项目，不光支持 hotkey 的发现，还支持 hotkey 的处理。\n\n4、根据业务情况提前预估。\n\n可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。\n\n不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。\n\n5、业务代码中记录分析。\n\n在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。\n\n6、借助公有云的 redis 分析服务。\n\n如果你用的是公有云的 redis 服务的话，可以看看其是否提供了 key 分析功能（一般都有提供）。\n\n# 如何解决 hotkey？\n\nhotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：\n\n * 读写分离：主节点处理写请求，从节点处理读请求。\n * 使用 redis cluster：将热点数据分散存储在多个 redis 节点上。\n * 二级缓存：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 jvm 本地内存中（可以用 caffeine）。\n\n除了这些方法之外，如果你使用的公有云的 redis 服务话，还可以留意其提供的开箱即用的解决方案。\n\n\n# 慢查询命令\n\n# 什么是慢查询命令？\n\n慢查询命令是指：执行时间超过 redis 配置的阈值的命令。\n\n这个阈值可以通过 redis 配置文件中的 slowlog-log-slower-than 参数进行设置，默认值是 10000，即 10 毫秒。\n\n当 redis 执行一个命令的时间超过了这个阈值，这个命令就会被记录在 redis 的慢查询日志中。慢查询日志会记录命令的执行时间、执行命令的客户端、命令的参数等信息。通过查看慢查询日志，可以找到执行时间较长的命令，进而优化 redis 的性能。\n\n# 为什么会有慢查询命令？\n\n这是因为 redis 是单线程的，如果某个命令执行时间过长，就会阻塞其他命令的执行。为了避免这种情况的发生，redis 会记录所有执行时间超过一定阈值的命令，并将其作为慢查询命令进行记录和统计，以便开发人员进行优化和调整。\n\n# 如何找到慢查询命令？\n\n有三种常用的方法：\n\n 1. 使用 slowlog 命令：slowlog 命令可以查看 redis 慢查询日志，包括执行时间、客户端地址、命令名称和参数等信息。可以使用 slowlog len 命令查看慢查询日志的长度，使用slowlog get 命令获取指定的慢查询日志。\n 2. 使用 redis-slowlog 工具：redis-slowlog 是一个命令行工具，可以方便地查看 redis 慢查询日志。通过运行 redis-slowlog 命令，可以列出慢查询命令的执行时间、客户端地址、命令名称和参数等信息。\n 3. 使用 redis 监控工具：redis 监控工具可以监控 redis 的各种指标，包括慢查询命令的执行时间。通过监控工具，可以实时地查看 redis 的性能指标，并及时发现慢查询命令。\n\n\n# redis 内存碎片\n\n# 什么是内存碎片?\n\n可以将内存碎片简单地理解为那些不可用的后续没办法再被分配存储其他数据的空闲内存。\n\n比如：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。\n\nredis 内存碎片虽然不会影响 redis 性能，但是会增加内存消耗。\n\n# 为什么会有 redis 内存碎片?\n\n有 2 个比较常见的原因：\n\n1、redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。\n\n因为 redis 对内存的分配和回收采用的是 jemalloc 或 libc 等第三方库，这些库的内存分配策略可能会导致内存碎片。\n\n2、频繁修改 redis 中的数据也会产生内存碎片。\n\n比如：当 redis 中的某个数据删除时，redis 通常不会轻易释放内存给操作系统。\n\n# 如何查看 redis 内存碎片的信息？\n\n使用 info memory 命令即可查看 redis 内存相关的信息。\n\n# 如何清理 redis 内存碎片？\n\nredis4.0-rc3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。\n\n有两种方法：\n\n1、直接通过 config set 命令将 activedefrag 配置项设置为 yes 即可，但可能会对 redis 的性能产生影响。\n\n> 通过 redis 自动内存碎片清理机制可能会对 redis 的性能产生影响。\n> \n> 可以设置相关参数来控制具体什么时候清理以及减少对 redis 性能的影响。\n\n2、重启 redis 可以做到内存碎片重新整理，但是需要重启redis服务，会导致一定的停机时间。\n\n\n# redis 实战\n\n\n# 延迟队列\n\n# 什么是延迟队列？\n\n延迟队列是指：把当前要做的事情，往后推迟一段时间再做。\n\n延迟队列的常见使用场景有以下几种：\n\n * 在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；\n * 打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；\n * 点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单。\n\n# redis 如何实现延迟队列？\n\n可以使用有序集合（zset）的方式来实现延迟消息队列的，zset 有一个 score 属性可以用来存储延迟执行的时间。\n\n * 使用 zadd score1 value1 命令就可以一直往内存中生产消息。\n * 再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。\n\n\n\n\n# redis 管道有什么用？\n\n管道技术（pipeline）：是客户端提供的一种批处理技术，用于一次处理多个 redis 命令，从而提高整个交互的性能。\n\n使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。\n\n\n# redis 事务\n\n# redis 事务支持回滚吗？\n\n不支持。\n\nredis 中并没有提供回滚机制，虽然 redis 提供了 discard 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。\n\n事务执行过程中，如果命令入队时没报错，而事务提交后，实际执行时报错了，正确的命令依然可以正常执行，所以这可以看出 redis 并不一定保证原子性\n\n> mysql 在执行事务时，会提供回滚机制，当事务执行发生错误时，事务中的所有操作都会撤销，已经修改的数据也会被恢复到事务执行前的状态。\n\n# 为什么 redis 不支持事务回滚？\n\nredis 不支持事务回滚的原因有两个：\n\n 1. 官方认为 redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 redis 开发事务回滚功能；\n 2. 不支持事务回滚是因为这种复杂的功能和 redis 追求的简单高效的设计主旨不符合。\n\n这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚\n\n\n# redis 分布式锁\n\n# 如何用 redis 实现分布式锁的？\n\n1、什么是分布式锁？\n\n分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。\n\n\n\n2、加锁\n\nredis 的 set 命令有个 nx 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：\n\n * 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；\n * 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。\n\n基于 redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。\n\n * 加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 set 命令带上 nx 选项来实现加锁；\n * 锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 set 命令执行时加上 ex/px 选项，设置其过期时间；\n * 锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 set 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；\n\n满足这三个条件的分布式命令如下：\n\nset lock_key unique_value nx px 10000 \n\n\n1\n\n * lock_key 就是 key 键；\n * unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；\n * nx 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；\n * px 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。\n\n简单来说，三个条件就是：需以原子操作完成、要有过期时间和一个用于标识客户端的标识。\n\n3、解锁\n\n用 lua 脚本来进行解锁。\n\n解锁的过程就是：将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。\n\n可以看到，解锁是有两个操作，这时就需要 lua 脚本来保证解锁的原子性，因为 redis 在执行 lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。\n\n# 基于 redis 实现分布式锁有什么优缺点？\n\n1、优点\n\n基于 redis 实现分布式锁的优点：\n\n 1. 性能高效（这是选择缓存实现分布式锁最核心的出发点）。\n 2. 实现方便。很多研发工程师选择使用 redis 来实现分布式锁，很大成分上是因为 redis 提供了 setnx 方法，实现分布式锁很方便。\n 3. 避免单点故障（因为 redis 是跨集群部署的，自然就避免了单点故障）。\n\n2、缺点\n\n基于 redis 实现分布式锁的缺点：\n\n * 超时时间不好设置。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。比如在有些场景中，一个线程 a 获取到了锁之后，由于业务代码执行时间可能比较长，导致超过了锁的超时时间，自动失效，注意 a 线程没执行完，后续线程 b 又意外的持有了锁，意味着可以操作共享资源，那么两个线程之间的共享资源就没办法进行保护了。\n   * 那么如何合理设置超时时间呢？ 我们可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。\n * redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性。如果在 redis 主节点获取到锁后，在没有同步到其他节点时，redis 主节点宕机了，此时新的 redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\n\n# redis 如何解决集群情况下分布式锁的可靠性？\n\n为了保证集群环境下分布式锁的可靠性，redis 官方设计了一个分布式锁算法 redlock（红锁）。\n\n它是基于多个 redis 节点的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。\n\nredlock 算法的基本思路，是让客户端和多个独立的 redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\n\n加锁失败会怎样？\n\n加锁失败后，客户端会向所有 redis 节点发起释放锁的操作，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 lua 脚本就可以了。\n\n\n# 参考\n\n图解redis| 小林coding",charsets:{cjk:!0}},{title:"JWT",frontmatter:{title:"JWT",date:"2023-06-07T22:23:52.000Z",permalink:"/pages/793d0a/"},regularPath:"/05.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/03.%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/01.JWT%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%BB%93.html",relativePath:"05.系统设计/03.权限校验/01.JWT基础小结.md",key:"v-36e58cd3",path:"/pages/793d0a/",headers:[{level:2,title:"什么是 JWT？",slug:"什么是-jwt",normalizedTitle:"什么是 jwt？",charIndex:15},{level:2,title:"JWT 有什么用？",slug:"jwt-有什么用",normalizedTitle:"jwt 有什么用？",charIndex:376},{level:2,title:"JWT 的组成",slug:"jwt-的组成",normalizedTitle:"jwt 的组成",charIndex:470},{level:3,title:"Header",slug:"header",normalizedTitle:"header",charIndex:783},{level:3,title:"Payload 声明",slug:"payload-声明",normalizedTitle:"payload 声明",charIndex:1015},{level:3,title:"Signature 签名",slug:"signature-签名",normalizedTitle:"signature 签名",charIndex:1901},{level:2,title:"相关依赖",slug:"相关依赖",normalizedTitle:"相关依赖",charIndex:2396},{level:2,title:"如何基于 JWT 进行身份验证？",slug:"如何基于-jwt-进行身份验证",normalizedTitle:"如何基于 jwt 进行身份验证？",charIndex:3158},{level:2,title:"为什么用 JWT 代替 Session",slug:"为什么用-jwt-代替-session",normalizedTitle:"为什么用 jwt 代替 session",charIndex:3491},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:4136}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.94,time:116399.99999999999,words:388},headersStr:"什么是 JWT？ JWT 有什么用？ JWT 的组成 Header Payload 声明 Signature 签名 相关依赖 如何基于 JWT 进行身份验证？ 为什么用 JWT 代替 Session 参考文献",content:'# JWT 基础小结\n\n\n# 什么是 JWT？\n\nJWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。\n\n从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。\n\n通过数字签名的方式，以 JSON 对象为载体，在不同的服务终端之间安全的传输信息。\n\n> JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。(JWT 存储在【客户端】)\n> \n> 并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。\n\n\n# JWT 有什么用？\n\nJWT 最常见的场景就是授权认证，一旦用户登录，后续每个请求都将包含JWT，系统在每次处理用户请求的之前，都要先进行 JWT 安全校验，通过之后再进行处理。\n\n\n# JWT 的组成\n\nJWT 由 3 部分组成，用 . 拼接\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n.eyJ1c2VybmFtZSI6IlRvbSIsInJvbGUiOiJhZG1pbiIsInN1YiI6ImFkbWluLXRlc3QiLCJleHAiOjE2MjMyMjM2NzUsImp0aSI6ImQ2MTJjZjcxLWI5ZmUtNGMwNy04MzQwLTViOWViZmMyNjExNyJ9\n.FOS9Y7rYNdc2AOidnSPrgg2XTYePU0yGZ598h2gtabE\n\n\n1\n2\n3\n\n\n可以在 jwt.io 这个网站上对 JWT 进行解码，解码之后得到的就是 Header、Payload、Signature 这三部分。\n\n这三部分分别是：\n\n\n# Header\n\nHeader 通常由两部分组成：\n\n * typ（Type）：令牌类型，也就是 JWT。\n * alg（Algorithm）：签名算法，比如 HS256。\n\n> JSON 形式的 Header 被转换成 Base64 编码，成为 JWT 的第一部分。\n\n{\n  \'typ\': \'JWT\',\n  \'alg\': \'HS256\'\n}\n\n\n1\n2\n3\n4\n\n\n\n# Payload 声明\n\nPayload 也是 JSON 格式数据，其中包含了 Claims(声明，包含 JWT 的相关信息)。\n\n> Payload 部分默认是不加密的，一定不要将隐私信息存放在 Payload 当中！！！\n> \n> JSON 形式的 Payload 被转换成 Base64 编码，成为 JWT 的第二部分\n\nClaims 分为三种类型：\n\n * Registered Claims（注册声明）：预定义的一些声明，建议使用，但不是强制性的。\n * Public Claims（公有声明）：JWT 签发方可以自定义的声明，但是为了避免冲突，应该在 IANA JSON Web Token Registry 中定义它们。\n * Private Claims（私有声明）：JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景使用。\n\n下面是一些常见的注册声明：\n\n * iss（issuer）：JWT 签发方。\n * iat（issued at time）：JWT 签发时间。\n * sub（subject）：JWT 主题。\n * aud（audience）：JWT 接收方。\n * exp（expiration time）：JWT 的过期时间。\n * nbf（not before time）：JWT 生效时间，早于该定义的时间的 JWT 不能被接受处理。\n * jti（JWT ID）：JWT 唯一标识。\n\n{\n  "uid": "ff1212f5-d8d1-4496-bf41-d2dda73de19a",\n  "sub": "1234567890",\n  "name": "John Doe",\n  "exp": 15323232,\n  "iat": 1516239022,\n  "scope": ["admin", "user"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n{\n    "sub": \'1234567890\',\n    "name": \'john\',\n    "admin": true\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# Signature 签名\n\nSignature 部分是对前两部分的签名，作用是防止 JWT（主要是 payload）被篡改。\n\n这个签名的生成需要用到：\n\n * Header + Payload。\n * 存放在服务端的密钥(一定不要泄露出去)。 -- secret\n * 签名算法。 -- HMACSHA256\n\n// 第一种方式\nvar encodedString = base64UrlEncode(header) + \'.\' + base64UrlEncode(payload);\nvar signature = HMACSHA256(encodedString, \'secret\');\n\n// 第二种方式\nHMACSHA256(\n  base64UrlEncode(header) + "." +\n  base64UrlEncode(payload),\n  secret)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，这个字符串就是 JWT 。\n\n\n# 相关依赖\n\npom.xml 文件\n\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.9.1</version>\n</dependency>\n\n<dependency>\n    <groupId>javax.xml.bind</groupId>\n    <artifactId>jaxb-api</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>com.sun.xml.bind</groupId>\n    <artifactId>jaxb-impl</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>com.sun.xml.bind</groupId>\n    <artifactId>jaxb-core</artifactId>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupId>javax.activation</groupId>\n    <artifactId>activation</artifactId>\n    <version>1.1.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 如何基于 JWT 进行身份验证？\n\n在基于 JWT 进行身份验证的的应用程序中，\n\n服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。\n\n客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。\n\n从用户的角度来分析：\n\n 1. 用户向服务器发送用户名、密码以及验证码用于登陆系统。\n 2. 如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。\n 3. 用户以后每次向后端发请求都在 Header 中带上这个 JWT 。\n 4. 服务端检查 JWT 并从中获取用户相关信息。\n\n\n# 为什么用 JWT 代替 Session\n\nJWT (JSON Web Token) 被用于代替传统的基于 Session 的身份认证和授权机制的主要原因有以下几点：\n\n 1. 无需服务器存储： 在传统的 Session 机制中，服务器需要维护每个用户的会话状态，通常是存储在内存或数据库中。而使用 JWT，所有的用户信息和权限信息都被编码到了 token 中，服务器无需存储任何状态信息，这样可以减轻服务器的负担。\n 2. 跨域支持： JWT 可以轻松地在多个域之间进行传递和使用，这使得跨域通信和微服务架构变得更加简单。\n 3. 扩展性： JWT 是一种开放标准，可以支持自定义的声明和数据结构。这使得 JWT 非常灵活，可以根据实际需求添加额外的信息。\n 4. 无状态性： 传统的基于 Session 的认证机制需要服务器保存会话状态，而 JWT 是无状态的。每个请求都包含了认证信息，服务器不需要再去查询数据库或存储中心来验证用户的身份。\n 5. 安全性： JWT 内置了签名机制，可以验证 token 的真实性和完整性。这样即使 token 被篡改，服务器也能识别出来并拒绝该 token。\n 6. 适用于分布式系统： JWT 适用于分布式系统和微服务架构，可以跨多个服务进行认证和授权。\n\n总的来说，JWT 是一种轻量级、可扩展、无状态和安全的认证机制，相较于传统的基于 Session 的认证机制，JWT 具有更多优势，特别适合于现代的分布式、跨域和无状态的应用场景。\n\n\n# 参考文献\n\n * JWT 基础概念详解\n * 用户认证：基于jwt和session的区别和优缺点',normalizedContent:'# jwt 基础小结\n\n\n# 什么是 jwt？\n\njwt （json web token） 是目前最流行的跨域认证解决方案，是一种基于 token 的认证授权机制。\n\n从 jwt 的全称可以看出，jwt 本身也是 token，一种规范化之后的 json 结构的 token。\n\n通过数字签名的方式，以 json 对象为载体，在不同的服务终端之间安全的传输信息。\n\n> jwt 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。(jwt 存储在【客户端】)\n> \n> 并且， 使用 jwt 认证可以有效避免 csrf 攻击，因为 jwt 一般是存在在 localstorage 中，使用 jwt 进行身份验证的过程中是不会涉及到 cookie 的。\n\n\n# jwt 有什么用？\n\njwt 最常见的场景就是授权认证，一旦用户登录，后续每个请求都将包含jwt，系统在每次处理用户请求的之前，都要先进行 jwt 安全校验，通过之后再进行处理。\n\n\n# jwt 的组成\n\njwt 由 3 部分组成，用 . 拼接\n\neyjhbgcioijiuzi1niisinr5cci6ikpxvcj9\n.eyj1c2vybmftzsi6ilrvbsisinjvbguioijhzg1pbiisinn1yii6imfkbwlulxrlc3qilcjlehaioje2mjmymjm2nzusimp0asi6imq2mtjjzjcxlwi5zmutngmwny04mzqwltviowvizmmynjexnyj9\n.fos9y7ryndc2aoidnsprgg2xtyepu0ygz598h2gtabe\n\n\n1\n2\n3\n\n\n可以在 jwt.io 这个网站上对 jwt 进行解码，解码之后得到的就是 header、payload、signature 这三部分。\n\n这三部分分别是：\n\n\n# header\n\nheader 通常由两部分组成：\n\n * typ（type）：令牌类型，也就是 jwt。\n * alg（algorithm）：签名算法，比如 hs256。\n\n> json 形式的 header 被转换成 base64 编码，成为 jwt 的第一部分。\n\n{\n  \'typ\': \'jwt\',\n  \'alg\': \'hs256\'\n}\n\n\n1\n2\n3\n4\n\n\n\n# payload 声明\n\npayload 也是 json 格式数据，其中包含了 claims(声明，包含 jwt 的相关信息)。\n\n> payload 部分默认是不加密的，一定不要将隐私信息存放在 payload 当中！！！\n> \n> json 形式的 payload 被转换成 base64 编码，成为 jwt 的第二部分\n\nclaims 分为三种类型：\n\n * registered claims（注册声明）：预定义的一些声明，建议使用，但不是强制性的。\n * public claims（公有声明）：jwt 签发方可以自定义的声明，但是为了避免冲突，应该在 iana json web token registry 中定义它们。\n * private claims（私有声明）：jwt 签发方因为项目需要而自定义的声明，更符合实际项目场景使用。\n\n下面是一些常见的注册声明：\n\n * iss（issuer）：jwt 签发方。\n * iat（issued at time）：jwt 签发时间。\n * sub（subject）：jwt 主题。\n * aud（audience）：jwt 接收方。\n * exp（expiration time）：jwt 的过期时间。\n * nbf（not before time）：jwt 生效时间，早于该定义的时间的 jwt 不能被接受处理。\n * jti（jwt id）：jwt 唯一标识。\n\n{\n  "uid": "ff1212f5-d8d1-4496-bf41-d2dda73de19a",\n  "sub": "1234567890",\n  "name": "john doe",\n  "exp": 15323232,\n  "iat": 1516239022,\n  "scope": ["admin", "user"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n{\n    "sub": \'1234567890\',\n    "name": \'john\',\n    "admin": true\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# signature 签名\n\nsignature 部分是对前两部分的签名，作用是防止 jwt（主要是 payload）被篡改。\n\n这个签名的生成需要用到：\n\n * header + payload。\n * 存放在服务端的密钥(一定不要泄露出去)。 -- secret\n * 签名算法。 -- hmacsha256\n\n// 第一种方式\nvar encodedstring = base64urlencode(header) + \'.\' + base64urlencode(payload);\nvar signature = hmacsha256(encodedstring, \'secret\');\n\n// 第二种方式\nhmacsha256(\n  base64urlencode(header) + "." +\n  base64urlencode(payload),\n  secret)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 算出签名以后，把 header、payload、signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，这个字符串就是 jwt 。\n\n\n# 相关依赖\n\npom.xml 文件\n\n<dependency>\n    <groupid>io.jsonwebtoken</groupid>\n    <artifactid>jjwt</artifactid>\n    <version>0.9.1</version>\n</dependency>\n\n<dependency>\n    <groupid>javax.xml.bind</groupid>\n    <artifactid>jaxb-api</artifactid>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupid>com.sun.xml.bind</groupid>\n    <artifactid>jaxb-impl</artifactid>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupid>com.sun.xml.bind</groupid>\n    <artifactid>jaxb-core</artifactid>\n    <version>2.3.0</version>\n</dependency>\n<dependency>\n    <groupid>javax.activation</groupid>\n    <artifactid>activation</artifactid>\n    <version>1.1.1</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 如何基于 jwt 进行身份验证？\n\n在基于 jwt 进行身份验证的的应用程序中，\n\n服务器通过 payload、header 和 secret(密钥)创建 jwt 并将 jwt 发送给客户端。\n\n客户端接收到 jwt 之后，会将其保存在 cookie 或者 localstorage 里面，以后客户端发出的所有请求都会携带这个令牌。\n\n从用户的角度来分析：\n\n 1. 用户向服务器发送用户名、密码以及验证码用于登陆系统。\n 2. 如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 token，也就是 jwt。\n 3. 用户以后每次向后端发请求都在 header 中带上这个 jwt 。\n 4. 服务端检查 jwt 并从中获取用户相关信息。\n\n\n# 为什么用 jwt 代替 session\n\njwt (json web token) 被用于代替传统的基于 session 的身份认证和授权机制的主要原因有以下几点：\n\n 1. 无需服务器存储： 在传统的 session 机制中，服务器需要维护每个用户的会话状态，通常是存储在内存或数据库中。而使用 jwt，所有的用户信息和权限信息都被编码到了 token 中，服务器无需存储任何状态信息，这样可以减轻服务器的负担。\n 2. 跨域支持： jwt 可以轻松地在多个域之间进行传递和使用，这使得跨域通信和微服务架构变得更加简单。\n 3. 扩展性： jwt 是一种开放标准，可以支持自定义的声明和数据结构。这使得 jwt 非常灵活，可以根据实际需求添加额外的信息。\n 4. 无状态性： 传统的基于 session 的认证机制需要服务器保存会话状态，而 jwt 是无状态的。每个请求都包含了认证信息，服务器不需要再去查询数据库或存储中心来验证用户的身份。\n 5. 安全性： jwt 内置了签名机制，可以验证 token 的真实性和完整性。这样即使 token 被篡改，服务器也能识别出来并拒绝该 token。\n 6. 适用于分布式系统： jwt 适用于分布式系统和微服务架构，可以跨多个服务进行认证和授权。\n\n总的来说，jwt 是一种轻量级、可扩展、无状态和安全的认证机制，相较于传统的基于 session 的认证机制，jwt 具有更多优势，特别适合于现代的分布式、跨域和无状态的应用场景。\n\n\n# 参考文献\n\n * jwt 基础概念详解\n * 用户认证：基于jwt和session的区别和优缺点',charsets:{cjk:!0}},{title:"设计模式 13 问",frontmatter:{title:"设计模式 13 问",date:"2023-07-27T10:49:00.000Z",permalink:"/pages/0863fc/"},regularPath:"/05.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2013%20%E9%97%AE.html",relativePath:"05.系统设计/04.设计模式/02.设计模式 13 问.md",key:"v-3e1c391d",path:"/pages/0863fc/",headers:[{level:2,title:"1、谈谈你对设计模式的理解？",slug:"_1、谈谈你对设计模式的理解",normalizedTitle:"1、谈谈你对设计模式的理解？",charIndex:16},{level:2,title:"2、谈谈你对工厂方法模式的理解？",slug:"_2、谈谈你对工厂方法模式的理解",normalizedTitle:"2、谈谈你对工厂方法模式的理解？",charIndex:555},{level:2,title:"3、谈谈你对简单工厂模式的理解？",slug:"_3、谈谈你对简单工厂模式的理解",normalizedTitle:"3、谈谈你对简单工厂模式的理解？",charIndex:1287},{level:2,title:"4、谈谈你对单例模式的理解？",slug:"_4、谈谈你对单例模式的理解",normalizedTitle:"4、谈谈你对单例模式的理解？",charIndex:2352},{level:2,title:"5、谈谈你对代理模式的理解？",slug:"_5、谈谈你对代理模式的理解",normalizedTitle:"5、谈谈你对代理模式的理解？",charIndex:2895},{level:2,title:"6、谈谈你对模板模式的理解？",slug:"_6、谈谈你对模板模式的理解",normalizedTitle:"6、谈谈你对模板模式的理解？",charIndex:3661},{level:2,title:"7、谈谈你对观察者模式的理解？",slug:"_7、谈谈你对观察者模式的理解",normalizedTitle:"7、谈谈你对观察者模式的理解？",charIndex:4289},{level:2,title:"8、谈谈你对装饰器模式的理解？",slug:"_8、谈谈你对装饰器模式的理解",normalizedTitle:"8、谈谈你对装饰器模式的理解？",charIndex:5448},{level:2,title:"9、谈谈你对策略模式的理解？",slug:"_9、谈谈你对策略模式的理解",normalizedTitle:"9、谈谈你对策略模式的理解？",charIndex:6544},{level:2,title:"10、谈谈你对适配器模式的理解？",slug:"_10、谈谈你对适配器模式的理解",normalizedTitle:"10、谈谈你对适配器模式的理解？",charIndex:7595},{level:2,title:"11、谈谈 IO 中用到的设计模式？",slug:"_11、谈谈-io-中用到的设计模式",normalizedTitle:"11、谈谈 io 中用到的设计模式？",charIndex:8302},{level:2,title:"12、谈谈 Spring 中用到的设计模式？",slug:"_12、谈谈-spring-中用到的设计模式",normalizedTitle:"12、谈谈 spring 中用到的设计模式？",charIndex:8686},{level:2,title:"13、谈谈 MyBatis 中用到的设计模式？",slug:"_13、谈谈-mybatis-中用到的设计模式",normalizedTitle:"13、谈谈 mybatis 中用到的设计模式？",charIndex:9248}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"5 min read",minutes:4.105,time:246300,words:821},headersStr:"1、谈谈你对设计模式的理解？ 2、谈谈你对工厂方法模式的理解？ 3、谈谈你对简单工厂模式的理解？ 4、谈谈你对单例模式的理解？ 5、谈谈你对代理模式的理解？ 6、谈谈你对模板模式的理解？ 7、谈谈你对观察者模式的理解？ 8、谈谈你对装饰器模式的理解？ 9、谈谈你对策略模式的理解？ 10、谈谈你对适配器模式的理解？ 11、谈谈 IO 中用到的设计模式？ 12、谈谈 Spring 中用到的设计模式？ 13、谈谈 MyBatis 中用到的设计模式？",content:'# 设计模式 13 问\n\n\n# 1、谈谈你对设计模式的理解？\n\n 1. 设计模式是一种被广泛应用的解决问题的经验总结，它提供了一套可复用、可扩展、易于维护的解决方案。设计模式可以帮助我们更好地组织代码，提高代码质量和可读性。\n    \n    我将他理解成是一种由以前的程序员在实际工作中反复使用，总结得出的经验，最终形成的使用的模式。\n\n 2. 有 7 个常用的软件设计原则\n    \n    * 开闭原则 -- 对扩展开放，对修改关闭\n    \n    * 单一职责原则 -- ⼀个类只负责⼀个功能领域中的相应职责\n    \n    * 里氏替换原则 -- 所有引用基类的地方必须能透明地使用其子类的对象\n    \n    * 依赖倒置原则 -- 依赖于抽象，不能依赖于具体实现\n    \n    * 接口隔离原则 -- 类之间的依赖关系应该建立在最小的接口上\n    \n    * 合成/聚合复用原则 -- 尽量使用合成/聚合，而不是通过继承达到复用的目的\n    \n    * 最少知识原则 或者 迪米特法则 -- 一个软件实体应当尽可能少的与其他实体发生相互作用\n\n 3. 主要有三大分类\n    \n    * 创建型模式\n    * 结构型模式\n    * 行为型模式\n    \n    \n\n\n# 2、谈谈你对工厂方法模式的理解？\n\n工厂方法模式是一种创建型设计模式，它将对象的创建委托给子类，由子类决定实例化哪个类。这样可以将对象的创建与使用分离，提高了代码的可扩展性和灵活性。\n\ninterface Product {\n    void show();\n}\n\nclass ConcreteProduct implements Product {\n    @Override\n    public void show() {\n        System.out.println("具体产品");\n    }\n}\n\nabstract class Factory {\n    public abstract Product createProduct();\n}\n\nclass ConcreteFactory extends Factory {\n    @Override\n    public Product createProduct() {\n        return new ConcreteProduct();\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    Factory factory = new ConcreteFactory();\n    Product product = factory.createProduct();\n    product.show(); // 输出：具体产品\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 3、谈谈你对简单工厂模式的理解？\n\n简单工厂模式是一种创建型设计模式，它通过一个工厂类来创建对象，而不是直接在客户端代码中实例化对象。简单工厂模式简化了对象的创建过程，对客户端隐藏了对象的创建细节。\n\ninterface Product {\n    void show();\n}\n\nclass ConcreteProductA implements Product {\n    @Override\n    public void show() {\n        System.out.println("产品A");\n    }\n}\n\nclass ConcreteProductB implements Product {\n    @Override\n    public void show() {\n        System.out.println("产品B");\n    }\n}\n\nclass SimpleFactory {\n    public static Product createProduct(String type) {\n        if ("A".equals(type)) {\n            return new ConcreteProductA();\n        } else if ("B".equals(type)) {\n            return new ConcreteProductB();\n        } else {\n            throw new IllegalArgumentException("无效的产品类型");\n        }\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    Product productA = SimpleFactory.createProduct("A");\n    Product productB = SimpleFactory.createProduct("B");\n    productA.show(); // 输出：产品A\n    productB.show(); // 输出：产品B\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 4、谈谈你对单例模式的理解？\n\n单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点。单例模式通常用于管理全局资源或控制某些共享资源的访问。\n\nclass Singleton {\n    private static Singleton instance;\n\n    private Singleton() {\n        // 私有构造方法\n    }\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    Singleton singleton = Singleton.getInstance();\n    // 使用singleton对象进行操作\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 5、谈谈你对代理模式的理解？\n\n代理模式是一种结构型设计模式，它通过一个代理类来控制对另一个对象的访问。代理模式可以用于实现延迟加载、权限控制、远程访问等功能。\n\ninterface Subject {\n    void request();\n}\n\nclass RealSubject implements Subject {\n    @Override\n    public void request() {\n        System.out.println("真实主题");\n    }\n}\n\nclass Proxy implements Subject {\n    private RealSubject realSubject;\n\n    @Override\n    public void request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        System.out.println("代理前处理");\n        realSubject.request();\n        System.out.println("代理后处理");\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    Subject proxy = new Proxy();\n    proxy.request();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 6、谈谈你对模板模式的理解？\n\n模板模式是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤的具体实现延迟到子类中。模板模式可以提高代码的复用性和可扩展性。\n\nabstract class AbstractClass {\n    public void templateMethod() {\n        // 一些公共的处理逻辑\n        specificMethod();\n        // 一些其他的公共处理逻辑\n    }\n\n    protected abstract void specificMethod();\n}\n\nclass ConcreteClass extends AbstractClass {\n    @Override\n    protected void specificMethod() {\n        System.out.println("具体子类实现");\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    AbstractClass abstractClass = new ConcreteClass();\n    abstractClass.templateMethod();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 7、谈谈你对观察者模式的理解？\n\n观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象状态发生改变时，它的所有依赖者都会收到通知。观察者模式可以用于实现事件监听、消息订阅等功能。\n\ninterface Observer {\n    void update(String message);\n}\n\nclass ConcreteObserver implements Observer {\n    @Override\n    public void update(String message) {\n        System.out.println("收到消息：" + message);\n    }\n}\n\nclass Subject {\n    private List<Observer> observers = new ArrayList<>();\n\n    public void addObserver(Observer observer) {\n        observers.add(observer);\n    }\n\n    public void removeObserver(Observer observer) {\n        observers.remove(observer);\n    }\n\n    public void notifyObservers(String message) {\n        for (Observer observer : observers) {\n            observer.update(message);\n        }\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    Subject subject = new Subject();\n    Observer observer1 = new ConcreteObserver();\n    Observer observer2 = new ConcreteObserver();\n\n    subject.addObserver(observer1);\n    subject.addObserver(observer2);\n\n    subject.notifyObservers("Hello, observers!");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 8、谈谈你对装饰器模式的理解？\n\n装饰器模式是一种结构型设计模式，它动态地给一个对象添加一些额外的功能，而不影响其接口。装饰器模式可以用于扩展一个类的功能，而不需要修改其原始代码。\n\ninterface Component {\n    void operation();\n}\n\nclass ConcreteComponent implements Component {\n    @Override\n    public void operation() {\n        System.out.println("具体组件");\n    }\n}\n\nabstract class Decorator implements Component {\n    protected Component component;\n\n    public Decorator(Component component) {\n        this.component = component;\n    }\n\n    @Override\n    public void operation() {\n        component.operation();\n    }\n}\n\nclass ConcreteDecorator extends Decorator {\n    public ConcreteDecorator(Component component) {\n        super(component);\n    }\n\n    @Override\n    public void operation() {\n        super.operation();\n        System.out.println("装饰器扩展功能");\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    Component component = new ConcreteComponent();\n    Component decorator = new ConcreteDecorator(component);\n    decorator.operation();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 9、谈谈你对策略模式的理解？\n\n策略模式是一种行为型设计模式，它定义了一系列算法，并使它们可以相互替换，让算法的变化独立于使用算法的客户端。策略模式可以提高代码的灵活性和可维护性。\n\ninterface Strategy {\n    void algorithm();\n}\n\nclass ConcreteStrategyA implements Strategy {\n    @Override\n    public void algorithm() {\n        System.out.println("具体策略A");\n    }\n}\n\nclass ConcreteStrategyB implements Strategy {\n    @Override\n    public void algorithm() {\n        System.out.println("具体策略B");\n    }\n}\n\nclass Context {\n    private Strategy strategy;\n\n    public Context(Strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void execute() {\n        strategy.algorithm();\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    Strategy strategyA = new ConcreteStrategyA();\n    Strategy strategyB = new ConcreteStrategyB();\n\n    Context contextA = new Context(strategyA);\n    Context contextB = new Context(strategyB);\n\n    contextA.execute(); // 输出：具体策略A\n    contextB.execute(); // 输出：具体策略B\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 10、谈谈你对适配器模式的理解？\n\n适配器模式是一种结构型设计模式，它将一个类的接口转换成客户端所期待的接口，使得原本不兼容的类可以协同工作。适配器模式可以用于解决不同接口之间的兼容性问题。\n\ninterface Target {\n    void request();\n}\n\nclass Adaptee {\n    public void specificRequest() {\n        System.out.println("适配者的方法");\n    }\n}\n\nclass Adapter implements Target {\n    private Adaptee adaptee;\n\n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    @Override\n    public void request() {\n        adaptee.specificRequest();\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(String[] args) {\n    Adaptee adaptee = new Adaptee();\n    Target target = new Adapter(adaptee);\n    target.request();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 11、谈谈 IO 中用到的设计模式？\n\n在IO中，常用的设计模式包括装饰器模式（例如BufferedInputStream）、观察者模式（例如Java IO的事件监听器）、适配器模式（例如InputStreamReader）等。\n\nInputStream inputStream = new FileInputStream("file.txt");\ninputStream = new BufferedInputStream(inputStream);\ninputStream = new DataInputStream(inputStream);\n// 在这里，BufferedInputStream 和 DataInputStream 就是装饰器，通过组合方式给 FileInputStream 添加了缓冲和处理基本数据类型的功能。\n\n\n1\n2\n3\n4\n\n\n\n# 12、谈谈 Spring 中用到的设计模式？\n\n在Spring中，常用的设计模式包括单例模式（例如Spring容器管理Bean的单例实例）、模板模式（例如JdbcTemplate）、代理模式（例如AOP实现）等。\n\n// IoC示例\n@Service\npublic class MyService {\n    private MyRepository repository;\n\n    @Autowired\n    public MyService(MyRepository repository) {\n        this.repository = repository;\n    }\n\n    // ...\n}\n\n// AOP示例\n@Aspect\n@Component\npublic class MyAspect {\n    @Before("execution(* com.example.MyService.*(..))")\n    public void beforeAdvice() {\n        System.out.println("执行前置通知");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 13、谈谈 MyBatis 中用到的设计模式？\n\n在MyBatis中，常用的设计模式包括工厂模式（例如SqlSessionFactoryBuilder用于创建SqlSessionFactory）、模板模式（例如BaseExecutor中定义SqlSession的模板方法）等。\n\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);\nSqlSession session = factory.openSession();\n\n// Mapper接口代理示例\nMapperInterface mapper = session.getMapper(MapperInterface.class);\n\n\n1\n2\n3\n4\n5\n',normalizedContent:'# 设计模式 13 问\n\n\n# 1、谈谈你对设计模式的理解？\n\n 1. 设计模式是一种被广泛应用的解决问题的经验总结，它提供了一套可复用、可扩展、易于维护的解决方案。设计模式可以帮助我们更好地组织代码，提高代码质量和可读性。\n    \n    我将他理解成是一种由以前的程序员在实际工作中反复使用，总结得出的经验，最终形成的使用的模式。\n\n 2. 有 7 个常用的软件设计原则\n    \n    * 开闭原则 -- 对扩展开放，对修改关闭\n    \n    * 单一职责原则 -- ⼀个类只负责⼀个功能领域中的相应职责\n    \n    * 里氏替换原则 -- 所有引用基类的地方必须能透明地使用其子类的对象\n    \n    * 依赖倒置原则 -- 依赖于抽象，不能依赖于具体实现\n    \n    * 接口隔离原则 -- 类之间的依赖关系应该建立在最小的接口上\n    \n    * 合成/聚合复用原则 -- 尽量使用合成/聚合，而不是通过继承达到复用的目的\n    \n    * 最少知识原则 或者 迪米特法则 -- 一个软件实体应当尽可能少的与其他实体发生相互作用\n\n 3. 主要有三大分类\n    \n    * 创建型模式\n    * 结构型模式\n    * 行为型模式\n    \n    \n\n\n# 2、谈谈你对工厂方法模式的理解？\n\n工厂方法模式是一种创建型设计模式，它将对象的创建委托给子类，由子类决定实例化哪个类。这样可以将对象的创建与使用分离，提高了代码的可扩展性和灵活性。\n\ninterface product {\n    void show();\n}\n\nclass concreteproduct implements product {\n    @override\n    public void show() {\n        system.out.println("具体产品");\n    }\n}\n\nabstract class factory {\n    public abstract product createproduct();\n}\n\nclass concretefactory extends factory {\n    @override\n    public product createproduct() {\n        return new concreteproduct();\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    factory factory = new concretefactory();\n    product product = factory.createproduct();\n    product.show(); // 输出：具体产品\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 3、谈谈你对简单工厂模式的理解？\n\n简单工厂模式是一种创建型设计模式，它通过一个工厂类来创建对象，而不是直接在客户端代码中实例化对象。简单工厂模式简化了对象的创建过程，对客户端隐藏了对象的创建细节。\n\ninterface product {\n    void show();\n}\n\nclass concreteproducta implements product {\n    @override\n    public void show() {\n        system.out.println("产品a");\n    }\n}\n\nclass concreteproductb implements product {\n    @override\n    public void show() {\n        system.out.println("产品b");\n    }\n}\n\nclass simplefactory {\n    public static product createproduct(string type) {\n        if ("a".equals(type)) {\n            return new concreteproducta();\n        } else if ("b".equals(type)) {\n            return new concreteproductb();\n        } else {\n            throw new illegalargumentexception("无效的产品类型");\n        }\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    product producta = simplefactory.createproduct("a");\n    product productb = simplefactory.createproduct("b");\n    producta.show(); // 输出：产品a\n    productb.show(); // 输出：产品b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 4、谈谈你对单例模式的理解？\n\n单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点。单例模式通常用于管理全局资源或控制某些共享资源的访问。\n\nclass singleton {\n    private static singleton instance;\n\n    private singleton() {\n        // 私有构造方法\n    }\n\n    public static singleton getinstance() {\n        if (instance == null) {\n            instance = new singleton();\n        }\n        return instance;\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    singleton singleton = singleton.getinstance();\n    // 使用singleton对象进行操作\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 5、谈谈你对代理模式的理解？\n\n代理模式是一种结构型设计模式，它通过一个代理类来控制对另一个对象的访问。代理模式可以用于实现延迟加载、权限控制、远程访问等功能。\n\ninterface subject {\n    void request();\n}\n\nclass realsubject implements subject {\n    @override\n    public void request() {\n        system.out.println("真实主题");\n    }\n}\n\nclass proxy implements subject {\n    private realsubject realsubject;\n\n    @override\n    public void request() {\n        if (realsubject == null) {\n            realsubject = new realsubject();\n        }\n        system.out.println("代理前处理");\n        realsubject.request();\n        system.out.println("代理后处理");\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    subject proxy = new proxy();\n    proxy.request();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 6、谈谈你对模板模式的理解？\n\n模板模式是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤的具体实现延迟到子类中。模板模式可以提高代码的复用性和可扩展性。\n\nabstract class abstractclass {\n    public void templatemethod() {\n        // 一些公共的处理逻辑\n        specificmethod();\n        // 一些其他的公共处理逻辑\n    }\n\n    protected abstract void specificmethod();\n}\n\nclass concreteclass extends abstractclass {\n    @override\n    protected void specificmethod() {\n        system.out.println("具体子类实现");\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    abstractclass abstractclass = new concreteclass();\n    abstractclass.templatemethod();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 7、谈谈你对观察者模式的理解？\n\n观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象状态发生改变时，它的所有依赖者都会收到通知。观察者模式可以用于实现事件监听、消息订阅等功能。\n\ninterface observer {\n    void update(string message);\n}\n\nclass concreteobserver implements observer {\n    @override\n    public void update(string message) {\n        system.out.println("收到消息：" + message);\n    }\n}\n\nclass subject {\n    private list<observer> observers = new arraylist<>();\n\n    public void addobserver(observer observer) {\n        observers.add(observer);\n    }\n\n    public void removeobserver(observer observer) {\n        observers.remove(observer);\n    }\n\n    public void notifyobservers(string message) {\n        for (observer observer : observers) {\n            observer.update(message);\n        }\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    subject subject = new subject();\n    observer observer1 = new concreteobserver();\n    observer observer2 = new concreteobserver();\n\n    subject.addobserver(observer1);\n    subject.addobserver(observer2);\n\n    subject.notifyobservers("hello, observers!");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 8、谈谈你对装饰器模式的理解？\n\n装饰器模式是一种结构型设计模式，它动态地给一个对象添加一些额外的功能，而不影响其接口。装饰器模式可以用于扩展一个类的功能，而不需要修改其原始代码。\n\ninterface component {\n    void operation();\n}\n\nclass concretecomponent implements component {\n    @override\n    public void operation() {\n        system.out.println("具体组件");\n    }\n}\n\nabstract class decorator implements component {\n    protected component component;\n\n    public decorator(component component) {\n        this.component = component;\n    }\n\n    @override\n    public void operation() {\n        component.operation();\n    }\n}\n\nclass concretedecorator extends decorator {\n    public concretedecorator(component component) {\n        super(component);\n    }\n\n    @override\n    public void operation() {\n        super.operation();\n        system.out.println("装饰器扩展功能");\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    component component = new concretecomponent();\n    component decorator = new concretedecorator(component);\n    decorator.operation();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 9、谈谈你对策略模式的理解？\n\n策略模式是一种行为型设计模式，它定义了一系列算法，并使它们可以相互替换，让算法的变化独立于使用算法的客户端。策略模式可以提高代码的灵活性和可维护性。\n\ninterface strategy {\n    void algorithm();\n}\n\nclass concretestrategya implements strategy {\n    @override\n    public void algorithm() {\n        system.out.println("具体策略a");\n    }\n}\n\nclass concretestrategyb implements strategy {\n    @override\n    public void algorithm() {\n        system.out.println("具体策略b");\n    }\n}\n\nclass context {\n    private strategy strategy;\n\n    public context(strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void execute() {\n        strategy.algorithm();\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    strategy strategya = new concretestrategya();\n    strategy strategyb = new concretestrategyb();\n\n    context contexta = new context(strategya);\n    context contextb = new context(strategyb);\n\n    contexta.execute(); // 输出：具体策略a\n    contextb.execute(); // 输出：具体策略b\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 10、谈谈你对适配器模式的理解？\n\n适配器模式是一种结构型设计模式，它将一个类的接口转换成客户端所期待的接口，使得原本不兼容的类可以协同工作。适配器模式可以用于解决不同接口之间的兼容性问题。\n\ninterface target {\n    void request();\n}\n\nclass adaptee {\n    public void specificrequest() {\n        system.out.println("适配者的方法");\n    }\n}\n\nclass adapter implements target {\n    private adaptee adaptee;\n\n    public adapter(adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    @override\n    public void request() {\n        adaptee.specificrequest();\n    }\n}\n\n// 在客户端代码中使用\npublic static void main(string[] args) {\n    adaptee adaptee = new adaptee();\n    target target = new adapter(adaptee);\n    target.request();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 11、谈谈 io 中用到的设计模式？\n\n在io中，常用的设计模式包括装饰器模式（例如bufferedinputstream）、观察者模式（例如java io的事件监听器）、适配器模式（例如inputstreamreader）等。\n\ninputstream inputstream = new fileinputstream("file.txt");\ninputstream = new bufferedinputstream(inputstream);\ninputstream = new datainputstream(inputstream);\n// 在这里，bufferedinputstream 和 datainputstream 就是装饰器，通过组合方式给 fileinputstream 添加了缓冲和处理基本数据类型的功能。\n\n\n1\n2\n3\n4\n\n\n\n# 12、谈谈 spring 中用到的设计模式？\n\n在spring中，常用的设计模式包括单例模式（例如spring容器管理bean的单例实例）、模板模式（例如jdbctemplate）、代理模式（例如aop实现）等。\n\n// ioc示例\n@service\npublic class myservice {\n    private myrepository repository;\n\n    @autowired\n    public myservice(myrepository repository) {\n        this.repository = repository;\n    }\n\n    // ...\n}\n\n// aop示例\n@aspect\n@component\npublic class myaspect {\n    @before("execution(* com.example.myservice.*(..))")\n    public void beforeadvice() {\n        system.out.println("执行前置通知");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 13、谈谈 mybatis 中用到的设计模式？\n\n在mybatis中，常用的设计模式包括工厂模式（例如sqlsessionfactorybuilder用于创建sqlsessionfactory）、模板模式（例如baseexecutor中定义sqlsession的模板方法）等。\n\nsqlsessionfactory factory = new sqlsessionfactorybuilder().build(inputstream);\nsqlsession session = factory.opensession();\n\n// mapper接口代理示例\nmapperinterface mapper = session.getmapper(mapperinterface.class);\n\n\n1\n2\n3\n4\n5\n',charsets:{cjk:!0}},{title:"Git知识总结",frontmatter:{title:"Git知识总结",date:"2023-05-28T23:19:27.000Z",permalink:"/pages/71f6ae/"},regularPath:"/07.%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/02.Git%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.html",relativePath:"07.开发日常/02.Git知识总结.md",key:"v-9234eeec",path:"/pages/71f6ae/",headers:[{level:2,title:"版本控制",slug:"版本控制",normalizedTitle:"版本控制",charIndex:64},{level:3,title:"什么是版本控制？",slug:"什么是版本控制",normalizedTitle:"什么是版本控制？",charIndex:73},{level:3,title:"为什么需要版本控制？",slug:"为什么需要版本控制",normalizedTitle:"为什么需要版本控制？",charIndex:170},{level:3,title:"三大版本控制系统",slug:"三大版本控制系统",normalizedTitle:"三大版本控制系统",charIndex:310},{level:4,title:"本地版本控制系统",slug:"本地版本控制系统",normalizedTitle:"本地版本控制系统",charIndex:322},{level:4,title:"集中化的版本控制系统",slug:"集中化的版本控制系统",normalizedTitle:"集中化的版本控制系统",charIndex:376},{level:4,title:"分布式版本控制系统",slug:"分布式版本控制系统",normalizedTitle:"分布式版本控制系统",charIndex:626},{level:2,title:"在开发中，常用的 git 开发操作流程是怎样的？",slug:"在开发中-常用的-git-开发操作流程是怎样的",normalizedTitle:"在开发中，常用的 git 开发操作流程是怎样的？",charIndex:834},{level:2,title:"Git 快速入门",slug:"git-快速入门",normalizedTitle:"git 快速入门",charIndex:1437},{level:3,title:"Git 有哪三种状态？",slug:"git-有哪三种状态",normalizedTitle:"git 有哪三种状态？",charIndex:1450},{level:3,title:"Git 关联 idea 文件颜色的意思？",slug:"git-关联-idea-文件颜色的意思",normalizedTitle:"git 关联 idea 文件颜色的意思？",charIndex:1596},{level:3,title:"Git 项目的三个工作区域",slug:"git-项目的三个工作区域",normalizedTitle:"git 项目的三个工作区域",charIndex:1749},{level:3,title:"基本的 Git 工作流程",slug:"基本的-git-工作流程",normalizedTitle:"基本的 git 工作流程",charIndex:1871},{level:3,title:"查看 Git 版本号",slug:"查看-git-版本号",normalizedTitle:"查看 git 版本号",charIndex:2232},{level:3,title:"Git的配置文件",slug:"git的配置文件",normalizedTitle:"git的配置文件",charIndex:2266},{level:3,title:"什么是 Git Flow",slug:"什么是-git-flow",normalizedTitle:"什么是 git flow",charIndex:2734},{level:3,title:"常用操作",slug:"常用操作",normalizedTitle:"常用操作",charIndex:2851},{level:4,title:"获取 Git 仓库",slug:"获取-git-仓库",normalizedTitle:"获取 git 仓库",charIndex:2859},{level:4,title:"添加和提交",slug:"添加和提交",normalizedTitle:"添加和提交",charIndex:3161},{level:4,title:"初始化一个 Readme文件",slug:"初始化一个-readme文件",normalizedTitle:"初始化一个 readme文件",charIndex:3457},{level:4,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:1119},{level:4,title:"推送",slug:"推送",normalizedTitle:"推送",charIndex:1171},{level:2,title:"IDEA 使用更新项目操作",slug:"idea-使用更新项目操作",normalizedTitle:"idea 使用更新项目操作",charIndex:3694},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4283}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.075,time:124500.00000000001,words:415},headersStr:"版本控制 什么是版本控制？ 为什么需要版本控制？ 三大版本控制系统 本地版本控制系统 集中化的版本控制系统 分布式版本控制系统 在开发中，常用的 git 开发操作流程是怎样的？ Git 快速入门 Git 有哪三种状态？ Git 关联 idea 文件颜色的意思？ Git 项目的三个工作区域 基本的 Git 工作流程 查看 Git 版本号 Git的配置文件 什么是 Git Flow 常用操作 获取 Git 仓库 添加和提交 初始化一个 Readme文件 切换分支 推送 IDEA 使用更新项目操作 参考",content:'# Git 知识总结\n\n> 命令学习：Learn Git Branching\n> \n> Git 命令大全：Git 大全\n\n\n# 版本控制\n\n\n# 什么是版本控制？\n\n版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。关键时刻，可以回退版本。\n\n> 除了项目源代码，你可以对任何类型的文件进行版本控制。\n\n\n# 为什么需要版本控制？\n\n * 版本控制可以让你将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。\n * 你还可以通过提交的历史记录来比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。\n\n\n# 三大版本控制系统\n\n# 本地版本控制系统\n\n方便个人管理项目文件。\n\n大多都是采用某种简单的数据库来记录文件的历次更新差异。\n\n# 集中化的版本控制系统\n\n为解决开发者协同合作问题而生。\n\n都有一个单一的集中管理的服务器，可以保存所有文件的修订版本，协同工作的开发者们都可以通过客户端连到这台服务器，取出最新的文件或者提交更新。\n\n有两个问题：\n\n 1. 单点故障： 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n 2. **必须联网才能工作：**受网络状况和网络带宽影响。\n\n# 分布式版本控制系统\n\n为解决上面的问题面世，比如：Git\n\n有以下几个优点：\n\n 1. 这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地克隆下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个克隆出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n 2. 可以不用联网工作，因为每个人的电脑上都是完整的版本库。\n 3. 强大的分支管理功能。\n\n\n# 在开发中，常用的 git 开发操作流程是怎样的？\n\n在使用 Git 进行开发时，常用的操作流程包括：\n\n 1.  创建 Git 仓库：使用 git init 命令初始化一个新的 Git 仓库。也可以使用 git clone 命令克隆一个远程仓库到本地。\n\n 2.  添加文件到暂存区：使用 git add 命令将修改的文件添加到 Git 的暂存区中。\n\n 3.  提交修改：使用 git commit 命令提交修改。可以使用 -m 参数指定提交的注释信息。\n\n 4.  分支操作：使用 git branch 命令创建、删除、查看分支。使用 git checkout 命令切换分支。\n\n 5.  合并分支：使用 git merge 命令将一个分支合并到当前分支。\n\n 6.  推送修改：使用 git push 命令将本地修改推送到远程仓库。\n\n 7.  拉取修改：使用 git pull 命令从远程仓库拉取最新修改。\n\n 8.  查看修改历史：使用 git log 命令查看提交历史。\n\n 9.  撤销修改：使用 git reset 命令撤销某次提交。可以使用 --soft 参数保留修改到暂存区，使用 --mixed 参数保留修改到工作区，使用 --hard 参数彻底删除修改。\n\n 10. 标签操作：使用 git tag 命令创建、删除、查看标签。标签可以用于标记某个版本，便于后续查找和发布。\n\n\n# Git 快速入门\n\n\n# Git 有哪三种状态？\n\n 1. 已提交（committed）：数据已经安全的保存在本地数据库中。\n 2. 已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。\n 3. 已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n\n# Git 关联 idea 文件颜色的意思？\n\n 1. 红色（red），未加入版本控制\n 2. 绿色（green），已经加入版本控制暂未提交\n 3. 蓝色（blue），加入版本控制，已提交，有改动\n 4. 白色（white），加入版本控制，已提交，无改动\n 5. 灰色（grey）：版本控制已忽略文件\n\n\n# Git 项目的三个工作区域\n\n 1. 工作目录(working)\n 2. 暂存区域(index)\n 3. Git 仓库(HEAD)\n\nworking =add=> index =commit=> HEAD =push=> 远程仓库\n\n\n\n\n# 基本的 Git 工作流程\n\n 1. 准备仓库：创建或从服务端克隆一个仓库。\n 2. 搬砖：在工作目录中添加、修改代码。\n 3. 暂存（git add）：将需要进行版本管理的文件放入暂存区域。\n 4. 提交（git commit）：将暂存区域的文件提交到Git仓库。\n 5. 推送（git push）：将本地仓库推送到远程仓库，同步版本库。\n 6. 获取更新（fetch/pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享\n\n * 在工作目录中修改文件。 -- 即写代码\n\n * 暂存文件，将文件的快照放入暂存区域。 -- 即表示已修改，文件变蓝色\n\n * 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录中。\n\n> 文件的快照：就是指 文件的数据。是 Git 版本控制的核心。\n\n\n# 查看 Git 版本号\n\n指令：git -- version\n\n\n# Git的配置文件\n\nGit有三个主要的配置文件：\n\n三个配置文件的优先级是 ① < ② < ③\n\n① 系统全局配置(--system)：包含了适用于系统所有用户和所有仓库（项目）的配置信息，存放在 Git 安装目录下：C:\\Program Files\\Git\\etc\\gitconfig\n\n② 用户全局配置(--global)：当前系统用户的全局配置，存放用户目录：C:\\Users\\[系统用户名]\\.gitconfig。\n\n③ 仓库/项目配置(--local)：仓库（项目）的特定配置，存放在项目目录下：.git/config\n\n#查看git配置\ngit config --list\ngit config -l\n \n#查看系统配置\ngit config --system --list\n \n#查看当前用户（global）全局配置\ngit config --list --global\n \n#查看当前仓库配置信息\ngit config --local  --list\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 什么是 Git Flow\n\nGit Flow 是一种基于 Git 版本控制工具的分支管理工作流程，它定义了一套完整的分支模型，包括主分支、开发分支、功能分支、修复分支等，旨在优化团队协作、版本发布和代码质量等方面的工作流程。\n\n\n# 常用操作\n\n# 获取 Git 仓库\n\n有两种方法：\n\n 1. 在当前项目目录中初始化仓库：\n    \n    右键点击 Git Bash Here 进入窗口运行 git init 命令，该命令将创建一个名为 .git 的子目录，代表已经加入版本控制。\n\n 2. 从一个服务器（远程仓库）克隆一个现有的 Git 仓库：\n    \n    进入希望项目存放的目录地址，运行 git clone [url] 自定义文件夹名称 命令。\n    \n    注意，使用Git命令克隆的方式可以和 原项目 随时保持更新同步。\n\n 3. 克隆本地仓库\n    \n    git clone /path/to/repository\n\n# 添加和提交\n\n添加、删除、改名：\n\n# 添加指定文件到暂存区，包括被修改的文件\n$ git add [file1] [file2] ...\n \n# 添加当前目录的所有文件到暂存区\n$ git add .\n \n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n \n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提交：\n\n * git commit -m "代码提交信息" -- 此时已提交到了本地仓库中\n\n# 初始化一个 Readme文件\n\ntouch README.md\n\n\n1\n\n\n# 切换分支\n\ngit checkout <branch>\n\n# 推送\n\n * 查看本地 Git 仓库已经关联的远程仓库：git remote -v\n\n * 关联远程仓库：git remote add origin <server>\n\n * 推送分支：git push origin master[分支名称]\n\n> origin 是远程仓库的名称，<server> 是远程仓库的 URL。\n\n\n# IDEA 使用更新项目操作\n\n在使用 IntelliJ IDEA 进行 Git 操作时，更新项目时会出现如下两个选项：\n\n 1. Update Project 使用的是普通合并（merge）的方式，它会将远程分支上的最新代码拉取到本地，然后将本地分支上的代码与远程分支上的代码合并。如果有冲突，需要手动解决冲突并提交代码。这种方式会生成一个新的合并提交，保留了本地分支和远程分支的所有提交历史。\n 2. Update Project with Rebase 使用的是变基（rebase）的方式，它会将本地分支上的所有提交临时保存，然后将远程分支上的最新代码拉取到本地，并用变基的方式将本地分支上的所有提交重新基于远程分支的最新提交。如果有冲突，需要手动解决冲突并提交代码。这种方式会生成一系列新的提交，覆盖了本地分支的所有提交历史。\n\n需要注意的是，使用变基操作会改变提交历史，可能会影响其他人的开发分支。因此，在多人协作开发中，建议使用普通合并（merge）操作，只在特定情况下使用变基操作，例如在开发分支上进行调整和整理提交历史。\n\n在选择更新方式时，可以根据实际情况选择合适的选项。如果当前分支与远程分支的差异较小，可以使用普通合并；如果差异较大，或者需要整理提交历史，可以使用变基操作。无论选择哪种方式，都需要谨慎处理未提交的修改，以免造成代码冲突和数据丢失。\n\n\n# 参考\n\ngit - 简明指南：git - the simple guide - no deep shit! (rogerdudler.github.io)',normalizedContent:'# git 知识总结\n\n> 命令学习：learn git branching\n> \n> git 命令大全：git 大全\n\n\n# 版本控制\n\n\n# 什么是版本控制？\n\n版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。关键时刻，可以回退版本。\n\n> 除了项目源代码，你可以对任何类型的文件进行版本控制。\n\n\n# 为什么需要版本控制？\n\n * 版本控制可以让你将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。\n * 你还可以通过提交的历史记录来比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。\n\n\n# 三大版本控制系统\n\n# 本地版本控制系统\n\n方便个人管理项目文件。\n\n大多都是采用某种简单的数据库来记录文件的历次更新差异。\n\n# 集中化的版本控制系统\n\n为解决开发者协同合作问题而生。\n\n都有一个单一的集中管理的服务器，可以保存所有文件的修订版本，协同工作的开发者们都可以通过客户端连到这台服务器，取出最新的文件或者提交更新。\n\n有两个问题：\n\n 1. 单点故障： 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。\n 2. **必须联网才能工作：**受网络状况和网络带宽影响。\n\n# 分布式版本控制系统\n\n为解决上面的问题面世，比如：git\n\n有以下几个优点：\n\n 1. 这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地克隆下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个克隆出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。\n 2. 可以不用联网工作，因为每个人的电脑上都是完整的版本库。\n 3. 强大的分支管理功能。\n\n\n# 在开发中，常用的 git 开发操作流程是怎样的？\n\n在使用 git 进行开发时，常用的操作流程包括：\n\n 1.  创建 git 仓库：使用 git init 命令初始化一个新的 git 仓库。也可以使用 git clone 命令克隆一个远程仓库到本地。\n\n 2.  添加文件到暂存区：使用 git add 命令将修改的文件添加到 git 的暂存区中。\n\n 3.  提交修改：使用 git commit 命令提交修改。可以使用 -m 参数指定提交的注释信息。\n\n 4.  分支操作：使用 git branch 命令创建、删除、查看分支。使用 git checkout 命令切换分支。\n\n 5.  合并分支：使用 git merge 命令将一个分支合并到当前分支。\n\n 6.  推送修改：使用 git push 命令将本地修改推送到远程仓库。\n\n 7.  拉取修改：使用 git pull 命令从远程仓库拉取最新修改。\n\n 8.  查看修改历史：使用 git log 命令查看提交历史。\n\n 9.  撤销修改：使用 git reset 命令撤销某次提交。可以使用 --soft 参数保留修改到暂存区，使用 --mixed 参数保留修改到工作区，使用 --hard 参数彻底删除修改。\n\n 10. 标签操作：使用 git tag 命令创建、删除、查看标签。标签可以用于标记某个版本，便于后续查找和发布。\n\n\n# git 快速入门\n\n\n# git 有哪三种状态？\n\n 1. 已提交（committed）：数据已经安全的保存在本地数据库中。\n 2. 已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。\n 3. 已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n\n\n# git 关联 idea 文件颜色的意思？\n\n 1. 红色（red），未加入版本控制\n 2. 绿色（green），已经加入版本控制暂未提交\n 3. 蓝色（blue），加入版本控制，已提交，有改动\n 4. 白色（white），加入版本控制，已提交，无改动\n 5. 灰色（grey）：版本控制已忽略文件\n\n\n# git 项目的三个工作区域\n\n 1. 工作目录(working)\n 2. 暂存区域(index)\n 3. git 仓库(head)\n\nworking =add=> index =commit=> head =push=> 远程仓库\n\n\n\n\n# 基本的 git 工作流程\n\n 1. 准备仓库：创建或从服务端克隆一个仓库。\n 2. 搬砖：在工作目录中添加、修改代码。\n 3. 暂存（git add）：将需要进行版本管理的文件放入暂存区域。\n 4. 提交（git commit）：将暂存区域的文件提交到git仓库。\n 5. 推送（git push）：将本地仓库推送到远程仓库，同步版本库。\n 6. 获取更新（fetch/pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享\n\n * 在工作目录中修改文件。 -- 即写代码\n\n * 暂存文件，将文件的快照放入暂存区域。 -- 即表示已修改，文件变蓝色\n\n * 提交更新，找到暂存区域的文件，将快照永久性存储到 git 仓库目录中。\n\n> 文件的快照：就是指 文件的数据。是 git 版本控制的核心。\n\n\n# 查看 git 版本号\n\n指令：git -- version\n\n\n# git的配置文件\n\ngit有三个主要的配置文件：\n\n三个配置文件的优先级是 ① < ② < ③\n\n① 系统全局配置(--system)：包含了适用于系统所有用户和所有仓库（项目）的配置信息，存放在 git 安装目录下：c:\\program files\\git\\etc\\gitconfig\n\n② 用户全局配置(--global)：当前系统用户的全局配置，存放用户目录：c:\\users\\[系统用户名]\\.gitconfig。\n\n③ 仓库/项目配置(--local)：仓库（项目）的特定配置，存放在项目目录下：.git/config\n\n#查看git配置\ngit config --list\ngit config -l\n \n#查看系统配置\ngit config --system --list\n \n#查看当前用户（global）全局配置\ngit config --list --global\n \n#查看当前仓库配置信息\ngit config --local  --list\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 什么是 git flow\n\ngit flow 是一种基于 git 版本控制工具的分支管理工作流程，它定义了一套完整的分支模型，包括主分支、开发分支、功能分支、修复分支等，旨在优化团队协作、版本发布和代码质量等方面的工作流程。\n\n\n# 常用操作\n\n# 获取 git 仓库\n\n有两种方法：\n\n 1. 在当前项目目录中初始化仓库：\n    \n    右键点击 git bash here 进入窗口运行 git init 命令，该命令将创建一个名为 .git 的子目录，代表已经加入版本控制。\n\n 2. 从一个服务器（远程仓库）克隆一个现有的 git 仓库：\n    \n    进入希望项目存放的目录地址，运行 git clone [url] 自定义文件夹名称 命令。\n    \n    注意，使用git命令克隆的方式可以和 原项目 随时保持更新同步。\n\n 3. 克隆本地仓库\n    \n    git clone /path/to/repository\n\n# 添加和提交\n\n添加、删除、改名：\n\n# 添加指定文件到暂存区，包括被修改的文件\n$ git add [file1] [file2] ...\n \n# 添加当前目录的所有文件到暂存区\n$ git add .\n \n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n \n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n提交：\n\n * git commit -m "代码提交信息" -- 此时已提交到了本地仓库中\n\n# 初始化一个 readme文件\n\ntouch readme.md\n\n\n1\n\n\n# 切换分支\n\ngit checkout <branch>\n\n# 推送\n\n * 查看本地 git 仓库已经关联的远程仓库：git remote -v\n\n * 关联远程仓库：git remote add origin <server>\n\n * 推送分支：git push origin master[分支名称]\n\n> origin 是远程仓库的名称，<server> 是远程仓库的 url。\n\n\n# idea 使用更新项目操作\n\n在使用 intellij idea 进行 git 操作时，更新项目时会出现如下两个选项：\n\n 1. update project 使用的是普通合并（merge）的方式，它会将远程分支上的最新代码拉取到本地，然后将本地分支上的代码与远程分支上的代码合并。如果有冲突，需要手动解决冲突并提交代码。这种方式会生成一个新的合并提交，保留了本地分支和远程分支的所有提交历史。\n 2. update project with rebase 使用的是变基（rebase）的方式，它会将本地分支上的所有提交临时保存，然后将远程分支上的最新代码拉取到本地，并用变基的方式将本地分支上的所有提交重新基于远程分支的最新提交。如果有冲突，需要手动解决冲突并提交代码。这种方式会生成一系列新的提交，覆盖了本地分支的所有提交历史。\n\n需要注意的是，使用变基操作会改变提交历史，可能会影响其他人的开发分支。因此，在多人协作开发中，建议使用普通合并（merge）操作，只在特定情况下使用变基操作，例如在开发分支上进行调整和整理提交历史。\n\n在选择更新方式时，可以根据实际情况选择合适的选项。如果当前分支与远程分支的差异较小，可以使用普通合并；如果差异较大，或者需要整理提交历史，可以使用变基操作。无论选择哪种方式，都需要谨慎处理未提交的修改，以免造成代码冲突和数据丢失。\n\n\n# 参考\n\ngit - 简明指南：git - the simple guide - no deep shit! (rogerdudler.github.io)',charsets:{cjk:!0}},{title:"常见设计模式总结",frontmatter:{title:"常见设计模式总结",date:"2023-06-13T20:32:07.000Z",permalink:"/pages/73ddd7/"},regularPath:"/05.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.html",relativePath:"05.系统设计/04.设计模式/01.常见设计模式总结.md",key:"v-12c5a2d2",path:"/pages/73ddd7/",headers:[{level:2,title:"谈谈你对设计模式的理解？",slug:"谈谈你对设计模式的理解",normalizedTitle:"谈谈你对设计模式的理解？",charIndex:15},{level:2,title:"有哪些常见的设计模式？",slug:"有哪些常见的设计模式",normalizedTitle:"有哪些常见的设计模式？",charIndex:601},{level:2,title:"单例模式了解么？说⼀下单例模式的使用场景。手写⼀个单例模式的实现。",slug:"单例模式了解么-说一下单例模式的使用场景。手写一个单例模式的实现。",normalizedTitle:"单例模式了解么？说⼀下单例模式的使用场景。手写⼀个单例模式的实现。",charIndex:659},{level:2,title:"观察者模式了解么？说⼀下观察者模式的使⽤场景。",slug:"观察者模式了解么-说一下观察者模式的使用场景。",normalizedTitle:"观察者模式了解么？说⼀下观察者模式的使⽤场景。",charIndex:2001}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.89,time:53400,words:178},headersStr:"谈谈你对设计模式的理解？ 有哪些常见的设计模式？ 单例模式了解么？说⼀下单例模式的使用场景。手写⼀个单例模式的实现。 观察者模式了解么？说⼀下观察者模式的使⽤场景。",content:"# 常见设计模式总结\n\n\n# 谈谈你对设计模式的理解？\n\n 1. 设计模式是一种被广泛应用的解决问题的经验总结，它提供了一套可复用、可扩展、易于维护的解决方案。设计模式可以帮助我们更好地组织代码，提高代码质量和可读性。\n    \n    由以前的程序员在实际工作中反复使用，总结得出的经验，形成的使用的模式。\n\n 2. 有 7 个常用的软件设计原则\n    \n    * 开闭原则 -- 对扩展开放，对修改关闭\n      \n      > 你要对某个类进行加功能的时候，直接去继承这个类写一个新的类来使用，而不是在原有类上做修改\n    \n    * 单一职责原则 -- ⼀个类只负责⼀个功能领域中的相应职责\n    \n    * 里氏替换原则 -- 所有引用基类的地方必须能透明地使用其子类的对象\n    \n    * 依赖倒置原则 -- 依赖于抽象，不能依赖于具体实现\n    \n    * 接口隔离原则 -- 类之间的依赖关系应该建立在最小的接口上\n    \n    * 合成/聚合复用原则 -- 尽量使用合成/聚合，而不是通过继承达到复用的目的\n    \n    * 最少知识原则 或者 迪米特法则 -- 一个软件实体应当尽可能少的与其他实体发生相互作用\n\n 3. 主要有三大分类\n    \n    * 创建型模式\n    * 结构型模式\n    * 行为型模式\n    \n    \n\n\n# 有哪些常见的设计模式？\n\n常见的设计模式包括 单例模式、工厂模式、观察者模式、策略模式、模板方法模式 等。\n\n\n# 单例模式了解么？说⼀下单例模式的使用场景。手写⼀个单例模式的实现。\n\n> 什么是单例模式？\n\n单例模式是一种常见的（创建型）设计模式，它的作用是确保一个类只有一个实例，并提供一个全局的访问点。\n\n在一些需要频繁创建对象的场景下，使用单例模式可以有效地减少系统的内存开销和性能损耗。\n\n> 单例模式的使用场景\n\n单例模式的使用场景包括：\n\n 1. 当类的实例化过程比较耗时或者需要消耗较多资源时，使用单例模式可以避免重复创建实例，从而提高系统性能。\n 2. 当需要一个共享访问点来管理全局变量时，使用单例模式可以确保数据的一致性和可靠性。\n 3. 当希望避免多个实例之间的冲突和竞争时，使用单例模式可以有效地避免这些问题。\n\n> 代码实现\n\n下面是一个简单的单例模式的实现：\n\npublic class Singleton {\n private static Singleton instance;\n private Singleton() {}\n public static Singleton getInstance() {\n     if(instance == null) {\n         instance = new Singleton();\n     }\n     return instance;\n }\n}// 只有在第一次调用getInstance()方法时才会创建实例\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这是懒汉式单例模式的基本实现，在这个实现中，我们使用了一个静态变量 instance 来保存单例实例，getInstance() 方法用来获取实例。\n\n * 在第一次调用 getInstance() 方法时，instance 还没有初始化，会创建一个新的实例并返回，\n\n * 以后再次调用 getInstance() 方法时，直接返回已经创建好的实例。\n\n * 这样就可以保证整个系统中只有一个 Singleton 实例存在。\n   \n   > 饿汉式单例模式:\n   > \n   > public class Singleton {\n   > private static Singleton instance = new Singleton();\n   > private Singleton() {}\n   > public static Singleton getInstance() {\n   >   return instance;\n   > }\n   > }\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > \n   > \n   > 在这个实现中，我们直接在静态变量中初始化 Singleton 实例，并在 getInstance() 方法中返回该实例。因为 instance 在类加载时就已经创建好了，所以不存在线程安全问题。\n   > \n   > 这种实现方式的缺点是，如果 Singleton 实例的初始化需要消耗较多的资源或时间，会影响系统的性能，而且如果 Singleton 实例在整个系统中没有被使用到，也会浪费系统的资源。\n\n\n# 观察者模式了解么？说⼀下观察者模式的使⽤场景。\n\n⼯⼚模式了解么？说⼀下⼯⼚模式的使⽤场景。\n\n责任链模式了解么？\n\n哪些开源项⽬（Netty、MyBatis）中⽤到了责任链模式？怎么⽤的？\n\nSOL ID 原则了解么？\n\n简单谈谈⾃⼰对于单⼀职责原则和开闭原则的理解。\n\n阅读 Spring 源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？",normalizedContent:"# 常见设计模式总结\n\n\n# 谈谈你对设计模式的理解？\n\n 1. 设计模式是一种被广泛应用的解决问题的经验总结，它提供了一套可复用、可扩展、易于维护的解决方案。设计模式可以帮助我们更好地组织代码，提高代码质量和可读性。\n    \n    由以前的程序员在实际工作中反复使用，总结得出的经验，形成的使用的模式。\n\n 2. 有 7 个常用的软件设计原则\n    \n    * 开闭原则 -- 对扩展开放，对修改关闭\n      \n      > 你要对某个类进行加功能的时候，直接去继承这个类写一个新的类来使用，而不是在原有类上做修改\n    \n    * 单一职责原则 -- ⼀个类只负责⼀个功能领域中的相应职责\n    \n    * 里氏替换原则 -- 所有引用基类的地方必须能透明地使用其子类的对象\n    \n    * 依赖倒置原则 -- 依赖于抽象，不能依赖于具体实现\n    \n    * 接口隔离原则 -- 类之间的依赖关系应该建立在最小的接口上\n    \n    * 合成/聚合复用原则 -- 尽量使用合成/聚合，而不是通过继承达到复用的目的\n    \n    * 最少知识原则 或者 迪米特法则 -- 一个软件实体应当尽可能少的与其他实体发生相互作用\n\n 3. 主要有三大分类\n    \n    * 创建型模式\n    * 结构型模式\n    * 行为型模式\n    \n    \n\n\n# 有哪些常见的设计模式？\n\n常见的设计模式包括 单例模式、工厂模式、观察者模式、策略模式、模板方法模式 等。\n\n\n# 单例模式了解么？说⼀下单例模式的使用场景。手写⼀个单例模式的实现。\n\n> 什么是单例模式？\n\n单例模式是一种常见的（创建型）设计模式，它的作用是确保一个类只有一个实例，并提供一个全局的访问点。\n\n在一些需要频繁创建对象的场景下，使用单例模式可以有效地减少系统的内存开销和性能损耗。\n\n> 单例模式的使用场景\n\n单例模式的使用场景包括：\n\n 1. 当类的实例化过程比较耗时或者需要消耗较多资源时，使用单例模式可以避免重复创建实例，从而提高系统性能。\n 2. 当需要一个共享访问点来管理全局变量时，使用单例模式可以确保数据的一致性和可靠性。\n 3. 当希望避免多个实例之间的冲突和竞争时，使用单例模式可以有效地避免这些问题。\n\n> 代码实现\n\n下面是一个简单的单例模式的实现：\n\npublic class singleton {\n private static singleton instance;\n private singleton() {}\n public static singleton getinstance() {\n     if(instance == null) {\n         instance = new singleton();\n     }\n     return instance;\n }\n}// 只有在第一次调用getinstance()方法时才会创建实例\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这是懒汉式单例模式的基本实现，在这个实现中，我们使用了一个静态变量 instance 来保存单例实例，getinstance() 方法用来获取实例。\n\n * 在第一次调用 getinstance() 方法时，instance 还没有初始化，会创建一个新的实例并返回，\n\n * 以后再次调用 getinstance() 方法时，直接返回已经创建好的实例。\n\n * 这样就可以保证整个系统中只有一个 singleton 实例存在。\n   \n   > 饿汉式单例模式:\n   > \n   > public class singleton {\n   > private static singleton instance = new singleton();\n   > private singleton() {}\n   > public static singleton getinstance() {\n   >   return instance;\n   > }\n   > }\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > \n   > \n   > 在这个实现中，我们直接在静态变量中初始化 singleton 实例，并在 getinstance() 方法中返回该实例。因为 instance 在类加载时就已经创建好了，所以不存在线程安全问题。\n   > \n   > 这种实现方式的缺点是，如果 singleton 实例的初始化需要消耗较多的资源或时间，会影响系统的性能，而且如果 singleton 实例在整个系统中没有被使用到，也会浪费系统的资源。\n\n\n# 观察者模式了解么？说⼀下观察者模式的使⽤场景。\n\n⼯⼚模式了解么？说⼀下⼯⼚模式的使⽤场景。\n\n责任链模式了解么？\n\n哪些开源项⽬（netty、mybatis）中⽤到了责任链模式？怎么⽤的？\n\nsol id 原则了解么？\n\n简单谈谈⾃⼰对于单⼀职责原则和开闭原则的理解。\n\n阅读 spring 源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？",charsets:{cjk:!0}},{title:"nvm使用小结",frontmatter:{title:"nvm使用小结",date:"2023-05-29T15:05:37.000Z",permalink:"/pages/777b8a/"},regularPath:"/07.%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/03.nvm%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93.html",relativePath:"07.开发日常/03.nvm使用小结.md",key:"v-aa36d4ca",path:"/pages/777b8a/",headers:[{level:2,title:"使用流程",slug:"使用流程",normalizedTitle:"使用流程",charIndex:2},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:52},{level:3,title:"列出所有已安装的 node 版本",slug:"列出所有已安装的-node-版本",normalizedTitle:"列出所有已安装的 node 版本",charIndex:61},{level:3,title:"列出所有远程服务器的版本",slug:"列出所有远程服务器的版本",normalizedTitle:"列出所有远程服务器的版本",charIndex:105},{level:3,title:"显示所有可下载的版本",slug:"显示所有可下载的版本",normalizedTitle:"显示所有可下载的版本",charIndex:167},{level:3,title:"安装指定版本的 node",slug:"安装指定版本的-node",normalizedTitle:"安装指定版本的 node",charIndex:200},{level:3,title:"删除指定版本 node",slug:"删除指定版本-node",normalizedTitle:"删除指定版本 node",charIndex:279},{level:3,title:"切换 node 版本",slug:"切换-node-版本",normalizedTitle:"切换 node 版本",charIndex:320},{level:3,title:"安装指定版本的 mvn",slug:"安装指定版本的-mvn",normalizedTitle:"安装指定版本的 mvn",charIndex:354},{level:2,title:"其他命令",slug:"其他命令",normalizedTitle:"其他命令",charIndex:434}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.48,time:28799.999999999996,words:96},headersStr:"使用流程 常用命令 列出所有已安装的 node 版本 列出所有远程服务器的版本 显示所有可下载的版本 安装指定版本的 node 删除指定版本 node 切换 node 版本 安装指定版本的 mvn 其他命令",content:"# 使用流程\n\n 1. 以管理员身份运行 命令提示符 即 cmd 窗口\n 2. 输入需要的命令\n\n\n# 常用命令\n\n\n# 列出所有已安装的 node 版本\n\n * nvm ls\n * nvm list\n\n\n# 列出所有远程服务器的版本\n\n * nvm ls-remote\n * node version list -- 官方\n\n\n# 显示所有可下载的版本\n\nnvm list avaible\n\n\n# 安装指定版本的 node\n\n * nvm install [node版本号]\n * nvm install stable -- 安装最新版 node\n\n\n# 删除指定版本 node\n\nnvm uninstall [node版本号]\n\n\n# 切换 node 版本\n\nnvm use [node版本号]\n\n\n# 安装指定版本的 mvn\n\nnpm install -g npm@<version>\n\n\n1\n\n\n替换 <version> 为你想要安装的 npm 版本\n\n\n# 其他命令\n\nnvm current：当前 node 版本\n\nnvm alias [别名] [node版本号]：给不同的版本号添加别名\n\nnvm unalias [别名]：删除已定义的别名\n\nnvm alias default [node版本号]：设置默认版本",normalizedContent:"# 使用流程\n\n 1. 以管理员身份运行 命令提示符 即 cmd 窗口\n 2. 输入需要的命令\n\n\n# 常用命令\n\n\n# 列出所有已安装的 node 版本\n\n * nvm ls\n * nvm list\n\n\n# 列出所有远程服务器的版本\n\n * nvm ls-remote\n * node version list -- 官方\n\n\n# 显示所有可下载的版本\n\nnvm list avaible\n\n\n# 安装指定版本的 node\n\n * nvm install [node版本号]\n * nvm install stable -- 安装最新版 node\n\n\n# 删除指定版本 node\n\nnvm uninstall [node版本号]\n\n\n# 切换 node 版本\n\nnvm use [node版本号]\n\n\n# 安装指定版本的 mvn\n\nnpm install -g npm@<version>\n\n\n1\n\n\n替换 <version> 为你想要安装的 npm 版本\n\n\n# 其他命令\n\nnvm current：当前 node 版本\n\nnvm alias [别名] [node版本号]：给不同的版本号添加别名\n\nnvm unalias [别名]：删除已定义的别名\n\nnvm alias default [node版本号]：设置默认版本",charsets:{cjk:!0}},{title:"NoSQL基础知识小结",frontmatter:{title:"NoSQL基础知识小结",date:"2023-07-24T10:38:52.000Z",permalink:"/pages/54fc03/"},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E5%9F%BA%E7%A1%80/02.NoSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93.html",relativePath:"03.数据库/01.基础/02.NoSQL基础知识小结.md",key:"v-c14a0baa",path:"/pages/54fc03/",headers:[{level:2,title:"什么是 NoSQL?",slug:"什么是-nosql",normalizedTitle:"什么是 nosql?",charIndex:17},{level:2,title:"MySQL 和 NoSQL 的区别",slug:"mysql-和-nosql-的区别",normalizedTitle:"mysql 和 nosql 的区别",charIndex:188},{level:2,title:"NoSQL 数据库有什么优势？",slug:"nosql-数据库有什么优势",normalizedTitle:"nosql 数据库有什么优势？",charIndex:1415},{level:2,title:"NoSQL 数据库有哪些类型？",slug:"nosql-数据库有哪些类型",normalizedTitle:"nosql 数据库有哪些类型？",charIndex:1720},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2200}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:1.005,time:60300,words:201},headersStr:"什么是 NoSQL? MySQL 和 NoSQL 的区别 NoSQL 数据库有什么优势？ NoSQL 数据库有哪些类型？ 参考",content:"# NoSQL 基础知识\n\n\n# 什么是 NoSQL?\n\nNoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。\n\nNoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。\n\nNoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis\n\n\n# MySQL 和 NoSQL 的区别\n\n        MYSQL                                          NOSQL\n数据模型    使用关系型数据模型（表格结构）                                使用非关系型数据模型（键值对、文档、列族等）\n数据存储    存储在预定义的表中                                      存储在集合、文档、列族等中\n数据查询    使用结构化查询语言 (SQL)                                使用特定的查询语言或 API\n数据灵活性   需要预先定义表结构                                      无需预先定义结构，可以灵活添加字段\n数据一致性   支持 ACID 事务，保证数据一致性                             大多数 NoSQL 数据库是 BASE 模型，注重可用性和分区容错性，牺牲一致性\n可扩展性    垂直扩展或水平分片                                      水平扩展，可以通过添加节点来扩展\n扩展性能    通常在高负载时性能下降                                    可以在大规模数据时保持高性能\n关系处理    支持复杂的关系查询和连接操作                                 通常不支持复杂的关系查询\n数据模式    使用固定模式，需定义表结构                                  动态模式，无需事先定义\n主要用途    适用于结构化数据和复杂查询                                  适用于半结构化或非结构化数据，高可扩展性和大规模数据存储\n事务支持    支持原子性、一致性、隔离性和持久性 (ACID) 事务                    通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对\n                                                       ACID 事务 的支持和 MySQL 还是有所区别的。\n示例      Oracle、MySQL、Microsoft SQL Server、PostgreSQL   文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、\n                                                       HBase，图表：Neo4j、 Amazon Neptune、Giraph\n\n\n# NoSQL 数据库有什么优势？\n\n 1. **架构灵活：**NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。\n 2. **可扩展性好：**NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。\n 3. **高性能：**NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。\n 4. **拥有强大的功能：**NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。\n\n\n# NoSQL 数据库有哪些类型？\n\n主要可以分为下面四种类型：\n\n * 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。\n * 文档：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。\n * 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。\n * 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。\n\n\n\n\n# 参考\n\n * https://javaguide.cn/database/nosql.html\n * Relational vs. NoSQL data | Microsoft Learn",normalizedContent:"# nosql 基础知识\n\n\n# 什么是 nosql?\n\nnosql（not only sql 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。\n\nnosql 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。\n\nnosql 数据库代表：hbase、cassandra、mongodb、redis\n\n\n# mysql 和 nosql 的区别\n\n        mysql                                          nosql\n数据模型    使用关系型数据模型（表格结构）                                使用非关系型数据模型（键值对、文档、列族等）\n数据存储    存储在预定义的表中                                      存储在集合、文档、列族等中\n数据查询    使用结构化查询语言 (sql)                                使用特定的查询语言或 api\n数据灵活性   需要预先定义表结构                                      无需预先定义结构，可以灵活添加字段\n数据一致性   支持 acid 事务，保证数据一致性                             大多数 nosql 数据库是 base 模型，注重可用性和分区容错性，牺牲一致性\n可扩展性    垂直扩展或水平分片                                      水平扩展，可以通过添加节点来扩展\n扩展性能    通常在高负载时性能下降                                    可以在大规模数据时保持高性能\n关系处理    支持复杂的关系查询和连接操作                                 通常不支持复杂的关系查询\n数据模式    使用固定模式，需定义表结构                                  动态模式，无需事先定义\n主要用途    适用于结构化数据和复杂查询                                  适用于半结构化或非结构化数据，高可扩展性和大规模数据存储\n事务支持    支持原子性、一致性、隔离性和持久性 (acid) 事务                    通常不支持 acid 事务，为了可扩展、高性能进行了权衡，少部分支持比如 mongodb 。不过，mongodb 对\n                                                       acid 事务 的支持和 mysql 还是有所区别的。\n示例      oracle、mysql、microsoft sql server、postgresql   文档：mongodb、couchdb，键值：redis、dynamodb，宽列：cassandra、\n                                                       hbase，图表：neo4j、 amazon neptune、giraph\n\n\n# nosql 数据库有什么优势？\n\n 1. **架构灵活：**nosql 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 nosql 数据库成为半结构化和非结构化数据的理想之选。\n 2. **可扩展性好：**nosql 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。\n 3. **高性能：**nosql 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。\n 4. **拥有强大的功能：**nosql 数据库提供功能强大的 api 和数据类型，专门针对其各自的数据模型而构建。\n\n\n# nosql 数据库有哪些类型？\n\n主要可以分为下面四种类型：\n\n * 键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 nosql 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。redis 和 dynanodb 是两款非常流行的键值数据库。\n * 文档：文档数据库中的数据被存储在类似于 json（javascript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。mongodb 就是一款非常流行的文档数据库。\n * 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。neo4j 和 giraph 是两款非常流行的图形数据库。\n * 宽列：宽列存储数据库非常适合需要存储大量的数据。cassandra 和 hbase 是两款非常流行的宽列存储数据库。\n\n\n\n\n# 参考\n\n * https://javaguide.cn/database/nosql.html\n * relational vs. nosql data | microsoft learn",charsets:{cjk:!0}},{title:"虚拟机固定ip地址",frontmatter:{title:"虚拟机固定ip地址",date:"2023-07-13T22:32:42.000Z",permalink:"/pages/ee770e/"},regularPath:"/07.%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/05.%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BA%E5%AE%9Aip%E5%9C%B0%E5%9D%80.html",relativePath:"07.开发日常/05.虚拟机固定ip地址.md",key:"v-5b96df4b",path:"/pages/ee770e/",headers:[{level:2,title:"第一步",slug:"第一步",normalizedTitle:"第一步",charIndex:18},{level:2,title:"第二步",slug:"第二步",normalizedTitle:"第二步",charIndex:401},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:399}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.315,time:18900,words:63},headersStr:"第一步 第二步 参考",content:'# 虚拟机固定 IP 地址\n\n\n# 第一步\n\n 1. 进入配置文件\n\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n\n\n1\n\n 2. 下面这部分，如果有，则修改，没有则添加进去\n\nIPADDR=192.168.78.132 //这是自己要改成的ip地址\nGATEWAY=192.168.78.2 //网关\nDNS1=192.168.78.2 //DNS\nNETMASK=255.255.255.0 //子网掩码\nHWADDR=00:0C:29:86:63:0e //mac地址\n\n\n1\n2\n3\n4\n5\n\n\n 3. 然后，把 BOOTPROTO="dhcp" 修改成 BOOTPROTO="static"\n\n 4. 重启网卡\n    \n    * ifdown ens33\n    * ifup ens33\n\n如果修改之后网卡激活不成功，连接不到网络，请参考第二步\n\n\n# 第二步\n\n按顺序执行以下指令\n\nchkconfig NetworkManager off\n\nchkconfig network on\n\nservice NetworkManager stop\n\nservice network start\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 参考\n\n * 修改虚拟机的IP地址（一看就懂）_虚拟机如何修改ip地址_zjh982534314的博客\n * 解决【ens33】这个网卡一直无法激活问题_利锴毅的博客',normalizedContent:'# 虚拟机固定 ip 地址\n\n\n# 第一步\n\n 1. 进入配置文件\n\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n\n\n1\n\n 2. 下面这部分，如果有，则修改，没有则添加进去\n\nipaddr=192.168.78.132 //这是自己要改成的ip地址\ngateway=192.168.78.2 //网关\ndns1=192.168.78.2 //dns\nnetmask=255.255.255.0 //子网掩码\nhwaddr=00:0c:29:86:63:0e //mac地址\n\n\n1\n2\n3\n4\n5\n\n\n 3. 然后，把 bootproto="dhcp" 修改成 bootproto="static"\n\n 4. 重启网卡\n    \n    * ifdown ens33\n    * ifup ens33\n\n如果修改之后网卡激活不成功，连接不到网络，请参考第二步\n\n\n# 第二步\n\n按顺序执行以下指令\n\nchkconfig networkmanager off\n\nchkconfig network on\n\nservice networkmanager stop\n\nservice network start\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 参考\n\n * 修改虚拟机的ip地址（一看就懂）_虚拟机如何修改ip地址_zjh982534314的博客\n * 解决【ens33】这个网卡一直无法激活问题_利锴毅的博客',charsets:{cjk:!0}},{title:"随笔（持续更新）",frontmatter:{title:"随笔（持续更新）",date:"2023-12-04T09:38:02.000Z",permalink:"/pages/e472d1/"},regularPath:"/07.%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/04.%E9%9A%8F%E7%AC%94%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.html",relativePath:"07.开发日常/04.随笔（持续更新）.md",key:"v-7a055f2b",path:"/pages/e472d1/",headers:[{level:2,title:"2.1 Linux环境下：",slug:"_2-1-linux环境下",normalizedTitle:"2.1 linux环境下：",charIndex:1045},{level:2,title:"2.2 Windows环境下",slug:"_2-2-windows环境下",normalizedTitle:"2.2 windows环境下",charIndex:3822},{level:2,title:"第一点：要将虚拟机的网络适配器改为桥接模式",slug:"第一点-要将虚拟机的网络适配器改为桥接模式",normalizedTitle:"第一点：要将虚拟机的网络适配器改为桥接模式",charIndex:4709},{level:2,title:"第二点：配置内网环境（每个公司的内网网段不一样哦）",slug:"第二点-配置内网环境-每个公司的内网网段不一样哦",normalizedTitle:"第二点：配置内网环境（每个公司的内网网段不一样哦）",charIndex:4737},{level:2,title:"第三点：终端连接另一台机器",slug:"第三点-终端连接另一台机器",normalizedTitle:"第三点：终端连接另一台机器",charIndex:4775}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.625,time:157500,words:525},headersStr:"2.1 Linux环境下： 2.2 Windows环境下 第一点：要将虚拟机的网络适配器改为桥接模式 第二点：配置内网环境（每个公司的内网网段不一样哦） 第三点：终端连接另一台机器",content:"# 随笔（持续更新）\n\n\n# 1、某个网络有没有连通\n\n要获取某个网站的ip地址，可以通过ping它的域名就可以得到IP地址\n\n例如：我想获取百度的ip地址（Windows环境）\n\nC:\\Users\\tq>ping www.baidu.com\n\n正在 Ping www.a.shifen.com [14.119.104.189] 具有 32 字节的数据:\n来自 14.119.104.189 的回复: 字节=32 时间=6ms TTL=56\n来自 14.119.104.189 的回复: 字节=32 时间=6ms TTL=56\n来自 14.119.104.189 的回复: 字节=32 时间=6ms TTL=56\n来自 14.119.104.189 的回复: 字节=32 时间=7ms TTL=56\n\n14.119.104.189 的 Ping 统计信息:\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 6ms，最长 = 7ms，平均 = 6ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如上述cmd终端中所示的14.119.104.189就是百度的一个ip地址\n\n所以直接用命令行ping 14.119.104.189也能ping通\n\n而在Linux环境下要检查是否ping通，除了ping 14.119.104.189这个命令，还可以使用telnet但是要加上本机已经开放的端口号这里使用80端口\n\nkylin@kylin:~/桌面$ telnet 14.119.104.189 80\nTrying 14.119.104.189...\nConnected to 14.119.104.189.\nEscape character is '^]'.\nGET / HTTP/1.1\nHost:14.119.104.189\nConnection closed by foreign host.\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们发现使用虚拟机telnet百度的ip地址会出现以下画面\n\n\n\n我们输入\n\nGET / HTTP/1.1\nHost:14.119.104.189\n\n\n1\n2\n\n\n发送一个HTTP 1.1的请求，发现连接会被百度的服务器所关闭，被对方的防火墙拦截了。但是实际上已经是连通了，只是对方把我们拦截住了。\n\n\n# 2、如何查看某个端口号是否已开放\n\n\n# 2.1 Linux环境下：\n\n可以使用以下几种方法：\n\n 1. 使用 netstat 命令： 使用 netstat 命令可以列出当前系统上的网络连接和监听端口。你可以运行以下命令，将端口号替换为你要检查的端口：\n    \n    netstat -tuln | grep <端口号>\n    #例如，要检查端口 80 是否开放，可以运行：\n    netstat -tuln | grep 80\n    \n    \n    1\n    2\n    3\n    \n    \n    如果该端口处于监听状态，表示它是开放的。\n    \n    例如：\n    \n    kylin@kylin:~/桌面$ netstat -tuln\n    激活Internet连接 (仅服务器)\n    Proto Recv-Q Send-Q Local Address           Foreign Address         State      \n    tcp        0      0 0.0.0.0:139             0.0.0.0:*               LISTEN     \n    tcp        0      0 0.0.0.0:8751            0.0.0.0:*               LISTEN     \n    tcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN     \n    tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN     \n    tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     \n    tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     \n    tcp        0      0 0.0.0.0:445             0.0.0.0:*               LISTEN     \n    tcp6       0      0 :::139                  :::*                    LISTEN     \n    tcp6       0      0 ::1:53                  :::*                    LISTEN     \n    tcp6       0      0 :::22                   :::*                    LISTEN     \n    tcp6       0      0 ::1:631                 :::*                    LISTEN     \n    tcp6       0      0 :::445                  :::*                    LISTEN     \n    ......\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n    \n    根据你的 netstat -tuln 输出，可以看到正在监听的端口以及它们的状态。以下是一些端口和状态的解释：\n    \n    * 0.0.0.0:139 和 :::139：这是端口 139，通常用于 NetBIOS 会话服务，用于文件和打印共享。\n    \n    * 0.0.0.0:8751：这是一个定制端口（非标准端口），目前不清楚它的具体用途。\n    \n    * 127.0.1.1:53 和 127.0.0.1:53：这是端口 53，用于 DNS 服务，但它仅绑定到本地主机（loopback）地址。这表示 DNS 服务仅对本地主机可用。\n    \n    * 0.0.0.0:22 和 :::22：这是端口 22，用于 SSH（Secure Shell）服务，用于远程访问和管理主机。\n    \n    * 127.0.0.1:631 和 ::1:631：这是端口 631，用于 CUPS（Common Unix Printing System）服务，用于打印服务。\n    \n    * 0.0.0.0:445 和 :::445：这是端口 445，通常用于 SMB（Server Message Block）文件共享服务，用于 Windows 文件共享。\n    \n    根据输出，端口 80 并没有显示在 netstat 结果中，这意味着在默认的配置下，端口 80 当前没有正在监听的服务。如果希望开放端口 80，需要启动或配置一个 Web 服务器（如 Apache 或 Nginx）来监听端口 80。\n\n 2. 使用 ss 命令： ss 命令与 netstat 类似，也可以用来列出网络连接和监听端口。运行以下命令来检查端口是否开放，将端口号替换为你要检查的端口：\n    \n    ss -tuln | grep <端口号>\n    \n    \n    1\n    \n    \n    例如，要检查端口 80 是否开放，可以运行：\n    \n    ss -tuln | grep 80\n    \n    \n    1\n    \n    \n    如果端口处于监听状态，它就是开放的。\n\n 3. 使用 telnet 命令： 你可以使用 telnet 命令来尝试连接到特定端口。如果连接成功，表示端口是开放的。运行以下命令，将 <IP地址> 替换为目标 IP 地址，<端口号> 替换为要检查的端口号：\n    \n    telnet <IP地址> <端口号>\n    \n    \n    1\n    \n    \n    例如，要检查 IP 地址为 192.168.1.100 的主机上的端口 80 是否开放，可以运行：\n    \n    telnet 192.168.1.100 80\n    \n    \n    1\n    \n    \n    如果连接成功，表示端口是开放的。\n\n\n# 2.2 Windows环境下\n\n可以使用以下方法来查看特定端口是否开放：\n\n 1. 使用 Telnet 命令：\n    \n    打开命令提示符（Command Prompt）并运行以下命令，将 <IP地址> 替换为目标 IP 地址，<端口号> 替换为要检查的端口号：\n    \n    telnet <IP地址> <端口号>\n    \n    \n    1\n    \n    \n    例如，要检查 IP 地址为 192.168.1.100 的主机上的端口 80 是否开放，可以运行：\n    \n    telnet 192.168.1.100 80\n    \n    \n    1\n    \n    \n    如果端口是开放的，你将看到成功的连接消息。如果连接失败，表示端口可能是关闭的或受到防火墙的阻止。\n\n 2. 使用 PowerShell 的 Test-NetConnection 命令：\n    \n    打开 PowerShell 并运行以下命令，将 <IP地址> 替换为目标 IP 地址，<端口号> 替换为要检查的端口号：\n    \n    Test-NetConnection -ComputerName <IP地址> -Port <端口号>\n    \n    \n    1\n    \n    \n    例如，要检查 IP 地址为 192.168.1.100 的主机上的端口 80 是否开放，可以运行：\n    \n    Test-NetConnection -ComputerName 192.168.1.100 -Port 80\n    \n    \n    1\n    \n    \n    该命令将提供关于连接状态的信息，包括是否成功连接到该端口。\n\n这些方法可以帮助你在 Windows 环境中检查特定端口是否开放。请注意，如果你尝试连接到远程主机上的端口，确保你具有适当的权限，并且目标主机处于运行状态。如果连接失败，可能是因为防火墙或网络配置的问题。\n\n\n# 3、通过内网拉取其他电脑的文件\n\n==笔者这里是kylinV10操作系统==\n\n\n# 第一点：要将虚拟机的网络适配器改为桥接模式\n\n\n\n\n# 第二点：配置内网环境（每个公司的内网网段不一样哦）\n\n\n\n\n\n\n\n\n\n\n# 第三点：终端连接另一台机器\n\n 1. 在终端输入\n\nssh 主机名@地址\n# 比如我的是\nssh kylin@192.168.0.213\n# 然后需要输入你要远程连接的那台主机的虚拟机登陆密码\n\n\n1\n2\n3\n4\n\n\n\n\n 2. 然后在你想存放从远程拷贝过来的文件的位置打开终端\n    \n    \n\n输入命令\n\nscp -r 主机名@地址:需要拷贝的文件的路径 .\n# 笔者这里是\nscp -r kylin@192.168.0.213:/data/king_check/ .\n# 注意最后还有一个点的，指的是当前目录\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 2023.12.12 更新\n\n\n# 4、关闭麒麟系统的 kysec 安全控制\n\n不关闭这个 KylinV10SP1 系统的 kysec 安全控制，编译途中会总是需求手动允许，未允许将会报错。\n\nsudo setstatus disable\n\n\n1\n\n\n\n\n想具体了解的看一看着篇文章https://zhuanlan.zhihu.com/p/349663329\n\n\n# 5、KylinV10 系统下 VScode 1.85 版本一直闪退问题\n\n以下是笔者的麒麟版本\n\n\n\n一开始笔者直接去官网下载 deb 包版本是 November 2023 (version 1.85) 的 code_1.85.0-1701902998_amd64.deb\n\n# 先卸载系统可能自带的或者以前残留的（也可能没有自带）\nsudo apt-get --purge remove code\n# 安装\nsudo dpkg -i code_1.85.0-1701902998_amd64.deb\n# 运行打开试试\ncode\n# 很好，画面一闪而过，网上查了N天资料，试了N种办法，无法解决\n# 最后还是选择广撒网，安装旧版本的VScode\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n其实只要老版本基本都能成功，但是，它不支持 CodeGeeX 插件啊，我要你何用！果断换新一点的版本，最后选择了 code_1.74.3-1673284829_amd64.deb 版本成功！没有闪退啦\n\n这是链接：https://code.visualstudio.com/updates/v1_74\n\n\n\nOK，这个 bug 完结撒花",normalizedContent:"# 随笔（持续更新）\n\n\n# 1、某个网络有没有连通\n\n要获取某个网站的ip地址，可以通过ping它的域名就可以得到ip地址\n\n例如：我想获取百度的ip地址（windows环境）\n\nc:\\users\\tq>ping www.baidu.com\n\n正在 ping www.a.shifen.com [14.119.104.189] 具有 32 字节的数据:\n来自 14.119.104.189 的回复: 字节=32 时间=6ms ttl=56\n来自 14.119.104.189 的回复: 字节=32 时间=6ms ttl=56\n来自 14.119.104.189 的回复: 字节=32 时间=6ms ttl=56\n来自 14.119.104.189 的回复: 字节=32 时间=7ms ttl=56\n\n14.119.104.189 的 ping 统计信息:\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 6ms，最长 = 7ms，平均 = 6ms\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如上述cmd终端中所示的14.119.104.189就是百度的一个ip地址\n\n所以直接用命令行ping 14.119.104.189也能ping通\n\n而在linux环境下要检查是否ping通，除了ping 14.119.104.189这个命令，还可以使用telnet但是要加上本机已经开放的端口号这里使用80端口\n\nkylin@kylin:~/桌面$ telnet 14.119.104.189 80\ntrying 14.119.104.189...\nconnected to 14.119.104.189.\nescape character is '^]'.\nget / http/1.1\nhost:14.119.104.189\nconnection closed by foreign host.\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n我们发现使用虚拟机telnet百度的ip地址会出现以下画面\n\n\n\n我们输入\n\nget / http/1.1\nhost:14.119.104.189\n\n\n1\n2\n\n\n发送一个http 1.1的请求，发现连接会被百度的服务器所关闭，被对方的防火墙拦截了。但是实际上已经是连通了，只是对方把我们拦截住了。\n\n\n# 2、如何查看某个端口号是否已开放\n\n\n# 2.1 linux环境下：\n\n可以使用以下几种方法：\n\n 1. 使用 netstat 命令： 使用 netstat 命令可以列出当前系统上的网络连接和监听端口。你可以运行以下命令，将端口号替换为你要检查的端口：\n    \n    netstat -tuln | grep <端口号>\n    #例如，要检查端口 80 是否开放，可以运行：\n    netstat -tuln | grep 80\n    \n    \n    1\n    2\n    3\n    \n    \n    如果该端口处于监听状态，表示它是开放的。\n    \n    例如：\n    \n    kylin@kylin:~/桌面$ netstat -tuln\n    激活internet连接 (仅服务器)\n    proto recv-q send-q local address           foreign address         state      \n    tcp        0      0 0.0.0.0:139             0.0.0.0:*               listen     \n    tcp        0      0 0.0.0.0:8751            0.0.0.0:*               listen     \n    tcp        0      0 127.0.1.1:53            0.0.0.0:*               listen     \n    tcp        0      0 127.0.0.1:53            0.0.0.0:*               listen     \n    tcp        0      0 0.0.0.0:22              0.0.0.0:*               listen     \n    tcp        0      0 127.0.0.1:631           0.0.0.0:*               listen     \n    tcp        0      0 0.0.0.0:445             0.0.0.0:*               listen     \n    tcp6       0      0 :::139                  :::*                    listen     \n    tcp6       0      0 ::1:53                  :::*                    listen     \n    tcp6       0      0 :::22                   :::*                    listen     \n    tcp6       0      0 ::1:631                 :::*                    listen     \n    tcp6       0      0 :::445                  :::*                    listen     \n    ......\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n    \n    根据你的 netstat -tuln 输出，可以看到正在监听的端口以及它们的状态。以下是一些端口和状态的解释：\n    \n    * 0.0.0.0:139 和 :::139：这是端口 139，通常用于 netbios 会话服务，用于文件和打印共享。\n    \n    * 0.0.0.0:8751：这是一个定制端口（非标准端口），目前不清楚它的具体用途。\n    \n    * 127.0.1.1:53 和 127.0.0.1:53：这是端口 53，用于 dns 服务，但它仅绑定到本地主机（loopback）地址。这表示 dns 服务仅对本地主机可用。\n    \n    * 0.0.0.0:22 和 :::22：这是端口 22，用于 ssh（secure shell）服务，用于远程访问和管理主机。\n    \n    * 127.0.0.1:631 和 ::1:631：这是端口 631，用于 cups（common unix printing system）服务，用于打印服务。\n    \n    * 0.0.0.0:445 和 :::445：这是端口 445，通常用于 smb（server message block）文件共享服务，用于 windows 文件共享。\n    \n    根据输出，端口 80 并没有显示在 netstat 结果中，这意味着在默认的配置下，端口 80 当前没有正在监听的服务。如果希望开放端口 80，需要启动或配置一个 web 服务器（如 apache 或 nginx）来监听端口 80。\n\n 2. 使用 ss 命令： ss 命令与 netstat 类似，也可以用来列出网络连接和监听端口。运行以下命令来检查端口是否开放，将端口号替换为你要检查的端口：\n    \n    ss -tuln | grep <端口号>\n    \n    \n    1\n    \n    \n    例如，要检查端口 80 是否开放，可以运行：\n    \n    ss -tuln | grep 80\n    \n    \n    1\n    \n    \n    如果端口处于监听状态，它就是开放的。\n\n 3. 使用 telnet 命令： 你可以使用 telnet 命令来尝试连接到特定端口。如果连接成功，表示端口是开放的。运行以下命令，将 <ip地址> 替换为目标 ip 地址，<端口号> 替换为要检查的端口号：\n    \n    telnet <ip地址> <端口号>\n    \n    \n    1\n    \n    \n    例如，要检查 ip 地址为 192.168.1.100 的主机上的端口 80 是否开放，可以运行：\n    \n    telnet 192.168.1.100 80\n    \n    \n    1\n    \n    \n    如果连接成功，表示端口是开放的。\n\n\n# 2.2 windows环境下\n\n可以使用以下方法来查看特定端口是否开放：\n\n 1. 使用 telnet 命令：\n    \n    打开命令提示符（command prompt）并运行以下命令，将 <ip地址> 替换为目标 ip 地址，<端口号> 替换为要检查的端口号：\n    \n    telnet <ip地址> <端口号>\n    \n    \n    1\n    \n    \n    例如，要检查 ip 地址为 192.168.1.100 的主机上的端口 80 是否开放，可以运行：\n    \n    telnet 192.168.1.100 80\n    \n    \n    1\n    \n    \n    如果端口是开放的，你将看到成功的连接消息。如果连接失败，表示端口可能是关闭的或受到防火墙的阻止。\n\n 2. 使用 powershell 的 test-netconnection 命令：\n    \n    打开 powershell 并运行以下命令，将 <ip地址> 替换为目标 ip 地址，<端口号> 替换为要检查的端口号：\n    \n    test-netconnection -computername <ip地址> -port <端口号>\n    \n    \n    1\n    \n    \n    例如，要检查 ip 地址为 192.168.1.100 的主机上的端口 80 是否开放，可以运行：\n    \n    test-netconnection -computername 192.168.1.100 -port 80\n    \n    \n    1\n    \n    \n    该命令将提供关于连接状态的信息，包括是否成功连接到该端口。\n\n这些方法可以帮助你在 windows 环境中检查特定端口是否开放。请注意，如果你尝试连接到远程主机上的端口，确保你具有适当的权限，并且目标主机处于运行状态。如果连接失败，可能是因为防火墙或网络配置的问题。\n\n\n# 3、通过内网拉取其他电脑的文件\n\n==笔者这里是kylinv10操作系统==\n\n\n# 第一点：要将虚拟机的网络适配器改为桥接模式\n\n\n\n\n# 第二点：配置内网环境（每个公司的内网网段不一样哦）\n\n\n\n\n\n\n\n\n\n\n# 第三点：终端连接另一台机器\n\n 1. 在终端输入\n\nssh 主机名@地址\n# 比如我的是\nssh kylin@192.168.0.213\n# 然后需要输入你要远程连接的那台主机的虚拟机登陆密码\n\n\n1\n2\n3\n4\n\n\n\n\n 2. 然后在你想存放从远程拷贝过来的文件的位置打开终端\n    \n    \n\n输入命令\n\nscp -r 主机名@地址:需要拷贝的文件的路径 .\n# 笔者这里是\nscp -r kylin@192.168.0.213:/data/king_check/ .\n# 注意最后还有一个点的，指的是当前目录\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n\n# 2023.12.12 更新\n\n\n# 4、关闭麒麟系统的 kysec 安全控制\n\n不关闭这个 kylinv10sp1 系统的 kysec 安全控制，编译途中会总是需求手动允许，未允许将会报错。\n\nsudo setstatus disable\n\n\n1\n\n\n\n\n想具体了解的看一看着篇文章https://zhuanlan.zhihu.com/p/349663329\n\n\n# 5、kylinv10 系统下 vscode 1.85 版本一直闪退问题\n\n以下是笔者的麒麟版本\n\n\n\n一开始笔者直接去官网下载 deb 包版本是 november 2023 (version 1.85) 的 code_1.85.0-1701902998_amd64.deb\n\n# 先卸载系统可能自带的或者以前残留的（也可能没有自带）\nsudo apt-get --purge remove code\n# 安装\nsudo dpkg -i code_1.85.0-1701902998_amd64.deb\n# 运行打开试试\ncode\n# 很好，画面一闪而过，网上查了n天资料，试了n种办法，无法解决\n# 最后还是选择广撒网，安装旧版本的vscode\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n其实只要老版本基本都能成功，但是，它不支持 codegeex 插件啊，我要你何用！果断换新一点的版本，最后选择了 code_1.74.3-1673284829_amd64.deb 版本成功！没有闪退啦\n\n这是链接：https://code.visualstudio.com/updates/v1_74\n\n\n\nok，这个 bug 完结撒花",charsets:{cjk:!0}},{title:"KylinV10 将项目上传至 Github",frontmatter:{title:"KylinV10 将项目上传至 Github",date:"2023-12-15T09:57:29.000Z",permalink:"/pages/0d525d/"},regularPath:"/07.%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/07.KylinV10%20%E5%B0%86%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3%20Github.html",relativePath:"07.开发日常/07.KylinV10 将项目上传至 Github.md",key:"v-ce0f9c12",path:"/pages/0d525d/",headers:[{level:2,title:"1、先配置 SSH",slug:"_1、先配置-ssh",normalizedTitle:"1、先配置 ssh",charIndex:253},{level:3,title:"第一种（已被弃用，提一下）==不要用这种！==",slug:"第一种-已被弃用-提一下-不要用这种",normalizedTitle:"第一种（已被弃用，提一下）==不要用这种！==",charIndex:267},{level:3,title:"第二种：==ED25519密钥==(推荐)",slug:"第二种-ed25519密钥-推荐",normalizedTitle:"第二种：==ed25519密钥==(推荐)",charIndex:462},{level:2,title:"2、在 GitHub 配置 SSH 密钥",slug:"_2、在-github-配置-ssh-密钥",normalizedTitle:"2、在 github 配置 ssh 密钥",charIndex:874},{level:2,title:"3、上传项目",slug:"_3、上传项目",normalizedTitle:"3、上传项目",charIndex:1057},{level:3,title:"3.1 更新远程仓库地址：",slug:"_3-1-更新远程仓库地址",normalizedTitle:"3.1 更新远程仓库地址：",charIndex:2081},{level:3,title:"3.2 如果输入commit指令后，出现错误：",slug:"_3-2-如果输入commit指令后-出现错误",normalizedTitle:"3.2 如果输入commit指令后，出现错误：",charIndex:2303},{level:3,title:"3.3 完结",slug:"_3-3-完结",normalizedTitle:"3.3 完结",charIndex:2894}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.76,time:105600,words:352},headersStr:"1、先配置 SSH 第一种（已被弃用，提一下）==不要用这种！== 第二种：==ED25519密钥==(推荐) 2、在 GitHub 配置 SSH 密钥 3、上传项目 3.1 更新远程仓库地址： 3.2 如果输入commit指令后，出现错误： 3.3 完结",content:'# KylinV10 将项目上传至 Github\n\n> 银河麒麟操作系统 V10 是在 Ubuntu 的基础上开发的，所以适用于 Ubuntu 的也适用于 KylinV10\n\n一般上传至 GitHub，有两种方式，一种是 HTTPS，一种是 SSH，但是在 KylinV10 操作系统 HTTPS 的上传方式一般都会被拦截，所以笔者推荐大家直接用 SSH 上传至 Github ，少走弯路。\n\n没有下载 Git 的记得要先下载 Git\n\nsudo apt-get install git\n\n\n1\n\n\n\n# 1、先配置 SSH\n\n\n# 第一种（已被弃用，提一下）==不要用这种！==\n\nssh-keygen -t rsa -C "邮箱地址"\n# 例如：\nssh-keygen -t rsa -C "cliviableak@outlook.com"\n\n\n1\n2\n3\n\n\n这个 SSH 密钥算法是 SHA-1，而 GitHub 现在不再接受使用 SHA-1 算法的密钥。需要更新 SSH 密钥并使用支持更强安全性的算法。\n\n\n# 第二种：==ED25519密钥==(推荐)\n\n为了更好的安全性，建议生成一个ED25519密钥。使用以下命令生成新密钥：\n\nssh-keygen -t ed25519 -C "your_email@example.com"\n# 例如：\nssh-keygen -t ed25519 -C "cliviableak@outlook.com"\n\n\n1\n2\n3\n\n\n\n\n将新SSH密钥添加到ssh-agent： 执行以下命令将新生成的SSH密钥添加到ssh-agent中：\n\neval "$(ssh-agent -s)"\nssh-add ~/.ssh/id_ed25519\n\n\n1\n2\n\n\n将新SSH公钥添加到GitHub帐户： 复制新生成的SSH公钥的内容：\n\ngedit id_ed25519.pub\n# 如果显示未知命令，那就执行先执行下面这句\nsudo apt-get install gedit\n\n\n1\n2\n3\n\n\n\n# 2、在 GitHub 配置 SSH 密钥\n\n在 GitHub 中依次点击 Settings -> SSH and GPG keys -> New SSH key，将 id_ed25519.pub 文件中的字符串复制进去；\n\n\n\n\n\n\n\n添加完成就可以检查关联情况\n\nssh -T git@github.com\n# 输出 欢迎，说明配置成功\n\n\n1\n2\n\n\n\n\n\n# 3、上传项目\n\n先在 Github 建立好仓库，然在在终端命令行进行操作\n\n如果第一次创建仓库，啥都没有，先进入到你要上传的项目里，然后初始化\n\n比如，笔者这里想把 net_wipe 项目目录全部上传上去，那就进入 net_wipe 目录\n\n\n\n然后就可以照搬命令，改改信息就行了。\n\n笔者设置用户名和邮箱这里没有使用全局 global，因为这个环境不是我私人的，所以没有配全局变量，因此终端对话关掉以后就得重新配置，想要一劳永逸的可以将命令改为如下（其他不用变）：\n\n  git config --global user.email "you@example.com"\t# 你的 Github 的用户名\n  git config --global user.name "Your Name"\t\t\t# 你的 Github 绑定的邮箱\n\n\n1\n2\n\n\ngit init\ngit add ./\t\t\t\t\t\t\t\t\t\t# 将当前目录整个文件夹内容都添加进去\ngit config user.name "xiaose-code"\t\t\t\t# 你的 Github 的用户名\ngit config user.email "cliviableak@outlook.com"\t# 你的 Github 绑定的邮箱\ngit commit -m "你自己的注释，比如，first commit"\ngit branch -M main \t\t\t\t\t\t\t\t#改变分支命名\n\n# git remote add origin https://github.com/你的 Github 昵称/仓库名字.git\n# 例如，笔者这里是：\n# git remote add origin https://github.com/xiaose-code/Net_wipe.git\n\n# 如果用 https 连接，大概率显示连接失败4 43，尽量直接配置 SSH，用 SSH 连接\n# git remote add origin git@github.com:你的 Github 昵称/仓库名字.git\n# 例如，笔者这里是：\ngit remote add origin git@github.com:xiaose-code/Net_wipe.git\n\ngit push -u origin main\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 3.1 更新远程仓库地址：\n\n如果你之前已经添加了一个origin远程仓库，请确保它指向新的SSH地址：\n\n比如，你之前使用了：\n\ngit remote add origin https://github.com/你的 Github 昵称/仓库名字.git\n\n\n1\n\n\n那就需要使用下面这行命令：\n\ngit remote set-url origin git@github.com:你的 Github 昵称/仓库名字.git\n\n\n1\n\n\n\n# 3.2 如果输入commit指令后，出现错误：\n\n** Please tell me who you are.\nRun\n  git config --global user.email "you@example.com"\n  git config --global user.name "Your Name"\n\nto set your account\'s default identity.\nOmit --global to set the identity only in this repository.\n\nfatal: unable to auto-detect email address (got \'XXX@YYY.(none)\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这时候的解决办法是，在进行git add ./操作的路径中，实际上已经生成了一个隐藏的.git文件夹。在该路径下输入指令cd ./.git便进入.git文件夹，使用gedit或vim打开文件config，在文件末尾加入内容：\n\n[user]\n email = your email\t\t# 你的 Github 的用户名\n name = your name\t\t# 你的 Github 绑定的邮箱\n\n\n1\n2\n3\n\n\n这时候再进行commit指令，应该就可以成功了。完成后就可以等待提交了。\n\n\n# 3.3 完结\n\n',normalizedContent:'# kylinv10 将项目上传至 github\n\n> 银河麒麟操作系统 v10 是在 ubuntu 的基础上开发的，所以适用于 ubuntu 的也适用于 kylinv10\n\n一般上传至 github，有两种方式，一种是 https，一种是 ssh，但是在 kylinv10 操作系统 https 的上传方式一般都会被拦截，所以笔者推荐大家直接用 ssh 上传至 github ，少走弯路。\n\n没有下载 git 的记得要先下载 git\n\nsudo apt-get install git\n\n\n1\n\n\n\n# 1、先配置 ssh\n\n\n# 第一种（已被弃用，提一下）==不要用这种！==\n\nssh-keygen -t rsa -c "邮箱地址"\n# 例如：\nssh-keygen -t rsa -c "cliviableak@outlook.com"\n\n\n1\n2\n3\n\n\n这个 ssh 密钥算法是 sha-1，而 github 现在不再接受使用 sha-1 算法的密钥。需要更新 ssh 密钥并使用支持更强安全性的算法。\n\n\n# 第二种：==ed25519密钥==(推荐)\n\n为了更好的安全性，建议生成一个ed25519密钥。使用以下命令生成新密钥：\n\nssh-keygen -t ed25519 -c "your_email@example.com"\n# 例如：\nssh-keygen -t ed25519 -c "cliviableak@outlook.com"\n\n\n1\n2\n3\n\n\n\n\n将新ssh密钥添加到ssh-agent： 执行以下命令将新生成的ssh密钥添加到ssh-agent中：\n\neval "$(ssh-agent -s)"\nssh-add ~/.ssh/id_ed25519\n\n\n1\n2\n\n\n将新ssh公钥添加到github帐户： 复制新生成的ssh公钥的内容：\n\ngedit id_ed25519.pub\n# 如果显示未知命令，那就执行先执行下面这句\nsudo apt-get install gedit\n\n\n1\n2\n3\n\n\n\n# 2、在 github 配置 ssh 密钥\n\n在 github 中依次点击 settings -> ssh and gpg keys -> new ssh key，将 id_ed25519.pub 文件中的字符串复制进去；\n\n\n\n\n\n\n\n添加完成就可以检查关联情况\n\nssh -t git@github.com\n# 输出 欢迎，说明配置成功\n\n\n1\n2\n\n\n\n\n\n# 3、上传项目\n\n先在 github 建立好仓库，然在在终端命令行进行操作\n\n如果第一次创建仓库，啥都没有，先进入到你要上传的项目里，然后初始化\n\n比如，笔者这里想把 net_wipe 项目目录全部上传上去，那就进入 net_wipe 目录\n\n\n\n然后就可以照搬命令，改改信息就行了。\n\n笔者设置用户名和邮箱这里没有使用全局 global，因为这个环境不是我私人的，所以没有配全局变量，因此终端对话关掉以后就得重新配置，想要一劳永逸的可以将命令改为如下（其他不用变）：\n\n  git config --global user.email "you@example.com"\t# 你的 github 的用户名\n  git config --global user.name "your name"\t\t\t# 你的 github 绑定的邮箱\n\n\n1\n2\n\n\ngit init\ngit add ./\t\t\t\t\t\t\t\t\t\t# 将当前目录整个文件夹内容都添加进去\ngit config user.name "xiaose-code"\t\t\t\t# 你的 github 的用户名\ngit config user.email "cliviableak@outlook.com"\t# 你的 github 绑定的邮箱\ngit commit -m "你自己的注释，比如，first commit"\ngit branch -m main \t\t\t\t\t\t\t\t#改变分支命名\n\n# git remote add origin https://github.com/你的 github 昵称/仓库名字.git\n# 例如，笔者这里是：\n# git remote add origin https://github.com/xiaose-code/net_wipe.git\n\n# 如果用 https 连接，大概率显示连接失败4 43，尽量直接配置 ssh，用 ssh 连接\n# git remote add origin git@github.com:你的 github 昵称/仓库名字.git\n# 例如，笔者这里是：\ngit remote add origin git@github.com:xiaose-code/net_wipe.git\n\ngit push -u origin main\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 3.1 更新远程仓库地址：\n\n如果你之前已经添加了一个origin远程仓库，请确保它指向新的ssh地址：\n\n比如，你之前使用了：\n\ngit remote add origin https://github.com/你的 github 昵称/仓库名字.git\n\n\n1\n\n\n那就需要使用下面这行命令：\n\ngit remote set-url origin git@github.com:你的 github 昵称/仓库名字.git\n\n\n1\n\n\n\n# 3.2 如果输入commit指令后，出现错误：\n\n** please tell me who you are.\nrun\n  git config --global user.email "you@example.com"\n  git config --global user.name "your name"\n\nto set your account\'s default identity.\nomit --global to set the identity only in this repository.\n\nfatal: unable to auto-detect email address (got \'xxx@yyy.(none)\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这时候的解决办法是，在进行git add ./操作的路径中，实际上已经生成了一个隐藏的.git文件夹。在该路径下输入指令cd ./.git便进入.git文件夹，使用gedit或vim打开文件config，在文件末尾加入内容：\n\n[user]\n email = your email\t\t# 你的 github 的用户名\n name = your name\t\t# 你的 github 绑定的邮箱\n\n\n1\n2\n3\n\n\n这时候再进行commit指令，应该就可以成功了。完成后就可以等待提交了。\n\n\n# 3.3 完结\n\n',charsets:{cjk:!0}},{title:"KylinV10 安装 MySQL 教程（可防踩雷）",frontmatter:{title:"KylinV10 安装 MySQL 教程（可防踩雷）",date:"2023-12-21T09:59:25.000Z",permalink:"/pages/ef40f0/"},regularPath:"/07.%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/08.KylinV10%20%E5%AE%89%E8%A3%85%20MySQL%20%E6%95%99%E7%A8%8B%EF%BC%88%E5%8F%AF%E9%98%B2%E8%B8%A9%E9%9B%B7%EF%BC%89.html",relativePath:"07.开发日常/08.KylinV10 安装 MySQL 教程（可防踩雷）.md",key:"v-314cb88d",path:"/pages/ef40f0/",headers:[{level:2,title:"1、直接用 apt 快捷安装 MySQL",slug:"_1、直接用-apt-快捷安装-mysql",normalizedTitle:"1、直接用 apt 快捷安装 mysql",charIndex:33},{level:2,title:"2、KylinV10 密码正确也无法登录的情况",slug:"_2、kylinv10-密码正确也无法登录的情况",normalizedTitle:"2、kylinv10 密码正确也无法登录的情况",charIndex:446},{level:2,title:"3、修改认证方式步骤",slug:"_3、修改认证方式步骤",normalizedTitle:"3、修改认证方式步骤",charIndex:693},{level:3,title:"1、在 mysqld.cnf 最后一行里添加 skip-grant-tables",slug:"_1、在-mysqld-cnf-最后一行里添加-skip-grant-tables",normalizedTitle:"1、在 mysqld.cnf 最后一行里添加 skip-grant-tables",charIndex:717},{level:3,title:"2、重启 MySQL",slug:"_2、重启-mysql",normalizedTitle:"2、重启 mysql",charIndex:982},{level:3,title:"3、连接 MySQL",slug:"_3、连接-mysql",normalizedTitle:"3、连接 mysql",charIndex:1030},{level:3,title:"4、切换到 mysql 数据库",slug:"_4、切换到-mysql-数据库",normalizedTitle:"4、切换到 mysql 数据库",charIndex:1079},{level:3,title:"5、查看一下加密方式",slug:"_5、查看一下加密方式",normalizedTitle:"5、查看一下加密方式",charIndex:1116},{level:3,title:"6、修改加密认证方式",slug:"_6、修改加密认证方式",normalizedTitle:"6、修改加密认证方式",charIndex:1256},{level:3,title:"7、修改密码",slug:"_7、修改密码",normalizedTitle:"7、修改密码",charIndex:1363},{level:3,title:"8、退出",slug:"_8、退出",normalizedTitle:"8、退出",charIndex:1638},{level:3,title:"9、去掉 skip-grant-tables 重启 MySQL 服务",slug:"_9、去掉-skip-grant-tables-重启-mysql-服务",normalizedTitle:"9、去掉 skip-grant-tables 重启 mysql 服务",charIndex:1659},{level:3,title:"10、重启 MySQL 服务",slug:"_10、重启-mysql-服务",normalizedTitle:"10、重启 mysql 服务",charIndex:1782},{level:3,title:"11、完整的过程图",slug:"_11、完整的过程图",normalizedTitle:"11、完整的过程图",charIndex:1834},{level:2,title:"4、还不行？还有招",slug:"_4、还不行-还有招",normalizedTitle:"4、还不行？还有招",charIndex:1850},{level:3,title:"1、初始化配置，设置密码",slug:"_1、初始化配置-设置密码",normalizedTitle:"1、初始化配置，设置密码",charIndex:1864},{level:3,title:"2、检查MySQL状态",slug:"_2、检查mysql状态",normalizedTitle:"2、检查mysql状态",charIndex:3535},{level:3,title:"3、在终端连接",slug:"_3、在终端连接",normalizedTitle:"3、在终端连接",charIndex:3588},{level:2,title:"5、sqoop 导入 MySQL 中文乱码问题",slug:"_5、sqoop-导入-mysql-中文乱码问题",normalizedTitle:"5、sqoop 导入 mysql 中文乱码问题",charIndex:3636},{level:3,title:"(1)编辑配置文件。",slug:"_1-编辑配置文件。",normalizedTitle:"(1)编辑配置文件。",charIndex:3798},{level:3,title:"(2)在[mysqld]下添加一行",slug:"_2-在-mysqld-下添加一行",normalizedTitle:"(2)在[mysqld]下添加一行",charIndex:3918},{level:3,title:"(3)重启MySQL服务。",slug:"_3-重启mysql服务。",normalizedTitle:"(3)重启mysql服务。",charIndex:3972},{level:3,title:"(4)查看character_set_server设置",slug:"_4-查看character-set-server设置",normalizedTitle:"(4)查看character_set_server设置",charIndex:4018}],readingTime:{text:"3 min read",minutes:2.875,time:172500,words:575},headersStr:"1、直接用 apt 快捷安装 MySQL 2、KylinV10 密码正确也无法登录的情况 3、修改认证方式步骤 1、在 mysqld.cnf 最后一行里添加 skip-grant-tables 2、重启 MySQL 3、连接 MySQL 4、切换到 mysql 数据库 5、查看一下加密方式 6、修改加密认证方式 7、修改密码 8、退出 9、去掉 skip-grant-tables 重启 MySQL 服务 10、重启 MySQL 服务 11、完整的过程图 4、还不行？还有招 1、初始化配置，设置密码 2、检查MySQL状态 3、在终端连接 5、sqoop 导入 MySQL 中文乱码问题 (1)编辑配置文件。 (2)在[mysqld]下添加一行 (3)重启MySQL服务。 (4)查看character_set_server设置",content:"# KylinV10 安装 MySQL 教程（可防踩雷）\n\n\n# 1、直接用 apt 快捷安装 MySQL\n\n$ sudo apt-get update #更新软件源\n$ sudo apt-get install mysql-server #安装mysql\n\n\n1\n2\n\n\n然后你会发现，KylinV10 安装畅通无阻，并没有设置密码的场景，于是你一登陆，发现有密码（？哪来的密码）\n\nkylin@kylinV10:~/桌面$ mysql -u root -p\nEnter password: \nERROR 1698 (28000): Access denied for user 'root'@'localhost'\nkylin@kylinV10:~/桌面$ mysql -u root -p\nEnter password: \nERROR 1698 (28000): Access denied for user 'root'@'localhost'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2、KylinV10 密码正确也无法登录的情况\n\n这里有点问题的是，银河麒麟系统有点不同，按网上一些改密码的教程，会发现，密码该成功了，输入密码正确也无法登录，输入密码半天连接不了，也不知道是当时设置密码的时候打错了，两次都打错不应该啊。\n\n\n\n其实这里主要原因就是因为 kylinV10 的加密方式不一样，MySQL 一般是 mysql_native_password 认证方式，但是 kylinV10 的认证方式是 auth_socket。所以要先改这个，接下来教大家如何改！\n\n\n\n\n# 3、修改认证方式步骤\n\n具体操作如下：\n\n\n# 1、在 mysqld.cnf 最后一行里添加 skip-grant-tables\n\n# 使用 gedit 或者 vim 命令都可以（二选一即可）\nsudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf\n# 使用 vim 命令\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n\n\n1\n2\n3\n4\n\n\n直接在最后一行添加\n\nskip-grant-tables\n# 如下图\n\n\n1\n2\n\n\n\n\n保存后，退出，不用去管报什么错误警告，比如下图这样的\n\n\n\n\n# 2、重启 MySQL\n\nsudo service mysql restart\n\n\n1\n\n\n\n# 3、连接 MySQL\n\n# 只需要输入mysql就行，其他不用\nmysql\n\n\n1\n2\n\n\n\n# 4、切换到 mysql 数据库\n\nuse mysql;\n\n\n1\n\n\n\n# 5、查看一下加密方式\n\nselect user, plugin from user;\n\n\n1\n\n\n如果是如图 auth_socket 需要将其修改为 mysql_native_password 这就是为什么我改了几次密码，都还是无法连接成功的原因：身份验证的插件是错的。\n\n\n# 6、修改加密认证方式\n\nupdate user set plugin='mysql_native_password' where user='root';\nflush privileges;\n\n\n1\n2\n\n\n\n# 7、修改密码\n\nALTER user 'root'@'localhost' IDENTIFIED BY '123456'; //123456是新密码，改成你自己的\n# 注意 MySQL8.0是不支持 password() 函数的，所以以下命令是无效的 \n# 如果你安装的是MySQL5.x可以执行下面命令\nupdate user set authentication_string=password(\"123456\"),plugin='mysql_native_password' where user='root';\n\n\n1\n2\n3\n4\n\n\n\n# 8、退出\n\nexit;\n\n\n1\n\n\n\n# 9、去掉 skip-grant-tables 重启 MySQL 服务\n\nsudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf\n# 可以选择删除或者注释掉，注释的话在前面加个 # 就行了\n\n\n1\n2\n\n\n\n# 10、重启 MySQL 服务\n\nsudo service mysql restart\n\n\n1\n\n\n\n# 11、完整的过程图\n\n\n\n\n# 4、还不行？还有招\n\n\n# 1、初始化配置，设置密码\n\nsudo mysql_secure_installation\n\n\n1\n\n\n然后下面步骤有点多，注意认真看\n\n# 1\nSecuring the MySQL server deployment.\n\nConnecting to MySQL using a blank password.\n\nVALIDATE PASSWORD PLUGIN can be used to test passwords\nand improve security. It checks the strength of password\nand allows the users to set only those passwords which are\nsecure enough. Would you like to setup VALIDATE PASSWORD plugin?\n# 这里我选择了 No\nPress y|Y for Yes, any other key for No: No\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 2\nPlease set the password for root here...\n\nNew password: (输入密码)\n\nRe-enter new password: (重复输入)\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 3\nBy default, a MySQL installation has an anonymous user,\nallowing anyone to log into MySQL without having to have\na user account created for them. This is intended only for\ntesting, and to make the installation go a bit smoother.\nYou should remove them before moving into a production\nenvironment.\n# 我选择了 No\nRemove anonymous users? (Press y|Y for Yes, any other key for No) : No \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 4\nNormally, root should only be allowed to connect from\n\n'localhost'. This ensures that someone cannot guess at\n\nthe root password from the network...\n# 我选择了 Yes\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) : Yes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n#5\n\nBy default, MySQL comes with a database named 'test' that\n\nanyone can access...\n# 我选择了 No\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) : No\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n#6\n\nReloading the privilege tables will ensure that all changes\n\nmade so far will take effect immediately.\n# 我选择了 Yes\nReload privilege tables now? (Press y|Y for Yes, any other key for No) : Yes\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2、检查MySQL状态\n\nsystemctl status mysql.service\n\n\n1\n\n\n\n# 3、在终端连接\n\nmysql -u root -p;\n\n# 输入密码\n\n\n1\n2\n3\n\n\n\n# 5、sqoop 导入 MySQL 中文乱码问题\n\n（可以插入中文，但不能用sqoop导入中文）导致导入时中文乱码的原因是character_set_server默认设置是latin1\n\n可以单个设置修改编码方式set character_set_server=utf8;但是重启会失效，建议按以下方式修改编码方式。\n\n\n# (1)编辑配置文件。\n\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n# 或者\nsudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf\n\n\n1\n2\n3\n\n\n\n# (2)在[mysqld]下添加一行\n\ncharacter_set_server=utf8\n\n\n1\n\n\n\n# (3)重启MySQL服务。\n\nservice mysql restart\n\n\n1\n\n\n\n# (4)查看character_set_server设置\n\nshow variables like \"char%\";\n# 如下图，可以看到 character_set_server 已经变成了 utf8 了\n\n\n1\n2\n\n\n",normalizedContent:"# kylinv10 安装 mysql 教程（可防踩雷）\n\n\n# 1、直接用 apt 快捷安装 mysql\n\n$ sudo apt-get update #更新软件源\n$ sudo apt-get install mysql-server #安装mysql\n\n\n1\n2\n\n\n然后你会发现，kylinv10 安装畅通无阻，并没有设置密码的场景，于是你一登陆，发现有密码（？哪来的密码）\n\nkylin@kylinv10:~/桌面$ mysql -u root -p\nenter password: \nerror 1698 (28000): access denied for user 'root'@'localhost'\nkylin@kylinv10:~/桌面$ mysql -u root -p\nenter password: \nerror 1698 (28000): access denied for user 'root'@'localhost'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2、kylinv10 密码正确也无法登录的情况\n\n这里有点问题的是，银河麒麟系统有点不同，按网上一些改密码的教程，会发现，密码该成功了，输入密码正确也无法登录，输入密码半天连接不了，也不知道是当时设置密码的时候打错了，两次都打错不应该啊。\n\n\n\n其实这里主要原因就是因为 kylinv10 的加密方式不一样，mysql 一般是 mysql_native_password 认证方式，但是 kylinv10 的认证方式是 auth_socket。所以要先改这个，接下来教大家如何改！\n\n\n\n\n# 3、修改认证方式步骤\n\n具体操作如下：\n\n\n# 1、在 mysqld.cnf 最后一行里添加 skip-grant-tables\n\n# 使用 gedit 或者 vim 命令都可以（二选一即可）\nsudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf\n# 使用 vim 命令\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n\n\n1\n2\n3\n4\n\n\n直接在最后一行添加\n\nskip-grant-tables\n# 如下图\n\n\n1\n2\n\n\n\n\n保存后，退出，不用去管报什么错误警告，比如下图这样的\n\n\n\n\n# 2、重启 mysql\n\nsudo service mysql restart\n\n\n1\n\n\n\n# 3、连接 mysql\n\n# 只需要输入mysql就行，其他不用\nmysql\n\n\n1\n2\n\n\n\n# 4、切换到 mysql 数据库\n\nuse mysql;\n\n\n1\n\n\n\n# 5、查看一下加密方式\n\nselect user, plugin from user;\n\n\n1\n\n\n如果是如图 auth_socket 需要将其修改为 mysql_native_password 这就是为什么我改了几次密码，都还是无法连接成功的原因：身份验证的插件是错的。\n\n\n# 6、修改加密认证方式\n\nupdate user set plugin='mysql_native_password' where user='root';\nflush privileges;\n\n\n1\n2\n\n\n\n# 7、修改密码\n\nalter user 'root'@'localhost' identified by '123456'; //123456是新密码，改成你自己的\n# 注意 mysql8.0是不支持 password() 函数的，所以以下命令是无效的 \n# 如果你安装的是mysql5.x可以执行下面命令\nupdate user set authentication_string=password(\"123456\"),plugin='mysql_native_password' where user='root';\n\n\n1\n2\n3\n4\n\n\n\n# 8、退出\n\nexit;\n\n\n1\n\n\n\n# 9、去掉 skip-grant-tables 重启 mysql 服务\n\nsudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf\n# 可以选择删除或者注释掉，注释的话在前面加个 # 就行了\n\n\n1\n2\n\n\n\n# 10、重启 mysql 服务\n\nsudo service mysql restart\n\n\n1\n\n\n\n# 11、完整的过程图\n\n\n\n\n# 4、还不行？还有招\n\n\n# 1、初始化配置，设置密码\n\nsudo mysql_secure_installation\n\n\n1\n\n\n然后下面步骤有点多，注意认真看\n\n# 1\nsecuring the mysql server deployment.\n\nconnecting to mysql using a blank password.\n\nvalidate password plugin can be used to test passwords\nand improve security. it checks the strength of password\nand allows the users to set only those passwords which are\nsecure enough. would you like to setup validate password plugin?\n# 这里我选择了 no\npress y|y for yes, any other key for no: no\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 2\nplease set the password for root here...\n\nnew password: (输入密码)\n\nre-enter new password: (重复输入)\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 3\nby default, a mysql installation has an anonymous user,\nallowing anyone to log into mysql without having to have\na user account created for them. this is intended only for\ntesting, and to make the installation go a bit smoother.\nyou should remove them before moving into a production\nenvironment.\n# 我选择了 no\nremove anonymous users? (press y|y for yes, any other key for no) : no \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 4\nnormally, root should only be allowed to connect from\n\n'localhost'. this ensures that someone cannot guess at\n\nthe root password from the network...\n# 我选择了 yes\ndisallow root login remotely? (press y|y for yes, any other key for no) : yes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n#5\n\nby default, mysql comes with a database named 'test' that\n\nanyone can access...\n# 我选择了 no\nremove test database and access to it? (press y|y for yes, any other key for no) : no\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n#6\n\nreloading the privilege tables will ensure that all changes\n\nmade so far will take effect immediately.\n# 我选择了 yes\nreload privilege tables now? (press y|y for yes, any other key for no) : yes\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2、检查mysql状态\n\nsystemctl status mysql.service\n\n\n1\n\n\n\n# 3、在终端连接\n\nmysql -u root -p;\n\n# 输入密码\n\n\n1\n2\n3\n\n\n\n# 5、sqoop 导入 mysql 中文乱码问题\n\n（可以插入中文，但不能用sqoop导入中文）导致导入时中文乱码的原因是character_set_server默认设置是latin1\n\n可以单个设置修改编码方式set character_set_server=utf8;但是重启会失效，建议按以下方式修改编码方式。\n\n\n# (1)编辑配置文件。\n\nsudo vim /etc/mysql/mysql.conf.d/mysqld.cnf\n# 或者\nsudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf\n\n\n1\n2\n3\n\n\n\n# (2)在[mysqld]下添加一行\n\ncharacter_set_server=utf8\n\n\n1\n\n\n\n# (3)重启mysql服务。\n\nservice mysql restart\n\n\n1\n\n\n\n# (4)查看character_set_server设置\n\nshow variables like \"char%\";\n# 如下图，可以看到 character_set_server 已经变成了 utf8 了\n\n\n1\n2\n\n\n",charsets:{cjk:!0}},{title:"个人博客代码推送教程",frontmatter:{title:"个人博客代码推送教程",date:"2023-12-21T09:59:43.000Z",permalink:"/pages/f8640c/"},regularPath:"/07.%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/09.%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BB%A3%E7%A0%81%E6%8E%A8%E9%80%81%E6%95%99%E7%A8%8B.html",relativePath:"07.开发日常/09.个人博客代码推送教程.md",key:"v-8fdd4394",path:"/pages/f8640c/",headers:[{level:2,title:"第一种，没有设置远程库",slug:"第一种-没有设置远程库",normalizedTitle:"第一种，没有设置远程库",charIndex:243},{level:2,title:"第二种，设置远程库",slug:"第二种-设置远程库",normalizedTitle:"第二种，设置远程库",charIndex:637},{level:2,title:"后续更改继续提交的方式",slug:"后续更改继续提交的方式",normalizedTitle:"后续更改继续提交的方式",charIndex:966}],readingTime:{text:"1 min read",minutes:.89,time:53400,words:178},headersStr:"第一种，没有设置远程库 第二种，设置远程库 后续更改继续提交的方式",content:"# 个人博客代码推送教程\n\n生成静态文件 , yarn docs:build\n\nnpm run docs:build\nrm -rf ../blog/dist/*\n\n\n1\n2\n\n\n将 build 生成的 dist 目录拷贝至上一层目录中\n\ncp -rf docs/.vuepress/dist ../blog/\n\n\n1\n\n\n进入生成的文件夹\n\ncd ../blog/dist\n\n\n1\n\n\n前面都一样，只有后面有没有设置远程库才有一点不一样\n\ngit 初始化，每次初始化不影响推送\n\n\n# 第一种，没有设置远程库\n\ngit init\n\n# git add 文件名，例如\ngit add SCY_BLOG\n# 或者\ngit add -A\n\ngit commit -m 'deploy'\n\ngit branch -M main\n\n# git push -f git@github.com:USERNAME/USERNAME.github.io.git main\n# SSH 传输\ngit push -f git@github.com:xiaose-code/xiaose-code.github.io.git main\n# HTTPS 传输\ngit push -f https://github.com/xiaose-code/xiaose-code.github.io.git main\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 第二种，设置远程库\n\ngit init\n\n# git add 文件名，例如\ngit add SCY_BLOG\n# 或者\ngit add -A\n\n# 添加远程库的方式, SCY_origin 远程仓库名\ngit remote add SCY_origin git@github.com:xiaose-code/SCY_BLOG.git\n\ngit commit -m 'deploy'\n\ngit branch -M main\n\n# 最后就是 git push 的提交，因此设置了远程库，所以可以直接用下面这行命令\ngit push -u SCY_origin main\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 后续更改继续提交的方式\n\n如果在本地仓库中进行了更改，并希望将这些更改推送到远程仓库\n\n可以按照以下步骤操作：\n\n 1. 首先，确保更改已经提交到本地仓库。如果没有提交，请使用以下命令提交更改：\n    \n    git add .\n    git commit -m \"提交信息\"\n    \n    \n    1\n    2\n    \n    请将 \"提交信息\" 替换为您想要使用的提交信息。\n 2. 推送更改到远程仓库：\n    \n    git push\n    \n    \n    1\n    \n    这条命令会将本地的更改推送到与本地分支关联的远程仓库。如果已经设置了默认的远程仓库（在本例中是 SCY_origin），则只需要执行 git push 命令。如果您有多个远程仓库，需要指定远程仓库名称，如 git push SCY_origin。\n 3. 如果您想要推送指定分支的更改，可以执行以下命令：\n    \n    git push <远程仓库名称> <分支名称>\n    \n    \n    1\n    \n    例如，要将更改推送到 SCY_origin 远程仓库的 main 分支，可以使用以下命令：\n    \n    git push SCY_origin main\n    \n    \n    1\n    \n    这样，您本地的更改就会被推送到远程仓库，其他人可以从中获取这些更改。",normalizedContent:"# 个人博客代码推送教程\n\n生成静态文件 , yarn docs:build\n\nnpm run docs:build\nrm -rf ../blog/dist/*\n\n\n1\n2\n\n\n将 build 生成的 dist 目录拷贝至上一层目录中\n\ncp -rf docs/.vuepress/dist ../blog/\n\n\n1\n\n\n进入生成的文件夹\n\ncd ../blog/dist\n\n\n1\n\n\n前面都一样，只有后面有没有设置远程库才有一点不一样\n\ngit 初始化，每次初始化不影响推送\n\n\n# 第一种，没有设置远程库\n\ngit init\n\n# git add 文件名，例如\ngit add scy_blog\n# 或者\ngit add -a\n\ngit commit -m 'deploy'\n\ngit branch -m main\n\n# git push -f git@github.com:username/username.github.io.git main\n# ssh 传输\ngit push -f git@github.com:xiaose-code/xiaose-code.github.io.git main\n# https 传输\ngit push -f https://github.com/xiaose-code/xiaose-code.github.io.git main\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 第二种，设置远程库\n\ngit init\n\n# git add 文件名，例如\ngit add scy_blog\n# 或者\ngit add -a\n\n# 添加远程库的方式, scy_origin 远程仓库名\ngit remote add scy_origin git@github.com:xiaose-code/scy_blog.git\n\ngit commit -m 'deploy'\n\ngit branch -m main\n\n# 最后就是 git push 的提交，因此设置了远程库，所以可以直接用下面这行命令\ngit push -u scy_origin main\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 后续更改继续提交的方式\n\n如果在本地仓库中进行了更改，并希望将这些更改推送到远程仓库\n\n可以按照以下步骤操作：\n\n 1. 首先，确保更改已经提交到本地仓库。如果没有提交，请使用以下命令提交更改：\n    \n    git add .\n    git commit -m \"提交信息\"\n    \n    \n    1\n    2\n    \n    请将 \"提交信息\" 替换为您想要使用的提交信息。\n 2. 推送更改到远程仓库：\n    \n    git push\n    \n    \n    1\n    \n    这条命令会将本地的更改推送到与本地分支关联的远程仓库。如果已经设置了默认的远程仓库（在本例中是 scy_origin），则只需要执行 git push 命令。如果您有多个远程仓库，需要指定远程仓库名称，如 git push scy_origin。\n 3. 如果您想要推送指定分支的更改，可以执行以下命令：\n    \n    git push <远程仓库名称> <分支名称>\n    \n    \n    1\n    \n    例如，要将更改推送到 scy_origin 远程仓库的 main 分支，可以使用以下命令：\n    \n    git push scy_origin main\n    \n    \n    1\n    \n    这样，您本地的更改就会被推送到远程仓库，其他人可以从中获取这些更改。",charsets:{cjk:!0}},{title:"项目笔记",frontmatter:{title:"项目笔记",date:"2023-11-24T15:44:11.000Z",permalink:"/pages/67c5c8/"},regularPath:"/08.%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/10.%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E6%B6%88%E9%99%A4%E5%B7%A5%E5%85%B7/01.%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.html",relativePath:"08.项目笔记/10.存储介质消除工具/01.项目笔记.md",key:"v-184e2a44",path:"/pages/67c5c8/",headers:[{level:2,title:"1、项目运行",slug:"_1、项目运行",normalizedTitle:"1、项目运行",charIndex:19},{level:2,title:"2、运行效果图",slug:"_2、运行效果图",normalizedTitle:"2、运行效果图",charIndex:247},{level:3,title:"未插入U盘时",slug:"未插入u盘时",normalizedTitle:"未插入u盘时",charIndex:259},{level:3,title:"插入U盘时",slug:"插入u盘时",normalizedTitle:"插入u盘时",charIndex:260},{level:3,title:"文件粉碎页面",slug:"文件粉碎页面",normalizedTitle:"文件粉碎页面",charIndex:732},{level:3,title:"痕迹清除页面",slug:"痕迹清除页面",normalizedTitle:"痕迹清除页面",charIndex:745},{level:3,title:"磁盘清理页面",slug:"磁盘清理页面",normalizedTitle:"磁盘清理页面",charIndex:758},{level:3,title:"点击数据清除功能",slug:"点击数据清除功能",normalizedTitle:"点击数据清除功能",charIndex:771},{level:3,title:"点击打开文件功能",slug:"点击打开文件功能",normalizedTitle:"点击打开文件功能",charIndex:802},{level:3,title:"点击关于我们",slug:"点击关于我们",normalizedTitle:"点击关于我们",charIndex:817},{level:2,title:"3、每个文件实现的功能",slug:"_3、每个文件实现的功能",normalizedTitle:"3、每个文件实现的功能",charIndex:846},{level:3,title:"fileswipe.h和fileswipe.cpp",slug:"files-wipe-h和files-wipe-cpp",normalizedTitle:"fileswipe.h和fileswipe.cpp",charIndex:null},{level:3,title:"infodev.h和infodev.cpp",slug:"info-dev-h和info-dev-cpp",normalizedTitle:"infodev.h和infodev.cpp",charIndex:null},{level:3,title:"scanfiles.h和scanfiles.cpp",slug:"scan-files-h和scan-files-cpp",normalizedTitle:"scanfiles.h和scanfiles.cpp",charIndex:null},{level:3,title:"webconnect.h和webconnect.cpp",slug:"web-connect-h和web-connect-cpp",normalizedTitle:"webconnect.h和webconnect.cpp",charIndex:null},{level:3,title:"workmain.h和workmain.cpp",slug:"work-main-h和work-main-cpp",normalizedTitle:"workmain.h和workmain.cpp",charIndex:null}],readingTime:{text:"3 min read",minutes:2.915,time:174900,words:583},headersStr:"1、项目运行 2、运行效果图 未插入U盘时 插入U盘时 文件粉碎页面 痕迹清除页面 磁盘清理页面 点击数据清除功能 点击打开文件功能 点击关于我们 3、每个文件实现的功能 fileswipe.h和fileswipe.cpp infodev.h和infodev.cpp scanfiles.h和scanfiles.cpp webconnect.h和webconnect.cpp workmain.h和workmain.cpp",content:"# 存储介质信息消除工具项目\n\n\n# 1、项目运行\n\n在release文件夹下有三个环境版本，这里选择X86_64的环境\n\n\n\n先运行服务端（要先把测试用的U盘先插入连接到虚拟机）\n\nsudo ./server_wipe -f ../etc/conf/configure.txt\n\n\n1\n\n\n运行客户端\n\n./client_wipe -f ../etc/conf/configure.txt\n\n\n1\n\n\n功能一：显示系统信息\n\n功能二：文件粉碎\n\n功能三：痕迹清楚\n\n功能四：磁盘清理\n\n\n# 2、运行效果图\n\n\n# 未插入U盘时\n\n\n\n\n# 插入U盘时\n\n\n\n> 默认第一个页面是显示系统信息页面\n\n主界面的实现在wid_main.h和wid_main.cpp文件中的 wid_main 的初始化信号槽部分。\n\n它包括以下几个部分：\n\n 1. 按钮颜色和状态控制： 使用 keep_butt_col 函数保持按钮选中颜色，into_sys_op 函数在点击左侧按钮时显示对应的操作界面，get_show_wid 函数获取当前显示的操作界面。\n\n 2. 左侧按钮事件连接： 为左侧按钮连接对应事件主动发送的信号，以及左侧按钮点击事件的连接。\n\n 3. 操作按钮信号： 连接清理按钮、打开按钮、关于我们按钮和退出程序按钮的点击事件。\n\n 4. 最小化和关闭按钮： 连接最小化按钮和关闭按钮的点击事件。\n\n这段代码主要是建立了各个按钮之间的关联关系，以及按钮和对应操作界面之间的连接。在用户点击按钮时，会触发相应的操作，例如打开文件选择对话框、清理文件等。\n\n> 页面系统信息内容主要在wid_sys_info.h和wid_sys_info.cpp文件中\n\n\n\n\n# 文件粉碎页面\n\n\n\n\n# 痕迹清除页面\n\n\n\n\n# 磁盘清理页面\n\n\n\n\n# 点击数据清除功能\n\n清除之前：\n\n\n\n清除之后：\n\n\n\n\n# 点击打开文件功能\n\n\n\n\n# 点击关于我们\n\n\n\n实际就是显示一张图片，省时间\n\n\n# 3、每个文件实现的功能\n\n\n# files_wipe.h和files_wipe.cpp\n\n用于安全删除文件和目录内容，确保无法被恢复。以下是每个函数的功能总结：\n\n 1. 构造函数和析构函数：\n    \n    files_wipe();\n    ~files_wipe();\n    \n    \n    1\n    2\n    \n    * 构造函数分配一个用于文件覆盖的缓冲区，并初始化随机数生成器。\n    * 析构函数释放分配的内存。\n\n 2. wipe_file 函数：\n    \n    //粉碎文件操作\n    //粉碎文件时参数:文件名,粉碎次数\n    //粉碎磁盘时参数:文件名,粉碎次数,false(非分件不删除),进度条回调,粉碎完成回调\n    void wipe_file(string filename,int num,bool is_file = true,                   \n                   function<void(string file,int current,int num)> fn_prog = nullptr,// 进度条回调函数\n                   function<void(string file,bool finish,__off_t off)> fn_finish = nullptr,// 粉碎完成回调函数\n                   __off_t off_continue = -1, // 中断时的偏移量\n                   int num_continue = -1);// 中断时的粉碎次数\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. wipe_dir 函数：\n    \n    // 粉碎文件夹及其子目录中的文件(回调可监控正在删除的文件)\n    void wipe_dir(string path_dir,int num,\n                  function<void(string)> fn_name = nullptr);\n    \n    \n    1\n    2\n    3\n    \n    * 参数：\n      * path_dir: 待覆盖的目录。\n      * num: 覆盖的次数。\n      * fn_name: 每个文件或目录的回调函数。\n\n 4. wipe_dir 函数（重载）：\n    \n    // 粉碎一组文件夹及其子目录中的文件(回调可监控正在删除的文件)\n    void wipe_dir(vector<string> vec_name,int num,\n                  function<void(string)> fn_name = nullptr);\n    \n    \n    1\n    2\n    3\n    \n    * 参数：\n      * vec_name: 待覆盖的目录向量。\n      * num: 覆盖的次数。\n      * fn_name: 每个文件或目录的回调函数。\n\n 5. get_dir_file 函数：\n    \n    //获取目录下需要删除的所有文件与目录名称\n    vector<string> get_dir_file(string path_dir);\n    \n    \n    1\n    2\n    \n    * 参数：\n      * path_dir: 目录路径。\n    * 返回一个包含文件和子目录路径的字符串向量。\n\n 6. get_err_vec 函数：\n    \n    //获取无法打开的文件\n    vector<string> get_err_vec();\n    \n    \n    1\n    2\n    \n    * 返回最近一次执行 wipe_file 函数时出现的错误文件向量。\n\n 7. set_skip 函数：\n    \n    //跳过并结束粉碎\n    void set_skip(bool skip);\n    \n    \n    1\n    2\n    \n    * 设置是否跳过执行。如果设置为跳过，下一次执行 wipe_file 时将退出。\n\n 8. set_flush_zero、set_flush_one、set_flush_letter 函数：\n    \n    //填充随机字节块内容\n    void set_flush_zero();\n    void set_flush_one();\n    void set_flush_letter();\n    \n    \n    1\n    2\n    3\n    4\n    \n    * 分别用于设置缓冲区的内容为全零、全一、随机字母。\n\n 9. is_exist_file 函数：\n    \n    //判断文件是否存在\n    bool is_exist_file(const string &name);\n    \n    \n    1\n    2\n    \n\n\n# info_dev.h和info_dev.cpp\n\n用于获取和处理硬盘设备信息。以下是每个函数的功能总结：\n\n 1. show_dev_info 函数：\n    \n    void show_dev_info(dev_info info);  //查看结构体信息\n    \n    \n    1\n    \n\n 2. less_enter 函数：\n    \n    void less_enter(char *buf);         //从字符尾部去除换行符号\n    \n    \n    1\n    \n\n 3. get_ctos 函数：\n    \n    string get_ctos(dev_info info);     //格式转换 获取磁盘结构体信息\n    \n    \n    1\n    \n\n 4. get_info_fdisk 函数：\n    \n    vector<dev_info> get_info_fdisk();  //获取磁盘结构体信息\n    \n    \n    1\n    \n    * 通过执行 fdisk -l 命令获取系统中的硬盘设备信息。\n    * \n    * 返回一个包含硬盘设备信息结构体的向量。\n\n 5. to_vec_send 函数：\n    \n    vector<string> to_vec_send(const vector<dev_info> &vec_dev);\n    // 将硬盘设备信息结构体转换为网络传输格式的字符串向量。\n    \n    \n    1\n    2\n    \n\n\n# scan_files.h和scan_files.cpp\n\n这段代码定义了一个名为 scan_files 的类，提供了一些功能来扫描目录、获取文件和目录信息，以及判断文件类型。以下是每个函数的功能总结：\n\n 1. get_files 函数：\n    \n    // 递归的将路径下所有普通文件和目录放入容器\n    static bool get_files(const string &path,vector<string> &vec_files,vector<string> &vec_dir)\n    \n    \n    1\n    2\n    \n    * 参数1：扫描目录（绝对路径）。\n    * 参数2：存储文件路径的容器。\n    * 参数3：存储目录路径的容器。\n\n 2. get_tree_dir 函数：\n    \n    // 对 get_tree 函数的简单调用，用于获取带层级的文件目录。\n    static bool get_tree_dir(const string &path_abs,vector<tree> &vec_tree)\n    \n    \n    1\n    2\n    \n    * 参数1：扫描目录（绝对路径）。\n    * 参数2：存储文件和目录结构信息的容器。\n\n 3. get_tree 函数：\n    \n    // 递归获取带层级的文件目录，深度优先（获取当前层文件，然后进入子文件夹获取所有内容，再获取第二个子文件夹）\n    static bool get_tree(const string &abs,const string &rel,vector<tree> &vec_tree,int deep)\n    \n    \n    1\n    2\n    \n    * 参数1：扫描目录的绝对路径。\n    * 参数2：文件或目录名称。\n    * 参数3：存储文件和目录结构信息的容器。\n    * 参数4：递归深度。\n\n 4. is_dir 函数：\n    \n    //判断目录\n    static bool is_dir(string path)\n    \n    \n    1\n    2\n    \n    * 参数：待判断的路径。\n\n 5. is_file 函数：\n    \n    //判断普通文件\n    static bool is_file(string path)\n    \n    \n    1\n    2\n    \n    * 参数：待判断的路径。\n\n\n# web_connect.h和web_connect.cpp\n\nvoid on_open(const sock_unix &sock);                        //连接成功\nvoid on_message(const sock_unix &sock, const string &msg);  //接收客户端\nvoid on_close(const sock_unix &sock);                       //关闭连接\nvoid send_message(const string &msg);                       //发送消息到客户端\nfunction<void(const string &)> fn_message = nullptr;        //向外发送消息--用于工作函数接收\n\n\n1\n2\n3\n4\n5\n\n\n\n# work_main.h和work_main.cpp\n\n这段代码是 work_main 类的实现部分。以下是每个函数的主要功能概述：\n\n 1.  构造函数：\n     \n     * 初始化线程池对象 _pool_th，用于执行任务函数。\n     * 注册不同类型任务函数到 _map_task 容器，使用宏 ADD_MAP_TASK 简化注册过程。\n\n 2.  cb_message(string sjson)：\n     \n     void cb_message(string msg);                    //接收客户端消息\n     \n     \n     1\n     \n     * 通过解析传入的 JSON 字符串，提取出任务类型和任务内容。\n     * 根据任务类型查找 _map_task 容器中注册的任务函数。\n     * 将任务函数和任务内容添加到线程池中异步执行。\n\n 3.  send_msg_th(string sjson)：\n     \n     function<void(string)> fn_send_msg = nullptr;   //向外传递消息--用于发送信息到客户端\n     \n     \n     1\n     \n     * 通过互斥锁确保在多线程环境中安全地发送消息。\n     * 调用注册的外部回调函数 fn_send_msg 发送消息。\n\n 4.  task_ask_dev_back(string sjson)：\n     \n     void task_ask_dev_back(string sjson);   //磁盘设备信息反馈\n     \n     \n     1\n     \n     * 获取磁盘信息，包括硬盘设备编号、用户重命名、硬盘容量、序列号等。\n     * 转换为网络传输格式，发送给客户端。\n\n 5.  task_ask_wipe_file(string sjson)：\n     \n     void task_ask_wipe_file(string sjson);  //处理请求粉碎文件\n     \n     \n     1\n     \n     * 获取需要粉碎的文件数组和粉碎次数。\n     * 根据文件类型进行粉碎，包括单个文件和整个目录。\n     * 将粉碎结果（成功/失败的文件）和粉碎次数发送给客户端。\n\n 6.  task_ask_wipe_rule(string sjson)：\n     \n     void task_ask_wipe_rule(string sjson);  //处理请求粉碎规则\n     \n     \n     1\n     \n     * 获取需要粉碎的文件数组和粉碎次数。\n     * 将目录展开成文件数组，然后进行粉碎操作。\n     * 将粉碎结果（成功/失败的文件）发送给客户端。\n\n 7.  task_ask_wipe_disk(string sjson)：\n     \n     void task_ask_wipe_disk(string sjson);  //处理请求磁盘清理\n     \n     \n     1\n     \n     * 获取需要粉碎的磁盘数组、粉碎次数、是否为中断继续、中断时的当前粉碎次数和偏移量。\n     * 根据是否中断继续，启动或继续多个线程粉碎磁盘。\n     * 发送粉碎进度信息给客户端。\n\n 8.  task_ask_stop_disk(string sjson)：\n     \n     void task_ask_stop_disk(string sjson);  //处理停止磁盘清理\n     \n     \n     1\n     \n     * 获取需要停止的磁盘名称，从 _map_disk 中找到对应的粉碎操作，并设置停止标志。\n\n 9.  task_ask_ukey_back(string sjson)：\n     \n     void task_ask_ukey_back(string sjson);  //处理请求UKey权限\n     \n     \n     1\n     \n     * 获取 UKey 权限信息，并发送给客户端。\n\n 10. task_ask_close_back(string sjson)：\n     \n     void task_ask_close_back(string sjson);\n     \n     \n     1\n     \n\n * 处理请求关闭的任务函数，退出程序。",normalizedContent:"# 存储介质信息消除工具项目\n\n\n# 1、项目运行\n\n在release文件夹下有三个环境版本，这里选择x86_64的环境\n\n\n\n先运行服务端（要先把测试用的u盘先插入连接到虚拟机）\n\nsudo ./server_wipe -f ../etc/conf/configure.txt\n\n\n1\n\n\n运行客户端\n\n./client_wipe -f ../etc/conf/configure.txt\n\n\n1\n\n\n功能一：显示系统信息\n\n功能二：文件粉碎\n\n功能三：痕迹清楚\n\n功能四：磁盘清理\n\n\n# 2、运行效果图\n\n\n# 未插入u盘时\n\n\n\n\n# 插入u盘时\n\n\n\n> 默认第一个页面是显示系统信息页面\n\n主界面的实现在wid_main.h和wid_main.cpp文件中的 wid_main 的初始化信号槽部分。\n\n它包括以下几个部分：\n\n 1. 按钮颜色和状态控制： 使用 keep_butt_col 函数保持按钮选中颜色，into_sys_op 函数在点击左侧按钮时显示对应的操作界面，get_show_wid 函数获取当前显示的操作界面。\n\n 2. 左侧按钮事件连接： 为左侧按钮连接对应事件主动发送的信号，以及左侧按钮点击事件的连接。\n\n 3. 操作按钮信号： 连接清理按钮、打开按钮、关于我们按钮和退出程序按钮的点击事件。\n\n 4. 最小化和关闭按钮： 连接最小化按钮和关闭按钮的点击事件。\n\n这段代码主要是建立了各个按钮之间的关联关系，以及按钮和对应操作界面之间的连接。在用户点击按钮时，会触发相应的操作，例如打开文件选择对话框、清理文件等。\n\n> 页面系统信息内容主要在wid_sys_info.h和wid_sys_info.cpp文件中\n\n\n\n\n# 文件粉碎页面\n\n\n\n\n# 痕迹清除页面\n\n\n\n\n# 磁盘清理页面\n\n\n\n\n# 点击数据清除功能\n\n清除之前：\n\n\n\n清除之后：\n\n\n\n\n# 点击打开文件功能\n\n\n\n\n# 点击关于我们\n\n\n\n实际就是显示一张图片，省时间\n\n\n# 3、每个文件实现的功能\n\n\n# files_wipe.h和files_wipe.cpp\n\n用于安全删除文件和目录内容，确保无法被恢复。以下是每个函数的功能总结：\n\n 1. 构造函数和析构函数：\n    \n    files_wipe();\n    ~files_wipe();\n    \n    \n    1\n    2\n    \n    * 构造函数分配一个用于文件覆盖的缓冲区，并初始化随机数生成器。\n    * 析构函数释放分配的内存。\n\n 2. wipe_file 函数：\n    \n    //粉碎文件操作\n    //粉碎文件时参数:文件名,粉碎次数\n    //粉碎磁盘时参数:文件名,粉碎次数,false(非分件不删除),进度条回调,粉碎完成回调\n    void wipe_file(string filename,int num,bool is_file = true,                   \n                   function<void(string file,int current,int num)> fn_prog = nullptr,// 进度条回调函数\n                   function<void(string file,bool finish,__off_t off)> fn_finish = nullptr,// 粉碎完成回调函数\n                   __off_t off_continue = -1, // 中断时的偏移量\n                   int num_continue = -1);// 中断时的粉碎次数\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. wipe_dir 函数：\n    \n    // 粉碎文件夹及其子目录中的文件(回调可监控正在删除的文件)\n    void wipe_dir(string path_dir,int num,\n                  function<void(string)> fn_name = nullptr);\n    \n    \n    1\n    2\n    3\n    \n    * 参数：\n      * path_dir: 待覆盖的目录。\n      * num: 覆盖的次数。\n      * fn_name: 每个文件或目录的回调函数。\n\n 4. wipe_dir 函数（重载）：\n    \n    // 粉碎一组文件夹及其子目录中的文件(回调可监控正在删除的文件)\n    void wipe_dir(vector<string> vec_name,int num,\n                  function<void(string)> fn_name = nullptr);\n    \n    \n    1\n    2\n    3\n    \n    * 参数：\n      * vec_name: 待覆盖的目录向量。\n      * num: 覆盖的次数。\n      * fn_name: 每个文件或目录的回调函数。\n\n 5. get_dir_file 函数：\n    \n    //获取目录下需要删除的所有文件与目录名称\n    vector<string> get_dir_file(string path_dir);\n    \n    \n    1\n    2\n    \n    * 参数：\n      * path_dir: 目录路径。\n    * 返回一个包含文件和子目录路径的字符串向量。\n\n 6. get_err_vec 函数：\n    \n    //获取无法打开的文件\n    vector<string> get_err_vec();\n    \n    \n    1\n    2\n    \n    * 返回最近一次执行 wipe_file 函数时出现的错误文件向量。\n\n 7. set_skip 函数：\n    \n    //跳过并结束粉碎\n    void set_skip(bool skip);\n    \n    \n    1\n    2\n    \n    * 设置是否跳过执行。如果设置为跳过，下一次执行 wipe_file 时将退出。\n\n 8. set_flush_zero、set_flush_one、set_flush_letter 函数：\n    \n    //填充随机字节块内容\n    void set_flush_zero();\n    void set_flush_one();\n    void set_flush_letter();\n    \n    \n    1\n    2\n    3\n    4\n    \n    * 分别用于设置缓冲区的内容为全零、全一、随机字母。\n\n 9. is_exist_file 函数：\n    \n    //判断文件是否存在\n    bool is_exist_file(const string &name);\n    \n    \n    1\n    2\n    \n\n\n# info_dev.h和info_dev.cpp\n\n用于获取和处理硬盘设备信息。以下是每个函数的功能总结：\n\n 1. show_dev_info 函数：\n    \n    void show_dev_info(dev_info info);  //查看结构体信息\n    \n    \n    1\n    \n\n 2. less_enter 函数：\n    \n    void less_enter(char *buf);         //从字符尾部去除换行符号\n    \n    \n    1\n    \n\n 3. get_ctos 函数：\n    \n    string get_ctos(dev_info info);     //格式转换 获取磁盘结构体信息\n    \n    \n    1\n    \n\n 4. get_info_fdisk 函数：\n    \n    vector<dev_info> get_info_fdisk();  //获取磁盘结构体信息\n    \n    \n    1\n    \n    * 通过执行 fdisk -l 命令获取系统中的硬盘设备信息。\n    * \n    * 返回一个包含硬盘设备信息结构体的向量。\n\n 5. to_vec_send 函数：\n    \n    vector<string> to_vec_send(const vector<dev_info> &vec_dev);\n    // 将硬盘设备信息结构体转换为网络传输格式的字符串向量。\n    \n    \n    1\n    2\n    \n\n\n# scan_files.h和scan_files.cpp\n\n这段代码定义了一个名为 scan_files 的类，提供了一些功能来扫描目录、获取文件和目录信息，以及判断文件类型。以下是每个函数的功能总结：\n\n 1. get_files 函数：\n    \n    // 递归的将路径下所有普通文件和目录放入容器\n    static bool get_files(const string &path,vector<string> &vec_files,vector<string> &vec_dir)\n    \n    \n    1\n    2\n    \n    * 参数1：扫描目录（绝对路径）。\n    * 参数2：存储文件路径的容器。\n    * 参数3：存储目录路径的容器。\n\n 2. get_tree_dir 函数：\n    \n    // 对 get_tree 函数的简单调用，用于获取带层级的文件目录。\n    static bool get_tree_dir(const string &path_abs,vector<tree> &vec_tree)\n    \n    \n    1\n    2\n    \n    * 参数1：扫描目录（绝对路径）。\n    * 参数2：存储文件和目录结构信息的容器。\n\n 3. get_tree 函数：\n    \n    // 递归获取带层级的文件目录，深度优先（获取当前层文件，然后进入子文件夹获取所有内容，再获取第二个子文件夹）\n    static bool get_tree(const string &abs,const string &rel,vector<tree> &vec_tree,int deep)\n    \n    \n    1\n    2\n    \n    * 参数1：扫描目录的绝对路径。\n    * 参数2：文件或目录名称。\n    * 参数3：存储文件和目录结构信息的容器。\n    * 参数4：递归深度。\n\n 4. is_dir 函数：\n    \n    //判断目录\n    static bool is_dir(string path)\n    \n    \n    1\n    2\n    \n    * 参数：待判断的路径。\n\n 5. is_file 函数：\n    \n    //判断普通文件\n    static bool is_file(string path)\n    \n    \n    1\n    2\n    \n    * 参数：待判断的路径。\n\n\n# web_connect.h和web_connect.cpp\n\nvoid on_open(const sock_unix &sock);                        //连接成功\nvoid on_message(const sock_unix &sock, const string &msg);  //接收客户端\nvoid on_close(const sock_unix &sock);                       //关闭连接\nvoid send_message(const string &msg);                       //发送消息到客户端\nfunction<void(const string &)> fn_message = nullptr;        //向外发送消息--用于工作函数接收\n\n\n1\n2\n3\n4\n5\n\n\n\n# work_main.h和work_main.cpp\n\n这段代码是 work_main 类的实现部分。以下是每个函数的主要功能概述：\n\n 1.  构造函数：\n     \n     * 初始化线程池对象 _pool_th，用于执行任务函数。\n     * 注册不同类型任务函数到 _map_task 容器，使用宏 add_map_task 简化注册过程。\n\n 2.  cb_message(string sjson)：\n     \n     void cb_message(string msg);                    //接收客户端消息\n     \n     \n     1\n     \n     * 通过解析传入的 json 字符串，提取出任务类型和任务内容。\n     * 根据任务类型查找 _map_task 容器中注册的任务函数。\n     * 将任务函数和任务内容添加到线程池中异步执行。\n\n 3.  send_msg_th(string sjson)：\n     \n     function<void(string)> fn_send_msg = nullptr;   //向外传递消息--用于发送信息到客户端\n     \n     \n     1\n     \n     * 通过互斥锁确保在多线程环境中安全地发送消息。\n     * 调用注册的外部回调函数 fn_send_msg 发送消息。\n\n 4.  task_ask_dev_back(string sjson)：\n     \n     void task_ask_dev_back(string sjson);   //磁盘设备信息反馈\n     \n     \n     1\n     \n     * 获取磁盘信息，包括硬盘设备编号、用户重命名、硬盘容量、序列号等。\n     * 转换为网络传输格式，发送给客户端。\n\n 5.  task_ask_wipe_file(string sjson)：\n     \n     void task_ask_wipe_file(string sjson);  //处理请求粉碎文件\n     \n     \n     1\n     \n     * 获取需要粉碎的文件数组和粉碎次数。\n     * 根据文件类型进行粉碎，包括单个文件和整个目录。\n     * 将粉碎结果（成功/失败的文件）和粉碎次数发送给客户端。\n\n 6.  task_ask_wipe_rule(string sjson)：\n     \n     void task_ask_wipe_rule(string sjson);  //处理请求粉碎规则\n     \n     \n     1\n     \n     * 获取需要粉碎的文件数组和粉碎次数。\n     * 将目录展开成文件数组，然后进行粉碎操作。\n     * 将粉碎结果（成功/失败的文件）发送给客户端。\n\n 7.  task_ask_wipe_disk(string sjson)：\n     \n     void task_ask_wipe_disk(string sjson);  //处理请求磁盘清理\n     \n     \n     1\n     \n     * 获取需要粉碎的磁盘数组、粉碎次数、是否为中断继续、中断时的当前粉碎次数和偏移量。\n     * 根据是否中断继续，启动或继续多个线程粉碎磁盘。\n     * 发送粉碎进度信息给客户端。\n\n 8.  task_ask_stop_disk(string sjson)：\n     \n     void task_ask_stop_disk(string sjson);  //处理停止磁盘清理\n     \n     \n     1\n     \n     * 获取需要停止的磁盘名称，从 _map_disk 中找到对应的粉碎操作，并设置停止标志。\n\n 9.  task_ask_ukey_back(string sjson)：\n     \n     void task_ask_ukey_back(string sjson);  //处理请求ukey权限\n     \n     \n     1\n     \n     * 获取 ukey 权限信息，并发送给客户端。\n\n 10. task_ask_close_back(string sjson)：\n     \n     void task_ask_close_back(string sjson);\n     \n     \n     1\n     \n\n * 处理请求关闭的任务函数，退出程序。",charsets:{cjk:!0}},{title:"VScode 插件 CodeGeex 使用教程",frontmatter:{title:"VScode 插件 CodeGeex 使用教程",date:"2023-12-04T09:37:37.000Z",permalink:"/pages/411aa4/"},regularPath:"/07.%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8/06.VScode%20%E6%8F%92%E4%BB%B6%20CodeGeex%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html",relativePath:"07.开发日常/06.VScode 插件 CodeGeex 使用教程.md",key:"v-2e8d2abf",path:"/pages/411aa4/",headers:[{level:3,title:"使用指南（方便大家查看）",slug:"使用指南-方便大家查看",normalizedTitle:"使用指南（方便大家查看）",charIndex:181},{level:2,title:"1、工具的网站",slug:"_1、工具的网站",normalizedTitle:"1、工具的网站",charIndex:483},{level:2,title:"2、VScode 配置 CodeGeeX",slug:"_2、vscode-配置-codegeex",normalizedTitle:"2、vscode 配置 codegeex",charIndex:627},{level:3,title:"第一步：",slug:"第一步",normalizedTitle:"第一步：",charIndex:652},{level:3,title:"第二步：",slug:"第二步",normalizedTitle:"第二步：",charIndex:691},{level:3,title:"第三步：",slug:"第三步",normalizedTitle:"第三步：",charIndex:787},{level:2,title:"3、大家可能遇到的问题",slug:"_3、大家可能遇到的问题",normalizedTitle:"3、大家可能遇到的问题",charIndex:835},{level:3,title:"第一个：关闭辅助侧栏，CodeGeeX 不见了",slug:"第一个-关闭辅助侧栏-codegeex-不见了",normalizedTitle:"第一个：关闭辅助侧栏，codegeex 不见了",charIndex:851},{level:3,title:"第二个：怎么从英文转成中文？",slug:"第二个-怎么从英文转成中文",normalizedTitle:"第二个：怎么从英文转成中文？",charIndex:988},{level:3,title:"第三个：怎么退出账户",slug:"第三个-怎么退出账户",normalizedTitle:"第三个：怎么退出账户",charIndex:1080}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.485,time:29099.999999999996,words:97},headersStr:"使用指南（方便大家查看） 1、工具的网站 2、VScode 配置 CodeGeeX 第一步： 第二步： 第三步： 3、大家可能遇到的问题 第一个：关闭辅助侧栏，CodeGeeX 不见了 第二个：怎么从英文转成中文？ 第三个：怎么退出账户",content:"# VScode 插件 CodeGeex 使用教程\n\n不过在笔者看来，和国外的 Copilot 存在不小的差距，Copilot 是基于国外的大模型，能力比国内 AI 大模型要强，但要付费、还可能因为网络原因影响速度，所以国内的胜在免费（不过新用户好像每天只能提问 20 次），可以白嫖，解释代码、生成代码、优化代码、自动补充注释、自动生成单元测试代码。\n\n\n# 使用指南（方便大家查看）\n\n * /explain 翻译代码\n * /tab 生成补全代码 生成校验 提高健壮性\n * /comment 生成注释\n * /tests 生成单元测试（需要告诉 ai 测试框架及测试用例等等）\n * /fixbug 替换有问题的代码\n\n==至于写代码环境在内网的无法联网，可以自己去部署，代码是开源的，官方有私有化部署解决方案==\n\n开源：https://github.com/THUDM/CodeGeeX2\n\nJetBrains 也支持~ https://plugins.jetbrains.com/plugin/20587-codegeex（这里就不写教程了）\n\n\n# 1、工具的网站\n\n工具官网：https://codegeex.cn/zh-CN?article=1130\n\n\n\nVS Code插件安装地址：https://marketplace.visualstudio.com/items?itemName=aminer.codegeex\n\n\n\n\n# 2、VScode 配置 CodeGeeX\n\n\n# 第一步：\n\n在 VScode 的扩展商店里搜索 CodeGeeX\n\n\n\n\n# 第二步：\n\n安装之后呢左边侧边栏就会出现 CodeGeeX 的图标，但是它会占用我们的左侧边栏，我们把它移动到右边去\n\n鼠标左键按住 CodeGeeX 图标不放，拖动到右边侧边栏\n\n\n\n\n# 第三步：\n\n直到出现这个画面，就可以释放鼠标左键\n\n\n\n然后就是常规的登录就行了。\n\n\n\n\n# 3、大家可能遇到的问题\n\n\n# 第一个：关闭辅助侧栏，CodeGeeX 不见了\n\n不小心关闭辅助侧栏后，找不到 CodeGeeX ，不知道如何打开，左边侧边栏也没有，删除重装也不会显示。\n\n\n\n这时候点击查看，打开视图\n\n\n\n搜索 CodeGeeX ，点击第一个 ，然后他就会恢复在右边侧栏了\n\n\n\n\n# 第二个：怎么从英文转成中文？\n\nvscode：首选项——设置——CodeGeeX——Coodegeex.Explanation:Language Preference\n\n\n\n\n\n\n# 第三个：怎么退出账户\n\n",normalizedContent:"# vscode 插件 codegeex 使用教程\n\n不过在笔者看来，和国外的 copilot 存在不小的差距，copilot 是基于国外的大模型，能力比国内 ai 大模型要强，但要付费、还可能因为网络原因影响速度，所以国内的胜在免费（不过新用户好像每天只能提问 20 次），可以白嫖，解释代码、生成代码、优化代码、自动补充注释、自动生成单元测试代码。\n\n\n# 使用指南（方便大家查看）\n\n * /explain 翻译代码\n * /tab 生成补全代码 生成校验 提高健壮性\n * /comment 生成注释\n * /tests 生成单元测试（需要告诉 ai 测试框架及测试用例等等）\n * /fixbug 替换有问题的代码\n\n==至于写代码环境在内网的无法联网，可以自己去部署，代码是开源的，官方有私有化部署解决方案==\n\n开源：https://github.com/thudm/codegeex2\n\njetbrains 也支持~ https://plugins.jetbrains.com/plugin/20587-codegeex（这里就不写教程了）\n\n\n# 1、工具的网站\n\n工具官网：https://codegeex.cn/zh-cn?article=1130\n\n\n\nvs code插件安装地址：https://marketplace.visualstudio.com/items?itemname=aminer.codegeex\n\n\n\n\n# 2、vscode 配置 codegeex\n\n\n# 第一步：\n\n在 vscode 的扩展商店里搜索 codegeex\n\n\n\n\n# 第二步：\n\n安装之后呢左边侧边栏就会出现 codegeex 的图标，但是它会占用我们的左侧边栏，我们把它移动到右边去\n\n鼠标左键按住 codegeex 图标不放，拖动到右边侧边栏\n\n\n\n\n# 第三步：\n\n直到出现这个画面，就可以释放鼠标左键\n\n\n\n然后就是常规的登录就行了。\n\n\n\n\n# 3、大家可能遇到的问题\n\n\n# 第一个：关闭辅助侧栏，codegeex 不见了\n\n不小心关闭辅助侧栏后，找不到 codegeex ，不知道如何打开，左边侧边栏也没有，删除重装也不会显示。\n\n\n\n这时候点击查看，打开视图\n\n\n\n搜索 codegeex ，点击第一个 ，然后他就会恢复在右边侧栏了\n\n\n\n\n# 第二个：怎么从英文转成中文？\n\nvscode：首选项——设置——codegeex——coodegeex.explanation:language preference\n\n\n\n\n\n\n# 第三个：怎么退出账户\n\n",charsets:{cjk:!0}},{title:"项目解读",frontmatter:{title:"项目解读",date:"2023-11-24T15:26:22.000Z",permalink:"/pages/08dfe9/"},regularPath:"/08.%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/30.ip_file_hook/01.%E9%A1%B9%E7%9B%AE%E8%A7%A3%E8%AF%BB.html",relativePath:"08.项目笔记/30.ip_file_hook/01.项目解读.md",key:"v-d11e1d16",path:"/pages/08dfe9/",headers:[{level:2,title:"文件访问拦截功能：",slug:"文件访问拦截功能",normalizedTitle:"文件访问拦截功能：",charIndex:34},{level:2,title:"IP 地址拦截功能：",slug:"ip-地址拦截功能",normalizedTitle:"ip 地址拦截功能：",charIndex:403},{level:2,title:"inet_ntop",slug:"inet-ntop",normalizedTitle:"inet_ntop",charIndex:2790},{level:2,title:"dlsym",slug:"dlsym",normalizedTitle:"dlsym",charIndex:4194},{level:2,title:"va_start",slug:"va-start",normalizedTitle:"va_start",charIndex:4382},{level:2,title:"va_arg",slug:"va-arg",normalizedTitle:"va_arg",charIndex:4427},{level:2,title:"va_end",slug:"va-end",normalizedTitle:"va_end",charIndex:4476},{level:2,title:"sendto",slug:"sendto",normalizedTitle:"sendto",charIndex:476},{level:2,title:"realpath",slug:"realpath",normalizedTitle:"realpath",charIndex:7842},{level:2,title:"getpeername",slug:"getpeername",normalizedTitle:"getpeername",charIndex:8239},{level:2,title:"inet_ntop",slug:"inet-ntop-2",normalizedTitle:"inet_ntop",charIndex:2790},{level:2,title:"readlink",slug:"readlink",normalizedTitle:"readlink",charIndex:8922},{level:2,title:"opendir",slug:"opendir",normalizedTitle:"opendir",charIndex:9801},{level:2,title:"readdir",slug:"readdir",normalizedTitle:"readdir",charIndex:9976},{level:2,title:"atoi",slug:"atoi",normalizedTitle:"atoi",charIndex:10161}],readingTime:{text:"12 min read",minutes:11.295,time:677700,words:2259},headersStr:"文件访问拦截功能： IP 地址拦截功能： inet_ntop dlsym va_start va_arg va_end sendto realpath getpeername inet_ntop readlink opendir readdir atoi",content:'# 程序流程\n\n执行文件访问拦截和 IP 地址拦截的流程：\n\n\n# 文件访问拦截功能：\n\n 1. 当应用程序尝试执行文件操作，例如打开文件，调用的是 open 或 openat 函数。\n\n 2. 由于这两个函数已经被重定向为自定义的版本，所以实际上调用的是 open 或 openat 函数的自定义替代版本。\n\n 3. 自定义的 open 或 openat 函数首先检查传递的文件路径和执行文件操作的进程是否符合访问控制策略。\n\n 4. 它检查文件路径是否在黑名单或白名单中，并检查执行文件操作的进程是否在白名单中。如果文件或进程不符合策略，函数会拒绝文件操作。\n\n 5. 如果文件和进程都符合策略，它会记录文件访问操作的结果，然后调用真正的 open 或 openat 函数执行操作。\n\n 6. 如果文件或进程不符合策略，它会记录拒绝的结果，并设置 errno 为 EPERM，表示权限被拒绝。\n\n\n# IP 地址拦截功能：\n\n 1. 当应用程序尝试执行网络连接操作，例如使用 connect 函数或发送数据到远程主机，调用的是 connect 或 sendto 函数。\n\n 2. 与文件访问拦截类似，这两个函数也已被重定向为自定义版本，因此实际上调用的是自定义的 connect 或 sendto 函数。\n\n 3. 自定义的 connect 或 sendto 函数首先检查传递的目标 IP 地址以及执行连接或数据发送操作的进程是否符合访问控制策略。\n\n 4. 它检查 IP 地址是否在黑名单或白名单中，并检查执行操作的进程是否在白名单中。如果 IP 地址或进程不符合策略，函数会拒绝操作。\n\n 5. 如果 IP 地址和进程都符合策略，它会记录 IP 操作的结果，然后调用真正的 connect 或 sendto 函数执行操作。\n\n 6. 如果 IP 地址或进程不符合策略，它会记录拒绝的结果，并设置 errno 为 EPERM，表示权限被拒绝。\n\n总的来说，这两段代码的流程是先检查文件或 IP 地址是否符合访问控制策略，如果符合则允许操作并记录结果，如果不符合则拒绝操作并记录结果，以确保系统的安全性和遵守访问策略。\n\n\n# libhook.cpp\n\n//验证文件访问是否受到权限限制\nstatic bool\nallow_open(const char *exe, const char *path, string &return_full_path) noexcept(true)\n{\n\ttry\n\t{\n\t\t// 检查传入的参数是否为NULL\n\t\tif (exe == NULL || path == NULL)\n\t\t\treturn false;\n\n\t\t// 获取目标文件的绝对路径\n\t\tconst string real_absolute_path = get_real_path(get_absolute_path(path).c_str());\n\t\treturn_full_path = real_absolute_path;\n\n\t\t// 遍历文件黑名单，检查是否有文件受黑名单保护\n\t\tfor (auto &i : file_black_list())\n\t\t{\n\t\t\tif (i.first == real_absolute_path)\n\t\t\t{\n\t\t\t\t// 文件在黑名单中，检查程序是否在黑名单\n\t\t\t\tif (i.second.count(exe) > 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// 遍历文件白名单，检查是否有文件受白名单保护\n\t\tfor (auto &i : file_white_list())\n\t\t{\n\t\t\tif (i.first == real_absolute_path)\n\t\t\t{\n\t\t\t\t// 文件在白名单中，检查程序是否不在白名单\n\t\t\t\tif (i.second.count(exe) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 文件访问权限通过，返回true\n\t\treturn true;\n\t}\n\tcatch (...)\n\t{\n\t\t// 捕获异常，如果出现异常，也返回true\n\t\treturn true;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n * 这个函数接受两个C风格字符串（exe 和 path）以及一个字符串引用参数（return_full_path）。\n * 函数首先检查传入的exe和path是否为NULL，如果是NULL，则直接返回false，表示不允许访问。\n * 然后，它获取目标文件的绝对路径，将其保存到real_absolute_path变量中，并将其赋值给return_full_path，以便后续使用。\n * 函数接着遍历文件黑名单（file_black_list()）和文件白名单（file_white_list()），分别检查目标文件是否在黑名单或白名单中，以及程序是否在对应的名单中。\n * 如果文件在黑名单中，并且程序也在黑名单中，或者文件在白名单中，但程序不在白名单中，则返回false，表示不允许访问。\n * 最后，如果一切正常，或者在处理过程中出现异常，都会返回true，表示允许文件访问。\n\n这段代码的目的是在文件访问时检查权限，以确保只有在允许名单中的程序可以访问允许名单中的文件，并且不在黑名单中。如果条件不满足，它返回false，表示拒绝访问。\n\n//验证IPv4地址的访问权限\nstatic bool\nallow_ipv4(int sockfd, const struct sockaddr *address, socklen_t addrlen, string &return_ip) noexcept(true)\n{\n\ttry {\n\t\tchar buf[INET_ADDRSTRLEN];\n\t\t// 强制将传入的地址指针转换为IPv4地址结构\n\t\tstruct sockaddr_in *addr_in = (struct sockaddr_in *)address;\n\n\t\t// 检查地址结构长度，以及地址类型是否为IPv4\n\t\tif (addrlen < sizeof(sockaddr_in) ||\n\t\t\taddr_in->sin_family != AF_INET)\n\t\t\treturn true;\n\n\t\t// 将IPv4地址转换为可读的字符串形式\n\t\tif (inet_ntop(AF_INET, &addr_in->sin_addr, buf, sizeof(buf)) == NULL)\n\t\t\treturn true;\n\n\t\t// 将IPv4地址字符串赋值给字符串变量ip\n\t\tconst string ip = string(buf);\n\t\treturn_ip = ip;\n\n\t\t// 获取当前进程的可执行文件路径\n\t\tconst string exe = get_real_exe_by_pid(getpid());\n\n\t\t// 遍历IP地址黑名单，检查是否有IP在黑名单中\n\t\tfor (auto &i : ip_black_list())\n\t\t{\n\t\t\tif (i.first == ip)\n\t\t\t{\n\t\t\t\t// 如果IP在黑名单中，检查程序是否在黑名单中\n\t\t\t\tif (i.second.count(exe) > 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// 遍历IP地址白名单，检查是否有IP在白名单中\n\t\tfor (auto &i : ip_white_list())\n\t\t{\n\t\t\tif (i.first == ip)\n\t\t\t{\n\t\t\t\t// 如果IP在白名单中，检查程序是否不在白名单中\n\t\t\t\tif (i.second.count(exe) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// IP地址访问权限通过，返回true\n\t\treturn true;\n\t}\n\tcatch (...)\n\t{\n\t\t// 捕获异常，如果出现异常，也返回true\n\t\treturn true;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n// 检查地址结构长度，以及地址类型是否为IPv4\nif (addrlen < sizeof(sockaddr_in) || addr_in->sin_family != AF_INET)\n\treturn true;\n\n\n这段代码的目的是在处理套接字地址之前，确保传入的地址是有效的 IPv4 地址，并且包含足够的信息来处理，以避免内存越界错误或无效的操作。如果传入的地址不满足这些条件，函数将立即返回 true，表示允许访问（不进行限制）。这有助于确保代码的稳定性和安全性。\n\ntypedef int (*open_func_t)(const char *, int, ...); // 定义一个函数指针类型，用于指向与标准 open 函数具有相同参数和返回类型的函数\nint\nopen(const char *path, int flags, ...) // 重载标准 open 函数，用于拦截文件操作\n{\n\tstatic open_func_t old_open = NULL; // 静态函数指针，用于存储原始的 open 函数地址\n\tif (old_open == NULL) // 如果第一次调用这个函数\n\t\told_open = (open_func_t)dlsym(RTLD_NEXT, "open"); // 使用 dlsym 获取标准 open 函数的地址\n\n\tmode_t mode = 0; // 定义文件操作的模式\n\n\tif (flags & O_CREAT) // 如果传入的 flags 参数包含 O_CREAT 标志（表示在文件不存在时创建文件）\n\t{\n\t\tva_list args; // 定义可变参数列表\n\t\tva_start(args, flags); // 初始化可变参数列表\n\t\tmode = va_arg(args, mode_t); // 获取可变参数列表中的 mode_t 参数值\n\t\tva_end(args); // 清理可变参数列表\n\t}\n\n\tstd::string full_path; // 用于存储文件的完整路径\n\n\tif (allow_open(get_real_exe_by_pid(getpid()).c_str(), path, full_path)) // 调用 allow_open 函数检查是否允许打开文件\n\t{\n\t\tlog(RESULT::ALLOW, TYPE::FILE, full_path, get_real_exe_by_pid(getpid()), getpid()); // 记录允许的日志\n\t\treturn old_open(path, flags, mode); // 调用原始的 open 函数\n\t}\n\telse\n\t{\n\t\tlog(RESULT::DENY, TYPE::FILE, full_path, get_real_exe_by_pid(getpid()), getpid()); // 记录拒绝的日志\n\t\terrno = EPERM; // 设置 errno 为 EPERM（权限错误）\n\t\treturn -1; // 返回 -1，表示打开文件失败\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这段代码是一个重载的open函数，它用于拦截文件操作，并在操作之前进行访问控制。以下是对这段代码的解释：\n\n * typedef int (*open_func_t)(const char *, int, ...);：这行代码定义了一个函数指针类型open_func_t，该函数指针可以指向与标准open函数具有相同参数和返回类型的函数。\n\n * static open_func_t old_open = NULL;：这行代码定义了一个静态函数指针old_open，并将其初始化为NULL。这个指针将用于保存原始的open函数的地址。\n\n * if (old_open == NULL)：这是一个条件语句，用于检查old_open是否为空，如果为空，表示第一次调用这个函数。\n\n * old_open = (open_func_t)dlsym(RTLD_NEXT, "open");：在第一次调用时，这行代码使用dlsym函数获取标准open函数的地址，并将其存储在old_open函数指针中。这是为了能够在拦截函数中调用原始的open函数。\n\n * mode_t mode = 0;：这行代码定义了一个mode_t类型的变量mode，并将其初始化为0。\n\n * if (flags & O_CREAT)：这行代码检查传入的flags参数是否包含O_CREAT标志。O_CREAT标志表示在文件不存在时创建文件。如果flags包含O_CREAT，则进入条件块，否则跳过。\n\n * va_list args; va_start(args, flags); mode = va_arg(args, mode_t); va_end(args);：在包含O_CREAT标志的情况下，这部分代码使用可变参数列表来提取额外的参数。特别是，它使用va_list来存储可变参数，通过va_start来初始化列表，然后使用va_arg来获取参数的值（在这种情况下，获取了mode的值），最后通过va_end来清理列表。\n\n * std::string full_path;：这行代码定义了一个std::string类型的变量full_path，用于存储文件的完整路径。\n\n * if (allow_open(get_real_exe_by_pid(getpid()).c_str(), path, full_path))：这行代码调用allow_open函数来检查是否允许打开文件。它传递了三个参数：当前进程的可执行文件路径、传入的文件路径path，以及用于存储文件的完整路径的full_path。如果allow_open函数返回true，表示允许打开文件，那么它记录了一个允许的日志，并通过old_open调用原始的open函数。\n\n * else：如果allow_open函数返回false，表示拒绝打开文件，这行代码记录了一个拒绝的日志，并设置了errno为EPERM（表示权限错误），然后返回-1，表示打开文件失败。\n\n总之，这段代码的目的是拦截标准open函数的调用，并在打开文件之前进行访问控制。如果满足控制条件，它将允许打开文件，并调用原始的open函数。如果不满足条件，它将拒绝打开文件，并返回一个错误。这有助于实施文件访问控制策略。\n\ntypedef int (*openat_func_t)(int fd, const char *, int, ...);\nint openat(int fd, const char *path, int flags, ...)\n{\n    // 定义一个指向函数指针的变量 old_openat，并初始化为 NULL\n    static openat_func_t old_openat = NULL;\n\n    // 第一次调用时，通过 dlsym 函数获取真正的 openat 函数的地址\n    if (old_openat == NULL)\n        old_openat = (openat_func_t)dlsym(RTLD_NEXT, "openat");\n\n    // 定义文件打开权限 mode 为 0\n    mode_t mode = 0;\n\n    // 如果 flags 包含 O_CREAT 标志，获取变长参数列表中的文件权限 mode\n    if (flags & O_CREAT)\n    {\n        va_list args;\n        va_start(args, flags);\n        mode = va_arg(args, mode_t);\n        va_end(args);\n    }\n\n    std::string full_path; // 用于存储实际文件的全路径\n\n    // 调用 allow_open 函数来检查文件的访问权限\n    if (allow_open(get_real_exe_by_pid(getpid()).c_str(), path, full_path))\n    {\n        // 如果允许打开文件，记录相应的日志并调用真正的 openat 函数\n        log(RESULT::ALLOW, TYPE::FILE, full_path, get_real_exe_by_pid(getpid()), getpid());\n        return old_openat(fd, path, flags, mode);\n    }\n    else\n    {\n        // 如果不允许打开文件，记录相应的日志，设置错误号 errno 为 EPERM，并返回 -1 表示打开失败\n        log(RESULT::DENY, TYPE::FILE, full_path, get_real_exe_by_pid(getpid()), getpid());\n        errno = EPERM;\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# tool.cpp\n\nstring\nget_real_path (const char *path) // 函数名及参数说明\n{\n\tchar buf[PATH_MAX + 1]; // 声明一个字符数组用于存储路径\n\tif (realpath (path, buf) == NULL) // 调用realpath函数，将传入的路径规范化为绝对路径\n\t\treturn path; // 如果realpath调用失败，返回原始路径\n\treturn buf; // 如果realpath调用成功，返回规范化后的绝对路径\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nstring get_remote_ip_by_fd(int sockfd) noexcept(false)\n{\n    struct sockaddr_storage addr; // 声明一个套接字地址结构体，用于存储远程主机的地址信息\n    socklen_t addrlen = sizeof(addr); // 声明并初始化地址结构体的长度变量\n\n    // 获取远程主机的地址信息并存储到 addr 结构体中，如果失败则抛出异常\n    if (getpeername(sockfd, (sockaddr *)&addr, &addrlen) == -1)\n        throw SocketException();\n\n    sockaddr_in *tcp_addr = (sockaddr_in *)&addr; // 将 addr 转换为 IPv4 地址结构体\n    char ip[INET_ADDRSTRLEN]; // 用于存储 IP 地址的字符数组\n    // 将二进制形式的 IPv4 地址转换为文本形式的 IP 地址，并存储到 ip 数组中\n    if (inet_ntop(AF_INET, &tcp_addr->sin_addr, ip, sizeof(ip)) == NULL)\n        throw SocketException();\n\n    return string(ip); // 将 IP 地址转换为 Cpp 字符串并返回\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nstring get_real_exe_by_pid(pid_t pid) // 函数签名，获取指定进程的可执行文件路径\n{\n    string buf = format("/proc/%d/exe", pid); // 构造进程的符号链接路径，如 "/proc/1234/exe"\n    char exe[PATH_MAX]; // 创建一个字符数组用于存储符号链接指向的可执行文件路径\n    ssize_t nread = readlink(buf.c_str(), exe, sizeof(exe) - 1); // 通过 readlink 函数获取符号链接指向的路径\n    if (nread == -1) // 如果读取失败（返回值为-1），说明可能进程不存在或者没有符号链接\n        return string(); // 返回一个空字符串，表示获取可执行文件路径失败\n    exe[nread] = \'\\0\'; // 在字符数组的结尾添加 null 终止符，以确保它是一个以 null 结尾的 C 字符串\n    return get_real_path(exe); // 调用函数 get_real_path，以获取真实的路径并返回\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nstring get_absolute_path(const char *path) // 函数签名，用于获取绝对路径\n{\n    if (path == NULL || path[0] == \'/\') // 如果输入路径为空或已经是绝对路径，直接返回原路径\n        return path;\n    char buf[PATH_MAX + 1]; // 创建一个字符数组用于存储当前工作目录路径\n    if (getcwd(buf, sizeof(buf) - 1) == NULL) // 通过 getcwd 函数获取当前工作目录路径\n        return string(); // 如果获取失败，返回一个空字符串，表示无法获得绝对路径\n    return string(buf) + "/" + path; // 构造并返回合并后的绝对路径，将当前工作目录和输入路径拼接\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nvector<pid_t> get_all_pids() // 函数签名，用于获取系统中所有的进程ID\n{\n    vector<pid_t> pids; // 创建一个存储进程ID的向量\n    DIR *p_dir = opendir("/proc"); // 打开位于 /proc 目录下的目录流，该目录通常包含进程信息\n    if (p_dir == NULL) // 如果目录流打开失败\n        return pids; // 返回一个空向量，表示无法获取进程ID\n    for (;;)\n    {\n        dirent *p_file = readdir(p_dir); // 读取目录中的下一个条目\n        if (p_file == NULL) // 如果没有更多的条目可读\n            break; // 退出循环\n        pid_t pid; // 创建一个变量用于存储进程ID\n        if (p_file->d_type == DT_DIR && (pid = atoi(p_file->d_name)) != 0) // 如果是目录且目录名能够转换为有效的进程ID\n            pids.push_back(pid); // 将该进程ID添加到向量中\n    }\n    closedir(p_dir); // 关闭目录流，释放资源\n    return pids; // 返回包含所有有效进程ID的向量\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ptrace_tool.cpp\n\n//从目标进程的内存中读取64位整数数据（\'WORD\'类型）\n[[deprecated]]static void\nget_tracee_words (pid_t pid, WORD *src, WORD *dest, size_t len) noexcept (false)\n{\n\tfor (size_t i = 0; i < len; ++i) {\n\t\tdest[i] = ptrace (PTRACE_PEEKDATA, pid, src + i, NULL);\n\t\tif (dest[i] == -1)\n\t\t\tthrow PtraceException ();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 它接受参数 pid，要读取的数据的地址 src，以及存储读取数据的数组 dest 以及要读取的数据的长度 len。\n * 使用 ptrace 调用的 PTRACE_PEEKDATA 选项从目标进程的内存中读取数据，并将数据存储在 dest 数组中。\n * 如果读取失败，会抛出 PtraceException 异常。\n\n> PTRACE_POKEDATA 是 Linux 操作系统提供的 ptrace 系统调用的一个选项之一，它用于将数据写入远程进程的内存空间。这个选项通常用于修改目标进程的内存中的数据，允许一个进程追踪和修改另一个进程的执行状态和内存。\n\n具体解释如下：\n\n 1. ptrace 系统调用： ptrace 是一个用于进程追踪的系统调用，允许一个进程（通常是父进程）监视和控制另一个进程。通过 ptrace，一个进程可以读取和写入目标进程的寄存器、内存，以及控制目标进程的执行。\n\n 2. PTRACE_POKEDATA： PTRACE_POKEDATA 是 ptrace 的一个选项（请求），它表示要将数据写入目标进程的内存。这个选项通常与 ptrace 函数一起使用，用于修改目标进程的内存。\n\n 3. 用途： PTRACE_POKEDATA 主要用于在调试或进程注入等场景中，以编程方式修改目标进程的内存数据。例如，可以使用它来修改目标进程的变量值，注入代码，或执行其他需要改变内存数据的操作。\n\n 4. 参数： 调用 ptrace 时，需要提供目标进程的进程 ID，要写入的目标地址，以及要写入的数据。\n\n 5. 注意事项： 使用 PTRACE_POKEDATA 需要特权，通常只能由具有足够权限的进程来执行，例如，需要具有 root 或 debug 能力的权限。\n\n总之，PTRACE_POKEDATA 是 ptrace 的一个选项，用于在目标进程的内存中写入数据，通常用于调试、注入或修改目标进程的内存。\n\n//向目标进程的内存中写入64位整数数据\n[[deprecated]]static void\nset_tracee_words (pid_t pid,  WORD *src,  WORD *dest, size_t len)\n{\n\tfor (size_t i = 0; i < len; ++i) {\n\t\tif (ptrace (PTRACE_POKEDATA, pid, &dest[i], src[i]) == -1)\n\t\t\tthrow PtraceException ();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 它接受参数 pid，要写入的数据 src，以及要写入的目标地址 dest 以及数据的长度 len。\n * 使用 ptrace 调用的 PTRACE_POKEDATA 选项将数据写入目标进程的内存。\n * 如果写入失败，会抛出 PtraceException 异常。\n\n//计算目标进程内存中以"remote_str"开头的字符串的长度\nint get_tracee_strlen (pid_t pid, char *remote_str)\n{\n\tuser_regs_struct regs;\n\tint len = 0;\n\tfor (int i = 0; ; ++i) {\n\t\tWORD word = ptrace (PTRACE_PEEKDATA, pid, remote_str + i * sizeof (WORD), NULL);\n\t\tif (word == -1)\n\t\t\tthrow PtraceException ();\n\t\tchar *end = (char *) memchr (&word, \'\\0\', sizeof (word));\n\t\tif (end == NULL)\n\t\t\tlen += sizeof (WORD) / sizeof (char);\n\t\telse {\n\t\t\tlen += end - (char *) &word;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn len;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 它接受参数 pid 和 remote_str，表示目标进程的进程 ID 和指向目标进程内存的指针。\n * 通过循环逐个读取字符并查找字符串的终止符 \\0 来计算字符串的长度。\n * 如果读取失败，会抛出 PtraceException 异常。\n\n//从目标进程的内存中复制字符串并返回复制后的字符串\nchar * get_tracee_strdup (pid_t pid, char *remote_str)\n{\n\tconst int len = get_tracee_strlen (pid, remote_str);\n\tchar buf[len + 1];\n\tget_tracee_bytes (pid, remote_str, buf, len + 1);\n\treturn strdup (buf);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 此函数用于从目标进程的内存中复制字符串并返回复制后的字符串。\n * 它首先调用 get_tracee_strlen 计算字符串的长度，然后调用 get_tracee_bytes 读取字符串的字节数据。\n * 最后，它使用 strdup 函数分配新的字符串并返回。\n\n// 从目标进程的内存中读取字节数据\nvoid get_tracee_bytes (pid_t pid, void *remote_src, void *local_dest, size_t len)\n{\n\tconst int word_len = len / sizeof (WORD);\n\tfor (size_t i = 0; i < word_len ; ++i) {\n\t\tWORD ret = ptrace (PTRACE_PEEKDATA, pid, (WORD *) remote_src + i, NULL);\n\t\tif (ret == -1)\n\t\t\tthrow PtraceException ();\n\t\t( (WORD *) local_dest) [i] =  ret;\n\t}\n\tif (word_len > 1) {\n\t\tvoid *dest_last_word = (WORD *) ( (char *) local_dest + len) - 1;\n\t\tvoid *src_last_word = (WORD *) ( (char *) remote_src + len) - 1;\n\t\tif (len % sizeof (WORD) != 0) {\n\t\t\tWORD ret = ptrace (PTRACE_PEEKDATA, pid, src_last_word, NULL);\n\t\t\tif (ret == -1)\n\t\t\t\tthrow PtraceException ();\n\t\t\t* (WORD *) dest_last_word = ret;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 它接受参数 pid，指向目标进程内存的指针 remote_src，以及存储读取数据的本地缓冲区 local_dest 以及要读取的数据的长度 len。\n * 该函数首先将数据以 64 位整数（WORD）的形式逐个字的方式读取，然后将它们存储在 local_dest 中。\n * 最后，如果 len 不是 WORD 大小的整数倍，它会单独读取最后一个字。\n\n// 从目标进程的内存中读取字节数据\nvoid set_tracee_bytes (pid_t pid, void *remote_src, void *local_dest, size_t len)\n{\n\tconst int word_len = len / sizeof (WORD);\n\tfor (size_t i = 0; i < word_len ; ++i) {\n\t\tif (ptrace (PTRACE_POKEDATA, pid, (WORD *) local_dest + i, * ( (WORD *) remote_src + i)) == -1)\n\t\t\tthrow PtraceException ();\n\t}\n\tif (word_len > 1) {\n\t\tvoid *dest_last_word = (WORD *) ( (char *) local_dest + len) - 1;\n\t\tvoid *src_last_word = (WORD *) ( (char *) remote_src + len) - 1;\n\t\tif (len % sizeof (WORD) != 0) {\n\t\t\tif (ptrace (PTRACE_POKEDATA, pid,  dest_last_word, * (WORD *) src_last_word) == -1)\n\t\t\t\tthrow PtraceException ();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n它的参数和操作方式与 get_tracee_bytes 函数类似，但是它用 ptrace 调用的 PTRACE_POKEDATA 选项将数据写入目标进程的内存。\n\n\n# 总结：\n\n\n# inet_ntop\n\ninet_ntop 函数用于将二进制形式的网络地址转换为人类可读的IPv4或IPv6地址表示。\n\n其原型如下：\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n\n\n1\n\n * af：地址族（Address Family），可以是 AF_INET（IPv4）或 AF_INET6（IPv6）。\n * src：指向要转换的二进制网络地址的指针。\n * dst：指向用于存储结果的缓冲区。\n * size：dst 缓冲区的大小。\n\ninet_ntop 函数的原理是将二进制网络地址转换为可读的点分十进制（IPv4）或冒号十六进制（IPv6）表示。函数根据给定的地址族 af，采用不同的格式化方式来完成这一转换。\n\n对于 IPv4 地址（af 为 AF_INET），inet_ntop 函数将 32 位的二进制地址拆分成四个 8 位的部分，然后将它们以点分十进制的形式表示。例如，二进制地址 0x7F000001 被转换为字符串 "127.0.0.1"。\n\n对于 IPv6 地址（af 为 AF_INET6），inet_ntop 函数将 128 位的二进制地址按照冒号十六进制表示。例如，IPv6 地址 2001:0db8:85a3:0000:0000:8a2e:0370:7334 保持不变。\n\n\n# dlsym\n\ndlsym 函数是动态链接库操作的一部分，用于在共享库中查找符号（函数或变量）。其原型如下：\n\nvoid *dlsym(void *handle, const char *symbol);\n\n\n1\n\n * handle：表示已经打开的动态链接库的句柄，通常是由 dlopen 函数返回的。\n * symbol：是你想查找的符号（函数或变量）的名称。\n\ndlsym 函数的工作原理涉及以下几个步骤：\n\n 1. dlsym 函数通过 handle 参数确定要在哪个已加载的共享库中查找符号。\n 2. 它会在给定的共享库中查找具有名称 symbol 的符号。\n 3. 如果找到符号，dlsym 返回指向该符号的指针（函数指针或变量指针）；否则，返回 NULL。\n\n这个函数的主要用途是在运行时从共享库中获取函数或变量的地址，以便在程序中调用或使用它们。这是一种动态加载共享库中的函数的方法，可以在程序运行时决定使用哪个共享库，并且可以根据需要加载或卸载这些库。\n\n\n# va_start\n\nva_start 函数是 C/Cpp 标准库中的一个宏，用于在函数内部访问可变参数列表（variable argument list）。它的原型通常定义在 <cstdarg> 或 <stdarg.h> 头文件中，但是 va_start 宏的具体实现会根据编译器和平台而有所不同。\n\nva_start 宏的一般原型如下：\n\nvoid va_start(va_list ap, last_arg);\n\n\n1\n\n * va_list ap 是一个指向可变参数列表的指针，它将在函数内部用于迭代访问参数。\n * last_arg 是可变参数列表中的最后一个固定参数，用于确定可变参数列表的起始位置。\n\nva_start 宏的原理是基于编译器和体系结构的底层机制，通常使用汇编代码来实现。它的主要任务是将 va_list 指针初始化为指向参数列表中的第一个可变参数。\n\n具体实现方法取决于编译器和平台，但通常涉及以下步骤：\n\n 1. 确定固定参数的位置。编译器需要知道在参数列表中哪里是可变参数的开始位置。这通常由 last_arg 参数指定。\n\n 2. 计算可变参数列表的地址。编译器会使用一些规则来计算可变参数列表的地址。这通常涉及堆栈指针（栈帧指针）的调整和偏移计算。\n\n 3. 初始化 va_list 指针。va_start 宏会将 va_list 指针初始化为可变参数列表的起始位置，以便函数内部可以使用 va_arg 宏来访问参数。\n\n总之，va_start 宏的原理是在函数内部为可变参数列表创建一个指针，使得程序可以依次访问参数。不同编译器和平台的实现可能会有所不同，但通常都是基于底层的堆栈和内存管理机制。\n\n\n# va_arg\n\nva_arg 函数是 C/Cpp 标准库中用于访问可变参数列表（variable argument list）的宏。它的原型通常定义在 <cstdarg> 或 <stdarg.h> 头文件中，但 va_arg 宏的具体实现会根据编译器和平台而有所不同。\n\n一般情况下，va_arg 宏的原型如下：\n\ntype va_arg(va_list ap, type);\n\n\n1\n\n * va_list ap 是一个指向可变参数列表的指针，它在 va_start 函数之后初始化，用于迭代访问参数。\n * type 是要获取的参数的类型。\n\nva_arg 宏的原理是基于编译器和体系结构的底层机制，通常使用汇编代码来实现。它的主要任务是从可变参数列表中按指定类型提取参数的值。\n\n具体实现方法取决于编译器和平台，但通常涉及以下步骤：\n\n 1. 计算参数的大小。编译器需要知道参数的大小，以便正确地从堆栈中读取数据。这取决于参数的类型。\n\n 2. 更新 va_list 指针。va_arg 宏会将 va_list 指针移动到下一个参数的位置，以准备下一次调用 va_arg。\n\n 3. 从内存中读取参数值。va_arg 宏通过 va_list 指针获取参数的值，然后将指针移动到下一个参数的位置。\n\n总之，va_arg 宏的原理是在可变参数列表中按照指定的类型提取参数值。不同编译器和平台的实现可能会有所不同，但通常都是基于底层的堆栈和内存管理机制。 va_arg 宏为处理可变参数提供了一种通用的方法，使得在不知道参数个数和类型的情况下能够访问参数。\n\n\n# va_end\n\nva_end 函数是 C/Cpp 标准库中用于终止可变参数列表（variable argument list）操作的宏。它的原型通常定义在 <cstdarg> 或 <stdarg.h> 头文件中，但 va_end 宏的具体实现会根据编译器和平台而有所不同。\n\n一般情况下，va_end 宏的原型如下：\n\nvoid va_end(va_list ap);\n\n\n1\n\n * va_list ap 是一个指向可变参数列表的指针，它在 va_start 函数之后初始化。\n\nva_end 宏的原理是用于清理 va_list 指针，以便资源得到正确释放。具体实现方法取决于编译器和平台，但通常会在 va_end 中执行以下操作：\n\n 1. 将 va_list 指针设置为一个未定义或无效的状态。这意味着该指针不再指向可变参数列表中的任何参数。\n\n 2. 释放或清理 va_list 指针可能使用的任何资源。这通常涉及一些与堆栈或寄存器状态相关的操作，以确保不会出现内存泄漏或资源泄漏。\n\n总之，va_end 宏的原理是用于清理和终止可变参数列表的操作，以确保不会出现资源泄漏或其他问题。不同编译器和平台的实现方式可能有所不同，但它们的共同目标是安全地结束可变参数列表的操作。\n\n\n# sendto\n\nsendto 函数是用于将数据发送到指定的目标地址的系统调用，通常用于网络编程。它的原型如下：\n\nssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);\n\n\n1\n\n * sockfd 是套接字文件描述符，用于标识要发送数据的套接字。\n * buf 是包含要发送的数据的缓冲区。\n * len 是要发送的数据的字节数。\n * flags 是发送选项，通常可以设置为 0。\n * dest_addr 是目标地址的指针，通常是 struct sockaddr 结构的指针，包含目标地址信息。\n * addrlen 是目标地址结构的长度。\n\nsendto 函数的原理是将 buf 中的数据发送到指定的目标地址，然后返回发送的字节数。数据包将通过 sockfd 套接字发送，而 dest_addr 和 addrlen 用于指定目标地址。\n\n原理包括以下步骤：\n\n 1. 根据 sockfd 找到关联的套接字，该套接字用于数据发送。\n 2. 将 buf 缓冲区中的数据封装成数据包，同时添加目标地址信息（由 dest_addr 指定）。\n 3. 数据包被发送到目标地址，这通常涉及到网络协议栈的操作。\n 4. sendto 函数返回发送的字节数或出现的错误。\n\nsendto 可以用于 UDP 和基于 IP 的协议（例如 ICMP），以便将数据发送到指定的目标地址。通过 dest_addr 参数，您可以指定数据包要发送到的目标主机和端口。此函数常用于网络编程中，用于实现数据的发送和接收。\n\n\n# realpath\n\nrealpath 函数用于获取一个路径的绝对路径，将相对路径转换为绝对路径。其原型如下：\n\nchar *realpath(const char *path, char *resolved_path);\n\n\n1\n\n * path 是要获取绝对路径的输入路径。\n * resolved_path 是一个缓冲区，用于存储解析后的绝对路径。它可以为 NULL，如果为 NULL，realpath 函数会自动为您分配内存。\n\nrealpath 函数的原理是将输入的相对路径 path 转换为绝对路径并存储在 resolved_path 缓冲区中。如果 resolved_path 参数为 NULL，则会自动分配内存并存储绝对路径。\n\n原理包括以下步骤：\n\n 1. realpath 检查输入路径 path 是否为相对路径或绝对路径。如果 path 为绝对路径（以 / 开头），则它是其自身的绝对路径，无需进一步处理。\n 2. 如果 path 为相对路径，realpath 将获取当前工作目录，并将其与 path 连接，以得到绝对路径。\n 3. realpath 对路径中的符号链接进行解析，以获得路径的最终绝对路径。这包括将路径中的 . 和 .. 等符号链接替换为实际目录。\n 4. 最终的绝对路径存储在 resolved_path 缓冲区中，或者如果 resolved_path 为 NULL，则由 realpath 函数自动分配内存来存储绝对路径。\n 5. realpath 返回指向 resolved_path 缓冲区的指针，其中包含了输入路径的绝对路径。这个缓冲区可以被后续代码使用。\n\nrealpath 函数通常用于获取文件的绝对路径，以确保以绝对路径方式引用文件。这在文件系统操作和路径处理中非常有用，可以避免相对路径引发的问题。\n\n\n# getpeername\n\ngetpeername 函数用于获取与已连接套接字关联的远程端的地址信息。其原型如下：\n\nint getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n\n\n1\n\n * sockfd 是一个已连接套接字的文件描述符，用于表示与远程主机建立的连接。\n * addr 是一个指向 struct sockaddr 结构的指针，用于存储远程端的地址信息。\n * addrlen 是一个指向 socklen_t 类型的指针，用于存储 addr 缓冲区的长度。\n\ngetpeername 函数的原理是在套接字 sockfd 上执行操作，以获取远程端的地址信息并存储在 addr 缓冲区中。\n\n原理包括以下步骤：\n\n 1. getpeername 函数接收 sockfd，这是一个已连接套接字，表示与远程主机的连接。\n 2. 它将 addr 缓冲区用于存储远程端的地址信息。\n 3. 通过 addrlen 参数传递缓冲区的大小。\n 4. getpeername 函数将远程端的地址信息填充到 addr 缓冲区中。\n 5. 如果成功，函数返回0，否则返回-1，并在错误情况下设置 errno，以指示错误的类型。\n\ngetpeername 函数通常用于网络编程，以获取远程客户端的地址信息，以便了解与服务器建立连接的客户端。这是在服务器端套接字编程中的常见用例，用于识别连接到服务器的客户端的地址信息。\n\n\n# inet_ntop\n\ninet_ntop 函数用于将网络字节序的 IP 地址转换为人类可读的 IP 地址字符串。其原型如下：\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n\n\n1\n\n * af 是地址族参数，通常是 AF_INET 表示 IPv4 地址族或 AF_INET6 表示 IPv6 地址族。\n * src 是指向包含二进制 IP 地址的内存地址。\n * dst 是用于存储 IP 地址字符串的缓冲区。\n * size 是 dst 缓冲区的大小。\n\n原理： inet_ntop 函数的实现依赖于不同的操作系统，但其核心思想相似。它将二进制 IP 地址转换为字符串的过程通常如下：\n\n 1. 首先，函数根据地址族 (af) 来判断是 IPv4 还是 IPv6 地址。\n\n 2. 然后，它根据地址族决定如何将二进制地址解析成字符串。对于 IPv4 地址，将四个 8 位整数以点分隔的形式拼接成字符串；对于 IPv6 地址，将 16 位整数以冒号分隔的形式拼接成字符串。\n\n 3. 函数将转换后的字符串复制到 dst 缓冲区中，同时确保不会超过 size 字节的长度。\n\n 4. 如果转换成功，函数返回指向 dst 缓冲区的指针，否则返回 NULL，并在 errno 中设置相应的错误码，如 EINVAL（无效的地址族）或 ENOSPC（缓冲区不足）。\n\n需要注意的是，inet_ntop 是将二进制地址转换为可读字符串的逆过程，与之相反的函数是 inet_pton，它将字符串转换为二进制地址。这两个函数在网络编程中用于进行 IP 地址的解析和构建。\n\n\n# readlink\n\nreadlink 函数用于读取符号链接的目标路径。它的原型如下：\n\nssize_t readlink(const char *path, char *buf, size_t bufsiz);\n\n\n1\n\n * path 是要读取的符号链接文件的路径。\n * buf 是一个字符数组，用于存储目标路径。\n * bufsiz 是 buf 的大小，用于指定目标路径的最大长度。\n\n原理： readlink 函数的目的是获取符号链接文件所指向的实际目标路径。其工作原理如下：\n\n 1. 当调用 readlink 函数时，它会打开 path 所指定的符号链接文件，并尝试读取链接文件的内容。\n\n 2. 如果成功，它将读取的内容存储在 buf 中，并返回所复制的字符数，不包括 null 终止字符。如果 bufsiz 大于实际目标路径的长度，buf 中的数据将以 null 终止。\n\n 3. 如果读取的内容超过了 buf 的容量（bufsiz 不足以容纳目标路径），readlink 函数会截断目标路径并返回截断后的字符数。此时，buf 中的数据仍以 null 终止。\n\n 4. 如果读取符号链接文件失败，readlink 函数返回 -1，并在 errno 中设置相应的错误码，如 EACCES（权限不足）或 ENOENT（文件不存在）。\n\n需要注意的是，readlink 仅适用于符号链接文件。对于硬链接或普通文件，它不起作用。符号链接是一种特殊类型的文件，其中包含对其他文件或目录的路径引用，因此读取它的内容通常是获取所引用文件的路径。\n\n\n# opendir\n\nopendir 函数用于打开指定目录并返回一个指向目录流（DIR 结构体的指针）的句柄，以便后续对目录中的文件和子目录进行遍历。其原型如下：\n\nDIR *opendir(const char *dirname);\n\n\n1\n\n * dirname 是一个字符串，表示要打开的目录的路径名。\n\n原理：\n\n 1. 当调用 opendir 函数时，它会尝试打开指定路径的目录。\n\n 2. 如果成功，opendir 返回一个指向 DIR 结构体的指针，该结构体用于表示打开的目录流。这个结构体包含有关目录的信息，如目录的文件描述符和目录项列表。\n\n 3. 目录流句柄可以用于后续的目录遍历操作，例如使用 readdir 函数读取目录中的文件和子目录项。\n\n 4. 如果打开目录失败，opendir 返回 NULL，表示出现了错误。在这种情况下，通常可以使用 errno 来获取出错的详细信息，例如 ENOENT 表示指定的目录不存在，EACCES 表示无权限访问目录等。\n\nopendir 和 readdir 函数通常用于目录遍历操作，允许程序在目录中查找文件和子目录，并对它们进行处理。这对于编写文件管理和操作系统相关的程序非常有用。\n\n\n# readdir\n\nreaddir 函数用于从已打开的目录流中读取下一个目录项。其原型如下：\n\nstruct dirent *readdir(DIR *dirp);\n\n\n1\n\n\n * dirp 是一个指向已打开目录流（DIR 结构体的指针）的句柄。\n\n * struct dirent 是一个结构体，表示目录中的一个项，包括文件名、文件类型和其他属性。\n\n原理：\n\n 1. readdir 函数从指定的目录流 dirp 中读取下一个目录项，并返回一个指向 struct dirent 结构体的指针，其中包含有关该目录项的信息。\n\n 2. 如果目录流已经到达末尾（即没有更多的目录项可读取），或者出现错误，readdir 返回 NULL，表示读取结束或出现错误。此时，通常可以使用 errno 来获取出错的详细信息。\n\n 3. 通过多次调用 readdir 函数，可以依次读取目录中的所有文件和子目录项，直到读取到末尾为止。\n\n 4. struct dirent 结构体中包含了目录项的信息，如文件名、文件类型和其他属性。您可以使用这些信息来进一步处理目录中的文件和子目录。\n\nreaddir 函数通常与 opendir 函数一起使用，用于在目录中遍历文件和子目录。这对于需要执行文件管理或目录操作的应用程序非常有用。\n\n\n# atoi\n\natoi 函数用于将字符串转换为整数（int）。其原型如下：\n\nint atoi(const char *str);\n\n\n1\n\n * str 是一个指向包含表示整数的字符串的指针。\n\n原理：\n\n 1. atoi 函数从字符串 str 的起始位置开始扫描，并跳过前导空白字符（如空格、制表符等）。\n\n 2. 一旦遇到非空白字符，atoi 将开始解析整数。它会继续读取字符，直到遇到非数字字符或字符串的末尾。\n\n 3. 解析期间，atoi 将读取的字符转换为整数，并将其积累到一个整数值中。该整数值的初始值为零。\n\n 4. 如果字符串中包含无效字符或字符串为空，atoi 将停止解析，并返回当前积累的整数值。\n\n 5. 如果整数超出了 int 数据类型的范围，结果是未定义的。\n\n 6. 返回值为解析后的整数值。\n\natoi 主要用于将字符串形式的数字转换为整数，常用于文本处理和输入转换，但不提供错误检测机制。如果需要更强大的字符串到整数的转换和错误处理，可以使用 strtol 函数或其他更安全的替代方法。',normalizedContent:'# 程序流程\n\n执行文件访问拦截和 ip 地址拦截的流程：\n\n\n# 文件访问拦截功能：\n\n 1. 当应用程序尝试执行文件操作，例如打开文件，调用的是 open 或 openat 函数。\n\n 2. 由于这两个函数已经被重定向为自定义的版本，所以实际上调用的是 open 或 openat 函数的自定义替代版本。\n\n 3. 自定义的 open 或 openat 函数首先检查传递的文件路径和执行文件操作的进程是否符合访问控制策略。\n\n 4. 它检查文件路径是否在黑名单或白名单中，并检查执行文件操作的进程是否在白名单中。如果文件或进程不符合策略，函数会拒绝文件操作。\n\n 5. 如果文件和进程都符合策略，它会记录文件访问操作的结果，然后调用真正的 open 或 openat 函数执行操作。\n\n 6. 如果文件或进程不符合策略，它会记录拒绝的结果，并设置 errno 为 eperm，表示权限被拒绝。\n\n\n# ip 地址拦截功能：\n\n 1. 当应用程序尝试执行网络连接操作，例如使用 connect 函数或发送数据到远程主机，调用的是 connect 或 sendto 函数。\n\n 2. 与文件访问拦截类似，这两个函数也已被重定向为自定义版本，因此实际上调用的是自定义的 connect 或 sendto 函数。\n\n 3. 自定义的 connect 或 sendto 函数首先检查传递的目标 ip 地址以及执行连接或数据发送操作的进程是否符合访问控制策略。\n\n 4. 它检查 ip 地址是否在黑名单或白名单中，并检查执行操作的进程是否在白名单中。如果 ip 地址或进程不符合策略，函数会拒绝操作。\n\n 5. 如果 ip 地址和进程都符合策略，它会记录 ip 操作的结果，然后调用真正的 connect 或 sendto 函数执行操作。\n\n 6. 如果 ip 地址或进程不符合策略，它会记录拒绝的结果，并设置 errno 为 eperm，表示权限被拒绝。\n\n总的来说，这两段代码的流程是先检查文件或 ip 地址是否符合访问控制策略，如果符合则允许操作并记录结果，如果不符合则拒绝操作并记录结果，以确保系统的安全性和遵守访问策略。\n\n\n# libhook.cpp\n\n//验证文件访问是否受到权限限制\nstatic bool\nallow_open(const char *exe, const char *path, string &return_full_path) noexcept(true)\n{\n\ttry\n\t{\n\t\t// 检查传入的参数是否为null\n\t\tif (exe == null || path == null)\n\t\t\treturn false;\n\n\t\t// 获取目标文件的绝对路径\n\t\tconst string real_absolute_path = get_real_path(get_absolute_path(path).c_str());\n\t\treturn_full_path = real_absolute_path;\n\n\t\t// 遍历文件黑名单，检查是否有文件受黑名单保护\n\t\tfor (auto &i : file_black_list())\n\t\t{\n\t\t\tif (i.first == real_absolute_path)\n\t\t\t{\n\t\t\t\t// 文件在黑名单中，检查程序是否在黑名单\n\t\t\t\tif (i.second.count(exe) > 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// 遍历文件白名单，检查是否有文件受白名单保护\n\t\tfor (auto &i : file_white_list())\n\t\t{\n\t\t\tif (i.first == real_absolute_path)\n\t\t\t{\n\t\t\t\t// 文件在白名单中，检查程序是否不在白名单\n\t\t\t\tif (i.second.count(exe) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 文件访问权限通过，返回true\n\t\treturn true;\n\t}\n\tcatch (...)\n\t{\n\t\t// 捕获异常，如果出现异常，也返回true\n\t\treturn true;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n * 这个函数接受两个c风格字符串（exe 和 path）以及一个字符串引用参数（return_full_path）。\n * 函数首先检查传入的exe和path是否为null，如果是null，则直接返回false，表示不允许访问。\n * 然后，它获取目标文件的绝对路径，将其保存到real_absolute_path变量中，并将其赋值给return_full_path，以便后续使用。\n * 函数接着遍历文件黑名单（file_black_list()）和文件白名单（file_white_list()），分别检查目标文件是否在黑名单或白名单中，以及程序是否在对应的名单中。\n * 如果文件在黑名单中，并且程序也在黑名单中，或者文件在白名单中，但程序不在白名单中，则返回false，表示不允许访问。\n * 最后，如果一切正常，或者在处理过程中出现异常，都会返回true，表示允许文件访问。\n\n这段代码的目的是在文件访问时检查权限，以确保只有在允许名单中的程序可以访问允许名单中的文件，并且不在黑名单中。如果条件不满足，它返回false，表示拒绝访问。\n\n//验证ipv4地址的访问权限\nstatic bool\nallow_ipv4(int sockfd, const struct sockaddr *address, socklen_t addrlen, string &return_ip) noexcept(true)\n{\n\ttry {\n\t\tchar buf[inet_addrstrlen];\n\t\t// 强制将传入的地址指针转换为ipv4地址结构\n\t\tstruct sockaddr_in *addr_in = (struct sockaddr_in *)address;\n\n\t\t// 检查地址结构长度，以及地址类型是否为ipv4\n\t\tif (addrlen < sizeof(sockaddr_in) ||\n\t\t\taddr_in->sin_family != af_inet)\n\t\t\treturn true;\n\n\t\t// 将ipv4地址转换为可读的字符串形式\n\t\tif (inet_ntop(af_inet, &addr_in->sin_addr, buf, sizeof(buf)) == null)\n\t\t\treturn true;\n\n\t\t// 将ipv4地址字符串赋值给字符串变量ip\n\t\tconst string ip = string(buf);\n\t\treturn_ip = ip;\n\n\t\t// 获取当前进程的可执行文件路径\n\t\tconst string exe = get_real_exe_by_pid(getpid());\n\n\t\t// 遍历ip地址黑名单，检查是否有ip在黑名单中\n\t\tfor (auto &i : ip_black_list())\n\t\t{\n\t\t\tif (i.first == ip)\n\t\t\t{\n\t\t\t\t// 如果ip在黑名单中，检查程序是否在黑名单中\n\t\t\t\tif (i.second.count(exe) > 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// 遍历ip地址白名单，检查是否有ip在白名单中\n\t\tfor (auto &i : ip_white_list())\n\t\t{\n\t\t\tif (i.first == ip)\n\t\t\t{\n\t\t\t\t// 如果ip在白名单中，检查程序是否不在白名单中\n\t\t\t\tif (i.second.count(exe) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// ip地址访问权限通过，返回true\n\t\treturn true;\n\t}\n\tcatch (...)\n\t{\n\t\t// 捕获异常，如果出现异常，也返回true\n\t\treturn true;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n// 检查地址结构长度，以及地址类型是否为ipv4\nif (addrlen < sizeof(sockaddr_in) || addr_in->sin_family != af_inet)\n\treturn true;\n\n\n这段代码的目的是在处理套接字地址之前，确保传入的地址是有效的 ipv4 地址，并且包含足够的信息来处理，以避免内存越界错误或无效的操作。如果传入的地址不满足这些条件，函数将立即返回 true，表示允许访问（不进行限制）。这有助于确保代码的稳定性和安全性。\n\ntypedef int (*open_func_t)(const char *, int, ...); // 定义一个函数指针类型，用于指向与标准 open 函数具有相同参数和返回类型的函数\nint\nopen(const char *path, int flags, ...) // 重载标准 open 函数，用于拦截文件操作\n{\n\tstatic open_func_t old_open = null; // 静态函数指针，用于存储原始的 open 函数地址\n\tif (old_open == null) // 如果第一次调用这个函数\n\t\told_open = (open_func_t)dlsym(rtld_next, "open"); // 使用 dlsym 获取标准 open 函数的地址\n\n\tmode_t mode = 0; // 定义文件操作的模式\n\n\tif (flags & o_creat) // 如果传入的 flags 参数包含 o_creat 标志（表示在文件不存在时创建文件）\n\t{\n\t\tva_list args; // 定义可变参数列表\n\t\tva_start(args, flags); // 初始化可变参数列表\n\t\tmode = va_arg(args, mode_t); // 获取可变参数列表中的 mode_t 参数值\n\t\tva_end(args); // 清理可变参数列表\n\t}\n\n\tstd::string full_path; // 用于存储文件的完整路径\n\n\tif (allow_open(get_real_exe_by_pid(getpid()).c_str(), path, full_path)) // 调用 allow_open 函数检查是否允许打开文件\n\t{\n\t\tlog(result::allow, type::file, full_path, get_real_exe_by_pid(getpid()), getpid()); // 记录允许的日志\n\t\treturn old_open(path, flags, mode); // 调用原始的 open 函数\n\t}\n\telse\n\t{\n\t\tlog(result::deny, type::file, full_path, get_real_exe_by_pid(getpid()), getpid()); // 记录拒绝的日志\n\t\terrno = eperm; // 设置 errno 为 eperm（权限错误）\n\t\treturn -1; // 返回 -1，表示打开文件失败\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这段代码是一个重载的open函数，它用于拦截文件操作，并在操作之前进行访问控制。以下是对这段代码的解释：\n\n * typedef int (*open_func_t)(const char *, int, ...);：这行代码定义了一个函数指针类型open_func_t，该函数指针可以指向与标准open函数具有相同参数和返回类型的函数。\n\n * static open_func_t old_open = null;：这行代码定义了一个静态函数指针old_open，并将其初始化为null。这个指针将用于保存原始的open函数的地址。\n\n * if (old_open == null)：这是一个条件语句，用于检查old_open是否为空，如果为空，表示第一次调用这个函数。\n\n * old_open = (open_func_t)dlsym(rtld_next, "open");：在第一次调用时，这行代码使用dlsym函数获取标准open函数的地址，并将其存储在old_open函数指针中。这是为了能够在拦截函数中调用原始的open函数。\n\n * mode_t mode = 0;：这行代码定义了一个mode_t类型的变量mode，并将其初始化为0。\n\n * if (flags & o_creat)：这行代码检查传入的flags参数是否包含o_creat标志。o_creat标志表示在文件不存在时创建文件。如果flags包含o_creat，则进入条件块，否则跳过。\n\n * va_list args; va_start(args, flags); mode = va_arg(args, mode_t); va_end(args);：在包含o_creat标志的情况下，这部分代码使用可变参数列表来提取额外的参数。特别是，它使用va_list来存储可变参数，通过va_start来初始化列表，然后使用va_arg来获取参数的值（在这种情况下，获取了mode的值），最后通过va_end来清理列表。\n\n * std::string full_path;：这行代码定义了一个std::string类型的变量full_path，用于存储文件的完整路径。\n\n * if (allow_open(get_real_exe_by_pid(getpid()).c_str(), path, full_path))：这行代码调用allow_open函数来检查是否允许打开文件。它传递了三个参数：当前进程的可执行文件路径、传入的文件路径path，以及用于存储文件的完整路径的full_path。如果allow_open函数返回true，表示允许打开文件，那么它记录了一个允许的日志，并通过old_open调用原始的open函数。\n\n * else：如果allow_open函数返回false，表示拒绝打开文件，这行代码记录了一个拒绝的日志，并设置了errno为eperm（表示权限错误），然后返回-1，表示打开文件失败。\n\n总之，这段代码的目的是拦截标准open函数的调用，并在打开文件之前进行访问控制。如果满足控制条件，它将允许打开文件，并调用原始的open函数。如果不满足条件，它将拒绝打开文件，并返回一个错误。这有助于实施文件访问控制策略。\n\ntypedef int (*openat_func_t)(int fd, const char *, int, ...);\nint openat(int fd, const char *path, int flags, ...)\n{\n    // 定义一个指向函数指针的变量 old_openat，并初始化为 null\n    static openat_func_t old_openat = null;\n\n    // 第一次调用时，通过 dlsym 函数获取真正的 openat 函数的地址\n    if (old_openat == null)\n        old_openat = (openat_func_t)dlsym(rtld_next, "openat");\n\n    // 定义文件打开权限 mode 为 0\n    mode_t mode = 0;\n\n    // 如果 flags 包含 o_creat 标志，获取变长参数列表中的文件权限 mode\n    if (flags & o_creat)\n    {\n        va_list args;\n        va_start(args, flags);\n        mode = va_arg(args, mode_t);\n        va_end(args);\n    }\n\n    std::string full_path; // 用于存储实际文件的全路径\n\n    // 调用 allow_open 函数来检查文件的访问权限\n    if (allow_open(get_real_exe_by_pid(getpid()).c_str(), path, full_path))\n    {\n        // 如果允许打开文件，记录相应的日志并调用真正的 openat 函数\n        log(result::allow, type::file, full_path, get_real_exe_by_pid(getpid()), getpid());\n        return old_openat(fd, path, flags, mode);\n    }\n    else\n    {\n        // 如果不允许打开文件，记录相应的日志，设置错误号 errno 为 eperm，并返回 -1 表示打开失败\n        log(result::deny, type::file, full_path, get_real_exe_by_pid(getpid()), getpid());\n        errno = eperm;\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# tool.cpp\n\nstring\nget_real_path (const char *path) // 函数名及参数说明\n{\n\tchar buf[path_max + 1]; // 声明一个字符数组用于存储路径\n\tif (realpath (path, buf) == null) // 调用realpath函数，将传入的路径规范化为绝对路径\n\t\treturn path; // 如果realpath调用失败，返回原始路径\n\treturn buf; // 如果realpath调用成功，返回规范化后的绝对路径\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nstring get_remote_ip_by_fd(int sockfd) noexcept(false)\n{\n    struct sockaddr_storage addr; // 声明一个套接字地址结构体，用于存储远程主机的地址信息\n    socklen_t addrlen = sizeof(addr); // 声明并初始化地址结构体的长度变量\n\n    // 获取远程主机的地址信息并存储到 addr 结构体中，如果失败则抛出异常\n    if (getpeername(sockfd, (sockaddr *)&addr, &addrlen) == -1)\n        throw socketexception();\n\n    sockaddr_in *tcp_addr = (sockaddr_in *)&addr; // 将 addr 转换为 ipv4 地址结构体\n    char ip[inet_addrstrlen]; // 用于存储 ip 地址的字符数组\n    // 将二进制形式的 ipv4 地址转换为文本形式的 ip 地址，并存储到 ip 数组中\n    if (inet_ntop(af_inet, &tcp_addr->sin_addr, ip, sizeof(ip)) == null)\n        throw socketexception();\n\n    return string(ip); // 将 ip 地址转换为 cpp 字符串并返回\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nstring get_real_exe_by_pid(pid_t pid) // 函数签名，获取指定进程的可执行文件路径\n{\n    string buf = format("/proc/%d/exe", pid); // 构造进程的符号链接路径，如 "/proc/1234/exe"\n    char exe[path_max]; // 创建一个字符数组用于存储符号链接指向的可执行文件路径\n    ssize_t nread = readlink(buf.c_str(), exe, sizeof(exe) - 1); // 通过 readlink 函数获取符号链接指向的路径\n    if (nread == -1) // 如果读取失败（返回值为-1），说明可能进程不存在或者没有符号链接\n        return string(); // 返回一个空字符串，表示获取可执行文件路径失败\n    exe[nread] = \'\\0\'; // 在字符数组的结尾添加 null 终止符，以确保它是一个以 null 结尾的 c 字符串\n    return get_real_path(exe); // 调用函数 get_real_path，以获取真实的路径并返回\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nstring get_absolute_path(const char *path) // 函数签名，用于获取绝对路径\n{\n    if (path == null || path[0] == \'/\') // 如果输入路径为空或已经是绝对路径，直接返回原路径\n        return path;\n    char buf[path_max + 1]; // 创建一个字符数组用于存储当前工作目录路径\n    if (getcwd(buf, sizeof(buf) - 1) == null) // 通过 getcwd 函数获取当前工作目录路径\n        return string(); // 如果获取失败，返回一个空字符串，表示无法获得绝对路径\n    return string(buf) + "/" + path; // 构造并返回合并后的绝对路径，将当前工作目录和输入路径拼接\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nvector<pid_t> get_all_pids() // 函数签名，用于获取系统中所有的进程id\n{\n    vector<pid_t> pids; // 创建一个存储进程id的向量\n    dir *p_dir = opendir("/proc"); // 打开位于 /proc 目录下的目录流，该目录通常包含进程信息\n    if (p_dir == null) // 如果目录流打开失败\n        return pids; // 返回一个空向量，表示无法获取进程id\n    for (;;)\n    {\n        dirent *p_file = readdir(p_dir); // 读取目录中的下一个条目\n        if (p_file == null) // 如果没有更多的条目可读\n            break; // 退出循环\n        pid_t pid; // 创建一个变量用于存储进程id\n        if (p_file->d_type == dt_dir && (pid = atoi(p_file->d_name)) != 0) // 如果是目录且目录名能够转换为有效的进程id\n            pids.push_back(pid); // 将该进程id添加到向量中\n    }\n    closedir(p_dir); // 关闭目录流，释放资源\n    return pids; // 返回包含所有有效进程id的向量\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# ptrace_tool.cpp\n\n//从目标进程的内存中读取64位整数数据（\'word\'类型）\n[[deprecated]]static void\nget_tracee_words (pid_t pid, word *src, word *dest, size_t len) noexcept (false)\n{\n\tfor (size_t i = 0; i < len; ++i) {\n\t\tdest[i] = ptrace (ptrace_peekdata, pid, src + i, null);\n\t\tif (dest[i] == -1)\n\t\t\tthrow ptraceexception ();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 它接受参数 pid，要读取的数据的地址 src，以及存储读取数据的数组 dest 以及要读取的数据的长度 len。\n * 使用 ptrace 调用的 ptrace_peekdata 选项从目标进程的内存中读取数据，并将数据存储在 dest 数组中。\n * 如果读取失败，会抛出 ptraceexception 异常。\n\n> ptrace_pokedata 是 linux 操作系统提供的 ptrace 系统调用的一个选项之一，它用于将数据写入远程进程的内存空间。这个选项通常用于修改目标进程的内存中的数据，允许一个进程追踪和修改另一个进程的执行状态和内存。\n\n具体解释如下：\n\n 1. ptrace 系统调用： ptrace 是一个用于进程追踪的系统调用，允许一个进程（通常是父进程）监视和控制另一个进程。通过 ptrace，一个进程可以读取和写入目标进程的寄存器、内存，以及控制目标进程的执行。\n\n 2. ptrace_pokedata： ptrace_pokedata 是 ptrace 的一个选项（请求），它表示要将数据写入目标进程的内存。这个选项通常与 ptrace 函数一起使用，用于修改目标进程的内存。\n\n 3. 用途： ptrace_pokedata 主要用于在调试或进程注入等场景中，以编程方式修改目标进程的内存数据。例如，可以使用它来修改目标进程的变量值，注入代码，或执行其他需要改变内存数据的操作。\n\n 4. 参数： 调用 ptrace 时，需要提供目标进程的进程 id，要写入的目标地址，以及要写入的数据。\n\n 5. 注意事项： 使用 ptrace_pokedata 需要特权，通常只能由具有足够权限的进程来执行，例如，需要具有 root 或 debug 能力的权限。\n\n总之，ptrace_pokedata 是 ptrace 的一个选项，用于在目标进程的内存中写入数据，通常用于调试、注入或修改目标进程的内存。\n\n//向目标进程的内存中写入64位整数数据\n[[deprecated]]static void\nset_tracee_words (pid_t pid,  word *src,  word *dest, size_t len)\n{\n\tfor (size_t i = 0; i < len; ++i) {\n\t\tif (ptrace (ptrace_pokedata, pid, &dest[i], src[i]) == -1)\n\t\t\tthrow ptraceexception ();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 它接受参数 pid，要写入的数据 src，以及要写入的目标地址 dest 以及数据的长度 len。\n * 使用 ptrace 调用的 ptrace_pokedata 选项将数据写入目标进程的内存。\n * 如果写入失败，会抛出 ptraceexception 异常。\n\n//计算目标进程内存中以"remote_str"开头的字符串的长度\nint get_tracee_strlen (pid_t pid, char *remote_str)\n{\n\tuser_regs_struct regs;\n\tint len = 0;\n\tfor (int i = 0; ; ++i) {\n\t\tword word = ptrace (ptrace_peekdata, pid, remote_str + i * sizeof (word), null);\n\t\tif (word == -1)\n\t\t\tthrow ptraceexception ();\n\t\tchar *end = (char *) memchr (&word, \'\\0\', sizeof (word));\n\t\tif (end == null)\n\t\t\tlen += sizeof (word) / sizeof (char);\n\t\telse {\n\t\t\tlen += end - (char *) &word;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn len;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 它接受参数 pid 和 remote_str，表示目标进程的进程 id 和指向目标进程内存的指针。\n * 通过循环逐个读取字符并查找字符串的终止符 \\0 来计算字符串的长度。\n * 如果读取失败，会抛出 ptraceexception 异常。\n\n//从目标进程的内存中复制字符串并返回复制后的字符串\nchar * get_tracee_strdup (pid_t pid, char *remote_str)\n{\n\tconst int len = get_tracee_strlen (pid, remote_str);\n\tchar buf[len + 1];\n\tget_tracee_bytes (pid, remote_str, buf, len + 1);\n\treturn strdup (buf);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 此函数用于从目标进程的内存中复制字符串并返回复制后的字符串。\n * 它首先调用 get_tracee_strlen 计算字符串的长度，然后调用 get_tracee_bytes 读取字符串的字节数据。\n * 最后，它使用 strdup 函数分配新的字符串并返回。\n\n// 从目标进程的内存中读取字节数据\nvoid get_tracee_bytes (pid_t pid, void *remote_src, void *local_dest, size_t len)\n{\n\tconst int word_len = len / sizeof (word);\n\tfor (size_t i = 0; i < word_len ; ++i) {\n\t\tword ret = ptrace (ptrace_peekdata, pid, (word *) remote_src + i, null);\n\t\tif (ret == -1)\n\t\t\tthrow ptraceexception ();\n\t\t( (word *) local_dest) [i] =  ret;\n\t}\n\tif (word_len > 1) {\n\t\tvoid *dest_last_word = (word *) ( (char *) local_dest + len) - 1;\n\t\tvoid *src_last_word = (word *) ( (char *) remote_src + len) - 1;\n\t\tif (len % sizeof (word) != 0) {\n\t\t\tword ret = ptrace (ptrace_peekdata, pid, src_last_word, null);\n\t\t\tif (ret == -1)\n\t\t\t\tthrow ptraceexception ();\n\t\t\t* (word *) dest_last_word = ret;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 它接受参数 pid，指向目标进程内存的指针 remote_src，以及存储读取数据的本地缓冲区 local_dest 以及要读取的数据的长度 len。\n * 该函数首先将数据以 64 位整数（word）的形式逐个字的方式读取，然后将它们存储在 local_dest 中。\n * 最后，如果 len 不是 word 大小的整数倍，它会单独读取最后一个字。\n\n// 从目标进程的内存中读取字节数据\nvoid set_tracee_bytes (pid_t pid, void *remote_src, void *local_dest, size_t len)\n{\n\tconst int word_len = len / sizeof (word);\n\tfor (size_t i = 0; i < word_len ; ++i) {\n\t\tif (ptrace (ptrace_pokedata, pid, (word *) local_dest + i, * ( (word *) remote_src + i)) == -1)\n\t\t\tthrow ptraceexception ();\n\t}\n\tif (word_len > 1) {\n\t\tvoid *dest_last_word = (word *) ( (char *) local_dest + len) - 1;\n\t\tvoid *src_last_word = (word *) ( (char *) remote_src + len) - 1;\n\t\tif (len % sizeof (word) != 0) {\n\t\t\tif (ptrace (ptrace_pokedata, pid,  dest_last_word, * (word *) src_last_word) == -1)\n\t\t\t\tthrow ptraceexception ();\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n它的参数和操作方式与 get_tracee_bytes 函数类似，但是它用 ptrace 调用的 ptrace_pokedata 选项将数据写入目标进程的内存。\n\n\n# 总结：\n\n\n# inet_ntop\n\ninet_ntop 函数用于将二进制形式的网络地址转换为人类可读的ipv4或ipv6地址表示。\n\n其原型如下：\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n\n\n1\n\n * af：地址族（address family），可以是 af_inet（ipv4）或 af_inet6（ipv6）。\n * src：指向要转换的二进制网络地址的指针。\n * dst：指向用于存储结果的缓冲区。\n * size：dst 缓冲区的大小。\n\ninet_ntop 函数的原理是将二进制网络地址转换为可读的点分十进制（ipv4）或冒号十六进制（ipv6）表示。函数根据给定的地址族 af，采用不同的格式化方式来完成这一转换。\n\n对于 ipv4 地址（af 为 af_inet），inet_ntop 函数将 32 位的二进制地址拆分成四个 8 位的部分，然后将它们以点分十进制的形式表示。例如，二进制地址 0x7f000001 被转换为字符串 "127.0.0.1"。\n\n对于 ipv6 地址（af 为 af_inet6），inet_ntop 函数将 128 位的二进制地址按照冒号十六进制表示。例如，ipv6 地址 2001:0db8:85a3:0000:0000:8a2e:0370:7334 保持不变。\n\n\n# dlsym\n\ndlsym 函数是动态链接库操作的一部分，用于在共享库中查找符号（函数或变量）。其原型如下：\n\nvoid *dlsym(void *handle, const char *symbol);\n\n\n1\n\n * handle：表示已经打开的动态链接库的句柄，通常是由 dlopen 函数返回的。\n * symbol：是你想查找的符号（函数或变量）的名称。\n\ndlsym 函数的工作原理涉及以下几个步骤：\n\n 1. dlsym 函数通过 handle 参数确定要在哪个已加载的共享库中查找符号。\n 2. 它会在给定的共享库中查找具有名称 symbol 的符号。\n 3. 如果找到符号，dlsym 返回指向该符号的指针（函数指针或变量指针）；否则，返回 null。\n\n这个函数的主要用途是在运行时从共享库中获取函数或变量的地址，以便在程序中调用或使用它们。这是一种动态加载共享库中的函数的方法，可以在程序运行时决定使用哪个共享库，并且可以根据需要加载或卸载这些库。\n\n\n# va_start\n\nva_start 函数是 c/cpp 标准库中的一个宏，用于在函数内部访问可变参数列表（variable argument list）。它的原型通常定义在 <cstdarg> 或 <stdarg.h> 头文件中，但是 va_start 宏的具体实现会根据编译器和平台而有所不同。\n\nva_start 宏的一般原型如下：\n\nvoid va_start(va_list ap, last_arg);\n\n\n1\n\n * va_list ap 是一个指向可变参数列表的指针，它将在函数内部用于迭代访问参数。\n * last_arg 是可变参数列表中的最后一个固定参数，用于确定可变参数列表的起始位置。\n\nva_start 宏的原理是基于编译器和体系结构的底层机制，通常使用汇编代码来实现。它的主要任务是将 va_list 指针初始化为指向参数列表中的第一个可变参数。\n\n具体实现方法取决于编译器和平台，但通常涉及以下步骤：\n\n 1. 确定固定参数的位置。编译器需要知道在参数列表中哪里是可变参数的开始位置。这通常由 last_arg 参数指定。\n\n 2. 计算可变参数列表的地址。编译器会使用一些规则来计算可变参数列表的地址。这通常涉及堆栈指针（栈帧指针）的调整和偏移计算。\n\n 3. 初始化 va_list 指针。va_start 宏会将 va_list 指针初始化为可变参数列表的起始位置，以便函数内部可以使用 va_arg 宏来访问参数。\n\n总之，va_start 宏的原理是在函数内部为可变参数列表创建一个指针，使得程序可以依次访问参数。不同编译器和平台的实现可能会有所不同，但通常都是基于底层的堆栈和内存管理机制。\n\n\n# va_arg\n\nva_arg 函数是 c/cpp 标准库中用于访问可变参数列表（variable argument list）的宏。它的原型通常定义在 <cstdarg> 或 <stdarg.h> 头文件中，但 va_arg 宏的具体实现会根据编译器和平台而有所不同。\n\n一般情况下，va_arg 宏的原型如下：\n\ntype va_arg(va_list ap, type);\n\n\n1\n\n * va_list ap 是一个指向可变参数列表的指针，它在 va_start 函数之后初始化，用于迭代访问参数。\n * type 是要获取的参数的类型。\n\nva_arg 宏的原理是基于编译器和体系结构的底层机制，通常使用汇编代码来实现。它的主要任务是从可变参数列表中按指定类型提取参数的值。\n\n具体实现方法取决于编译器和平台，但通常涉及以下步骤：\n\n 1. 计算参数的大小。编译器需要知道参数的大小，以便正确地从堆栈中读取数据。这取决于参数的类型。\n\n 2. 更新 va_list 指针。va_arg 宏会将 va_list 指针移动到下一个参数的位置，以准备下一次调用 va_arg。\n\n 3. 从内存中读取参数值。va_arg 宏通过 va_list 指针获取参数的值，然后将指针移动到下一个参数的位置。\n\n总之，va_arg 宏的原理是在可变参数列表中按照指定的类型提取参数值。不同编译器和平台的实现可能会有所不同，但通常都是基于底层的堆栈和内存管理机制。 va_arg 宏为处理可变参数提供了一种通用的方法，使得在不知道参数个数和类型的情况下能够访问参数。\n\n\n# va_end\n\nva_end 函数是 c/cpp 标准库中用于终止可变参数列表（variable argument list）操作的宏。它的原型通常定义在 <cstdarg> 或 <stdarg.h> 头文件中，但 va_end 宏的具体实现会根据编译器和平台而有所不同。\n\n一般情况下，va_end 宏的原型如下：\n\nvoid va_end(va_list ap);\n\n\n1\n\n * va_list ap 是一个指向可变参数列表的指针，它在 va_start 函数之后初始化。\n\nva_end 宏的原理是用于清理 va_list 指针，以便资源得到正确释放。具体实现方法取决于编译器和平台，但通常会在 va_end 中执行以下操作：\n\n 1. 将 va_list 指针设置为一个未定义或无效的状态。这意味着该指针不再指向可变参数列表中的任何参数。\n\n 2. 释放或清理 va_list 指针可能使用的任何资源。这通常涉及一些与堆栈或寄存器状态相关的操作，以确保不会出现内存泄漏或资源泄漏。\n\n总之，va_end 宏的原理是用于清理和终止可变参数列表的操作，以确保不会出现资源泄漏或其他问题。不同编译器和平台的实现方式可能有所不同，但它们的共同目标是安全地结束可变参数列表的操作。\n\n\n# sendto\n\nsendto 函数是用于将数据发送到指定的目标地址的系统调用，通常用于网络编程。它的原型如下：\n\nssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);\n\n\n1\n\n * sockfd 是套接字文件描述符，用于标识要发送数据的套接字。\n * buf 是包含要发送的数据的缓冲区。\n * len 是要发送的数据的字节数。\n * flags 是发送选项，通常可以设置为 0。\n * dest_addr 是目标地址的指针，通常是 struct sockaddr 结构的指针，包含目标地址信息。\n * addrlen 是目标地址结构的长度。\n\nsendto 函数的原理是将 buf 中的数据发送到指定的目标地址，然后返回发送的字节数。数据包将通过 sockfd 套接字发送，而 dest_addr 和 addrlen 用于指定目标地址。\n\n原理包括以下步骤：\n\n 1. 根据 sockfd 找到关联的套接字，该套接字用于数据发送。\n 2. 将 buf 缓冲区中的数据封装成数据包，同时添加目标地址信息（由 dest_addr 指定）。\n 3. 数据包被发送到目标地址，这通常涉及到网络协议栈的操作。\n 4. sendto 函数返回发送的字节数或出现的错误。\n\nsendto 可以用于 udp 和基于 ip 的协议（例如 icmp），以便将数据发送到指定的目标地址。通过 dest_addr 参数，您可以指定数据包要发送到的目标主机和端口。此函数常用于网络编程中，用于实现数据的发送和接收。\n\n\n# realpath\n\nrealpath 函数用于获取一个路径的绝对路径，将相对路径转换为绝对路径。其原型如下：\n\nchar *realpath(const char *path, char *resolved_path);\n\n\n1\n\n * path 是要获取绝对路径的输入路径。\n * resolved_path 是一个缓冲区，用于存储解析后的绝对路径。它可以为 null，如果为 null，realpath 函数会自动为您分配内存。\n\nrealpath 函数的原理是将输入的相对路径 path 转换为绝对路径并存储在 resolved_path 缓冲区中。如果 resolved_path 参数为 null，则会自动分配内存并存储绝对路径。\n\n原理包括以下步骤：\n\n 1. realpath 检查输入路径 path 是否为相对路径或绝对路径。如果 path 为绝对路径（以 / 开头），则它是其自身的绝对路径，无需进一步处理。\n 2. 如果 path 为相对路径，realpath 将获取当前工作目录，并将其与 path 连接，以得到绝对路径。\n 3. realpath 对路径中的符号链接进行解析，以获得路径的最终绝对路径。这包括将路径中的 . 和 .. 等符号链接替换为实际目录。\n 4. 最终的绝对路径存储在 resolved_path 缓冲区中，或者如果 resolved_path 为 null，则由 realpath 函数自动分配内存来存储绝对路径。\n 5. realpath 返回指向 resolved_path 缓冲区的指针，其中包含了输入路径的绝对路径。这个缓冲区可以被后续代码使用。\n\nrealpath 函数通常用于获取文件的绝对路径，以确保以绝对路径方式引用文件。这在文件系统操作和路径处理中非常有用，可以避免相对路径引发的问题。\n\n\n# getpeername\n\ngetpeername 函数用于获取与已连接套接字关联的远程端的地址信息。其原型如下：\n\nint getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n\n\n1\n\n * sockfd 是一个已连接套接字的文件描述符，用于表示与远程主机建立的连接。\n * addr 是一个指向 struct sockaddr 结构的指针，用于存储远程端的地址信息。\n * addrlen 是一个指向 socklen_t 类型的指针，用于存储 addr 缓冲区的长度。\n\ngetpeername 函数的原理是在套接字 sockfd 上执行操作，以获取远程端的地址信息并存储在 addr 缓冲区中。\n\n原理包括以下步骤：\n\n 1. getpeername 函数接收 sockfd，这是一个已连接套接字，表示与远程主机的连接。\n 2. 它将 addr 缓冲区用于存储远程端的地址信息。\n 3. 通过 addrlen 参数传递缓冲区的大小。\n 4. getpeername 函数将远程端的地址信息填充到 addr 缓冲区中。\n 5. 如果成功，函数返回0，否则返回-1，并在错误情况下设置 errno，以指示错误的类型。\n\ngetpeername 函数通常用于网络编程，以获取远程客户端的地址信息，以便了解与服务器建立连接的客户端。这是在服务器端套接字编程中的常见用例，用于识别连接到服务器的客户端的地址信息。\n\n\n# inet_ntop\n\ninet_ntop 函数用于将网络字节序的 ip 地址转换为人类可读的 ip 地址字符串。其原型如下：\n\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n\n\n1\n\n * af 是地址族参数，通常是 af_inet 表示 ipv4 地址族或 af_inet6 表示 ipv6 地址族。\n * src 是指向包含二进制 ip 地址的内存地址。\n * dst 是用于存储 ip 地址字符串的缓冲区。\n * size 是 dst 缓冲区的大小。\n\n原理： inet_ntop 函数的实现依赖于不同的操作系统，但其核心思想相似。它将二进制 ip 地址转换为字符串的过程通常如下：\n\n 1. 首先，函数根据地址族 (af) 来判断是 ipv4 还是 ipv6 地址。\n\n 2. 然后，它根据地址族决定如何将二进制地址解析成字符串。对于 ipv4 地址，将四个 8 位整数以点分隔的形式拼接成字符串；对于 ipv6 地址，将 16 位整数以冒号分隔的形式拼接成字符串。\n\n 3. 函数将转换后的字符串复制到 dst 缓冲区中，同时确保不会超过 size 字节的长度。\n\n 4. 如果转换成功，函数返回指向 dst 缓冲区的指针，否则返回 null，并在 errno 中设置相应的错误码，如 einval（无效的地址族）或 enospc（缓冲区不足）。\n\n需要注意的是，inet_ntop 是将二进制地址转换为可读字符串的逆过程，与之相反的函数是 inet_pton，它将字符串转换为二进制地址。这两个函数在网络编程中用于进行 ip 地址的解析和构建。\n\n\n# readlink\n\nreadlink 函数用于读取符号链接的目标路径。它的原型如下：\n\nssize_t readlink(const char *path, char *buf, size_t bufsiz);\n\n\n1\n\n * path 是要读取的符号链接文件的路径。\n * buf 是一个字符数组，用于存储目标路径。\n * bufsiz 是 buf 的大小，用于指定目标路径的最大长度。\n\n原理： readlink 函数的目的是获取符号链接文件所指向的实际目标路径。其工作原理如下：\n\n 1. 当调用 readlink 函数时，它会打开 path 所指定的符号链接文件，并尝试读取链接文件的内容。\n\n 2. 如果成功，它将读取的内容存储在 buf 中，并返回所复制的字符数，不包括 null 终止字符。如果 bufsiz 大于实际目标路径的长度，buf 中的数据将以 null 终止。\n\n 3. 如果读取的内容超过了 buf 的容量（bufsiz 不足以容纳目标路径），readlink 函数会截断目标路径并返回截断后的字符数。此时，buf 中的数据仍以 null 终止。\n\n 4. 如果读取符号链接文件失败，readlink 函数返回 -1，并在 errno 中设置相应的错误码，如 eacces（权限不足）或 enoent（文件不存在）。\n\n需要注意的是，readlink 仅适用于符号链接文件。对于硬链接或普通文件，它不起作用。符号链接是一种特殊类型的文件，其中包含对其他文件或目录的路径引用，因此读取它的内容通常是获取所引用文件的路径。\n\n\n# opendir\n\nopendir 函数用于打开指定目录并返回一个指向目录流（dir 结构体的指针）的句柄，以便后续对目录中的文件和子目录进行遍历。其原型如下：\n\ndir *opendir(const char *dirname);\n\n\n1\n\n * dirname 是一个字符串，表示要打开的目录的路径名。\n\n原理：\n\n 1. 当调用 opendir 函数时，它会尝试打开指定路径的目录。\n\n 2. 如果成功，opendir 返回一个指向 dir 结构体的指针，该结构体用于表示打开的目录流。这个结构体包含有关目录的信息，如目录的文件描述符和目录项列表。\n\n 3. 目录流句柄可以用于后续的目录遍历操作，例如使用 readdir 函数读取目录中的文件和子目录项。\n\n 4. 如果打开目录失败，opendir 返回 null，表示出现了错误。在这种情况下，通常可以使用 errno 来获取出错的详细信息，例如 enoent 表示指定的目录不存在，eacces 表示无权限访问目录等。\n\nopendir 和 readdir 函数通常用于目录遍历操作，允许程序在目录中查找文件和子目录，并对它们进行处理。这对于编写文件管理和操作系统相关的程序非常有用。\n\n\n# readdir\n\nreaddir 函数用于从已打开的目录流中读取下一个目录项。其原型如下：\n\nstruct dirent *readdir(dir *dirp);\n\n\n1\n\n\n * dirp 是一个指向已打开目录流（dir 结构体的指针）的句柄。\n\n * struct dirent 是一个结构体，表示目录中的一个项，包括文件名、文件类型和其他属性。\n\n原理：\n\n 1. readdir 函数从指定的目录流 dirp 中读取下一个目录项，并返回一个指向 struct dirent 结构体的指针，其中包含有关该目录项的信息。\n\n 2. 如果目录流已经到达末尾（即没有更多的目录项可读取），或者出现错误，readdir 返回 null，表示读取结束或出现错误。此时，通常可以使用 errno 来获取出错的详细信息。\n\n 3. 通过多次调用 readdir 函数，可以依次读取目录中的所有文件和子目录项，直到读取到末尾为止。\n\n 4. struct dirent 结构体中包含了目录项的信息，如文件名、文件类型和其他属性。您可以使用这些信息来进一步处理目录中的文件和子目录。\n\nreaddir 函数通常与 opendir 函数一起使用，用于在目录中遍历文件和子目录。这对于需要执行文件管理或目录操作的应用程序非常有用。\n\n\n# atoi\n\natoi 函数用于将字符串转换为整数（int）。其原型如下：\n\nint atoi(const char *str);\n\n\n1\n\n * str 是一个指向包含表示整数的字符串的指针。\n\n原理：\n\n 1. atoi 函数从字符串 str 的起始位置开始扫描，并跳过前导空白字符（如空格、制表符等）。\n\n 2. 一旦遇到非空白字符，atoi 将开始解析整数。它会继续读取字符，直到遇到非数字字符或字符串的末尾。\n\n 3. 解析期间，atoi 将读取的字符转换为整数，并将其积累到一个整数值中。该整数值的初始值为零。\n\n 4. 如果字符串中包含无效字符或字符串为空，atoi 将停止解析，并返回当前积累的整数值。\n\n 5. 如果整数超出了 int 数据类型的范围，结果是未定义的。\n\n 6. 返回值为解析后的整数值。\n\natoi 主要用于将字符串形式的数字转换为整数，常用于文本处理和输入转换，但不提供错误检测机制。如果需要更强大的字符串到整数的转换和错误处理，可以使用 strtol 函数或其他更安全的替代方法。',charsets:{cjk:!0}},{title:"项目bug汇总",frontmatter:{title:"项目bug汇总",date:"2023-11-24T15:27:03.000Z",permalink:"/pages/00e0b6/"},regularPath:"/08.%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/30.ip_file_hook/02.%E9%A1%B9%E7%9B%AEbug%E6%B1%87%E6%80%BB.html",relativePath:"08.项目笔记/30.ip_file_hook/02.项目bug汇总.md",key:"v-c8b112f4",path:"/pages/00e0b6/",readingTime:{text:"1 min read",minutes:.805,time:48300.00000000001,words:161},headersStr:null,content:'1、先搜索target_link_libraries然后在 cjson 后面加上dl\n\n\n\n\n\n2、记得在CMakeLists.txt文件中添加\n\nset(CMAKE_CXX_STANDARD 11)\n\n\n\n3、Ninja下载\n\n\n\n你遇到的问题与CMake项目的配置有关。CMake 无法找到与 "Ninja" 对应的构建程序，同时还提示C和Cpp编译器未设置。通常可以通过以下步骤解决这些问题：\n\n 1. 安装 Ninja： 如果你想使用 Ninja 作为构建工具，你需要确保它已安装在你的系统上。Ninja 是一种构建工具，通常比 Make 更快。你可以使用系统的软件包管理器来安装它。例如，在 Debian/Ubuntu 上，你可以运行以下命令：\n    \n    sudo apt-get install ninja-build\n    \n    \n    1\n    \n    \n    在其他系统上，你可能需要使用不同的软件包管理器或手动下载 Ninja。\n\n 2. 设置C和Cpp编译器： CMake 需要知道要使用哪个C和Cpp编译器。你可以在运行CMake时通过设置 CMAKE_C_COMPILER 和 CMAKE_CXX_COMPILER 变量来指定这些编译器。例如，如果你想使用GCC作为编译器，可以执行以下命令：\n    \n    cmake -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ /你的源代码路径\n    \n    \n    1\n    \n    \n    请将 "gcc" 和 "g++" 替换为你的系统上适当的编译器命令。\n\n 3. 生成构建系统： 在设置编译器和任何其他必要选项后，你可以生成构建系统。确保指定要使用的生成器（在这种情况下是Ninja）：\n    \n    cmake --build . -G Ninja\n    \n    \n    1\n    \n    \n    将 "." 替换为你的CMake项目目录的路径。这个命令将生成Ninja构建文件并启动构建过程。\n\n如果你不想使用Ninja作为构建系统，你可以在命令中使用不同的生成器，常见的替代选项包括 "Make" 或不指定生成器（CMake将使用系统的默认生成器）。\n\n一旦你解决了这些问题，CMake应该能够成功配置你的项目并生成构建系统。\n\n4、dlsym的bug问题\n\n\n\n你的错误消息表明在运行 cat test_white_list.txt 时出现了符号查找错误。这通常发生在共享库（libhook.so）中引用了一个未定义的符号。\n\n在这种情况下，可能发生以下情况：\n\n 1. 共享库问题：libhook.so 可能依赖于其他共享库，而这些库没有正确链接或者版本不匹配。你可以使用以下命令查看 libhook.so 的依赖关系：\n    \n    ldd libhook.so\n    \n    \n    1\n    \n    \n    确保所有依赖项都可以正确找到，并且版本匹配。\n\n 2. 库加载顺序：在运行 cat 时，动态链接器加载共享库。可能 libhook.so 被加载，但它依赖的符号在加载时找不到。你可以尝试设置 LD_PRELOAD 环境变量来确保 libhook.so 在其他库之前加载：\n    \n    LD_PRELOAD=/path/to/libhook.so cat test_white_list.txt\n    \n    \n    1\n    \n\n 3. CMake 链接问题：检查你的 CMake 构建脚本是否正确配置了链接依赖项，特别是 dlsym 这个符号是否正确链接到 libdl 库。确保你的 CMakeLists.txt 文件中有类似以下的行：\n    \n    target_link_libraries(your_target_name dl)\n    \n    \n    1\n    \n    \n    这将确保 libdl 库正确链接到你的项目中。\n\n如果以上方法仍无法解决问题，你可能需要进一步检查共享库的依赖关系和构建过程，以确保所有库正确链接，并且符号都能够正确解析。\n\n\n\n根据你提供的 libcjson.so.1 的依赖信息，它似乎没有显式依赖于 libdl 库，因为 libdl 没有在依赖列表中。\n\n问题可能出在 libhook.so 中，它依赖于 cjson 并可能间接依赖于 libdl，但却未正确链接到 libdl。\n\n你可以尝试在 libhook.so 的构建过程中显式链接到 libdl，以确保 dlsym 等符号能够正确解析。在你的 CMakeLists.txt 文件中添加以下行：\n\ntarget_link_libraries(${CMAKE_PROJECT_NAME} PRIVATE cjson dl)\n\n\n1\n\n\n这将确保在构建 libhook.so 时，它会正确链接到 libdl。\n\n重新构建 libhook.so 后，再次运行你的测试命令 cat test_white_list.txt，看看是否问题得到解决。如果问题仍然存在，请确保 libhook.so 的链接设置和运行时环境都正确。',normalizedContent:'1、先搜索target_link_libraries然后在 cjson 后面加上dl\n\n\n\n\n\n2、记得在cmakelists.txt文件中添加\n\nset(cmake_cxx_standard 11)\n\n\n\n3、ninja下载\n\n\n\n你遇到的问题与cmake项目的配置有关。cmake 无法找到与 "ninja" 对应的构建程序，同时还提示c和cpp编译器未设置。通常可以通过以下步骤解决这些问题：\n\n 1. 安装 ninja： 如果你想使用 ninja 作为构建工具，你需要确保它已安装在你的系统上。ninja 是一种构建工具，通常比 make 更快。你可以使用系统的软件包管理器来安装它。例如，在 debian/ubuntu 上，你可以运行以下命令：\n    \n    sudo apt-get install ninja-build\n    \n    \n    1\n    \n    \n    在其他系统上，你可能需要使用不同的软件包管理器或手动下载 ninja。\n\n 2. 设置c和cpp编译器： cmake 需要知道要使用哪个c和cpp编译器。你可以在运行cmake时通过设置 cmake_c_compiler 和 cmake_cxx_compiler 变量来指定这些编译器。例如，如果你想使用gcc作为编译器，可以执行以下命令：\n    \n    cmake -dcmake_c_compiler=gcc -dcmake_cxx_compiler=g++ /你的源代码路径\n    \n    \n    1\n    \n    \n    请将 "gcc" 和 "g++" 替换为你的系统上适当的编译器命令。\n\n 3. 生成构建系统： 在设置编译器和任何其他必要选项后，你可以生成构建系统。确保指定要使用的生成器（在这种情况下是ninja）：\n    \n    cmake --build . -g ninja\n    \n    \n    1\n    \n    \n    将 "." 替换为你的cmake项目目录的路径。这个命令将生成ninja构建文件并启动构建过程。\n\n如果你不想使用ninja作为构建系统，你可以在命令中使用不同的生成器，常见的替代选项包括 "make" 或不指定生成器（cmake将使用系统的默认生成器）。\n\n一旦你解决了这些问题，cmake应该能够成功配置你的项目并生成构建系统。\n\n4、dlsym的bug问题\n\n\n\n你的错误消息表明在运行 cat test_white_list.txt 时出现了符号查找错误。这通常发生在共享库（libhook.so）中引用了一个未定义的符号。\n\n在这种情况下，可能发生以下情况：\n\n 1. 共享库问题：libhook.so 可能依赖于其他共享库，而这些库没有正确链接或者版本不匹配。你可以使用以下命令查看 libhook.so 的依赖关系：\n    \n    ldd libhook.so\n    \n    \n    1\n    \n    \n    确保所有依赖项都可以正确找到，并且版本匹配。\n\n 2. 库加载顺序：在运行 cat 时，动态链接器加载共享库。可能 libhook.so 被加载，但它依赖的符号在加载时找不到。你可以尝试设置 ld_preload 环境变量来确保 libhook.so 在其他库之前加载：\n    \n    ld_preload=/path/to/libhook.so cat test_white_list.txt\n    \n    \n    1\n    \n\n 3. cmake 链接问题：检查你的 cmake 构建脚本是否正确配置了链接依赖项，特别是 dlsym 这个符号是否正确链接到 libdl 库。确保你的 cmakelists.txt 文件中有类似以下的行：\n    \n    target_link_libraries(your_target_name dl)\n    \n    \n    1\n    \n    \n    这将确保 libdl 库正确链接到你的项目中。\n\n如果以上方法仍无法解决问题，你可能需要进一步检查共享库的依赖关系和构建过程，以确保所有库正确链接，并且符号都能够正确解析。\n\n\n\n根据你提供的 libcjson.so.1 的依赖信息，它似乎没有显式依赖于 libdl 库，因为 libdl 没有在依赖列表中。\n\n问题可能出在 libhook.so 中，它依赖于 cjson 并可能间接依赖于 libdl，但却未正确链接到 libdl。\n\n你可以尝试在 libhook.so 的构建过程中显式链接到 libdl，以确保 dlsym 等符号能够正确解析。在你的 cmakelists.txt 文件中添加以下行：\n\ntarget_link_libraries(${cmake_project_name} private cjson dl)\n\n\n1\n\n\n这将确保在构建 libhook.so 时，它会正确链接到 libdl。\n\n重新构建 libhook.so 后，再次运行你的测试命令 cat test_white_list.txt，看看是否问题得到解决。如果问题仍然存在，请确保 libhook.so 的链接设置和运行时环境都正确。',charsets:{cjk:!0}},{title:"js学习",frontmatter:{title:"js学习",date:"2023-07-06T08:46:25.000Z",permalink:"/pages/51542d/"},regularPath:"/09.%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/03.js%E5%AD%A6%E4%B9%A0.html",relativePath:"09.前端学习/03.js学习.md",key:"v-1e3da8ea",path:"/pages/51542d/",headers:[{level:2,title:"什么是 ES6 ？",slug:"什么是-es6",normalizedTitle:"什么是 es6 ？",charIndex:22},{level:2,title:"1、变量与数据类型",slug:"_1、变量与数据类型",normalizedTitle:"1、变量与数据类型",charIndex:279},{level:3,title:"声明变量（作用域）",slug:"声明变量-作用域",normalizedTitle:"声明变量（作用域）",charIndex:293},{level:4,title:"1) let ⭐️",slug:"_1-let",normalizedTitle:"1) let ⭐️",charIndex:306},{level:4,title:"2) const ⭐️",slug:"_2-const",normalizedTitle:"2) const ⭐️",charIndex:424},{level:4,title:"3) var",slug:"_3-var",normalizedTitle:"3) var",charIndex:690},{level:4,title:"let 和 var 的区别？",slug:"let-和-var-的区别",normalizedTitle:"let 和 var 的区别？",charIndex:759},{level:3,title:"基本类型",slug:"基本类型",normalizedTitle:"基本类型",charIndex:1211},{level:4,title:"1,2) undefined 和 null",slug:"_1-2-undefined-和-null",normalizedTitle:"1,2) undefined 和 null",charIndex:1219},{level:4,title:"3) string ⭐️",slug:"_3-string",normalizedTitle:"3) string ⭐️",charIndex:1731},{level:4,title:"4,5) number 和 bigint⭐️",slug:"_4-5-number-和-bigint",normalizedTitle:"4,5) number 和 bigint⭐️",charIndex:2473},{level:4,title:"6) boolean ⭐️",slug:"_6-boolean",normalizedTitle:"6) boolean ⭐️",charIndex:3030},{level:4,title:"7) symbol",slug:"_7-symbol",normalizedTitle:"7) symbol",charIndex:3493},{level:3,title:"对象类型",slug:"对象类型",normalizedTitle:"对象类型",charIndex:3574},{level:4,title:"1) Function(函数)⭐️⭐️",slug:"_1-function-函数",normalizedTitle:"1) function(函数)⭐️⭐️",charIndex:3582},{level:5,title:"定义函数",slug:"定义函数",normalizedTitle:"定义函数",charIndex:3605},{level:5,title:"调用函数",slug:"调用函数",normalizedTitle:"调用函数",charIndex:3726},{level:5,title:"默认参数",slug:"默认参数",normalizedTitle:"默认参数",charIndex:3997},{level:5,title:"匿名函数",slug:"匿名函数",normalizedTitle:"匿名函数",charIndex:4480},{level:5,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:4898},{level:5,title:"函数是对象",slug:"函数是对象",normalizedTitle:"函数是对象",charIndex:5611},{level:5,title:"函数作用域",slug:"函数作用域",normalizedTitle:"函数作用域",charIndex:6517},{level:5,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:7029},{level:5,title:"let、var 与作用域",slug:"let、var-与作用域",normalizedTitle:"let、var 与作用域",charIndex:7329},{level:4,title:"2) Array ⭐️",slug:"_2-array",normalizedTitle:"2) array ⭐️",charIndex:8380},{level:4,title:"3) Object ⭐️⭐️",slug:"_3-object",normalizedTitle:"3) object ⭐️⭐️",charIndex:10413},{level:5,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:4486},{level:5,title:"特色：属性增删",slug:"特色-属性增删",normalizedTitle:"特色：属性增删",charIndex:11284},{level:5,title:"特色：this",slug:"特色-this",normalizedTitle:"特色：this",charIndex:11842},{level:5,title:"特色：原型继承",slug:"特色-原型继承",normalizedTitle:"特色：原型继承",charIndex:13952},{level:5,title:"特色：基于函数的原型继承",slug:"特色-基于函数的原型继承",normalizedTitle:"特色：基于函数的原型继承",charIndex:14420},{level:5,title:"JSON",slug:"json",normalizedTitle:"json",charIndex:14961},{level:3,title:"类型",slug:"类型",normalizedTitle:"类型",charIndex:286},{level:4,title:"静态类型",slug:"静态类型",normalizedTitle:"静态类型",charIndex:15490},{level:4,title:"动态类型",slug:"动态类型",normalizedTitle:"动态类型",charIndex:15613},{level:2,title:"2、运算符与表达式",slug:"_2、运算符与表达式",normalizedTitle:"2、运算符与表达式",charIndex:15838},{level:3,title:"1) ===",slug:"_1",normalizedTitle:"1) ===",charIndex:15992},{level:3,title:"2) ||",slug:"_2",normalizedTitle:"2) ||",charIndex:16246},{level:3,title:"3) ?? 与 ?.",slug:"_3-与",normalizedTitle:"3) ?? 与 ?.",charIndex:16706},{level:4,title:"??",slug:"",normalizedTitle:"??",charIndex:15958},{level:4,title:"?.",slug:"-2",normalizedTitle:"?.",charIndex:15961},{level:3,title:"4) ...",slug:"_4",normalizedTitle:"4) ...",charIndex:17646},{level:3,title:"5) [] {}",slug:"_5",normalizedTitle:"5) [] {}",charIndex:18536},{level:4,title:"[]",slug:"-3",normalizedTitle:"[]",charIndex:3473},{level:4,title:"{}",slug:"-4",normalizedTitle:"{}",charIndex:3483},{level:2,title:"3、控制语句",slug:"_3、控制语句",normalizedTitle:"3、控制语句",charIndex:19027},{level:3,title:"1) for in",slug:"_1-for-in",normalizedTitle:"1) for in",charIndex:19150},{level:3,title:"2) for of",slug:"_2-for-of",normalizedTitle:"2) for of",charIndex:19588},{level:3,title:"3) try catch",slug:"_3-try-catch",normalizedTitle:"3) try catch",charIndex:19962},{level:2,title:"4、API",slug:"_4、api",normalizedTitle:"4、api",charIndex:20282},{level:3,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:20292},{level:4,title:"1) 安装 nvm",slug:"_1-安装-nvm",normalizedTitle:"1) 安装 nvm",charIndex:20300},{level:4,title:"2) 检查 npm",slug:"_2-检查-npm",normalizedTitle:"2) 检查 npm",charIndex:22267},{level:4,title:"3) 搭建前端服务器",slug:"_3-搭建前端服务器",normalizedTitle:"3) 搭建前端服务器",charIndex:22470},{level:3,title:"前端案例",slug:"前端案例",normalizedTitle:"前端案例",charIndex:22896},{level:4,title:"1) 查找元素",slug:"_1-查找元素",normalizedTitle:"1) 查找元素",charIndex:23002},{level:4,title:"2) 修改元素内容",slug:"_2-修改元素内容",normalizedTitle:"2) 修改元素内容",charIndex:24558},{level:4,title:"3) 利用模板",slug:"_3-利用模板",normalizedTitle:"3) 利用模板",charIndex:24776},{level:4,title:"4) Fetch API",slug:"_4-fetch-api",normalizedTitle:"4) fetch api",charIndex:26152},{level:5,title:"跨域问题",slug:"跨域问题",normalizedTitle:"跨域问题",charIndex:28817},{level:4,title:"5) 模块化",slug:"_5-模块化",normalizedTitle:"5) 模块化",charIndex:29767},{level:4,title:"export 导出",slug:"export-导出",normalizedTitle:"export 导出",charIndex:29777},{level:4,title:"import 导入",slug:"import-导入",normalizedTitle:"import 导入",charIndex:30159}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"21 min read",minutes:20.255,time:1215300,words:4051},headersStr:"什么是 ES6 ？ 1、变量与数据类型 声明变量（作用域） 1) let ⭐️ 2) const ⭐️ 3) var let 和 var 的区别？ 基本类型 1,2) undefined 和 null 3) string ⭐️ 4,5) number 和 bigint⭐️ 6) boolean ⭐️ 7) symbol 对象类型 1) Function(函数)⭐️⭐️ 定义函数 调用函数 默认参数 匿名函数 箭头函数 函数是对象 函数作用域 闭包 let、var 与作用域 2) Array ⭐️ 3) Object ⭐️⭐️ 语法 特色：属性增删 特色：this 特色：原型继承 特色：基于函数的原型继承 JSON 类型 静态类型 动态类型 2、运算符与表达式 1) === 2) || 3) ?? 与 ?. ?? ?. 4) ... 5) [] {} [] {} 3、控制语句 1) for in 2) for of 3) try catch 4、API 环境准备 1) 安装 nvm 2) 检查 npm 3) 搭建前端服务器 前端案例 1) 查找元素 2) 修改元素内容 3) 利用模板 4) Fetch API 跨域问题 5) 模块化 export 导出 import 导入",content:'# JavaScript 学习小结\n\n\n# 什么是 ES6 ？\n\n根据维基百科解释 ECMAScript 规范是由 Netscape 的 Brendan Eich 开发的脚本语言的标准化规范。\n\n最初命名为 Mocha，然后是 LiveScript，最后是 JavaScript。\n\n> ECMAScript 是规范，JavaScript 是其的一种实现\n\nECMAScript 2015 (ES2015) 是第 6 版，最初称为 ECMAScript 6 (ES6)，它添加了许多新功能，这些新功能后来成为 Web 开发人员工具包的重要组成部分。\n\n\n# 1、变量与数据类型\n\n\n# 声明变量（作用域）\n\n# 1) let ⭐️\n\nlet 变量名 = 值;\n\n\n1\n\n * let 声明的变量可以被多次赋值，例如\n\nlet a = 100;  // 初始值是 100\na = 200;\t  // ok, 被重新赋值为 200\n\n\n1\n2\n\n\n# 2) const ⭐️\n\n * const 修饰的叫常量，只能赋值一次\n\nconst b = 300; // 初始值是 300\nb = 400;\t   // error, 不能再次赋值\n\n\n1\n2\n\n * const 并不意味着它引用的内容不可修改，例如\n\nconst c = [1,2,3];\nc[2] = 4; \t        // ok, 数组内容被修改成 [1,2,4]\nc = [5,6];\t\t\t// error, 不能再次赋值\n\n\n1\n2\n3\n\n\n> 总结：const 修饰的变量，只能被赋值一次但内容可以修改\n\n# 3) var\n\nvar 声明的变量可以被多次赋值（let 也是），例如\n\nvar f = 100;\nf = 200;\n\n\n1\n2\n\n\n# let 和 var 的区别？\n\n作用域（即范围）不同。\n\n首先，什么是范围？\n\n范围是指：来自我们程序不同部分的变量的可访问性。\n\n * 使用 var 声明时，JavaScript 变量具有全局范围和函数范围。\n * 当使用 let 声明变量时，ES6 为 JavaScript 带来了块级范围。\n\n{\n    var a = "🍉";\n    let b = "⛳";\n}\nconsole.log(a);\nconsole.log(b);\nUncaught ReferenceError: b is not defined // b 没有定义\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出，我们使用 var 关键字在 block 中定义了变量 “a”，可以全局访问。所以 var 声明的变量是全局的。\n\n但是，我们希望变量在 block 中生效，退出 block 时不可访问。然后，可以使用 ES6 新的块级作用域关键字 let 来声明变量，就像这里的变量 b 一样，会报错说 b 没有定义。\n\n\n# 基本类型\n\n# 1,2) undefined 和 null\n\n 1. 执行表达式或函数，没有返回结果，出现 undefined\n 2. 访问数组不存在的元素，访问对象不存在的属性，出现 undefined\n 3. 定义变量，没有初始化，出现 undefined\n\n例如：\n\nconsole.log(1);  \t// 函数没有返回值, 结果是  undefined\n\nlet a = 10;\t\t \t// 表达式没有返回值, 结果是 undefined\n\nlet b = [1,2,3];\nconsole.log(b[10]); // 数组未定义元素，结果是 undefined\n\nlet c = {"name":"张三"};\nconsole.log(c.age); // 对象未定义属性，结果是 undefined\n\nlet d;\nconsole.log(d);\t\t// 变量未初始化，结果是 undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n二者共同点：\n\n * 都没有属性、方法\n * 二者合称 Nullish\n\n二者区别：\n\n * undefined 由 js 产生\n * null 由程序员提供\n\n# 3) string ⭐️\n\njs 字符串有以下三种写法：\n\nlet a = "hello";  // 双引号\nlet b = "world";  // 单引号\nlet c = `hello`;  // 反引号\n\n\n1\n2\n3\n\n\n> 字符串如何表示？\n\nhtml 代码如下\n\n<a href="1.html">超链接</a>\n\n\n1\n\n\njava 显得比较繁琐\n\nString s1 = "<a href=\\"1.html\\">超链接</a>";\n\nString s2 = """\n    <a href="1.html">超链接</a>""";\n\n\n1\n2\n3\n4\n\n\njs 就比较灵活\n\nlet s1 = \'<a href="1.html">超链接</a>\';\n\nlet s2 = `<a href="1.html">超链接</a>`;\n\n\n1\n2\n3\n\n\n> 模板字符串（Template strings）\n\n需求：拼接 URL 的请求参数，如\n\n/test?name=zhang&age=18\n/test?name=li&age=20\n\n\n1\n2\n\n\n传统方法拼接，用 + 号拼接：\n\nlet name = ; // zhang li ...\nlet age = ; // 18 20 ...\n\nlet url = "/test?name=" + name + "&age=" + age;\n\n\n1\n2\n3\n4\n\n\n模板字符串方式，用 ${参数}：\n\nlet name = ; // zhang li ...\nlet age = ; // 18 20 ...\n\nlet url = `/test?name=${name}&age=${age}`;\n\n\n1\n2\n3\n4\n\n\n# 4,5) number 和 bigint⭐️\n\n> number\n\nnumber 类型标识的是双精度浮动小数，例如\n\n10 / 3;   // 结果 3.3333333333333335\n\n\n1\n\n\n既然是浮点小数，那么可以除零\n\n10 / 0;\t  // 结果 Infinity 正无穷大\n-10 / 0;  // 结果 -Infinity 负无穷大\n\n\n1\n2\n\n\n浮点小数都有运算精度问题，例如\n\n2.0 - 1.1; // 结果 0.8999999999999999\n\n\n1\n\n\n字符串转数字\n\nparseInt("10"); \t// 结果是数字 10 \nparseInt("10.5");\t// 结果是数字 10, 去除了小数部分\n\nparseInt("10") / 3; // 结果仍视为 number 浮点数, 因此结果为 3.3333333333333335\n\nparseInt("abc");\t// 转换失败，结果是特殊值 NaN (Not a Number)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> bigint\n\n要表示真正的整数，需要用 bigint。\n\n注意：数字的结尾用 n 表示它是一个 bigint 类型。\n\n10n / 3n;\t\t\t// 结果 3n, 按整数除法处理\n\n\n1\n\n\n# 6) boolean ⭐️\n\n * Truthy\n * Falsy\n\n在 js 中，并不是 boolean 才能用于条件判断，你可以在 if 语句中使用【数字】、【字符串】... 作为判断条件\n\nlet b = 1;\n\nif(b) { // true\n    console.log("进入了");\n}\n\n\n1\n2\n3\n4\n5\n\n\n这时就有一个规则，当需要条件判断时，这个值被当作 true 还是 false。\n\n * 当作 true 的值归类为 truthy，\n * 当作 false 的值归类为 falsy\n\n> 下面值都是 falsy\n\n * false\n * Nullish (null, undefined)\n * 0, 0n, NaN\n * "" \'\' `` 即长度为零的字符串\n\n> 剩余的值绝大部分都是 truthy\n\n有几个容易被当作 falsy 实际是 truthy 的\n\n * "false", "0" (注意双引号）即字符串的 false 和 字符串的零\n * [] 空数组\n * {} 空对象\n\n# 7) symbol\n\n用于表示唯一的标识符。\n\nconst mySymbol = Symbol(\'description\');\n\n\n1\n\n * 很少使用\n\n\n# 对象类型\n\n# 1) Function(函数)⭐️⭐️\n\n# 定义函数\n\nfunction 函数名(参数) {\n    // 函数体\n    return 结果;\n}\n\n\n1\n2\n3\n4\n\n\n例\n\nfunction add(a, b) {\n    return a + b;\n}\n\n\n1\n2\n3\n\n\n# 调用函数\n\n函数名(实参);\n\n\n1\n\n\n例\n\nadd(1, 2);     // 返回 3\n\n\n1\n\n\njs 中的函数调用特点：对参数的类型和个数都没有限制，例如\n\n// 对类型没限制\nadd(\'a\', \'b\');  // 返回 ab\nadd(4, 5, 6);   // 返回 9, 第三个参数没有被用到, 不会报错\n// 对参数个数没限制\nadd(1);\t\t\t// 返回 NaN, 这时 b 没有定义是 undefined, undefined 做数学运算结果就是 NaN（1 + undefined）\n\n\n1\n2\n3\n4\n5\n\n\n# 默认参数\n\n * java 中（spring）要实现默认参数的效果得这么做：\n\n用 @RequestParam(defaultValue="1") 指定参数默认值\n\n@RestController \npublic class MyController {\n    \n    @RequestMapping("/page")\n    @ResponseBody\n    public void page(\n        @RequestParam(defaultValue="1") int page, \n        @RequestParam(defaultValue="10") int size\n    ){\n        // ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 在 js 中，直接用 参数 = 值 的形式就可以赋默认值：\n\nfunction pagination(page = 1, size = 10) {\n    console.log(page, size);\n}\n\n\n1\n2\n3\n\n\n# 匿名函数\n\n语法，小括号包含整个函数内容\n\n(function (参数) {\n    // 函数体\n    return 结果;\n})\n\n\n1\n2\n3\n4\n\n\n例\n\n(function(a,b){\n    return a + b;\n})\n\n\n1\n2\n3\n\n\n> 第一种场景：定义完毕后立刻调用\n\n(function(a,b){\n    return a + b;\n})(1,2)\n\n\n1\n2\n3\n\n\n> 第二种场景：作为其它对象的方法，例如\n\n页面有元素\n\n<p id="p1">点我啊</p>\n\n\n1\n\n\n此元素有一个 onclick 方法，会在鼠标单击这个元素后被执行，onclick 方法刚开始是 null，需要赋值后才能使用。\n\ndocument.getElementById("p1").onclick = (function(){\n    console.log("鼠标单击了...");\n});\n\n\n1\n2\n3\n\n\n# 箭头函数\n\n(参数) => {\n    // 函数体\n    return 结果;\n}\n\n\n1\n2\n3\n4\n\n\n语法规则，有点像 java 中的 Lambda 表达式：\n\n * 如果没有参数，() 还是要保留\n   \n   const sayHello = () => {\n     console.log("Hello!");\n   };\n   \n   sayHello();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 如果只有一个参数，() 可以省略\n   \n   const double = number => {\n     return number * 2;\n   };\n   \n   console.log(double(5));\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 如果函数体内只有一行代码，{} 可以省略\n   \n   const sayHi = () => console.log("Hi!");\n   \n   sayHi();\n   \n   document.getElementById("p1").onclick = () =>  console.log("aa");\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 如果这一行代码就是结果，return 可以省略\n   \n   const multiply = (a, b) => a * b;\n   \n   console.log(multiply(2, 3));\n   \n   \n   1\n   2\n   3\n   \n\n# 函数是对象\n\n以下形式在 js 中非常常见！\n\n>  1. 可以参与赋值，例，具名函数也能参与赋值\n\nfunction abc() {\n    console.log("bb");\n}\n// 将函数赋值到 onclick 方法中\ndocument.getElementById("p1").onclick = abc;\n\n\n1\n2\n3\n4\n5\n\n>  2. 有属性、有方法，执行 console.dir(abc)，输出结果如下\n\nƒ abc()\n    arguments: null\n    caller: null\n    length: 0\n    name: "abc"\n    ➡prototype: {constructor: ƒ}\n    [[FunctionLocation]]: VM1962:1\n    ➡[[Prototype]]: ƒ ()\n    ➡[[Scopes]]: Scopes[1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 其中带有 f 标记的是方法，不带的是属性\n\n * 带有 ➡ 符号的可以继续展开，限于篇幅省略了\n\n * 带有 [[ ]] 的是内置属性，不能访问，只能查看\n\n * 相对重要的是 [[Prototype]] 和 [[Scopes]] 会在后面继承和作用域时讲到\n\n>  3. 可以作为方法参数\n\nfunction a() {\n    console.log(\'a\')\n}\n\nfunction b(fn) {          // fn 将来可以是一个函数对象\n    console.log(\'b\')\n    fn();                 // 调用函数对象\n}\n\nb(a)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n>  4. 可以作为方法返回值\n\nfunction c() {\n    console.log("c");\n    function d() {\n        console.log("d");\n    }\n    return d;\n}\n\nc()()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 函数作用域\n\n函数可以嵌套（js 代码中很常见，只是嵌套的形式更多是匿名函数，箭头函数）\n\nfunction a() {\n    function b() {        \n    }\n}\n\n\n1\n2\n3\n4\n\n\n看下面的例子\n\nfunction c() {\n    var z = 30;\n}\n\nvar x = 10; // 全局作用域\nfunction a() {\n    var y = 20; // 局部作用域，只能在 a() 和 b() 中访问\n    function b() {\n        // 看这里\n        console.log(x, y);\n    }\n    b(); // 输出 10 20\n}\n\na(); // 10 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 以函数为分界线划定作用域，所有函数之外是全局作用域\n * 查找变量时，由内向外查找\n   * 在内层作用域找到变量，就会停止查找，不会再找外层\n   * 所有作用域都找不到变量，报错\n * 作用域本质上是函数对象的属性，可以通过 console.dir 来查看调试\n\n# 闭包\n\n * 函数定义时，它的作用域已经确定好了，因此无论函数将来去了哪，都能从它的作用域中找到当时那些变量\n * 别被概念忽悠了，闭包就是指函数能够访问自己的作用域中变量\n\nvar x = 10;\nfunction a() {\n    var y = 20;\n    function b() {\n        console.log(x,y);\n    }\n    return b;\n}\n// 在外面执行了 b，通过调用a()()，首先执行a()函数，然后再 调用返回的函数b\na()(); // 最终的输出结果还是 10 20\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# let、var 与作用域\n\n> 如果函数外层引用的是 let 变量，那么外层普通的 {} 也会作为作用域边界，最外层的 let 也占一个 script 作用域\n\nlet x = 10; \nif(true) {\n    let y = 20;\n    function b() {\n        console.log(x,y);\n    }\n    console.dir(b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 如果函数外层引用的是 var 变量，外层普通的 {} 不会视为边界\n\nvar x = 10; \nif(true) {\n    var y = 20; // 注意，是在 b 函数外定义的\n    function b() {\n        console.log(x,y);\n    }\n    console.dir(b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 如果 var 变量出现了重名，则他俩会被视为同一作用域中的同一个变量\n\nvar e = 10; \nif(true) {\n    var e = 20;\n    console.log(e);\t// 打印 20\n}\nconsole.log(e);\t\t// 因为是同一个变量，还是打印 20\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 如果是 let，则视为两个作用域中的两个变量，一个全局范围，一个块局范围\n\nlet e = 10; \nif(true) {\n    let e = 20;\t\n    console.log(e);\t// 打印 20\n}\nconsole.log(e);\t\t// 打印 10\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 要想里面的 e 和外面的 e 能区分开来，最简单的办法是改成 let，或者用函数来界定作用域范围\n\nvar e = 10; \nif(true) {\n    function b() {\n        var e = 20;\n    \tconsole.log(e);\n    }\n    b(); // 20\n}\nconsole.log(e); // 10\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n函数 b() 的作用域与外部作用域是分离的，因此在函数 b() 内部声明的变量 e 不会影响外部作用域中的变量 e。因此，函数 b() 内部的 console.log(e) 会打印 20，而外部的 console.log(e) 会打印最初的值 10。\n\n# 2) Array ⭐️\n\n> 语法\n\n// 创建数组\nlet arr = [1,2,3]; \n\n// 获取数组元素\nconsole.log(arr[0]); // 输出 1\n\n// 修改数组元素\narray[0] = 5;\t\t // 数组元素变成了 [5,2,3]\n\n// 遍历数组元素，其中 length 是数组属性，代表数组长度\nfor(let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> API\n\n * push 【尾部】添加、shift 【头部】移除、splice 删除【参数1】索引位置开始的【参数2】个元素\n\nlet arr = [1,2,3]; \n\narr.push(4);    \t// 向数组尾部(右侧)添加元素, 结果 [1,2,3,4]\narr.shift();\t\t// 从数组头部(左侧)移除元素, 结果 [2,3,4]\narr.splice(1,1);\t// 删除【参数1】索引位置的【参数2】个元素，结果 [2,4]\n\n\n1\n2\n3\n4\n5\n\n * join\n\n用于将数组中的所有元素连接成一个字符串。\n\n语法：array.join(separator)\n\nseparator：可选参数，表示在连接数组元素时使用的分隔符字符串。如果省略该参数，则默认使用逗号 , 作为分隔符。\n\nlet arr = [\'a\',\'b\',\'c\'];\n\narr.join(); \t\t// 默认使用【,】作为连接符，结果 \'a,b,c\'\narr.join(\'\');\t\t// 结果 \'abc\'\narr.join(\'-\');\t\t// 结果 \'a-b-c\'\n\n\n1\n2\n3\n4\n5\n\n * map、filter、forEach\n\n> map 例子 -- 处理元素，返回新数组\n\n * map 方法用于遍历数组的每个元素，并对每个元素执行指定的回调函数，然后将返回的值组成一个新数组。\n * 它返回一个新数组，其中包含每个元素经过回调函数处理后的结果。\n * 回调函数接受三个参数：当前元素的值、当前索引和数组本身。\n\nlet arr = [1,2,3,6];\n\nfunction a(i) {   // 代表的新旧元素之间的变换规则\n    return i * 10\n}\n\n// arr.map(a) // 具名函数，结果 [10,20,30,60]\n\n// arr.map( (i) => {return i * 10} ); // 箭头函数\narr.map( i => i * 10 ); // 箭头函数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 传给 map 的函数，参数代表旧元素，返回值代表新元素\n\nmap 的内部实现（伪代码）\n\nfunction map(a) { // 参数是一个函数\n    let narr = [];\n    for(let i = 0; i < arr.length; i++) {\n        let o = arr[i]; // 旧元素\n        let n = a(o);   // 新元素\n        narr.push(n);\n    }\n    return narr;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> filter 例子 -- 筛选元数，返回新数组\n\n * filter 方法用于遍历数组的每个元素，并对每个元素执行指定的回调函数，然后根据回调函数的返回值来筛选出符合条件的元素组成一个新数组。\n * 它返回一个新数组，其中包含满足回调函数条件的元素。\n * 回调函数接受三个参数：当前元素的值、当前索引和数组本身。\n\nlet arr = [1,2,3,6];\narr.filter( (i)=> i % 2 == 1 ); // 结果 [1,3]\n\n\n1\n2\n\n * 传给 filter 的函数，参数代表旧元素，返回 true 表示要留下的元素\n\n> forEach 例子 -- 遍历数组，没有返回值\n\n * forEach 方法用于遍历数组的每个元素，并对每个元素执行指定的回调函数。\n * 它没有返回值，只是依次对数组的每个元素执行回调函数。\n * 回调函数接受三个参数：当前元素的值、当前索引和数组本身。\n\nlet arr = [1,2,3,6];\n\n/*for(let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}*/\n\narr.forEach( (i) => console.log(i) );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n两个称呼\n\n * 高阶函数，map，filter，forEach\n * 回调函数，例如作为参数传入的函数\n\n# 3) Object ⭐️⭐️\n\n# 语法\n\nlet obj = {\n    属性名: 值,\n    方法名: 函数,\n    get 属性名() {},\n    set 属性名(新值) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n例1\n\nlet stu1 = {\n    name: "小明",\n    age: 18,\n    study: function(){\n        console.log(this.name + "爱学习");\n    }    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n例2\n\nlet name = "小黑";\nlet age = 20;\nlet study = function(){\n    console.log(this.name + "爱学习");\n}\n\nlet stu2 = { name, age, study }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n例3（重点）\n\nlet stu3 = {\n    name: "小白",\n    age: 18,\n    study(){\n        console.log(this.name + "爱学习");\n    }    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 注意：对象方法这么写，仅限于对象内部\n\n例4\n\nlet stu4 = {\n    _name: null, /*类似于java中私有成员变量*/\n    get name() {\n        console.log("进入了get");\n        return this._name;\n    },\n    set name(name) {\n        console.log("进入了set");\n        this._name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n调用 get，set\n\nstu4.name = "小白"\n\nconsole.log(stu4.name)\n\n\n1\n2\n3\n\n\n# 特色：属性增删\n\n对比一下 Java 中的 Object\n\n * Java 的 Object 是以类作为模板来创建，对象不能脱离类模板的范围，一个对象的属性、能用的方法都是确定好的\n * js 的对象，不需要什么模板，它的属性和方法可以随时加减\n\nlet stu = {name:\'张三\'};\nstu.age = 18;\t\t\t\t\t// 添加属性\ndelete stu.age;\t\t\t\t\t// 删除属性\n\nstu.study = function() {\t\t// 添加方法\n    console.log(this.name + "在学习");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n添加 get，set，需要借助 Object.definePropery\n\nlet stu = {_name:null};\n\nObject.defineProperty(stu, "name", {\n    get(){\n        return this._name;\n    },\n    set(name){\n        this._name = name;\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 参数1：目标对象\n * 参数2：属性名\n * 参数3：get，set 的定义\n\n# 特色：this\n\n 1. 先来对 Java 中的 this 有个理解\n\npublic class TestMethod {\n\n    static class Student {\n        private String name;\n\n        public Student(String name) {\n            this.name = name;\n        }\n\n        public void study(Student this, String subject) {\n            System.out.println(this.name + "在学习 " + subject);\n        }\n    }\n\n    public static void main(String[] args) {\n        Student stu = new Student("小明");\n        \n        // 下面的代码，本质上是执行 study(stu, "java")，因此 this 就是 stu\n        stu.study("java"); \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * Java 中的 this 是个隐式参数\n * Java 中，我们说 this 代表的就是调用方法的那个对象\n\n 2. js 中的 this 也是隐式参数，但它与函数运行时上下文相关\n\n> 例如，一个“落单”的函数\n\nfunction study(subject) {\n    console.log(this.name + "在学习 " + subject)\n}\n\n\n1\n2\n3\n\n\n测试一下\n\nstudy("js");  // 输出 在学习 js\n\n\n1\n\n\n这是因为此时函数执行，全局对象 window 被当作了 this，window 对象的 name 属性是空串\n\n> 同样的函数，如果作为对象的方法\n\nlet stu = {\n    name:"小白",\n    study\n}\n\n\n1\n2\n3\n4\n\n\n这种情况下，会将当前对象作为 this\n\nstu.study(\'js\'); \t// 输出 小白在学习 js\n\n\n1\n\n\n> 还可以动态改变 this\n\nlet stu = {name:"小黑"};\nstudy.call(stu, "js");\t// 输出 小黑在学习 js\n\n\n1\n2\n\n\n使用了 call 方法来调用 study 函数，这回 study 执行时，就把 call 的第一个参数 stu 作为 this\n\n> 一个例外是，在箭头函数内出现的 this，以外层 this 理解\n\n 1. 用匿名函数\n\nlet stu = {\n    name: "小花",\n    friends: ["小白","小黑","小明"],\n    play() {\n        this.friends.forEach(function(e){\n            console.log(this.name + "与" + e + "在玩耍");\n        });\n    }\n}\nstu.play()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * this.name 所在的函数是【落单】的函数，因此 this 代表 window\n\n输出结果为\n\n与小白在玩耍\n与小黑在玩耍\n与小明在玩耍\n\n\n1\n2\n3\n\n 2. 用箭头函数\n\nlet stu = {\n    name: "小花",\n    friends: ["小白","小黑","小明"],\n    play() {\n        this.friends.forEach(e => {\n            console.log(this.name + "与" + e + "在玩耍");\n        })\n    }    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * this.name 所在的函数是箭头函数，因此 this 要看它外层的 play 函数，play 又是属于 stu 的方法，因此 this 代表 stu 对象\n\n输出结果为\n\n小花与小白在玩耍\n小花与小黑在玩耍\n小花与小明在玩耍\n\n\n1\n2\n3\n\n 3. 不用箭头函数的做法\n\nlet stu = {\n    name: "小花",\n    friends: ["小白","小黑","小明"],\n    play() {\n        let me = this; // 指定this\n        this.friends.forEach(function(e){\n            console.log(me.name + "与" + e + "在玩耍");\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 特色：原型继承\n\nlet father = {\n    f1: \'父属性\',\n    m1: function() {\n        console.log("父方法");\n    }\n}\n\nlet son = Object.create(father);\n\nconsole.log(son.f1);  // 打印 父属性\nson.m1();\t\t\t  // 打印 父方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * father 是父对象，son 去调用 .m1 或 .f1 时，自身对象没有，就到父对象找\n * son 自己可以添加自己的属性和方法\n * son 里有特殊属性 __proto__ 代表它的父对象，js 术语： son 的原型对象\n * 不同浏览器对打印 son 的 __proto__ 属性时显示不同\n   * Edge 打印 console.dir(son) 显示 [[Prototype]]\n   * Firefox 打印 console.dir(son) 显示 <prototype>\n\n# 特色：基于函数的原型继承\n\n出于方便的原因，js 又提供了一种基于函数的原型继承\n\n> 函数职责\n> \n>  1. 负责创建子对象，给子对象提供属性、方法，功能上相当于构造方法\n> \n>  2. 函数有个特殊的属性 prototype，它就是函数创建的子对象的父对象\n>     \n>     **注意！**名字有差异，这个属性的作用就是为新对象提供原型\n\nfunction cons(f2) {\n    // 创建子对象(this), 给子对象提供属性和方法\n    this.f2 = f2;\n    this.m2 = function () {\n        console.log("子方法");\n    }\n}\n// cons.prototype 就是父对象\ncons.prototype.f1 = "父属性";\ncons.prototype.m1 = function() {\n    console.log("父方法");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n配合 new 关键字，创建子对象\n\nlet son = new cons("子属性")\n\n\n1\n\n\n子对象的 __proto__ 就是函数的 prototype 属性\n\n# JSON\n\n之前我们讲 http 请求格式时，讲过 json 这种数据格式，它的语法看起来与 js 对象非常相似，例如：\n\n一个 json 对象可以长这样：\n\n{\n    "name":"张三",\n    "age":18\n}\n\n\n1\n2\n3\n4\n\n\n一个 js 对象长这样：\n\n{\n    name:"张三",\n    age:18\n}\n\n\n1\n2\n3\n4\n\n\n那么他们的区别在哪儿呢？我总结了这么几点\n\n 1. 本质不同\n    * json 对象本质上是个字符串，它的职责是作为客户端和服务器之间传递数据的一种格式，它的属性只是样子货\n    * js 对象是切切实实的对象，可以有属性方法\n 2. 语法细节不同\n    * json 中只能有 null、true|false、数字、字符串（只有双引号）、对象、数组\n    * json 中不能有除以上的其它 js 对象的特性，如方法等\n    * json 中的属性必须用双引号引起来\n\njson 字符串与 js 对象的转换\n\nJSON.parse(json字符串);  // 返回js对象\nJSON.stringify(js对象);  // 返回json字符串\n\n\n1\n2\n\n\n\n# 类型\n\n# 静态类型\n\n静态类型语言，如 Java\n\n * 值有类型\n * 变量也有类型\n * 赋值给变量时，类型要相符\n\nint a = 10;\nString b = "abc";\n\nint c = "abc";  // 错误\n\n\n1\n2\n3\n4\n\n\n# 动态类型\n\njs 属于动态类型语言\n\n * 值有类型\n * 但变量没有类型\n * 赋值给变量时，没要求\n\n例如\n\nlet a = 200;\n\nlet b = 100;\nb = \'abc\';\nb = true;\n\n\n1\n2\n3\n4\n5\n\n\n动态类型看起来比较灵活，但变量没有类型，会给后期维护带来困难，例如\n\nfunction test(obj) {\n    // obj 的类型未知，必须根据不同类型做出相应的容错处理\n}\n\n\n1\n2\n3\n\n\n\n# 2、运算符与表达式\n\n * + - * / % **\n * += -= *= /= %= **=\n * ++ --\n * 位运算、移位运算\n * == != > >= < <=\n * === !== ⭐️\n * && || ! ⭐️\n * ?? ?. ⭐️\n * ... ⭐️\n * 解构赋值 ⭐️\n\n\n# 1) ===\n\n严格相等运算符，用作逻辑判等\n\n * == 会进行类型转换\n * === 不会转换，类型不等直接返回 false\n\n1 == 1    \t// 返回 true \n1 == \'1\'\t// 返回 true，会先将右侧的字符串转为数字，再做比较\n1 === \'1\'\t// 返回 false，类型不等，直接返回 false\n\n\n1\n2\n3\n\n\ntypeof 查看某个值的类型\n\ntypeof 1\t// 返回 \'number\'\ntypeof \'1\'\t// 返回 \'string\'\n\n\n1\n2\n\n\n\n# 2) ||\n\n需求，如果参数 n 没有传递，给它一个【男】\n\n推荐做法\n\nfunction test(n = \'男\') {\n    console.log(n);\n}\n\n\n1\n2\n3\n\n\n你可能的做法\n\nfunction test(n) {\n    if(n === undefined) {\n        n = \'男\';\n    }\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n还可能是这样\n\nfunction test(n) {\n    n = (n === undefined) ? \'男\' : n;\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n\n\n一些老旧代码中可能的做法（不推荐）\n\nfunction test(n) {\n    n = n || \'男\';\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n\n\n它的语法是\n\n值1 || 值2\n\n\n1\n\n\n如果值1 是 Truthy，返回值1，如果值1 是 Falsy 返回值 2\n\n\n# 3) ?? 与 ?.\n\n# ??\n\n需求，如果参数 n 没有传递或是 null，给它一个【男】\n\n如果用传统办法\n\nfunction test(n) {\n    if(n === undefined || n === null) {\n        n = \'男\';\n    }\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n用 ??\n\nfunction test(n) {\n    n = n ?? \'男\';\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n\n\n语法\n\n值1 ?? 值2\n\n\n1\n\n * 值1 是 nullish，返回值2\n * 值1 不是 nullish，返回值1\n\n# ?.\n\n需求，函数参数是一个对象，可能包含有子属性\n\n例如，参数可能是\n\nlet stu1 = {\n    name:"张三",\n    address: {\n        city: \'北京\'\n    }\n};\n\nlet stu2 = {\n    name:"李四"\n}\n\nlet stu3 = {\n    name:"李四",\n    address: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n现在要访问子属性（有问题）\n\nfunction test(stu) {\n    console.log(stu.address.city)\n}\n\n\n1\n2\n3\n\n\n现在希望当某个属性是 nullish 时，短路并返回 undefined，可以用 ?.\n\nfunction test(stu) {\n    console.log(stu.address?.city)\n}\n\n\n1\n2\n3\n\n\n用传统办法\n\nfunction test(stu) {\n    if(stu.address === undefined || stu.address === null) {\n        console.log(undefined);\n        return;\n    }\n    console.log(stu.address.city)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4) ...\n\n展开运算符\n\n作用1：打散数组，把元素传递给多个参数\n\nlet arr = [1,2,3];\n\nfunction test(a,b,c) {\n    console.log(a,b,c);\n}\n\n\n1\n2\n3\n4\n5\n\n\n需求，把数组元素依次传递给函数参数\n\n传统写法\n\ntest(arr[0],arr[1],arr[2]);\t\t// 输出 1,2,3\n\n\n1\n\n\n展开运算符写法\n\ntest(...arr);\t\t\t\t\t// 输出 1,2,3\n\n\n1\n\n * 打散可以理解为【去掉了】数组外侧的中括号，只剩下数组元素\n\n作用2：复制数组或对象\n\n数组\n\nlet arr1 = [1,2,3];\nlet arr2 = [...arr1];\t\t// 复制数组\n\n\n1\n2\n\n\n对象\n\nlet obj1 = {name:\'张三\', age: 18};\n\nlet obj2 = {...obj1};\t\t// 复制对象\n\n\n1\n2\n3\n\n\n注意：展开运算符复制属于浅拷贝，例如\n\nlet o1 = {name:\'张三\', address: {city: \'北京\'} }\n\nlet o2 = {...o1};\n\n\n1\n2\n3\n\n\n作用3：合并数组或对象\n\n合并数组\n\nlet a1 = [1,2];\nlet a2 = [3,4];\n\nlet b1 = [...a1,...a2];\t\t// 结果 [1,2,3,4]\nlet b2 = [...a2,5,...a1]\t// 结果 [3,4,5,1,2]\n\n\n1\n2\n3\n4\n5\n\n\n合并对象\n\nlet o1 = {name:\'张三\'};\nlet o2 = {age:18};\nlet o3 = {name:\'李四\'};\n\nlet n1 = {...o1, ...o2};\t// 结果 {name:\'张三\',age:18}\n\nlet n2 = {...o3, ...o2, ...o1}; // 结果{name:\'李四\',age:18}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 复制对象时出现同名属性，后面的会覆盖前面的\n\n\n# 5) [] {}\n\n解构赋值\n\n# []\n\n用在声明变量时\n\nlet arr = [1,2,3];\n\nlet [a, b, c] = arr;\t// 结果 a=1, b=2, c=3\n\n\n1\n2\n3\n\n\n用在声明参数时\n\nlet arr = [1,2,3];\n\nfunction test([a,b,c]) {\n    console.log(a,b,c) \t// 结果 a=1, b=2, c=3\n}\n\ntest(arr);\t\t\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# {}\n\n用在声明变量时\n\nlet obj = {name:"张三", age:18};\n\nlet {name,age} = obj;\t// 结果 name=张三, age=18\n\n\n1\n2\n3\n\n\n用在声明参数时\n\nlet obj = {name:"张三", age:18};\n\nfunction test({name, age}) {\n    console.log(name, age); // 结果 name=张三, age=18\n}\n\ntest(obj)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3、控制语句\n\n * if ... else\n * switch\n * while\n * do ... while\n * for\n * for ... in ⭐️\n * for ... of ⭐️\n * try ... catch ⭐️\n\n\n# 1) for in\n\n主要用来遍历对象\n\nlet father = {name:\'张三\', age:18, study:function(){}};\n\nfor(const n in father) {\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n\n * 其中 const n 代表遍历出来的属性名\n * 注意1：方法名也能被遍历出来（它其实也算一种特殊属性）\n * 注意2：遍历子对象时，父对象的属性会跟着遍历出来\n\nlet son = Object.create(father);\nson.sex = "男";\n\nfor(const n in son) {\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 注意3：在 for in 内获取属性值，要使用 [] 语法，而不能用 . 语法\n\nfor(const n in son) {\n    console.log(n, son[n]);\n}\n\n\n1\n2\n3\n\n\n\n# 2) for of\n\n主要用来遍历数组，也可以是其它可迭代对象，如 Map，Set 等\n\nlet a1 = [1,2,3];\n\nfor(const i of a1) {\n    console.log(i);\n}\n\nlet a2 = [\n    {name:\'张三\', age:18},\n    {name:\'李四\', age:20},\n    {name:\'王五\', age:22}\n];\n\nfor(const obj of a2) {\n    console.log(obj.name, obj.age);\n}\n\nfor(const {name,age} of a2) {\n    console.log(name, age);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3) try catch\n\nlet stu1 = {name:\'张三\', age:18, address: {city:\'北京\'}};\nlet stu2 = {name:\'张三\', age:18};\n\nfunction test(stu) {\n    try {\n        console.log(stu.address.city)   \n    } catch(e) {\n        console.log(\'出现了异常\', e.message)\n    } finally {\n        console.log(\'finally\');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4、API\n\n\n# 环境准备\n\n# 1) 安装 nvm\n\nnvm 即 (node version manager)，好处是方便切换 node.js 版本\n\n安装注意事项\n\n 1. 要卸载掉现有的 nodejs\n 2. 提示选择 nvm 和 nodejs 目录时，一定要避免目录中出现空格\n 3. 选用【以管理员身份运行】cmd 程序来执行 nvm 命令\n 4. 首次运行前设置好国内镜像地址\n\nnvm node_mirror http://npm.taobao.org/mirrors/node/\nnvm npm_mirror https://npm.taobao.org/mirrors/npm/\n\n\n1\n2\n\n\n首先查看有哪些可用版本\n\nnvm list available\n\n\n1\n\n\n输出\n\n|   CURRENT    |     LTS      |  OLD STABLE  | OLD UNSTABLE |\n|--------------|--------------|--------------|--------------|\n|    18.7.0    |   16.16.0    |   0.12.18    |   0.11.16    |\n|    18.6.0    |   16.15.1    |   0.12.17    |   0.11.15    |\n|    18.5.0    |   16.15.0    |   0.12.16    |   0.11.14    |\n|    18.4.0    |   16.14.2    |   0.12.15    |   0.11.13    |\n|    18.3.0    |   16.14.1    |   0.12.14    |   0.11.12    |\n|    18.2.0    |   16.14.0    |   0.12.13    |   0.11.11    |\n|    18.1.0    |   16.13.2    |   0.12.12    |   0.11.10    |\n|    18.0.0    |   16.13.1    |   0.12.11    |    0.11.9    |\n|    17.9.1    |   16.13.0    |   0.12.10    |    0.11.8    |\n|    17.9.0    |   14.20.0    |    0.12.9    |    0.11.7    |\n|    17.8.0    |   14.19.3    |    0.12.8    |    0.11.6    |\n|    17.7.2    |   14.19.2    |    0.12.7    |    0.11.5    |\n|    17.7.1    |   14.19.1    |    0.12.6    |    0.11.4    |\n|    17.7.0    |   14.19.0    |    0.12.5    |    0.11.3    |\n|    17.6.0    |   14.18.3    |    0.12.4    |    0.11.2    |\n|    17.5.0    |   14.18.2    |    0.12.3    |    0.11.1    |\n|    17.4.0    |   14.18.1    |    0.12.2    |    0.11.0    |\n|    17.3.1    |   14.18.0    |    0.12.1    |    0.9.12    |\n|    17.3.0    |   14.17.6    |    0.12.0    |    0.9.11    |\n|    17.2.0    |   14.17.5    |   0.10.48    |    0.9.10    |\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n建议安装 LTS（长期支持版）\n\nnvm install 16.16.0\nnvm install 14.20.0\n\n\n1\n2\n\n\n执行 nvm list 会列出已安装版本\n\n切换到 16.16.0\n\nnvm use 16.16.0\n\n\n1\n\n\n切换到 14.20.0\n\nnvm use 14.20.0\n\n\n1\n\n\n安装后 nvm 自己的环境变量会自动添加，但可能需要手工添加 nodejs 的 PATH 环境变量\n\n# 2) 检查 npm\n\nnpm 是 js 的包管理器，就类似于 java 界的 maven，要确保它使用的是国内镜像\n\n检查镜像\n\nnpm get registry\n\n\n1\n\n\n如果返回的不是 https://registry.npm.taobao.org/，需要做如下设置\n\nnpm config set registry https://registry.npm.taobao.org/\n\n\n1\n\n\n# 3) 搭建前端服务器\n\n 1. 新建一个保存项目的 client 文件夹，进入文件夹执行\n\nnpm install express --save-dev\n\n\n1\n\n 2. 修改 package.json 文件\n\n{\n  "type": "module",\n  "devDependencies": {\n    "express": "^4.18.1"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 其中 devDependencies 是 npm install --save-dev 添加的\n\n 3. 编写 main.js 代码\n\nimport express from \'express\'\nconst app = express()\n\napp.use(express.static(\'./\'))\napp.listen(7070)\n\n\n1\n2\n3\n4\n5\n\n 4. 执行 js 代码（运行前端服务器）\n\nnode main.js\n\n\n1\n\n\n\n# 前端案例\n\n> 初步效果\n\n\n\n> 架构\n\n\n\n * 前端只有静态页面，使用 Express 服务器\n * 后端使用 Tomcat 服务器，通过 SpringBoot、MyBatis 等框架获取数据库数据\n\n# 1) 查找元素\n\n * document.getElementById - 根据 id 值查找一个元素\n * [document|元素].querySelector - 根据选择器查找第一个匹配元素\n * [document|元素].querySelectorAll - 根据选择器查找所有匹配元素\n\n例如，有下面的 html 代码\n\n<div>\n    <div class="title">学生列表</div>\n    <div class="thead">\n        <div class="row bold">\n            <div class="col">编号</div>\n            <div class="col">姓名</div>\n            <div class="col">性别</div>\n            <div class="col">年龄</div>\n        </div>\n    </div>\n    <div class="tbody">\n        <div class="row">\n            <div class="col">1</div>\n            <div class="col">张三</div>\n            <div class="col">男</div>\n            <div class="col">18</div>\n        </div>\n    </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n执行\n\ndocument.querySelector(\'.title\'); // 找到 <div class="title">学生列表</div>\n\n\n1\n\n\n执行\n\ndocument.querySelector(\'.col\'); // 找到 <div class="col">编号</div>\n\n\n1\n\n\n执行\n\ndocument.querySelectorAll(\'.col\');\n\n/*\n  找到的是一个集合\n  <div class="col">编号</div>\n  <div class="col">姓名</div>\n  <div class="col">性别</div>\n  <div class="col">年龄</div>\n  <div class="col">1</div>\n  <div class="col">张三</div>\n  <div class="col">男</div>\n  <div class="col">18</div>\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n执行\n\nconst thead = document.querySelector(\'.thead\');\n\n// 只在 thead 元素范围内找\nthead.querySelectorAll(\'.col\');\n\n/*\n  找到的是一个集合\n  <div class="col">编号</div>\n  <div class="col">姓名</div>\n  <div class="col">性别</div>\n  <div class="col">年龄</div>\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n根据 id 属性查找既可以用\n\ndocument.getElementById("id值")\n\n\n1\n\n\n也可以用\n\ndocument.querySelector("#id值")\n\n\n1\n\n\n# 2) 修改元素内容\n\n * 元素.innerHTML\n * 元素.textContent\n\n例如\n\ndocument.querySelector(\'.title\').innerHTML = \'侠客列表\'\n\n\n1\n\n\n效果\n\n\n\n> innerHTML 会解析内容中的标签，例如\n\n\n\n> textContext 不会解析内容中的标签\n\n\n\n给 innerHTML 或 textContent 赋值空串，可以实现清空标签内容的效果\n\n# 3) 利用模板\n\n<div>\n    <div class="title">学生列表</div>\n    <div class="thead">\n        <div class="row bold">\n            <div class="col">编号</div>\n            <div class="col">姓名</div>\n            <div class="col">性别</div>\n            <div class="col">年龄</div>\n        </div>\n    </div>\n    <div class="tbody">\n    </div>\n</div>\n\n<template id="tp">\n    <div class="row">\n        <div class="col">xx</div>\n        <div class="col">xx</div>\n        <div class="col">xx</div>\n        <div class="col">xx</div>\n    </div>\n</template>\n\n<script>\n    // 将来这些数据从 java 端返回\n    let array = [\n        { id: 1, name: \'张三\', sex: \'男\', age: 18 },\n        { id: 2, name: \'李四\', sex: \'女\', age: 17 }\n    ];\n\n    const tp = document.getElementById("tp"); // 获取模板的引用\n    const row = tp.content; // row 代表了 <template> 元素中的内容\n    const [c1,c2,c3,c4] = row.querySelectorAll(".col"); // 获取每个列的引用\n    const tbody = document.querySelector(\'.tbody\');\n    for(const {id,name,sex,age} of array) {\n        c1.textContent = id;\n        c2.textContent = name;\n        c3.textContent = sex;\n        c4.textContent = age;\n        // 复制元素\n        const newRow = document.importNode(row, true);\n        // 建立父子关系，左边父，右边子\n        tbody.appendChild(newRow); // 对应上面 tbody\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n# 4) Fetch API\n\nFetch API 可以用来获取远程数据，它有两种方式接收结果，同步方式与异步方式\n\n> 格式\n\nfetch(url, options) // 返回 Promise\n\n\n1\n\n\n> 同步方式 -- await\n\nconst 结果 = await Promise\n// 后续代码\n\n\n1\n2\n\n * await 关键字必须在一个标记了 async 的 function 内来使用\n * 后续代码 不会 在结果返回前 执行\n\n> 异步方式 -- Promise\n\nPromise\n\t.then(结果 => { ... })\n// 后续代码                 \n\n\n1\n2\n3\n\n * 后续代码 不必 等待结果返回 就可以执行\n\n例：\n\n在 express 服务器上有 students.json 文件\n\n[\n    { "id": 1, "name": "张三", "sex": "男", "age": 18 },\n    { "id": 2, "name": "李四", "sex": "女", "age": 17 }\n]\n\n\n1\n2\n3\n4\n\n\n现在用 fetch api 获取这些数据，并展示\n\n同步方式\n\n<script>\n    async function findStudents() {\n        try {\n            // 获取响应对象\n            const resp = await fetch(\'students.json\')\n\n            // 获取响应体, 按json格式转换为js数组\n            const array = await resp.json();\n\n            // 显示数据\n            const tp = document.getElementById("tp");\n            const row = tp.content;\n            const [c1,c2,c3,c4] = row.querySelectorAll(".col");\n            const tbody = document.querySelector(\'.tbody\');\n            for(const {id,name,sex,age} of array) {\n                c1.textContent = id;\n                c2.textContent = name;\n                c3.textContent = sex;\n                c4.textContent = age;\n                // 复制元素\n                const newRow = document.importNode(row, true);\n                // 建立父子关系\n                tbody.appendChild(newRow);\n            }\n        } catch (e) {\n            console.log(e);\n        }\n\n    }\n    findStudents()\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * fetch(\'students.json\') 内部会发送请求，但响应结果不能立刻返回，因此 await 就是等待响应结果返回\n * 其中 resp.json() 也不是立刻能返回结果，它返回的也是 Promise 对象，也要配合 await 取结果\n\n异步方式\n\n<script>\n    fetch(\'students.json\')\n        .then( resp => resp.json() )\n        .then( array => {\n        \t// 显示数据\n            const tp = document.getElementById("tp");\n            const row = tp.content;\n            const [c1,c2,c3,c4] = row.querySelectorAll(".col");\n            const tbody = document.querySelector(\'.tbody\');\n            for(const {id,name,sex,age} of array) {\n                c1.textContent = id;\n                c2.textContent = name;\n                c3.textContent = sex;\n                c4.textContent = age;\n                // 复制元素\n                const newRow = document.importNode(row, true);\n                // 建立父子关系\n                tbody.appendChild(newRow);\n            }\n        })\n        .catch( e => console.log(e) )\n\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 第一个 then 是在响应返回后，才会调用它里面的箭头函数，箭头函数参数即 resp 响应对象\n * 第二个 then 是在 json 解析完成后，才会调用它里面的箭头函数，箭头函数参数即解析结果（本例是 array 数组）\n * 上一个 then 返回的是 Promise 对象时，才能链式调用下一个 then\n\n# 跨域问题\n\n\n\n * 只要协议、主机、端口之一不同，就不同源，例如\n   * http://localhost:7070/a 和 https://localhost:7070/b 就不同源\n * 同源检查是浏览器的行为，而且只针对 fetch、xhr 请求\n   * 如果是其它客户端，例如 java http client，postman，它们是不做同源检查的\n   * 通过表单提交、浏览器直接输入 url 地址这些方式发送的请求，也不会做同源检查\n * 更多相关知识请参考\n   * 跨源资源共享（CORS） - HTTP | MDN (mozilla.org)\n\n> 请求响应头解决\n\n\n\n * fetch 请求跨域，会携带一个 Origin 头，代表【发请求的资源源自何处】，目标通过它就能辨别是否发生跨域\n   * 我们的例子中：student.html 发送 fetch 请求，告诉 tomcat，我源自 localhost:7070\n * 目标资源通过返回 Access-Control-Allow-Origin 头，告诉浏览器【允许哪些源使用此响应】\n   * 我们的例子中：tomcat 返回 fetch 响应，告诉浏览器，这个响应允许源自 localhost:7070 的资源使用\n\n> 代理解决\n\n\n\nnpm install http-proxy-middleware --save-dev\n\n\n1\n\n\n在 express 服务器启动代码中加入\n\nimport {createProxyMiddleware} from \'http-proxy-middleware\'\n\n// ...\n\napp.use(\'/api\', createProxyMiddleware({ target: \'http://localhost:8080\', changeOrigin: true }));\n\n\n1\n2\n3\n4\n5\n\n\nfetch 代码改为\n\nconst resp = await fetch(\'http://localhost:7070/api/students\')\n\n\n1\n\n\n或\n\nconst resp = await fetch(\'/api/students\')\n\n\n1\n\n\n# 5) 模块化\n\n# export 导出\n\n单个导出 const、let、function\n\nexport const a = 10;\nexport let b = 20;\nexport function c() {\n    console.log(\'c\');\n}\n\n\n1\n2\n3\n4\n5\n\n\n一齐导出\n\nconst a = 10;\nlet b = 20;\nfunction c() {\n    console.log(\'c\')\n}\n\nexport {a,b,c}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n导出 default，只能有一个\n\nexport const a = 10;\nexport let b = 20;\nexport function c() {\n    console.log(\'c\')\n}\n\nexport default b;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# import 导入\n\nimport 语法\n\n<script type="module">\n\timport 语句\n<\/script>\n\n\n1\n2\n3\n\n * import 需要遵循同源策略\n\n整个导入\n\nimport * as module from \'/1.js\'\nconsole.log(module.a)\t\t// 输出10\nconsole.log(module.b)\t\t// 输出20\nmodule.c()\t\t\t\t\t// 输出c\n\n\n1\n2\n3\n4\n\n\n单个导入\n\nimport {a,c} from \'/1.js\'\nconsole.log(a)\t\t\t\t// 输出10\nc()\t\t\t\t\t\t\t// 输出c\n\n\n1\n2\n3\n\n\n导入默认\n\nimport x from \'/1.js\'\nconsole.log(x)\t\t\t\t// 输出20\n\n\n1\n2\n',normalizedContent:'# javascript 学习小结\n\n\n# 什么是 es6 ？\n\n根据维基百科解释 ecmascript 规范是由 netscape 的 brendan eich 开发的脚本语言的标准化规范。\n\n最初命名为 mocha，然后是 livescript，最后是 javascript。\n\n> ecmascript 是规范，javascript 是其的一种实现\n\necmascript 2015 (es2015) 是第 6 版，最初称为 ecmascript 6 (es6)，它添加了许多新功能，这些新功能后来成为 web 开发人员工具包的重要组成部分。\n\n\n# 1、变量与数据类型\n\n\n# 声明变量（作用域）\n\n# 1) let ⭐️\n\nlet 变量名 = 值;\n\n\n1\n\n * let 声明的变量可以被多次赋值，例如\n\nlet a = 100;  // 初始值是 100\na = 200;\t  // ok, 被重新赋值为 200\n\n\n1\n2\n\n\n# 2) const ⭐️\n\n * const 修饰的叫常量，只能赋值一次\n\nconst b = 300; // 初始值是 300\nb = 400;\t   // error, 不能再次赋值\n\n\n1\n2\n\n * const 并不意味着它引用的内容不可修改，例如\n\nconst c = [1,2,3];\nc[2] = 4; \t        // ok, 数组内容被修改成 [1,2,4]\nc = [5,6];\t\t\t// error, 不能再次赋值\n\n\n1\n2\n3\n\n\n> 总结：const 修饰的变量，只能被赋值一次但内容可以修改\n\n# 3) var\n\nvar 声明的变量可以被多次赋值（let 也是），例如\n\nvar f = 100;\nf = 200;\n\n\n1\n2\n\n\n# let 和 var 的区别？\n\n作用域（即范围）不同。\n\n首先，什么是范围？\n\n范围是指：来自我们程序不同部分的变量的可访问性。\n\n * 使用 var 声明时，javascript 变量具有全局范围和函数范围。\n * 当使用 let 声明变量时，es6 为 javascript 带来了块级范围。\n\n{\n    var a = "🍉";\n    let b = "⛳";\n}\nconsole.log(a);\nconsole.log(b);\nuncaught referenceerror: b is not defined // b 没有定义\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出，我们使用 var 关键字在 block 中定义了变量 “a”，可以全局访问。所以 var 声明的变量是全局的。\n\n但是，我们希望变量在 block 中生效，退出 block 时不可访问。然后，可以使用 es6 新的块级作用域关键字 let 来声明变量，就像这里的变量 b 一样，会报错说 b 没有定义。\n\n\n# 基本类型\n\n# 1,2) undefined 和 null\n\n 1. 执行表达式或函数，没有返回结果，出现 undefined\n 2. 访问数组不存在的元素，访问对象不存在的属性，出现 undefined\n 3. 定义变量，没有初始化，出现 undefined\n\n例如：\n\nconsole.log(1);  \t// 函数没有返回值, 结果是  undefined\n\nlet a = 10;\t\t \t// 表达式没有返回值, 结果是 undefined\n\nlet b = [1,2,3];\nconsole.log(b[10]); // 数组未定义元素，结果是 undefined\n\nlet c = {"name":"张三"};\nconsole.log(c.age); // 对象未定义属性，结果是 undefined\n\nlet d;\nconsole.log(d);\t\t// 变量未初始化，结果是 undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n二者共同点：\n\n * 都没有属性、方法\n * 二者合称 nullish\n\n二者区别：\n\n * undefined 由 js 产生\n * null 由程序员提供\n\n# 3) string ⭐️\n\njs 字符串有以下三种写法：\n\nlet a = "hello";  // 双引号\nlet b = "world";  // 单引号\nlet c = `hello`;  // 反引号\n\n\n1\n2\n3\n\n\n> 字符串如何表示？\n\nhtml 代码如下\n\n<a href="1.html">超链接</a>\n\n\n1\n\n\njava 显得比较繁琐\n\nstring s1 = "<a href=\\"1.html\\">超链接</a>";\n\nstring s2 = """\n    <a href="1.html">超链接</a>""";\n\n\n1\n2\n3\n4\n\n\njs 就比较灵活\n\nlet s1 = \'<a href="1.html">超链接</a>\';\n\nlet s2 = `<a href="1.html">超链接</a>`;\n\n\n1\n2\n3\n\n\n> 模板字符串（template strings）\n\n需求：拼接 url 的请求参数，如\n\n/test?name=zhang&age=18\n/test?name=li&age=20\n\n\n1\n2\n\n\n传统方法拼接，用 + 号拼接：\n\nlet name = ; // zhang li ...\nlet age = ; // 18 20 ...\n\nlet url = "/test?name=" + name + "&age=" + age;\n\n\n1\n2\n3\n4\n\n\n模板字符串方式，用 ${参数}：\n\nlet name = ; // zhang li ...\nlet age = ; // 18 20 ...\n\nlet url = `/test?name=${name}&age=${age}`;\n\n\n1\n2\n3\n4\n\n\n# 4,5) number 和 bigint⭐️\n\n> number\n\nnumber 类型标识的是双精度浮动小数，例如\n\n10 / 3;   // 结果 3.3333333333333335\n\n\n1\n\n\n既然是浮点小数，那么可以除零\n\n10 / 0;\t  // 结果 infinity 正无穷大\n-10 / 0;  // 结果 -infinity 负无穷大\n\n\n1\n2\n\n\n浮点小数都有运算精度问题，例如\n\n2.0 - 1.1; // 结果 0.8999999999999999\n\n\n1\n\n\n字符串转数字\n\nparseint("10"); \t// 结果是数字 10 \nparseint("10.5");\t// 结果是数字 10, 去除了小数部分\n\nparseint("10") / 3; // 结果仍视为 number 浮点数, 因此结果为 3.3333333333333335\n\nparseint("abc");\t// 转换失败，结果是特殊值 nan (not a number)\n\n\n1\n2\n3\n4\n5\n6\n\n\n> bigint\n\n要表示真正的整数，需要用 bigint。\n\n注意：数字的结尾用 n 表示它是一个 bigint 类型。\n\n10n / 3n;\t\t\t// 结果 3n, 按整数除法处理\n\n\n1\n\n\n# 6) boolean ⭐️\n\n * truthy\n * falsy\n\n在 js 中，并不是 boolean 才能用于条件判断，你可以在 if 语句中使用【数字】、【字符串】... 作为判断条件\n\nlet b = 1;\n\nif(b) { // true\n    console.log("进入了");\n}\n\n\n1\n2\n3\n4\n5\n\n\n这时就有一个规则，当需要条件判断时，这个值被当作 true 还是 false。\n\n * 当作 true 的值归类为 truthy，\n * 当作 false 的值归类为 falsy\n\n> 下面值都是 falsy\n\n * false\n * nullish (null, undefined)\n * 0, 0n, nan\n * "" \'\' `` 即长度为零的字符串\n\n> 剩余的值绝大部分都是 truthy\n\n有几个容易被当作 falsy 实际是 truthy 的\n\n * "false", "0" (注意双引号）即字符串的 false 和 字符串的零\n * [] 空数组\n * {} 空对象\n\n# 7) symbol\n\n用于表示唯一的标识符。\n\nconst mysymbol = symbol(\'description\');\n\n\n1\n\n * 很少使用\n\n\n# 对象类型\n\n# 1) function(函数)⭐️⭐️\n\n# 定义函数\n\nfunction 函数名(参数) {\n    // 函数体\n    return 结果;\n}\n\n\n1\n2\n3\n4\n\n\n例\n\nfunction add(a, b) {\n    return a + b;\n}\n\n\n1\n2\n3\n\n\n# 调用函数\n\n函数名(实参);\n\n\n1\n\n\n例\n\nadd(1, 2);     // 返回 3\n\n\n1\n\n\njs 中的函数调用特点：对参数的类型和个数都没有限制，例如\n\n// 对类型没限制\nadd(\'a\', \'b\');  // 返回 ab\nadd(4, 5, 6);   // 返回 9, 第三个参数没有被用到, 不会报错\n// 对参数个数没限制\nadd(1);\t\t\t// 返回 nan, 这时 b 没有定义是 undefined, undefined 做数学运算结果就是 nan（1 + undefined）\n\n\n1\n2\n3\n4\n5\n\n\n# 默认参数\n\n * java 中（spring）要实现默认参数的效果得这么做：\n\n用 @requestparam(defaultvalue="1") 指定参数默认值\n\n@restcontroller \npublic class mycontroller {\n    \n    @requestmapping("/page")\n    @responsebody\n    public void page(\n        @requestparam(defaultvalue="1") int page, \n        @requestparam(defaultvalue="10") int size\n    ){\n        // ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 在 js 中，直接用 参数 = 值 的形式就可以赋默认值：\n\nfunction pagination(page = 1, size = 10) {\n    console.log(page, size);\n}\n\n\n1\n2\n3\n\n\n# 匿名函数\n\n语法，小括号包含整个函数内容\n\n(function (参数) {\n    // 函数体\n    return 结果;\n})\n\n\n1\n2\n3\n4\n\n\n例\n\n(function(a,b){\n    return a + b;\n})\n\n\n1\n2\n3\n\n\n> 第一种场景：定义完毕后立刻调用\n\n(function(a,b){\n    return a + b;\n})(1,2)\n\n\n1\n2\n3\n\n\n> 第二种场景：作为其它对象的方法，例如\n\n页面有元素\n\n<p id="p1">点我啊</p>\n\n\n1\n\n\n此元素有一个 onclick 方法，会在鼠标单击这个元素后被执行，onclick 方法刚开始是 null，需要赋值后才能使用。\n\ndocument.getelementbyid("p1").onclick = (function(){\n    console.log("鼠标单击了...");\n});\n\n\n1\n2\n3\n\n\n# 箭头函数\n\n(参数) => {\n    // 函数体\n    return 结果;\n}\n\n\n1\n2\n3\n4\n\n\n语法规则，有点像 java 中的 lambda 表达式：\n\n * 如果没有参数，() 还是要保留\n   \n   const sayhello = () => {\n     console.log("hello!");\n   };\n   \n   sayhello();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 如果只有一个参数，() 可以省略\n   \n   const double = number => {\n     return number * 2;\n   };\n   \n   console.log(double(5));\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 如果函数体内只有一行代码，{} 可以省略\n   \n   const sayhi = () => console.log("hi!");\n   \n   sayhi();\n   \n   document.getelementbyid("p1").onclick = () =>  console.log("aa");\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 如果这一行代码就是结果，return 可以省略\n   \n   const multiply = (a, b) => a * b;\n   \n   console.log(multiply(2, 3));\n   \n   \n   1\n   2\n   3\n   \n\n# 函数是对象\n\n以下形式在 js 中非常常见！\n\n>  1. 可以参与赋值，例，具名函数也能参与赋值\n\nfunction abc() {\n    console.log("bb");\n}\n// 将函数赋值到 onclick 方法中\ndocument.getelementbyid("p1").onclick = abc;\n\n\n1\n2\n3\n4\n5\n\n>  2. 有属性、有方法，执行 console.dir(abc)，输出结果如下\n\nƒ abc()\n    arguments: null\n    caller: null\n    length: 0\n    name: "abc"\n    ➡prototype: {constructor: ƒ}\n    [[functionlocation]]: vm1962:1\n    ➡[[prototype]]: ƒ ()\n    ➡[[scopes]]: scopes[1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n * 其中带有 f 标记的是方法，不带的是属性\n\n * 带有 ➡ 符号的可以继续展开，限于篇幅省略了\n\n * 带有 [[ ]] 的是内置属性，不能访问，只能查看\n\n * 相对重要的是 [[prototype]] 和 [[scopes]] 会在后面继承和作用域时讲到\n\n>  3. 可以作为方法参数\n\nfunction a() {\n    console.log(\'a\')\n}\n\nfunction b(fn) {          // fn 将来可以是一个函数对象\n    console.log(\'b\')\n    fn();                 // 调用函数对象\n}\n\nb(a)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n>  4. 可以作为方法返回值\n\nfunction c() {\n    console.log("c");\n    function d() {\n        console.log("d");\n    }\n    return d;\n}\n\nc()()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 函数作用域\n\n函数可以嵌套（js 代码中很常见，只是嵌套的形式更多是匿名函数，箭头函数）\n\nfunction a() {\n    function b() {        \n    }\n}\n\n\n1\n2\n3\n4\n\n\n看下面的例子\n\nfunction c() {\n    var z = 30;\n}\n\nvar x = 10; // 全局作用域\nfunction a() {\n    var y = 20; // 局部作用域，只能在 a() 和 b() 中访问\n    function b() {\n        // 看这里\n        console.log(x, y);\n    }\n    b(); // 输出 10 20\n}\n\na(); // 10 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 以函数为分界线划定作用域，所有函数之外是全局作用域\n * 查找变量时，由内向外查找\n   * 在内层作用域找到变量，就会停止查找，不会再找外层\n   * 所有作用域都找不到变量，报错\n * 作用域本质上是函数对象的属性，可以通过 console.dir 来查看调试\n\n# 闭包\n\n * 函数定义时，它的作用域已经确定好了，因此无论函数将来去了哪，都能从它的作用域中找到当时那些变量\n * 别被概念忽悠了，闭包就是指函数能够访问自己的作用域中变量\n\nvar x = 10;\nfunction a() {\n    var y = 20;\n    function b() {\n        console.log(x,y);\n    }\n    return b;\n}\n// 在外面执行了 b，通过调用a()()，首先执行a()函数，然后再 调用返回的函数b\na()(); // 最终的输出结果还是 10 20\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# let、var 与作用域\n\n> 如果函数外层引用的是 let 变量，那么外层普通的 {} 也会作为作用域边界，最外层的 let 也占一个 script 作用域\n\nlet x = 10; \nif(true) {\n    let y = 20;\n    function b() {\n        console.log(x,y);\n    }\n    console.dir(b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 如果函数外层引用的是 var 变量，外层普通的 {} 不会视为边界\n\nvar x = 10; \nif(true) {\n    var y = 20; // 注意，是在 b 函数外定义的\n    function b() {\n        console.log(x,y);\n    }\n    console.dir(b);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 如果 var 变量出现了重名，则他俩会被视为同一作用域中的同一个变量\n\nvar e = 10; \nif(true) {\n    var e = 20;\n    console.log(e);\t// 打印 20\n}\nconsole.log(e);\t\t// 因为是同一个变量，还是打印 20\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 如果是 let，则视为两个作用域中的两个变量，一个全局范围，一个块局范围\n\nlet e = 10; \nif(true) {\n    let e = 20;\t\n    console.log(e);\t// 打印 20\n}\nconsole.log(e);\t\t// 打印 10\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 要想里面的 e 和外面的 e 能区分开来，最简单的办法是改成 let，或者用函数来界定作用域范围\n\nvar e = 10; \nif(true) {\n    function b() {\n        var e = 20;\n    \tconsole.log(e);\n    }\n    b(); // 20\n}\nconsole.log(e); // 10\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n函数 b() 的作用域与外部作用域是分离的，因此在函数 b() 内部声明的变量 e 不会影响外部作用域中的变量 e。因此，函数 b() 内部的 console.log(e) 会打印 20，而外部的 console.log(e) 会打印最初的值 10。\n\n# 2) array ⭐️\n\n> 语法\n\n// 创建数组\nlet arr = [1,2,3]; \n\n// 获取数组元素\nconsole.log(arr[0]); // 输出 1\n\n// 修改数组元素\narray[0] = 5;\t\t // 数组元素变成了 [5,2,3]\n\n// 遍历数组元素，其中 length 是数组属性，代表数组长度\nfor(let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> api\n\n * push 【尾部】添加、shift 【头部】移除、splice 删除【参数1】索引位置开始的【参数2】个元素\n\nlet arr = [1,2,3]; \n\narr.push(4);    \t// 向数组尾部(右侧)添加元素, 结果 [1,2,3,4]\narr.shift();\t\t// 从数组头部(左侧)移除元素, 结果 [2,3,4]\narr.splice(1,1);\t// 删除【参数1】索引位置的【参数2】个元素，结果 [2,4]\n\n\n1\n2\n3\n4\n5\n\n * join\n\n用于将数组中的所有元素连接成一个字符串。\n\n语法：array.join(separator)\n\nseparator：可选参数，表示在连接数组元素时使用的分隔符字符串。如果省略该参数，则默认使用逗号 , 作为分隔符。\n\nlet arr = [\'a\',\'b\',\'c\'];\n\narr.join(); \t\t// 默认使用【,】作为连接符，结果 \'a,b,c\'\narr.join(\'\');\t\t// 结果 \'abc\'\narr.join(\'-\');\t\t// 结果 \'a-b-c\'\n\n\n1\n2\n3\n4\n5\n\n * map、filter、foreach\n\n> map 例子 -- 处理元素，返回新数组\n\n * map 方法用于遍历数组的每个元素，并对每个元素执行指定的回调函数，然后将返回的值组成一个新数组。\n * 它返回一个新数组，其中包含每个元素经过回调函数处理后的结果。\n * 回调函数接受三个参数：当前元素的值、当前索引和数组本身。\n\nlet arr = [1,2,3,6];\n\nfunction a(i) {   // 代表的新旧元素之间的变换规则\n    return i * 10\n}\n\n// arr.map(a) // 具名函数，结果 [10,20,30,60]\n\n// arr.map( (i) => {return i * 10} ); // 箭头函数\narr.map( i => i * 10 ); // 箭头函数\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 传给 map 的函数，参数代表旧元素，返回值代表新元素\n\nmap 的内部实现（伪代码）\n\nfunction map(a) { // 参数是一个函数\n    let narr = [];\n    for(let i = 0; i < arr.length; i++) {\n        let o = arr[i]; // 旧元素\n        let n = a(o);   // 新元素\n        narr.push(n);\n    }\n    return narr;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> filter 例子 -- 筛选元数，返回新数组\n\n * filter 方法用于遍历数组的每个元素，并对每个元素执行指定的回调函数，然后根据回调函数的返回值来筛选出符合条件的元素组成一个新数组。\n * 它返回一个新数组，其中包含满足回调函数条件的元素。\n * 回调函数接受三个参数：当前元素的值、当前索引和数组本身。\n\nlet arr = [1,2,3,6];\narr.filter( (i)=> i % 2 == 1 ); // 结果 [1,3]\n\n\n1\n2\n\n * 传给 filter 的函数，参数代表旧元素，返回 true 表示要留下的元素\n\n> foreach 例子 -- 遍历数组，没有返回值\n\n * foreach 方法用于遍历数组的每个元素，并对每个元素执行指定的回调函数。\n * 它没有返回值，只是依次对数组的每个元素执行回调函数。\n * 回调函数接受三个参数：当前元素的值、当前索引和数组本身。\n\nlet arr = [1,2,3,6];\n\n/*for(let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}*/\n\narr.foreach( (i) => console.log(i) );\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n两个称呼\n\n * 高阶函数，map，filter，foreach\n * 回调函数，例如作为参数传入的函数\n\n# 3) object ⭐️⭐️\n\n# 语法\n\nlet obj = {\n    属性名: 值,\n    方法名: 函数,\n    get 属性名() {},\n    set 属性名(新值) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n例1\n\nlet stu1 = {\n    name: "小明",\n    age: 18,\n    study: function(){\n        console.log(this.name + "爱学习");\n    }    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n例2\n\nlet name = "小黑";\nlet age = 20;\nlet study = function(){\n    console.log(this.name + "爱学习");\n}\n\nlet stu2 = { name, age, study }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n例3（重点）\n\nlet stu3 = {\n    name: "小白",\n    age: 18,\n    study(){\n        console.log(this.name + "爱学习");\n    }    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 注意：对象方法这么写，仅限于对象内部\n\n例4\n\nlet stu4 = {\n    _name: null, /*类似于java中私有成员变量*/\n    get name() {\n        console.log("进入了get");\n        return this._name;\n    },\n    set name(name) {\n        console.log("进入了set");\n        this._name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n调用 get，set\n\nstu4.name = "小白"\n\nconsole.log(stu4.name)\n\n\n1\n2\n3\n\n\n# 特色：属性增删\n\n对比一下 java 中的 object\n\n * java 的 object 是以类作为模板来创建，对象不能脱离类模板的范围，一个对象的属性、能用的方法都是确定好的\n * js 的对象，不需要什么模板，它的属性和方法可以随时加减\n\nlet stu = {name:\'张三\'};\nstu.age = 18;\t\t\t\t\t// 添加属性\ndelete stu.age;\t\t\t\t\t// 删除属性\n\nstu.study = function() {\t\t// 添加方法\n    console.log(this.name + "在学习");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n添加 get，set，需要借助 object.definepropery\n\nlet stu = {_name:null};\n\nobject.defineproperty(stu, "name", {\n    get(){\n        return this._name;\n    },\n    set(name){\n        this._name = name;\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 参数1：目标对象\n * 参数2：属性名\n * 参数3：get，set 的定义\n\n# 特色：this\n\n 1. 先来对 java 中的 this 有个理解\n\npublic class testmethod {\n\n    static class student {\n        private string name;\n\n        public student(string name) {\n            this.name = name;\n        }\n\n        public void study(student this, string subject) {\n            system.out.println(this.name + "在学习 " + subject);\n        }\n    }\n\n    public static void main(string[] args) {\n        student stu = new student("小明");\n        \n        // 下面的代码，本质上是执行 study(stu, "java")，因此 this 就是 stu\n        stu.study("java"); \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * java 中的 this 是个隐式参数\n * java 中，我们说 this 代表的就是调用方法的那个对象\n\n 2. js 中的 this 也是隐式参数，但它与函数运行时上下文相关\n\n> 例如，一个“落单”的函数\n\nfunction study(subject) {\n    console.log(this.name + "在学习 " + subject)\n}\n\n\n1\n2\n3\n\n\n测试一下\n\nstudy("js");  // 输出 在学习 js\n\n\n1\n\n\n这是因为此时函数执行，全局对象 window 被当作了 this，window 对象的 name 属性是空串\n\n> 同样的函数，如果作为对象的方法\n\nlet stu = {\n    name:"小白",\n    study\n}\n\n\n1\n2\n3\n4\n\n\n这种情况下，会将当前对象作为 this\n\nstu.study(\'js\'); \t// 输出 小白在学习 js\n\n\n1\n\n\n> 还可以动态改变 this\n\nlet stu = {name:"小黑"};\nstudy.call(stu, "js");\t// 输出 小黑在学习 js\n\n\n1\n2\n\n\n使用了 call 方法来调用 study 函数，这回 study 执行时，就把 call 的第一个参数 stu 作为 this\n\n> 一个例外是，在箭头函数内出现的 this，以外层 this 理解\n\n 1. 用匿名函数\n\nlet stu = {\n    name: "小花",\n    friends: ["小白","小黑","小明"],\n    play() {\n        this.friends.foreach(function(e){\n            console.log(this.name + "与" + e + "在玩耍");\n        });\n    }\n}\nstu.play()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * this.name 所在的函数是【落单】的函数，因此 this 代表 window\n\n输出结果为\n\n与小白在玩耍\n与小黑在玩耍\n与小明在玩耍\n\n\n1\n2\n3\n\n 2. 用箭头函数\n\nlet stu = {\n    name: "小花",\n    friends: ["小白","小黑","小明"],\n    play() {\n        this.friends.foreach(e => {\n            console.log(this.name + "与" + e + "在玩耍");\n        })\n    }    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * this.name 所在的函数是箭头函数，因此 this 要看它外层的 play 函数，play 又是属于 stu 的方法，因此 this 代表 stu 对象\n\n输出结果为\n\n小花与小白在玩耍\n小花与小黑在玩耍\n小花与小明在玩耍\n\n\n1\n2\n3\n\n 3. 不用箭头函数的做法\n\nlet stu = {\n    name: "小花",\n    friends: ["小白","小黑","小明"],\n    play() {\n        let me = this; // 指定this\n        this.friends.foreach(function(e){\n            console.log(me.name + "与" + e + "在玩耍");\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 特色：原型继承\n\nlet father = {\n    f1: \'父属性\',\n    m1: function() {\n        console.log("父方法");\n    }\n}\n\nlet son = object.create(father);\n\nconsole.log(son.f1);  // 打印 父属性\nson.m1();\t\t\t  // 打印 父方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * father 是父对象，son 去调用 .m1 或 .f1 时，自身对象没有，就到父对象找\n * son 自己可以添加自己的属性和方法\n * son 里有特殊属性 __proto__ 代表它的父对象，js 术语： son 的原型对象\n * 不同浏览器对打印 son 的 __proto__ 属性时显示不同\n   * edge 打印 console.dir(son) 显示 [[prototype]]\n   * firefox 打印 console.dir(son) 显示 <prototype>\n\n# 特色：基于函数的原型继承\n\n出于方便的原因，js 又提供了一种基于函数的原型继承\n\n> 函数职责\n> \n>  1. 负责创建子对象，给子对象提供属性、方法，功能上相当于构造方法\n> \n>  2. 函数有个特殊的属性 prototype，它就是函数创建的子对象的父对象\n>     \n>     **注意！**名字有差异，这个属性的作用就是为新对象提供原型\n\nfunction cons(f2) {\n    // 创建子对象(this), 给子对象提供属性和方法\n    this.f2 = f2;\n    this.m2 = function () {\n        console.log("子方法");\n    }\n}\n// cons.prototype 就是父对象\ncons.prototype.f1 = "父属性";\ncons.prototype.m1 = function() {\n    console.log("父方法");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n配合 new 关键字，创建子对象\n\nlet son = new cons("子属性")\n\n\n1\n\n\n子对象的 __proto__ 就是函数的 prototype 属性\n\n# json\n\n之前我们讲 http 请求格式时，讲过 json 这种数据格式，它的语法看起来与 js 对象非常相似，例如：\n\n一个 json 对象可以长这样：\n\n{\n    "name":"张三",\n    "age":18\n}\n\n\n1\n2\n3\n4\n\n\n一个 js 对象长这样：\n\n{\n    name:"张三",\n    age:18\n}\n\n\n1\n2\n3\n4\n\n\n那么他们的区别在哪儿呢？我总结了这么几点\n\n 1. 本质不同\n    * json 对象本质上是个字符串，它的职责是作为客户端和服务器之间传递数据的一种格式，它的属性只是样子货\n    * js 对象是切切实实的对象，可以有属性方法\n 2. 语法细节不同\n    * json 中只能有 null、true|false、数字、字符串（只有双引号）、对象、数组\n    * json 中不能有除以上的其它 js 对象的特性，如方法等\n    * json 中的属性必须用双引号引起来\n\njson 字符串与 js 对象的转换\n\njson.parse(json字符串);  // 返回js对象\njson.stringify(js对象);  // 返回json字符串\n\n\n1\n2\n\n\n\n# 类型\n\n# 静态类型\n\n静态类型语言，如 java\n\n * 值有类型\n * 变量也有类型\n * 赋值给变量时，类型要相符\n\nint a = 10;\nstring b = "abc";\n\nint c = "abc";  // 错误\n\n\n1\n2\n3\n4\n\n\n# 动态类型\n\njs 属于动态类型语言\n\n * 值有类型\n * 但变量没有类型\n * 赋值给变量时，没要求\n\n例如\n\nlet a = 200;\n\nlet b = 100;\nb = \'abc\';\nb = true;\n\n\n1\n2\n3\n4\n5\n\n\n动态类型看起来比较灵活，但变量没有类型，会给后期维护带来困难，例如\n\nfunction test(obj) {\n    // obj 的类型未知，必须根据不同类型做出相应的容错处理\n}\n\n\n1\n2\n3\n\n\n\n# 2、运算符与表达式\n\n * + - * / % **\n * += -= *= /= %= **=\n * ++ --\n * 位运算、移位运算\n * == != > >= < <=\n * === !== ⭐️\n * && || ! ⭐️\n * ?? ?. ⭐️\n * ... ⭐️\n * 解构赋值 ⭐️\n\n\n# 1) ===\n\n严格相等运算符，用作逻辑判等\n\n * == 会进行类型转换\n * === 不会转换，类型不等直接返回 false\n\n1 == 1    \t// 返回 true \n1 == \'1\'\t// 返回 true，会先将右侧的字符串转为数字，再做比较\n1 === \'1\'\t// 返回 false，类型不等，直接返回 false\n\n\n1\n2\n3\n\n\ntypeof 查看某个值的类型\n\ntypeof 1\t// 返回 \'number\'\ntypeof \'1\'\t// 返回 \'string\'\n\n\n1\n2\n\n\n\n# 2) ||\n\n需求，如果参数 n 没有传递，给它一个【男】\n\n推荐做法\n\nfunction test(n = \'男\') {\n    console.log(n);\n}\n\n\n1\n2\n3\n\n\n你可能的做法\n\nfunction test(n) {\n    if(n === undefined) {\n        n = \'男\';\n    }\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n还可能是这样\n\nfunction test(n) {\n    n = (n === undefined) ? \'男\' : n;\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n\n\n一些老旧代码中可能的做法（不推荐）\n\nfunction test(n) {\n    n = n || \'男\';\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n\n\n它的语法是\n\n值1 || 值2\n\n\n1\n\n\n如果值1 是 truthy，返回值1，如果值1 是 falsy 返回值 2\n\n\n# 3) ?? 与 ?.\n\n# ??\n\n需求，如果参数 n 没有传递或是 null，给它一个【男】\n\n如果用传统办法\n\nfunction test(n) {\n    if(n === undefined || n === null) {\n        n = \'男\';\n    }\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n用 ??\n\nfunction test(n) {\n    n = n ?? \'男\';\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n\n\n语法\n\n值1 ?? 值2\n\n\n1\n\n * 值1 是 nullish，返回值2\n * 值1 不是 nullish，返回值1\n\n# ?.\n\n需求，函数参数是一个对象，可能包含有子属性\n\n例如，参数可能是\n\nlet stu1 = {\n    name:"张三",\n    address: {\n        city: \'北京\'\n    }\n};\n\nlet stu2 = {\n    name:"李四"\n}\n\nlet stu3 = {\n    name:"李四",\n    address: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n现在要访问子属性（有问题）\n\nfunction test(stu) {\n    console.log(stu.address.city)\n}\n\n\n1\n2\n3\n\n\n现在希望当某个属性是 nullish 时，短路并返回 undefined，可以用 ?.\n\nfunction test(stu) {\n    console.log(stu.address?.city)\n}\n\n\n1\n2\n3\n\n\n用传统办法\n\nfunction test(stu) {\n    if(stu.address === undefined || stu.address === null) {\n        console.log(undefined);\n        return;\n    }\n    console.log(stu.address.city)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4) ...\n\n展开运算符\n\n作用1：打散数组，把元素传递给多个参数\n\nlet arr = [1,2,3];\n\nfunction test(a,b,c) {\n    console.log(a,b,c);\n}\n\n\n1\n2\n3\n4\n5\n\n\n需求，把数组元素依次传递给函数参数\n\n传统写法\n\ntest(arr[0],arr[1],arr[2]);\t\t// 输出 1,2,3\n\n\n1\n\n\n展开运算符写法\n\ntest(...arr);\t\t\t\t\t// 输出 1,2,3\n\n\n1\n\n * 打散可以理解为【去掉了】数组外侧的中括号，只剩下数组元素\n\n作用2：复制数组或对象\n\n数组\n\nlet arr1 = [1,2,3];\nlet arr2 = [...arr1];\t\t// 复制数组\n\n\n1\n2\n\n\n对象\n\nlet obj1 = {name:\'张三\', age: 18};\n\nlet obj2 = {...obj1};\t\t// 复制对象\n\n\n1\n2\n3\n\n\n注意：展开运算符复制属于浅拷贝，例如\n\nlet o1 = {name:\'张三\', address: {city: \'北京\'} }\n\nlet o2 = {...o1};\n\n\n1\n2\n3\n\n\n作用3：合并数组或对象\n\n合并数组\n\nlet a1 = [1,2];\nlet a2 = [3,4];\n\nlet b1 = [...a1,...a2];\t\t// 结果 [1,2,3,4]\nlet b2 = [...a2,5,...a1]\t// 结果 [3,4,5,1,2]\n\n\n1\n2\n3\n4\n5\n\n\n合并对象\n\nlet o1 = {name:\'张三\'};\nlet o2 = {age:18};\nlet o3 = {name:\'李四\'};\n\nlet n1 = {...o1, ...o2};\t// 结果 {name:\'张三\',age:18}\n\nlet n2 = {...o3, ...o2, ...o1}; // 结果{name:\'李四\',age:18}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 复制对象时出现同名属性，后面的会覆盖前面的\n\n\n# 5) [] {}\n\n解构赋值\n\n# []\n\n用在声明变量时\n\nlet arr = [1,2,3];\n\nlet [a, b, c] = arr;\t// 结果 a=1, b=2, c=3\n\n\n1\n2\n3\n\n\n用在声明参数时\n\nlet arr = [1,2,3];\n\nfunction test([a,b,c]) {\n    console.log(a,b,c) \t// 结果 a=1, b=2, c=3\n}\n\ntest(arr);\t\t\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# {}\n\n用在声明变量时\n\nlet obj = {name:"张三", age:18};\n\nlet {name,age} = obj;\t// 结果 name=张三, age=18\n\n\n1\n2\n3\n\n\n用在声明参数时\n\nlet obj = {name:"张三", age:18};\n\nfunction test({name, age}) {\n    console.log(name, age); // 结果 name=张三, age=18\n}\n\ntest(obj)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3、控制语句\n\n * if ... else\n * switch\n * while\n * do ... while\n * for\n * for ... in ⭐️\n * for ... of ⭐️\n * try ... catch ⭐️\n\n\n# 1) for in\n\n主要用来遍历对象\n\nlet father = {name:\'张三\', age:18, study:function(){}};\n\nfor(const n in father) {\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n\n * 其中 const n 代表遍历出来的属性名\n * 注意1：方法名也能被遍历出来（它其实也算一种特殊属性）\n * 注意2：遍历子对象时，父对象的属性会跟着遍历出来\n\nlet son = object.create(father);\nson.sex = "男";\n\nfor(const n in son) {\n    console.log(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 注意3：在 for in 内获取属性值，要使用 [] 语法，而不能用 . 语法\n\nfor(const n in son) {\n    console.log(n, son[n]);\n}\n\n\n1\n2\n3\n\n\n\n# 2) for of\n\n主要用来遍历数组，也可以是其它可迭代对象，如 map，set 等\n\nlet a1 = [1,2,3];\n\nfor(const i of a1) {\n    console.log(i);\n}\n\nlet a2 = [\n    {name:\'张三\', age:18},\n    {name:\'李四\', age:20},\n    {name:\'王五\', age:22}\n];\n\nfor(const obj of a2) {\n    console.log(obj.name, obj.age);\n}\n\nfor(const {name,age} of a2) {\n    console.log(name, age);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3) try catch\n\nlet stu1 = {name:\'张三\', age:18, address: {city:\'北京\'}};\nlet stu2 = {name:\'张三\', age:18};\n\nfunction test(stu) {\n    try {\n        console.log(stu.address.city)   \n    } catch(e) {\n        console.log(\'出现了异常\', e.message)\n    } finally {\n        console.log(\'finally\');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4、api\n\n\n# 环境准备\n\n# 1) 安装 nvm\n\nnvm 即 (node version manager)，好处是方便切换 node.js 版本\n\n安装注意事项\n\n 1. 要卸载掉现有的 nodejs\n 2. 提示选择 nvm 和 nodejs 目录时，一定要避免目录中出现空格\n 3. 选用【以管理员身份运行】cmd 程序来执行 nvm 命令\n 4. 首次运行前设置好国内镜像地址\n\nnvm node_mirror http://npm.taobao.org/mirrors/node/\nnvm npm_mirror https://npm.taobao.org/mirrors/npm/\n\n\n1\n2\n\n\n首先查看有哪些可用版本\n\nnvm list available\n\n\n1\n\n\n输出\n\n|   current    |     lts      |  old stable  | old unstable |\n|--------------|--------------|--------------|--------------|\n|    18.7.0    |   16.16.0    |   0.12.18    |   0.11.16    |\n|    18.6.0    |   16.15.1    |   0.12.17    |   0.11.15    |\n|    18.5.0    |   16.15.0    |   0.12.16    |   0.11.14    |\n|    18.4.0    |   16.14.2    |   0.12.15    |   0.11.13    |\n|    18.3.0    |   16.14.1    |   0.12.14    |   0.11.12    |\n|    18.2.0    |   16.14.0    |   0.12.13    |   0.11.11    |\n|    18.1.0    |   16.13.2    |   0.12.12    |   0.11.10    |\n|    18.0.0    |   16.13.1    |   0.12.11    |    0.11.9    |\n|    17.9.1    |   16.13.0    |   0.12.10    |    0.11.8    |\n|    17.9.0    |   14.20.0    |    0.12.9    |    0.11.7    |\n|    17.8.0    |   14.19.3    |    0.12.8    |    0.11.6    |\n|    17.7.2    |   14.19.2    |    0.12.7    |    0.11.5    |\n|    17.7.1    |   14.19.1    |    0.12.6    |    0.11.4    |\n|    17.7.0    |   14.19.0    |    0.12.5    |    0.11.3    |\n|    17.6.0    |   14.18.3    |    0.12.4    |    0.11.2    |\n|    17.5.0    |   14.18.2    |    0.12.3    |    0.11.1    |\n|    17.4.0    |   14.18.1    |    0.12.2    |    0.11.0    |\n|    17.3.1    |   14.18.0    |    0.12.1    |    0.9.12    |\n|    17.3.0    |   14.17.6    |    0.12.0    |    0.9.11    |\n|    17.2.0    |   14.17.5    |   0.10.48    |    0.9.10    |\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n建议安装 lts（长期支持版）\n\nnvm install 16.16.0\nnvm install 14.20.0\n\n\n1\n2\n\n\n执行 nvm list 会列出已安装版本\n\n切换到 16.16.0\n\nnvm use 16.16.0\n\n\n1\n\n\n切换到 14.20.0\n\nnvm use 14.20.0\n\n\n1\n\n\n安装后 nvm 自己的环境变量会自动添加，但可能需要手工添加 nodejs 的 path 环境变量\n\n# 2) 检查 npm\n\nnpm 是 js 的包管理器，就类似于 java 界的 maven，要确保它使用的是国内镜像\n\n检查镜像\n\nnpm get registry\n\n\n1\n\n\n如果返回的不是 https://registry.npm.taobao.org/，需要做如下设置\n\nnpm config set registry https://registry.npm.taobao.org/\n\n\n1\n\n\n# 3) 搭建前端服务器\n\n 1. 新建一个保存项目的 client 文件夹，进入文件夹执行\n\nnpm install express --save-dev\n\n\n1\n\n 2. 修改 package.json 文件\n\n{\n  "type": "module",\n  "devdependencies": {\n    "express": "^4.18.1"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 其中 devdependencies 是 npm install --save-dev 添加的\n\n 3. 编写 main.js 代码\n\nimport express from \'express\'\nconst app = express()\n\napp.use(express.static(\'./\'))\napp.listen(7070)\n\n\n1\n2\n3\n4\n5\n\n 4. 执行 js 代码（运行前端服务器）\n\nnode main.js\n\n\n1\n\n\n\n# 前端案例\n\n> 初步效果\n\n\n\n> 架构\n\n\n\n * 前端只有静态页面，使用 express 服务器\n * 后端使用 tomcat 服务器，通过 springboot、mybatis 等框架获取数据库数据\n\n# 1) 查找元素\n\n * document.getelementbyid - 根据 id 值查找一个元素\n * [document|元素].queryselector - 根据选择器查找第一个匹配元素\n * [document|元素].queryselectorall - 根据选择器查找所有匹配元素\n\n例如，有下面的 html 代码\n\n<div>\n    <div class="title">学生列表</div>\n    <div class="thead">\n        <div class="row bold">\n            <div class="col">编号</div>\n            <div class="col">姓名</div>\n            <div class="col">性别</div>\n            <div class="col">年龄</div>\n        </div>\n    </div>\n    <div class="tbody">\n        <div class="row">\n            <div class="col">1</div>\n            <div class="col">张三</div>\n            <div class="col">男</div>\n            <div class="col">18</div>\n        </div>\n    </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n执行\n\ndocument.queryselector(\'.title\'); // 找到 <div class="title">学生列表</div>\n\n\n1\n\n\n执行\n\ndocument.queryselector(\'.col\'); // 找到 <div class="col">编号</div>\n\n\n1\n\n\n执行\n\ndocument.queryselectorall(\'.col\');\n\n/*\n  找到的是一个集合\n  <div class="col">编号</div>\n  <div class="col">姓名</div>\n  <div class="col">性别</div>\n  <div class="col">年龄</div>\n  <div class="col">1</div>\n  <div class="col">张三</div>\n  <div class="col">男</div>\n  <div class="col">18</div>\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n执行\n\nconst thead = document.queryselector(\'.thead\');\n\n// 只在 thead 元素范围内找\nthead.queryselectorall(\'.col\');\n\n/*\n  找到的是一个集合\n  <div class="col">编号</div>\n  <div class="col">姓名</div>\n  <div class="col">性别</div>\n  <div class="col">年龄</div>\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n根据 id 属性查找既可以用\n\ndocument.getelementbyid("id值")\n\n\n1\n\n\n也可以用\n\ndocument.queryselector("#id值")\n\n\n1\n\n\n# 2) 修改元素内容\n\n * 元素.innerhtml\n * 元素.textcontent\n\n例如\n\ndocument.queryselector(\'.title\').innerhtml = \'侠客列表\'\n\n\n1\n\n\n效果\n\n\n\n> innerhtml 会解析内容中的标签，例如\n\n\n\n> textcontext 不会解析内容中的标签\n\n\n\n给 innerhtml 或 textcontent 赋值空串，可以实现清空标签内容的效果\n\n# 3) 利用模板\n\n<div>\n    <div class="title">学生列表</div>\n    <div class="thead">\n        <div class="row bold">\n            <div class="col">编号</div>\n            <div class="col">姓名</div>\n            <div class="col">性别</div>\n            <div class="col">年龄</div>\n        </div>\n    </div>\n    <div class="tbody">\n    </div>\n</div>\n\n<template id="tp">\n    <div class="row">\n        <div class="col">xx</div>\n        <div class="col">xx</div>\n        <div class="col">xx</div>\n        <div class="col">xx</div>\n    </div>\n</template>\n\n<script>\n    // 将来这些数据从 java 端返回\n    let array = [\n        { id: 1, name: \'张三\', sex: \'男\', age: 18 },\n        { id: 2, name: \'李四\', sex: \'女\', age: 17 }\n    ];\n\n    const tp = document.getelementbyid("tp"); // 获取模板的引用\n    const row = tp.content; // row 代表了 <template> 元素中的内容\n    const [c1,c2,c3,c4] = row.queryselectorall(".col"); // 获取每个列的引用\n    const tbody = document.queryselector(\'.tbody\');\n    for(const {id,name,sex,age} of array) {\n        c1.textcontent = id;\n        c2.textcontent = name;\n        c3.textcontent = sex;\n        c4.textcontent = age;\n        // 复制元素\n        const newrow = document.importnode(row, true);\n        // 建立父子关系，左边父，右边子\n        tbody.appendchild(newrow); // 对应上面 tbody\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n# 4) fetch api\n\nfetch api 可以用来获取远程数据，它有两种方式接收结果，同步方式与异步方式\n\n> 格式\n\nfetch(url, options) // 返回 promise\n\n\n1\n\n\n> 同步方式 -- await\n\nconst 结果 = await promise\n// 后续代码\n\n\n1\n2\n\n * await 关键字必须在一个标记了 async 的 function 内来使用\n * 后续代码 不会 在结果返回前 执行\n\n> 异步方式 -- promise\n\npromise\n\t.then(结果 => { ... })\n// 后续代码                 \n\n\n1\n2\n3\n\n * 后续代码 不必 等待结果返回 就可以执行\n\n例：\n\n在 express 服务器上有 students.json 文件\n\n[\n    { "id": 1, "name": "张三", "sex": "男", "age": 18 },\n    { "id": 2, "name": "李四", "sex": "女", "age": 17 }\n]\n\n\n1\n2\n3\n4\n\n\n现在用 fetch api 获取这些数据，并展示\n\n同步方式\n\n<script>\n    async function findstudents() {\n        try {\n            // 获取响应对象\n            const resp = await fetch(\'students.json\')\n\n            // 获取响应体, 按json格式转换为js数组\n            const array = await resp.json();\n\n            // 显示数据\n            const tp = document.getelementbyid("tp");\n            const row = tp.content;\n            const [c1,c2,c3,c4] = row.queryselectorall(".col");\n            const tbody = document.queryselector(\'.tbody\');\n            for(const {id,name,sex,age} of array) {\n                c1.textcontent = id;\n                c2.textcontent = name;\n                c3.textcontent = sex;\n                c4.textcontent = age;\n                // 复制元素\n                const newrow = document.importnode(row, true);\n                // 建立父子关系\n                tbody.appendchild(newrow);\n            }\n        } catch (e) {\n            console.log(e);\n        }\n\n    }\n    findstudents()\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * fetch(\'students.json\') 内部会发送请求，但响应结果不能立刻返回，因此 await 就是等待响应结果返回\n * 其中 resp.json() 也不是立刻能返回结果，它返回的也是 promise 对象，也要配合 await 取结果\n\n异步方式\n\n<script>\n    fetch(\'students.json\')\n        .then( resp => resp.json() )\n        .then( array => {\n        \t// 显示数据\n            const tp = document.getelementbyid("tp");\n            const row = tp.content;\n            const [c1,c2,c3,c4] = row.queryselectorall(".col");\n            const tbody = document.queryselector(\'.tbody\');\n            for(const {id,name,sex,age} of array) {\n                c1.textcontent = id;\n                c2.textcontent = name;\n                c3.textcontent = sex;\n                c4.textcontent = age;\n                // 复制元素\n                const newrow = document.importnode(row, true);\n                // 建立父子关系\n                tbody.appendchild(newrow);\n            }\n        })\n        .catch( e => console.log(e) )\n\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 第一个 then 是在响应返回后，才会调用它里面的箭头函数，箭头函数参数即 resp 响应对象\n * 第二个 then 是在 json 解析完成后，才会调用它里面的箭头函数，箭头函数参数即解析结果（本例是 array 数组）\n * 上一个 then 返回的是 promise 对象时，才能链式调用下一个 then\n\n# 跨域问题\n\n\n\n * 只要协议、主机、端口之一不同，就不同源，例如\n   * http://localhost:7070/a 和 https://localhost:7070/b 就不同源\n * 同源检查是浏览器的行为，而且只针对 fetch、xhr 请求\n   * 如果是其它客户端，例如 java http client，postman，它们是不做同源检查的\n   * 通过表单提交、浏览器直接输入 url 地址这些方式发送的请求，也不会做同源检查\n * 更多相关知识请参考\n   * 跨源资源共享（cors） - http | mdn (mozilla.org)\n\n> 请求响应头解决\n\n\n\n * fetch 请求跨域，会携带一个 origin 头，代表【发请求的资源源自何处】，目标通过它就能辨别是否发生跨域\n   * 我们的例子中：student.html 发送 fetch 请求，告诉 tomcat，我源自 localhost:7070\n * 目标资源通过返回 access-control-allow-origin 头，告诉浏览器【允许哪些源使用此响应】\n   * 我们的例子中：tomcat 返回 fetch 响应，告诉浏览器，这个响应允许源自 localhost:7070 的资源使用\n\n> 代理解决\n\n\n\nnpm install http-proxy-middleware --save-dev\n\n\n1\n\n\n在 express 服务器启动代码中加入\n\nimport {createproxymiddleware} from \'http-proxy-middleware\'\n\n// ...\n\napp.use(\'/api\', createproxymiddleware({ target: \'http://localhost:8080\', changeorigin: true }));\n\n\n1\n2\n3\n4\n5\n\n\nfetch 代码改为\n\nconst resp = await fetch(\'http://localhost:7070/api/students\')\n\n\n1\n\n\n或\n\nconst resp = await fetch(\'/api/students\')\n\n\n1\n\n\n# 5) 模块化\n\n# export 导出\n\n单个导出 const、let、function\n\nexport const a = 10;\nexport let b = 20;\nexport function c() {\n    console.log(\'c\');\n}\n\n\n1\n2\n3\n4\n5\n\n\n一齐导出\n\nconst a = 10;\nlet b = 20;\nfunction c() {\n    console.log(\'c\')\n}\n\nexport {a,b,c}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n导出 default，只能有一个\n\nexport const a = 10;\nexport let b = 20;\nexport function c() {\n    console.log(\'c\')\n}\n\nexport default b;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# import 导入\n\nimport 语法\n\n<script type="module">\n\timport 语句\n<\/script>\n\n\n1\n2\n3\n\n * import 需要遵循同源策略\n\n整个导入\n\nimport * as module from \'/1.js\'\nconsole.log(module.a)\t\t// 输出10\nconsole.log(module.b)\t\t// 输出20\nmodule.c()\t\t\t\t\t// 输出c\n\n\n1\n2\n3\n4\n\n\n单个导入\n\nimport {a,c} from \'/1.js\'\nconsole.log(a)\t\t\t\t// 输出10\nc()\t\t\t\t\t\t\t// 输出c\n\n\n1\n2\n3\n\n\n导入默认\n\nimport x from \'/1.js\'\nconsole.log(x)\t\t\t\t// 输出20\n\n\n1\n2\n',charsets:{cjk:!0}},{title:"Vue3入门",frontmatter:{title:"Vue3入门",date:"2023-07-07T10:24:46.000Z",permalink:"/pages/803f9d/"},regularPath:"/09.%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/06.Vue3%E5%85%A5%E9%97%A8.html",relativePath:"09.前端学习/06.Vue3入门.md",key:"v-8189a45c",path:"/pages/803f9d/",headers:[{level:2,title:"Vue3 简介",slug:"vue3-简介",normalizedTitle:"vue3 简介",charIndex:14},{level:3,title:"Vue3 对研发更友好",slug:"vue3-对研发更友好",normalizedTitle:"vue3 对研发更友好",charIndex:252},{level:3,title:"如何学习 Vue3？",slug:"如何学习-vue3",normalizedTitle:"如何学习 vue3？",charIndex:1023},{level:2,title:"Vue 能做啥？",slug:"vue-能做啥",normalizedTitle:"vue 能做啥？",charIndex:1705},{level:3,title:"1 文档结构",slug:"_1-文档结构",normalizedTitle:"1 文档结构",charIndex:2011},{level:3,title:"1.1 HTML是一棵树",slug:"_1-1-html是一棵树",normalizedTitle:"1.1 html是一棵树",charIndex:2022},{level:3,title:"1.2 浏览器如何砍树",slug:"_1-2-浏览器如何砍树",normalizedTitle:"1.2 浏览器如何砍树",charIndex:2139},{level:3,title:"1.3 在性能优化之后",slug:"_1-3-在性能优化之后",normalizedTitle:"1.3 在性能优化之后",charIndex:2531},{level:3,title:"1.4 为何有 Vue",slug:"_1-4-为何有-vue",normalizedTitle:"1.4 为何有 vue",charIndex:2855},{level:2,title:"感受 Vue3",slug:"感受-vue3",normalizedTitle:"感受 vue3",charIndex:3355},{level:3,title:"1 如何使用 Vue",slug:"_1-如何使用-vue",normalizedTitle:"1 如何使用 vue",charIndex:3367},{level:3,title:"2 Vue3 倍轻松",slug:"_2-vue3-倍轻松",normalizedTitle:"2 vue3 倍轻松",charIndex:3826},{level:3,title:"3 Vue3 三步曲",slug:"_3-vue3-三步曲",normalizedTitle:"3 vue3 三步曲",charIndex:4951},{level:2,title:"核心语法",slug:"核心语法",normalizedTitle:"核心语法",charIndex:6148},{level:3,title:"1 文本插值",slug:"_1-文本插值",normalizedTitle:"1 文本插值",charIndex:6276},{level:3,title:"2 原始 HTML",slug:"_2-原始-html",normalizedTitle:"2 原始 html",charIndex:7098},{level:3,title:"3 属性绑定",slug:"_3-属性绑定",normalizedTitle:"3 属性绑定",charIndex:7905},{level:2,title:"条件渲染和 template",slug:"条件渲染和-template",normalizedTitle:"条件渲染和 template",charIndex:8922},{level:3,title:"1 v-if 指令",slug:"_1-v-if-指令",normalizedTitle:"1 v-if 指令",charIndex:9047},{level:3,title:"2 template",slug:"_2-template",normalizedTitle:"2 template",charIndex:10898},{level:3,title:"3 v-show 指令",slug:"_3-v-show-指令",normalizedTitle:"3 v-show 指令",charIndex:11694},{level:2,title:"循环渲染",slug:"循环渲染",normalizedTitle:"循环渲染",charIndex:12760},{level:3,title:"1 v-for 输出项",slug:"_1-v-for-输出项",normalizedTitle:"1 v-for 输出项",charIndex:12872},{level:3,title:"2 索引和值",slug:"_2-索引和值",normalizedTitle:"2 索引和值",charIndex:13841},{level:3,title:"3 v-for 和 v-if",slug:"_3-v-for-和-v-if",normalizedTitle:"3 v-for 和 v-if",charIndex:15760},{level:2,title:"样式绑定",slug:"样式绑定",normalizedTitle:"样式绑定",charIndex:18279},{level:3,title:"1 Class 指令",slug:"_1-class-指令",normalizedTitle:"1 class 指令",charIndex:18463},{level:3,title:"2 内联样式",slug:"_2-内联样式",normalizedTitle:"2 内联样式",charIndex:21790},{level:2,title:"计算属性",slug:"计算属性",normalizedTitle:"计算属性",charIndex:23367},{level:3,title:"1 计算属性",slug:"_1-计算属性",normalizedTitle:"1 计算属性",charIndex:23502},{level:3,title:"2 计算属性的 Setter",slug:"_2-计算属性的-setter",normalizedTitle:"2 计算属性的 setter",charIndex:25126},{level:2,title:"事件处理",slug:"事件处理",normalizedTitle:"事件处理",charIndex:26569},{level:3,title:"1 事件处理",slug:"_1-事件处理",normalizedTitle:"1 事件处理",charIndex:26769},{level:3,title:"2 传递参数",slug:"_2-传递参数",normalizedTitle:"2 传递参数",charIndex:27299},{level:3,title:"3 事件来源",slug:"_3-事件来源",normalizedTitle:"3 事件来源",charIndex:27935},{level:3,title:"4 多事件处理",slug:"_4-多事件处理",normalizedTitle:"4 多事件处理",charIndex:29862},{level:3,title:"5 按键修饰符",slug:"_5-按键修饰符",normalizedTitle:"5 按键修饰符",charIndex:30843},{level:2,title:"表单输入",slug:"表单输入",normalizedTitle:"表单输入",charIndex:31934},{level:3,title:"1 文本输入",slug:"_1-文本输入",normalizedTitle:"1 文本输入",charIndex:32071},{level:4,title:"1.1 文本框的 number 修饰符",slug:"_1-1-文本框的-number-修饰符",normalizedTitle:"1.1 文本框的 number 修饰符",charIndex:32867},{level:4,title:"1.2 文本框的 trim 修饰符",slug:"_1-2-文本框的-trim-修饰符",normalizedTitle:"1.2 文本框的 trim 修饰符",charIndex:33167},{level:3,title:"2 复选框 checkbox",slug:"_2-复选框-checkbox",normalizedTitle:"2 复选框 checkbox",charIndex:33452},{level:4,title:"2.1 单个 checkbox 与数据绑定",slug:"_2-1-单个-checkbox-与数据绑定",normalizedTitle:"2.1 单个 checkbox 与数据绑定",charIndex:33494},{level:4,title:"2.2 自定义单个 checkbox 的值",slug:"_2-2-自定义单个-checkbox-的值",normalizedTitle:"2.2 自定义单个 checkbox 的值",charIndex:34212},{level:4,title:"2.3 一组 checkbox 与数据绑定",slug:"_2-3-一组-checkbox-与数据绑定",normalizedTitle:"2.3 一组 checkbox 与数据绑定",charIndex:35007},{level:3,title:"3 单选框（radio）",slug:"_3-单选框-radio",normalizedTitle:"3 单选框（radio）",charIndex:35993},{level:4,title:"3.1 一组 radio 与数据绑定",slug:"_3-1-一组-radio-与数据绑定",normalizedTitle:"3.1 一组 radio 与数据绑定",charIndex:36038},{level:3,title:"4 select",slug:"_4-select",normalizedTitle:"4 select",charIndex:36954},{level:4,title:"4.1 select 与数据绑定",slug:"_4-1-select-与数据绑定",normalizedTitle:"4.1 select 与数据绑定",charIndex:37001},{level:4,title:"4.2 select 的选项从数据获得",slug:"_4-2-select-的选项从数据获得",normalizedTitle:"4.2 select 的选项从数据获得",charIndex:37904},{level:4,title:"4.3 select 的返回对象",slug:"_4-3-select-的返回对象",normalizedTitle:"4.3 select 的返回对象",charIndex:38930},{level:2,title:"Vue3 小项目实战",slug:"vue3-小项目实战",normalizedTitle:"vue3 小项目实战",charIndex:40046},{level:3,title:"1 产品列表",slug:"_1-产品列表",normalizedTitle:"1 产品列表",charIndex:40140},{level:3,title:"2 新增产品",slug:"_2-新增产品",normalizedTitle:"2 新增产品",charIndex:43896},{level:2,title:"自定义组件",slug:"自定义组件",normalizedTitle:"自定义组件",charIndex:49051},{level:3,title:"1 局部注册",slug:"_1-局部注册",normalizedTitle:"1 局部注册",charIndex:49259},{level:3,title:"2 全局注册",slug:"_2-全局注册",normalizedTitle:"2 全局注册",charIndex:50030},{level:2,title:"异步请求和侦听器",slug:"异步请求和侦听器",normalizedTitle:"异步请求和侦听器",charIndex:50964},{level:3,title:"1 axios 应用",slug:"_1-axios-应用",normalizedTitle:"1 axios 应用",charIndex:51239},{level:3,title:"2 侦听器",slug:"_2-侦听器",normalizedTitle:"2 侦听器",charIndex:52469},{level:2,title:"组件库 element+",slug:"组件库-element",normalizedTitle:"组件库 element+",charIndex:53848},{level:3,title:"官网",slug:"官网",normalizedTitle:"官网",charIndex:53865},{level:3,title:"1 安装 element+",slug:"_1-安装-element",normalizedTitle:"1 安装 element+",charIndex:54041},{level:3,title:"2 来点不一样的",slug:"_2-来点不一样的",normalizedTitle:"2 来点不一样的",charIndex:55147},{level:2,title:"电子地图",slug:"电子地图",normalizedTitle:"电子地图",charIndex:57095},{level:3,title:"1 获取 Appkey",slug:"_1-获取-appkey",normalizedTitle:"1 获取 appkey",charIndex:57180},{level:3,title:"2 电子地图",slug:"_2-电子地图",normalizedTitle:"2 电子地图",charIndex:57447},{level:2,title:"组合式 API",slug:"组合式-api",normalizedTitle:"组合式 api",charIndex:58504}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"23 min read",minutes:22.98,time:1378800,words:4596},headersStr:"Vue3 简介 Vue3 对研发更友好 如何学习 Vue3？ Vue 能做啥？ 1 文档结构 1.1 HTML是一棵树 1.2 浏览器如何砍树 1.3 在性能优化之后 1.4 为何有 Vue 感受 Vue3 1 如何使用 Vue 2 Vue3 倍轻松 3 Vue3 三步曲 核心语法 1 文本插值 2 原始 HTML 3 属性绑定 条件渲染和 template 1 v-if 指令 2 template 3 v-show 指令 循环渲染 1 v-for 输出项 2 索引和值 3 v-for 和 v-if 样式绑定 1 Class 指令 2 内联样式 计算属性 1 计算属性 2 计算属性的 Setter 事件处理 1 事件处理 2 传递参数 3 事件来源 4 多事件处理 5 按键修饰符 表单输入 1 文本输入 1.1 文本框的 number 修饰符 1.2 文本框的 trim 修饰符 2 复选框 checkbox 2.1 单个 checkbox 与数据绑定 2.2 自定义单个 checkbox 的值 2.3 一组 checkbox 与数据绑定 3 单选框（radio） 3.1 一组 radio 与数据绑定 4 select 4.1 select 与数据绑定 4.2 select 的选项从数据获得 4.3 select 的返回对象 Vue3 小项目实战 1 产品列表 2 新增产品 自定义组件 1 局部注册 2 全局注册 异步请求和侦听器 1 axios 应用 2 侦听器 组件库 element+ 官网 1 安装 element+ 2 来点不一样的 电子地图 1 获取 Appkey 2 电子地图 组合式 API",content:'# Vue3 入门\n\n\n# Vue3 简介\n\n菜鸟教程：https://www.runoob.com/vue3/vue3-install.html\n\n\n\n从 2020 年 9 月份 Vue3.0 发布以来，经过近两年的发展补充，Vue3 的生态圈逐步完善，已经成熟到足以支撑日常项目的研发。\n\n而且，Vue3 在 Vue2 的基础上引入了 Typescript 重构了大量的代码，增加了很多新的特性，并发布了新一代的工程化工具 vite 。这些新的改动，让 Vue3 对我们的研发变得更加友好。\n\n\n# Vue3 对研发更友好\n\n让我们来看一下，同样的项目，使用 vite 作为开发构建工具的 Vue3 和使用 vue-cli 的 Vue2 的运行对比。\n\n构建工具      启动时间     打包时间\nvite      135ms    13025ms\nvue-cli   1482ms   28186ms\n\n从上面的表格我们可以看到，vite 相对比 vue-cli 来说，启动项目时间缩短达到了 10 倍，打包时间也明显减小。\n\n同时，Vue3 也提高了编译的效率。以往当我们的项目越来越大时，经常是一个小小的改动，甚至需要等待几分钟的编译时间才能看到页面效果。而 vite 内部使用了 Esbuild 作为底层的依赖预编译工具，完全发挥了 Go 语言和多线程的优势，同时利用现代浏览器原生支持 ESM 特性，完全省略了打包的过程，极大的提高了编译运行的效率（关于 vite，我们会在其他章节详细介绍，这里只需要有个印象就可以了）。\n\n * 除了 vite 这个新工具以外，从代码层面，Vue3 的 Composition Api 新特性也让我们的项目代码功能结构更加清晰，组件拆分复用更加灵活。\n\n * 从框架层面，Vue3 框架的本身也使用 proxy 代替 Object.defineProperty 重新实现了真正的响应式“代理”，并且将渲染逻辑拆分为【浏览器渲染】和【平台无关渲染】，这对于我们的跨端，跨框架组合开发来说有着非同凡响的意义，你能想象在 React 中使用 Vue 的响应式吗，Vue3 就替你创造了这个可能性。\n\n综上可见，Vue3 做了如此多的改变，从编译运行、代码语法、框架结构等多个层面同时发力，给研发提供了编译更快、打包体积更小、写法更清晰的直观感受，那我们又有什么理由去拒绝 Vue3 呢？\n\n\n# 如何学习 Vue3？\n\n大部分的同学应该都有过 Vue 的相关开发经验，而且 Vue 也是流行框架中出了名的简单易学，所以从 Vue2 到 Vue3 的升级远远没有想象的那么困难。\n\n相信有部分同学阅读过 Vue 原理的相关文章，比如响应式的实现原理，使用了 Object.defineProperty 进行拦截代理等等，而在 Vue3 中，设计者们对部分功能的原理进行了重构调整，我们在学习的过程中，可以从两个方面来深入剖析。\n\n 1. 在纵向上，与 Vue2 的实现原理进行对比。\n\n这样可以帮助我们深刻的理解 Vue3 的新特性原理，新语法为什么要这么实现，同时也能更清楚 Vue2 的缺陷和短板，进一步的拓宽我们的知识面。\n\n如果大家过去只是单纯地使用 Vue2，只是根据文档按部就班的进行开发，那么通过 Vue3.0 再次学习的过程，我们可以从原理到基础 api，再到 vue-router、Vuex 的引入，认真体会下 Vue3 的渐进式设计。\n\n 2. 在横向上，与现有的热门框架 React ， Angular 等对比，深入理解各个框架的侧重点和特色。\n\n这样可以进一步地体会 Vue 本身的设计理念和均衡的特性，以及各个框架的优缺点，我们可以更好地明白各个框架的定位以及如何去根据项目来选择一个合适的前端框架。\n\n其实每个框架都有自己的核心点，只要抓住框架的几个重点，就像搭帐篷一样，就能支撑起我们自己的框架思维，学会去搭建自己的框架思维，那后面如果再有 Vue4，Vue5 或者其他新的框架，对于我们来说，都可以很快去接受并使用它们。\n\n\n# Vue 能做啥？\n\n我们知道，HTML 文档是由节点构成的集合。HTML 文件节点包括【元素节点、文本节点和属性节点】。下面请仔细观察 HTML 文件的页面结构。\n\n<!DOCTYPE html> \n<html> \n  <head>     \n    <meta charset="UTF-8">     \n    <title>Vue3.0篇</title> \n  </head> \n  <body> \n    <h1>说编程</h1> \n    <a href="demo1.html">个人简介</a> \n  </body> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 1 文档结构\n\n\n# 1.1 HTML是一棵树\n\n观察了 HTML 页面结构之后，细心的你会发现："HTML 是一棵树"！\n\n没错，HTML 就是一棵由 HTML 标签组成的树。树干是 <html> 标签，树枝是节点，树叶是属性，树花是文本。\n\n\n\n\n# 1.2 浏览器如何砍树\n\n为了方便浏览器，砍(解析) HTML 这棵树，W3C(万维网联盟)定义了访问 HTML 的 DOM 标准。DOM(Document Object Model)文档对象模型，定义了所有 HTML 元素的对象和属性，以及访问它们的方法。\n\nJS 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程（意味着每一次操作都需要重新计算）。比如在用户一次操作中，他/她需要更新 10 个 HTML 元素(DOM节点)内容时，浏览器在收到第 1 个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行了 10 次操作。\n\n在第 1 次计算完之后，紧接着下一个 DOM 更新请求时，之前节点的坐标值就变了。那么，进行第 2 次计算时，之前的操作相当于做了无用功，白白浪费了性能。频繁操作还会出现页面卡顿，影响用户体验的问题。\n\n\n# 1.3 在性能优化之后\n\n为了解决 DOM 访问 HTML 文件时存在的性能问题，一帮技术牛人就开始琢磨......\n\n在 2009 年时，经过 Misko Hevery 等人的努力，终于研究出了一种 diff 算法，实现了那里需要更新就更新那里的愿望，为了方便分享喜悦，Misko Hevery 等人对其进行了扩展、升级、包装并给它取了一个好听的名字：AngularJS。\n\n为了方便、保障 AngularJS 能更好的用到谷歌产品中，谷歌对其进行了收购。于是，一款有着诸多特性，核心功能的是 MVC(Model–view–controller)、模块化、自动化双向数据绑定、语义化标签、依赖注入等等的优秀前端 JS 框架，由此诞生了。\n\n\n# 1.4 为何有 Vue\n\n在 Angular 流行的那些年，好多程序员都投入了好多精力去学习，也不管 Angular 的 MVC 是否全部都能用得上。其实就算知道了，也无可奈何，理由你懂的。\n\n直到 2013，就职于 Google Creative Lab，名叫尤雨溪的帅哥的出现，程序员用前端 JS 框架，才发现根本不需要那么累。\n\n尤大大由于个人兴趣，对 Angular 进行了改造，去掉了 Angular MVC 中的 MV，只留下 V(View) 的内容。为了方便记忆，将其取名为 Vue.js。\n\nVue.js(读音 /vjuː/, 类似于 view) 是一套构建用户界面的渐进式框架。Vue 核心只关注视图层，采用自底向上增量开发的设计，目标是通过尽可能简单的 API 实现响应式的数据绑定和组合的视图组件。\n\nVue 从最初的实验阶段(2013年中到2014年2月)，0.x 阶段 (2014年2月到2015年10月)，1.x 阶段 (2015年10月到2016年9月)，2.x 阶段(2016年9月至2019年上半年)，到今天的 3.x 阶段，已经有足足 9 年多的时间了。\n\n\n# 感受 Vue3\n\n\n# 1 如何使用 Vue\n\n在使用 <script> 标签引入 Vue 的情况下，有两种引入方式：\n\n * 通过 CDN 地址引入\n\n * 或直接本地 Vue.js 文件引入。\n\n如果进行单文件组件(SFC)开发，则要复杂些，不是用 vite，就是用 CLI 脚手架。\n\n对于初学者，建议从 <script> 标签引入 Vue 开始学习。\n\n<script src="https://unpkg.com/vue@next"><\/script>\n\n\n1\n\n\n就是引用 CDN 的方式。从 https 名字，你就知道，这是引用网上的资源(受网络环境影响)。可网络差或断网的话，怎么办，不学了？\n\n所以，也可以回到以前的传统方法，就是直接到：\n\nhttps://cdn.jsdelivr.net/npm/vue@3.3.4/dist/\n\n下载 vue.global.js 文件，然后在要用 Vue 的 HTML 文件中引用就好了!\n\n<script src="vue.global.js"><\/script>\n\n\n1\n\n\n\n# 2 Vue3 倍轻松\n\n在 Vue3 中，每个 Vue 应用都是通过用 createApp 函数创建一个新的应用实例开始的，这种统一的应用方式，让你学起来更加轻松。\n\n学习 Vue 3，就是对其生命周期中的函数，有的放矢，加加减减，或独立或联合。生命周期图，你不用记忆，也不用背诵，浏览一下就好，后面会逐步讲解的。\n\n\n\n> 用第 1 个框图中的 createApp 和 mount 搞个样例，让代码飘一会。\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset="UTF-8">\n    <title>第1个vue 3程序</title>\n    <style>\n        .hello_div {\n            border: 1px solid darkgreen;\n            border-radius: 15px;\n            width: 850px;\n            line-height: 50px;\n            text-align: center;\n        }\n    </style>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="hello" class="hello_div"> 你好，{{ msg }} </div>\n    <script>\n        // 传统html写法\n        // let msg = \'vue.js 3\'\n        // // 找对人\n        // let helloDiv = document.getElementById(\'hello\')\n        // // 做对事\n        // helloDiv.innerText = `你好，${msg}`\n        const vue = Vue.createApp({\n            data() {\n                return { msg: "vue 3" }\n            }\n        })\n        vue.mount("#hello") <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n输出结果\n\n\n\n\n# 3 Vue3 三步曲\n\n应用 Vue3，可按三步曲进行：\n\n 1. 创建 Vue 实例；\n 2. 定义将要赋予元素的数据；\n 3. 将数据和元素进行绑定。\n\n定下这个调调之后，后面就是学习它的【语法(模板、条件和组件等)和生命周期函数的应用】了。\n\n为了方便和提高代码的可读性，定义数据和 Vue 实例，常常放在一起声明。为了让你更清晰 Vue 的意义，我就来个数据绑定的例子。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>第2个vue 3程序</title>\n    <style>\n        .input_div {\n            border: 1px solid darkgreen;\n            border-radius: 15px;\n            width: 850px;\n            line-height: 50px;\n            text-align: center;\n        }\n\n        input {\n            border: 1px solid salmon;\n            width: 200px;\n            height: 22px;\n        }\n    </style>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="hello" class="input_div"> \n      \t<input id="name" v-model="msg" placeholder="hello" />\n        <p>想学编程的人，快点来，<strong>{{ msg }}</strong>world。</p>\n    </div>\n    <script>\n        // 第1步：创建vue实例\n        // 第2步：定义数据\n        // 第3步：绑定元素     \n        Vue.createApp({\n            data() {\n                return { msg: \'\' }\n            }\n        }).mount("#hello")\n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 核心语法\n\n想学一门编程语言，就要先整明白它的语法规则。Vue 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层组件实例的数据。所有 Vue 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。\n\n\n# 1 文本插值\n\n数据绑定最常见的形式就是使用双大括号 {{}} 的文本插值，如果你要用不常见的，那可用 <span v-text=""></span> 的方式。\n\n在 Vue 中，带有 v- 前缀的特殊属性，称为指令。\n\n无论选择哪一个插值方式绑定到组件(HTML标签)上，在组件实例上的值发生了改变，插值处的内容都会更新，这便是数据驱动的方式。\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0核心语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="hello"> \n      <input id="name" v-model="msg" placeholder="输入文本内容" />\n      <p>用双大括号实现文本插值：{{ msg }}</p>\n      <p>用v-text指定实现插值：<span v-text="msg"></span></p>\n    </div>\n    <script>\n        // 第1步：data数据；\n        // 第2步：vue实例，\n        // 第3步：绑定元素     \n        Vue.createApp({\n            data() {\n                return { msg: \'\' }\n            }\n        }).mount("#hello") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 2 原始 HTML\n\n在开发过程中，有时会输出有格式的动态内容，比如输出带颜色文本。如果用插值的方式，输出的为文本内容，显然满足不了要求。这时就要用到 v-html 指令了。\n\n温馨提醒：原始 HTML，尽量不要用在输入上，因为它很容易导致 XSS 攻击。\n\nXSS 攻击通常指的是：通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页中。\n\n<!DOCTYPE html>\n<html>\n  \n  <head>\n    <meta charset="UTF-8">\n    <title>Vue3.0核心语法</title>\n    <script src="vue.global.js"><\/script>\n  </head>\n  \n  <body>\n    <div id="vh">\n      <p>文本插值结果: {{ msg }}</p>\n      <p>原始HTML结果: <span v-html="msg"></span></p>\n    </div>\n    <script>\n      // 第1步：data数据；\n      // 第2步：vue实例，\n      // 第3步：绑定元素     \n      Vue.createApp({\n        data() {\n          return {\n            msg: \'<span style="color: red">vue.js 3.0</span>\'\n          }\n        }\n      }).mount("#vh") \n    <\/script>\n  </body>\n  \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 3 属性绑定\n\n在 Vue 中，\n\n * 对 HTML 属性的绑定，采用 v-bind(可缩写为":")指令，\n * 对事件的绑定，采用 v-on(可缩写为"@")指令。\n\n这里说下 v-bind 的应用，v-on 在讲事件时再细讲。\n\n你可能会奇怪，绑定属性有什么用？我随便举一个例子，你就秒懂了。\n\n当美女程序员看我的文章时，系统就给她推荐有漂亮图表的文章链接地址；当男性程序员看我的文章时，系统就给推荐有漂亮MM的文章链接地址，以此来提高阅读量。\n\n\x3c!-- 完整语法 --\x3e <a v-bind:href="url"> ... </a>\n\n\x3c!-- 缩写 --\x3e <a :href="url"> ... </a>\n\n<!DOCTYPE html>\n<html>\n  \n  <head>\n    <meta charset="UTF-8">\n    <title>Vue3.0核心语法</title>\n    <script src="vue.global.js"><\/script>\n  </head>\n  \n  <body>\n    <div id="vh">\n      <p>文本插值结果: {{ msg }}</p>\n      <p>原始HTML结果: <span v-html="msg" ></span></p>\n      <a :href="site">跳转</a>\n    </div>\n    <script>\n      // 第1步：data数据；\n      // 第2步：vue实例，\n      // 第3步：绑定元素     \n      Vue.createApp({\n        data() {\n          return {\n            msg: \'<span style="color: red">vue.js 3.0</span>\',\n            site: \'http://www.sohu.com\'\n          }\n        }\n      }).mount("#vh") \n    <\/script>\n  </body>\n  \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 条件渲染和 template\n\n所谓的条件，指的就是满足什么条件，允许做什么事，不满足时，是不允许做的。如共享单车，规定满 12 周岁或以上才可以骑行，没满的则不被允许。学每门编程语言，条件语句都是必须熟练掌握的，Vue3.0 的也不例外。\n\n\n# 1 v-if 指令\n\n在 Vue3.0 中，条件语句是通过 v-if 指令实现的。\n\n如果判断条件为 True，就执行 v-if 语句里的内容，否则什么都不执行。\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset="UTF-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="app">\n        <h1 v-if=\'cool\'>前端编程</h1>\n    </div>\n    <script>\n        Vue.createApp({\n            data() {\n                return { cool: true }\n            }\n        }).mount("#app") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n如果 v-if 为 false 时，你不想输出空气，不想什么都不执行，那就其后面加上 v-else 指令。\n\nv-if 和 v-else 搭在一起使用，规则是：v-if 的条件为 true 时，执行 v-if 里的内容，否则执行 v-else 里的。\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset="UTF-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="app">\n        <h1 v-if=\'cool\'>前端编程</h1>\n        <h1 v-else>不学前端，还可以学后端嘛</h1>\n    </div>\n    <script>\n        Vue.createApp({\n            data() {\n                return { cool: false }\n            }\n        }).mount("#app") <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset="UTF-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="app">\n        <h1 v-if="program === \'Vue3.0\'">vue3.0 很酷，很酷 </h1>\n        <h1 v-else-if="program === \'前端\'">前端，很酷</h1>\n        <h1 v-else-if="program === \'Java\'">Java，很酷</h1>\n        <h1 v-else-if="program === \'App\'">App，很酷</h1>\n        <h1 v-else>Python，也酷</h1>\n    </div>\n    <script>\n        Vue.createApp({\n            data() {\n                return {\n                    program: \'Vue3.0\'\n                }\n            }\n        }).mount("#app") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 2 template\n\n长得有点(不是特别)酷的你，可能早就注意到了，v-if 指令，都是附加在一个元素上的；\n\n> 如果想要实现切换多个元素，该如何？\n\n可以将 v-if 放在 <template> 元素中。\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset="UTF-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="app">\n        <template v-if="show">\n            <h1>编程</h1>\n            <p>编程都用啥工具<br />\n                工具不重要，重要的是思想<br />\n                Python，前端(小程序)、Java和App 都是工具<br />\n                用啥都可以好程序</p>\n        </template>\n    </div>\n    <script>\n        Vue.createApp({\n            data() {\n                return {\n                    show: true\n                }\n            }\n        }).mount("#app") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3 v-show 指令\n\n * 如果你要实现业务方面的条件判断，用 v-if 指令就可以了；\n * 如果只是想切换一下 CSS 的内容，那你可以用 v-show 指令。\n\nv-show 只是简单地切换元素的 CSS 属性值，不支持 v-else，也不支持 <template> 元素，它常用于隐藏或显示某个元素。\n\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset="UTF-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .show {\n            margin-top: 20px;\n            width: 600px;\n            height: 50px;\n            background: darkcyan;\n        }\n    </style>\n</head>\n\n<body>\n    <div id="app">\n        <input type="button" value="按下就报幕" v-on:click="show"> <br />\n        <div class="show" v-show="report">报幕~~~</div>\n    </div>\n    <script>\n        Vue.createApp({\n            data() {\n                return {\n                    report: false\n                }\n            },\n            methods: {\n                show() {\n                    this.report = true;\n                }\n            }\n        }).mount("#app") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 循环渲染\n\n开发一个Web系统，如果没有涉及到列表功能的话，那真的有点奇葩了，而循环输出列表内容，不用for循环语句的话，那我真不知道该用什么了。在Vue3.0中，v-for指令基于一个数组来渲染输出一个列表内容。\n\n\n# 1 v-for 输出项\n\nVue 的 v-for 指令使用 item in items 形式的特殊语法，同其他编程语言(如Python)并没有多大区别。\n\n其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0循环语法</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .lang {\n            border: 1px solid darkcyan;\n            width: 600px;\n            height: 200px;\n        }\n    </style>\n</head>\n<body>\n<div class="lang">\n    Vue.js 3.0 系列教程\n    <ol id="program">\n        <li v-for="item in items">\n            {{ item.lang }}\n        </li>\n    </ol>\n</div>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                items: [{lang: \'Python\'}, {lang: \'前端\'},\n                    {lang: \'Vue3.0\'}, {lang: \'koa2\'},\n                    {lang: \'Java\'}, {lang: \'App\'}]\n            }\n        }\n    }).mount("#program")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 2 索引和值\n\n数据列表在表格输出时，常常需要用到序号。\n\nv-for 指令支持输出下标，将下标+1，即可获得序号。\n\n为了更接近 JavaScript 迭代器的语法，Vue3.0 支持用 of 替代 in 作为分隔。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0循环语法</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        h1 {\n            text-align: center;\n        }\n\n        table {\n            width: 600px;\n            margin: 0 auto;\n            text-align: center;\n            height: 200px;\n        }\n\n        td, th {\n            border: 1px solid #bcbcbc;\n            padding: 5px 10px;\n        }\n\n        th {\n            background: #42b983;\n            font-size: 1.2rem;\n            font-weight: 400;\n            color: #fff;\n            cursor: pointer;\n        }\n\n        tr:nth-of-type(odd) {\n            background: #fff;\n        }\n\n        tr:nth-of-type(even) {\n            background: #eee;\n        }\n    </style>\n</head>\n<body>\n<h1>vue.js 3.0 系列教程</h1>\n<table id="program">\n    <thead>\n    <tr>\n        <th>序号</th>\n        <th>编程语言</th>\n        <th>备注</th>\n    </tr>\n    </thead>\n    <tr v-for="(item,index) of items">\n        <td>{{ index + 1 }}</td>\n        <td>{{ item.lang }}</td>\n        <td>{{ item.remark }}</td>\n    </tr>\n</table>\n\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                items: [\n                    {lang: \'Python\', remark: \'入门、数据分析、爬虫\'},\n                    {lang: \'前端\', remark: \'网页三贱客\'},\n                    {lang: \'Vue3.0\', remark: \'能在项目中应用\'},\n                    {lang: \'Koa2\', remark: \'企业实战项目\'},\n                    {lang: \'Java\', remark: \'从0开始入门\'},\n                    {lang: \'App\', remark: \'安卓和iOS等开发\'}]\n            }\n        }\n    }).mount("#program")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 3 v-for 和 v-if\n\n由于当 v-if 和 v-for 处于同一节点时，v-if 的优先级比 v-for 更高，这意味着 v-if 将没有权限访问 v-for 里的变量，就是说不可以将 v-if 和 v-for 放在同一个元素里。\n\n\x3c!-- v-for 和 v-if 不可以放在同一个元素内 --\x3e\n<li v-for="item in items" v-if="item==true">\n    {{ good }}\n</li>\n\n\n1\n2\n3\n4\n\n\n> 为了解决 v-for 和 v-if 同一水平的问题，你可以把 v-for 移动到 <template> 标签中进行修正。就是将 v-if 放到 v-for 内部去的意思。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0循环语法</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        h1 {\n            text-align: center;\n            color: darkorange;\n        }\n\n        table {\n            width: 600px;\n            margin: 0 auto;\n            text-align: center;\n            height: 200px;\n        }\n\n        td, th {\n            border: 1px solid #bcbcbc;\n            padding: 5px 10px;\n        }\n\n        th {\n            background: #42b983;\n            font-size: 1.2rem;\n            font-weight: 400;\n            color: #fff;\n            cursor: pointer;\n        }\n\n        tr:nth-of-type(odd) {\n            background: #fff;\n        }\n\n        tr:nth-of-type(even) {\n            background: #eee;\n        }\n    </style>\n</head>\n<body>\n<h1>Vue.js 3.0 系列教程</h1>\n<table id="program">\n    <thead>\n    <tr>\n        <th>序号</th>\n        <th>编程语言</th>\n        <th>完成情况</th>\n    </tr>\n    </thead>\n    <template v-for="(item,index) in items">\n        <tr>\n            <td>\n                {{ index + 1 }}\n            </td>\n            <td>\n                {{ item.lang }}\n            </td>\n            <td>\n                <span v-if="item.todo==1">\n                    已完成\n                </span>\n                <span v-else-if="item.todo==2">\n                 进行中\n                </span>\n                <span v-else>\n                   将启动\n                </span>\n            </td>\n        </tr>\n    </template>\n</table>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                items: [\n                    {lang: \'Python\', todo: 1,},\n                    {lang: \'前端\', todo: 1},\n                    {lang: \'Vue3.0\', todo: 2},\n                    {lang: \'Koa2\', todo: 3},\n                    {lang: \'Java\', todo: 3},\n                    {lang: \'App\', todo: 3}]\n            }\n        }\n    }).mount("#program")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n\n# 样式绑定\n\n为了方便 CSS 对页面的美化，Vue3.0 特意提供了操作元素的 class 和内联样式的指令。\n\n因为它们都是元素，所以我们可以用 v-bind(属性绑定) 进行处理。\n\n由于字符串拼接麻烦且易错，所有 Vue3.0 在 v-bind 用于 class 和 style 时，做了专门的增强，表达式结果的类型除了字符串之外，还可以是对象或数组。\n\n\n# 1 Class 指令\n\nVue 用 v-bind:class(简写为:class)指令，用于解决动态切换 class 的需求。\n\n如果你不清楚用在什么哪方面的需求，就想一下提示信息的应用，在错误发生时，用红色字体，否则用绿色。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0 class指令</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .b {\n            font-weight: bold;\n        }\n\n        .error {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n<span id="app">\n<h1 class="b" :class="{ \'error\': hasError }">红色字体，好看么？</h1>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                hasError: true\n            }\n        }\n    }).mount("#app") // 挂载后成为组件\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n渲染结果(生成的代码)\n\n<h1 class="b error">红色字体，好看么？</h1>\n\n\n1\n\n\n> 思考：如何通过单击按钮来切换颜色？\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0 class指令</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .b {\n            font-weight: bold;\n        }\n\n        .error {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n<span id="app">\n    <button @click="change">改变颜色</button>\n\t  <h1 class="b" :class="{ \'error\': hasError }">红色字体，好看么？</h1>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                hasError: true\n            }\n        },\n        methods:{\n            change(){\n                this.hasError = !this.hasError\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n> 如果你想同时满足多个 class，你可以用 class 的数组语法。这个语法，可读性更强一些。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0 class指令</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .b {\n            font-weight: bold;\n        }\n\n        .big-text {\n            font-size: 60px;\n        }\n\n        .error {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n<span id="app">\n<p class="b" :class="[fontSize, errorInfo]">\n    程序员<br/>\n    除了会编程之外，还会什么？<br/>\n    当然是敲代码了。\n</p>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                fontSize: \'big-text\',\n                errorInfo: \'error\'\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n渲染结果(生成的代码)\n\n<span id="app"><p class="b big-text error"> 程序员<br> \n  除了会编程之外，还会什么？<br> 当然是敲代码了。 </p></span>\n\n\n1\n2\n\n\n> 你可以用三元表达式，根据条件切换列表中的 class。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0 class指令</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .b {\n            font-weight: bold;\n            font-size: 50px;\n        }\n\n        .yes {\n            color: #008CBA;\n        }\n\n        .no {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n<span id="app">\n<p class="b" :class="[isCool ? \'yes\' :\'no\']">\n    蓝色字体才好看。\n</p>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                isCool: true\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 2 内联样式\n\n在 HTML 中，在元素上用 style 的话，结果是不可改变的，为此 Vue3.0 加上了:style 指令。\n\n注意，你别看这个指令看起来十分直观，看着非常像 CSS，但其实是一个 JavaScript 对象来的。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0 style指令</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<span id="app">\n<p :style="{ color: textColor, fontSize: fontSize + \'px\' }">\n    程序员，都忙得跟狗一样，哈哈~\n</p>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                textColor: \'#008CBA\',\n                fontSize: 50\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 你可以用样式对象的方式。这样的写法，是不是更舒服了一些，输出结果和上面是一模一样的。\n\n<span id="app">\n<p :style="styleOj">\n    程序员，都忙得跟狗一样都忙得跟狗一样，哈哈~\n</p>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                styleOj: {\n                    color: \'#008CBA\',\n                    fontSize: \'50px\'\n                }\n            }\n        }\n    }).mount("#app")\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 既然 class 可以用数组语法，:style 当然也可以。\n\n:style 的数组语法可以将多个样式对象应用到同一个元素上。输出结果和上面的还是一样的。\n\n<span id="app">\n<p :style="[textColor, fontSize]">\n    程序员，都忙得跟狗一样，哈哈~\n</p>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                textColor: {\n                    color: \'#008CBA\',\n                },\n                fontSize: {\n                    \'font-size\': \'50px\'\n                }\n            }\n        }\n    }).mount("#app")\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 计算属性\n\n在如今编程都提出 MVC、MVP 或 MVVM 等模式的情况下，已经很少再将业务逻辑和视图层合在一起。\n\n在 Vue3.0 中，在 HTML(相当于视图层)插值方式是可以负责计算(相当于业务逻辑)，但不提倡你这么用，因为 Vue3.0 有计算属性。\n\n\n# 1 计算属性\n\n将计算放置在模板中，模板将不再是简单的和声明性的，此时，你必须先看一下它，然后才能意识到它执行的计算取决于 chen.lang。如果要在模板中多次包含此计算，则问题会变得更糟。\n\n所以，对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性，听到了没？如果没有的话，那就看看代码吧。计算属性放在 computed 里面，函数放在 methods 里面。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<span id="app">\n    <span>在插值中计算的结果：{{ chen.lang.length > 10 ? \'太多了\' : \'还好\' }}\n    </span>\n    <br/>\n    <span>获取计算属性的结果：{{ langCount }}</span>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                chen: {\n                    name: \'IT界老家伙\',\n                    lang: [\n                        \'Python\',\n                        \'前端\',\n                        \'小程序\',\n                        \'Java\',\n                        \'Android App\',\n                        \'iOS App\'\n                    ]\n                }\n            }\n        },\n        computed: {\n            // 计算属性的 getter\n            langCount() {\n                return this.chen.lang.length > 10 ? \'太多了\' : \'还好\'\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n细心的朋友，可能就会问了，那我用函数计算行不行。如果不考虑性能的话，当然可以的。只是函数和计算属性的区别在于，计算属性有缓存的作用，而函数没有。\n\n在操作过程中，如果内容没有改变，计算属性不会重新计算，而函数每次都会进行计算。用函数计算的代码，我发出来，你自己拷贝进去就好。\n\n \x3c!--  新增函数计算部分  --\x3e\n    <br/>\n    <span>函数计算属性的结果：{{ langFun() }}</span>\n,\n        methods: {\n            // 函数中\n            langFun() {\n                return this.chen.lang.length > 10 ? \'太多了\' : \'还好\'\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2 计算属性的 Setter\n\n计算属性默认只有 getter，如果你想要一个 setter 的话，手动加上就好。\n\n在函数里更新计算属性数据时，会调用 setter。你可以在 setter 里进行调整。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n<span id="app">\n<p>{{ fullName }}</p>\n<p>{{ firstName }}</p>\n<p>{{ lastName }}</p>\n<button @click="sayHello()">点击调用set方法</button>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                firstName: \'程\',\n                lastName: \'绪媛\'\n            }\n        },\n\n        computed: {\n            // 计算属性\n            fullName: {\n                //getter\n                get() {\n                    return this.firstName + \'\' + this.lastName\n                },\n                //setter\n                set(newValue) {\n                    const names = newValue.split(\'或\')\n                    this.firstName = names[0]\n                    this.lastName = \'没有\' + names[names.length - 1]\n                }\n            }\n        },\n        methods: {\n            // sayHello: function() {\n            //     this.fullName = \'程绪媛\'\n            // }\n            sayHello() {\n                this.fullName = \'程绪媛\'\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n> 运行结果\n\n\n\n> 点击调用 set 方法后\n\n\n\n\n# 事件处理\n\n在 JavaScript 语言中，当用户与 UI 组件交互时，UI 组件能够激发一个相应事件。例如，用户按动按钮、滚动文本、移动鼠标或按下按键等，都将产生一个相应的事件。\n\nVue3.0 使用 v-on 指令(缩写为 @ 符号)来监听 DOM 事件，并在触发事件时执行一些 JavaScript 函数。\n\n语法为 v-on:click="函数名" 或 @click="函数名"。\n\n\n# 1 事件处理\n\n如果你有看过前面的章节，应该知道响应用户操作事件的函数是放在 methods 里面的。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<span id="app">\n<button @click="say">说点什么</button>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n        },\n\n        methods: {\n            say() {\n               alert("艾边成，真酷!")\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 2 传递参数\n\nVue 事件绑定，除了支持直接绑定到一个方法外，也可以在内联 JavaScript 语句中调用方法。说白了，就是可以直接在函数中传递参数。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<span id="app">\n<button @click="say(\'老陈说\')">老陈说</button>\n<br/><br/>\n<button @click="say(\'老头说\')">老头说</button>\n</span>\n<script>\n    Vue.createApp({\n        data() {\n        },\n\n        methods: {\n            say(title) {\n                alert(title + "，爱编程的人真酷!")\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3 事件来源\n\n如果界面上有多个按钮或表单，你想根据用户的不同操作，响应不同的事件，这时你可以通过监听事件源的方式进行处理。\n\n在软件系统中，我们常常见到的打开、保存、导出、打印等多个按钮在同一个功能菜单时，就可以用这种方式。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .menu {\n            border: 1px solid darkgreen;\n            width: 100px;\n            height: 150px;\n            padding-top: 20px;\n            padding-left: 20px;\n        }\n    </style>\n</head>\n<body>\n<div class="menu" id="app">\n    <button name="save" @click="opt">保存</button>\n    <br/> <br/>\n    <button name="open" @click="opt">打开</button>\n    <br/> <br/>\n    <button name="print" @click="opt">打印</button>\n</div>\n<script>\n    Vue.createApp({\n        data() {\n        },\n        methods: {\n            opt(event) {\n                let opt = event.target.name\n                let src = event.target.tagName\n                alert(\'知道你点了 \' + opt + \' \' \n                      + src + \',我马上处理.\')\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n输出结果：\n\n\n\n细心的人，可能会想到，如果想要监听事件源，又想要传递参数时，Vue 又当如何处理，不要急，你想到的，我也想到了，Vue 创始人也想到了。\n\n传递参数时，将 $event 参数也传过去就好了。\n\n<div class="menu" id="app">\n    <button name="save" @click="opt(\'保存\',$event)">保存</button>\n    <br/> <br/>\n    <button name="open" @click="opt(\'打开\',$event)">打开</button>\n    <br/> <br/>\n    <button name="print" @click="opt(\'打印\',$event)">打印</button>\n</div>\n<script>\n    Vue.createApp({\n        data() {\n        },\n        methods: {\n            opt(name, event) {\n                let opt = event.target.name\n                let src = event.target.tagName\n                alert(\'知道你点了 \' + opt + \'(\' + name + \') \'\n                    + src + \',我马上处理.\')\n            }\n        },\n    }).mount("#app")\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n输出结果为：\n\n\n\n\n# 4 多事件处理\n\n一个操作，多个函数响应，这便是多事件也。在 Vue3.0 中，这些函数都放在 @click 里并用逗号分隔即可。\n\n这种处理方式，真的很赞，就像你转发分享这篇文章一样。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .menu {\n            border: 1px solid darkgreen;\n            width: 100px;\n            height: 150px;\n            padding-top: 20px;\n            padding-left: 20px;\n        }\n    </style>\n</head>\n<body>\n<div class="menu" id="app">\n    <button @click="add(6),sub(3)">加减</button>\n</div>\n<script>\n    let result = 0\n    Vue.createApp({\n\n        data() {\n        },\n        methods: {\n            add(num) {\n                result += num\n            },\n            sub(num) {\n                result -= num\n                alert(\'结果是：\' + result) // 结果是：3\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 5 按键修饰符\n\n不知你在用键盘输入多项内容之后，是否有按下回车键的习惯，如果没有，那证明你打字很慢，如果有，那证明你不是程序员，而是打字员(哈哈~~,什么鬼逻辑)。\n\n在较完善的系统中，当用户按下回车键(或其他键)时，都会有响应的。为了解决这个问题，Vue 允许为 v-on 或者 @ 在监听键盘事件时添加按键修饰符。\n\nVue 为最常用的键提供了 .enter(回车) 、.tab 、 .delete (捕获“删除”和“退格”键)、.esc(取消) 、.up(上)、.down(下)、.left(左)、.right(右)等。\n\n例如：@keyup.enter="submit"\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .menu {\n            border: 1px solid darkgreen;\n            width: 100px;\n            height: 150px;\n            padding-top: 20px;\n            padding-left: 20px;\n        }\n    </style>\n</head>\n<body>\n<div class="menu" id="app">\n    <button @keyup.enter="submit" @click="submit" type="submit">确定</button>\n</div>\n<script>\n    let result = 0\n    Vue.createApp({\n        data() {\n        },\n        methods: {\n            submit() {\n                alert(\'你明明按下了回车键，别耍赖,赶紧分享文章\')\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 表单输入\n\n在 Vue3.0 中，事件处理用 v-on 指令，表单输入绑定则用 v-model 指令。\n\nv-model 指令在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\n\n# 1 文本输入\n\n在 HTML 标签中，文本输入有单行(text)和多行(textarea)输入。\n\n温馨提醒: v-model 会忽略所有表单元素的 value 的初始值而总是将当前活动实例的数据作为数据来源。你应该通过 JavaScript 该组件的 data 选项中声明初始值。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0表单绑定</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<div id="app">\n    <input v-model="msg" placeholder="单行输入"/>\n    <p>单行输入结果: {{ msg }}</p>\n    <hr style="background-color: #4CAF50;height: 1px"/>\n    <textarea v-model="msg2" placeholder="多行输入"></textarea>\n    <p>多行输入结果: {{ msg2 }}</p>\n</div>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                msg: \'\',\n                msg2: \'\'\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 1.1 文本框的 number 修饰符\n\ntemplate : `\n            <div>\n              {{message}}\n              <input v-model.number="message" type="number" />\n              <button @click="getMessage">获取文本内容</button>\n            </div>  \n        `\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在文本框元素中使用 v-model.number ，得到的结果是一个数字类型的值，而不是字符串。\n\n# 1.2 文本框的 trim 修饰符\n\ntemplate : `\n            <div>\n              {{message}}\n              <input v-model.trim="message" />\n              <button @click="getMessage">获取文本内容</button>\n            </div>  \n        `\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在文本框元素中使用 v-model.trim ，得到的结果会去掉两端的空格、Tab、回车等特殊字符。\n\n\n# 2 复选框 checkbox\n\n在开发产品时，单个复选框常在勾选协议中见到。\n\n# 2.1 单个 checkbox 与数据绑定\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <input type="checkbox" v-model="checkboxFlag" />checkbox<br>\n        <button @click="getCheckboxFlag">获取checkbox设置</button>\n    </div>  \n\n<script>\n  const app = Vue.createApp({     // 创建一个vue应用实例\n  data() {\n    return {\n      checkboxFlag: true,\n    }\n  },\n  methods: {\n    getCheckboxFlag() {\n       console.info(this.checkboxFlag)\n    }\n  },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n当 checkbox 被选中时，值是 true，否则值是 false\n\n\n\n# 2.2 自定义单个 checkbox 的值\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <input type="checkbox" v-model="checkboxFlag2" true-value="选中" false-value="未选中" />checkbox<br>\n        <button @click="getCheckboxFlag2">获取checkbox设置</button>\n    </div>  \n<script>\n  const app = Vue.createApp({     // 创建一个vue应用实例\n    data() {\n        return {\n            checkboxFlag2: "选中",\n        }\n    },\n    methods : {\n        getCheckboxFlag2() {\n        console.info(this.checkboxFlag2)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n使用 true-value 和 false-value 自定义 checkbox 的值\n\n\n\n# 2.3 一组 checkbox 与数据绑定\n\n一组复选框，常在选择个人兴趣爱好等见到。复选框，单选时，绑定到布尔值，多选时，绑定到同一个数组。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <input type="checkbox" v-model="checkboxArr" value="football" />足球<br>\n        <input type="checkbox" v-model="checkboxArr" value="basketball" />篮球<br>\n        <input type="checkbox" v-model="checkboxArr" value="tableTennis" />乒乓球<br>\n        <button @click="getCheckboxArr">获取checkbox设置</button>\n    </div>  \n<script>\n  const app = Vue.createApp({     // 创建一个vue应用实例\n    data() {\n        return {\n            checkboxArr: [],\n        }\n    },\n    methods : {\n        getCheckboxArr() {\n            console.info(this.checkboxArr)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n一组 checkbox 与同一个数据 checkboxArr 绑定，得到的结果是一个数组\n\n\n\n\n# 3 单选框（radio）\n\n在开发产品时，单选按钮，用于多选一，在选择性别时常见。\n\n# 3.1 一组 radio 与数据绑定\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <input type="radio" v-model="radioValue" value="football" />足球<br>\n        <input type="radio" v-model="radioValue" value="basketball" />篮球<br>\n        <input type="radio" v-model="radioValue" value="tableTennis" />乒乓球<br>\n        <button @click="getRadioValue">获取radio设置</button>\n    </div>  \n<script>\n  const app = Vue.createApp({     // 创建一个vue应用实例\n    data() {\n        return {\n            radioValue: "tableTennis",\n         }\n    },\n    methods : {\n        getRadioValue() {\n            console.info(this.radioValue)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nradio 是单选（只能选择其中的一个），因此得到的值是一个 字符串\n\n\n\n\n# 4 select\n\n如果选择项很多，那可用多选下拉菜单 select，以节约布局空间。\n\n# 4.1 select 与数据绑定\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <select v-model="selectValue">\n            <option value="football">足球</option>\n            <option value="basketball">篮球</option>\n            <option value="tableTennis">乒乓球</option>\n        </select>\n        <br>\n        <button @click="getRadioValue">获取select设置</button>\n    </div>  \n<script>\n  const app = Vue.createApp({     // 创建一个vue应用实例\n    data() {\n        return {\n            selectValue: "",\n        }\n    },\n    methods : {\n        getRadioValue() {\n            alert(this.selectValue)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在 select 标签上使用 v-model 绑定数据 selectValue\n\n\n\n# 4.2 select 的选项从数据获得\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <select v-model="selectValue">\n            <option v-for="item in selectOptionArr" :value="item.value">{{item.text}}</option>\n        </select>\n        <br>\n        <button @click="getSelectValue">获取select设置</button>\n    </div>  \n<script>\n  const app = Vue.createApp({     // 创建一个vue应用实例\n    data() {\n        return {\n            selectOptionArr: [\n                {text: "足球", value: "football"}, \n                {text: "篮球", value: "basketball"}, \n                {text: "乒乓球", value: "tableTennis"}\n            ],\n        }\n    },\n    methods : {\n        getSelectValue() {\n            alert(this.selectValue)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n使用 v-for 得到 option 元素，运用数组的形式，效果和上一小节一致。\n\n# 4.3 select 的返回对象\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <select v-model="selectValue">\n            <option v-for="item in selectOptionArr2" :value="item.value">{{item.text}}</option>\n        </select>\n        <br>\n        <button @click="getSelectValue">获取select设置</button>\n    </div>  \n<script>\n  const app = Vue.createApp({     // 创建一个vue应用实例\n    data() {\n        return {\n            selectOptionArr2: [\n                {text: "足球", value: {name:"football", text:"足球"}}, \n                {text: "篮球", value: {name:"basketball", text:"篮球"}}, \n                {text: "乒乓球", value: {name:"tableTennis", text:"乒乓球"}}\n            ],\n        }\n    },\n    methods : {\n        getSelectValue() {\n            console.info(this.selectValue)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\noption 绑定的数据 selectOptionArr2 中，value 是一个对象。这样 select 的返回值就是对应的对象。\n\n\n\n\n# Vue3 小项目实战\n\n用所学过的 Vue3.0 双大括号文本插值、条件、循环渲染指令、表单数据双向绑定、计算属性和事件响应等相关知识，来开发一个小项目，以此达到技术总结的意义。\n\n\n# 1 产品列表\n\n * 页面布局，用纯天然的 HTML+CSS 就好了。\n * 用插值和计算属性，输出产品总数量。\n * 用 v-for 循环渲染，输出产品信息。\n * 用 v-if 判断产品规格是否为空。\n * 用 v-on(缩写 @)进行事件绑定。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0小项目实战</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n    <style>\n        h1 {\n            text-align: center;\n            color: darkorange;\n            margin-top: 30px;\n        }\n\n        .counter {\n            text-align: center;\n            margin-bottom: 5px;\n        }\n\n\n        table {\n            width: 800px;\n            margin: 0 auto;\n            text-align: center;\n        }\n\n        td, th {\n            border: 1px solid #bcbcbc;\n            padding: 5px 10px;\n        }\n\n        th {\n            background: #42b983;\n            font-size: 1.2rem;\n            font-weight: 400;\n            color: #fff;\n            cursor: pointer;\n        }\n\n        tr:nth-of-type(odd) {\n            background: #fff;\n        }\n\n        tr:nth-of-type(even) {\n            background: #eee;\n        }\n\n        .del {\n            color: red;\n        }\n\n        input {\n            border: 1px solid darkcyan;\n            line-height: 25px;\n            width: 200px;\n            color: #000;\n            font-weight: bold;\n            margin-top: 5px;\n            margin-left: 10px;\n        }\n    </style>\n</head>\n<body>\n<div id="app">\n    <h1>产品信息列表</h1>\n    <div class="counter">共有<strong>{{ counter }}</strong>件产品</div>\n    <table>\n        <thead>\n        <tr>\n            <th>序号</th>\n            <th>名称</th>\n            <th>型号</th>\n            <th>规格</th>\n            <th>操作</th>\n        </tr>\n        </thead>\n        <template v-for="(product,index) in products" :key="index">\n            <tr>\n                <td>\n                    {{ index + 1 }}\n                </td>\n                <td>\n                    {{ product.name }}\n                </td>\n                <td>\n                    {{ product.type }}\n                </td>\n                <td>\n                <span v-if="product.desc==\'\'">\n                 未填写规格\n                </span>\n                <span v-else>\n                   {{ product.desc }}\n                </span>\n                </td>\n                <td>\n                    <button class="del" @click=\'del(index)\'>删除</button>\n                </td>\n            </tr>\n        </template>\n    </table>\n</div>\n<script>\n    // const { createApp } = Vue\n    // createApp({...})\n    Vue.createApp({\n        data() {\n            return {\n                product: {\n                    name: \'\',\n                    type: \'\',\n                    desc: \'\',\n                },\n                products: [\n                    {name: \'安卓手机\', type: \'AZ321\', desc: \'6.8寸\'},\n                    {name: \'苹果手机\', type: \'PG222\', desc: \'4.8寸\'},\n                    {name: \'安卓平板\', type: \'PB666\', desc: \'9.8寸\'},\n                    {name: \'二手电视\', type: \'ER659\', desc: \'12寸\'},\n                    {name: \'洗衣机\', type: \'XY872\', desc: \'9.8斤\'}\n                ]\n            }\n        },\n        computed: {\n            counter() {\n                return this.products.length\n            }\n        },\n\n        methods: {\n            //删除数据\n            del(index) {\n                this.products.splice(index, 1)\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n\n\n\n# 2 新增产品\n\n在新增表单布局代码，实现新增产品功能的布局。\n\n * 用 v-model 指令，进行表单数据双向绑定；\n * 用 v-on(缩写@)进行事件绑定。\n * 在 method 里面添加 add 函数，进行表单是否为空校验，不通过就进行提示，通过就将信息添加到产品信息列表中。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0小项目实战</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n    <style>\n        h1 {\n            text-align: center;\n            color: darkorange;\n            margin-top: 30px;\n        }\n\n        .counter {\n            text-align: center;\n            margin-bottom: 5px;\n        }\n\n\n        table {\n            width: 800px;\n            margin: 0 auto;\n            text-align: center;\n        }\n\n        td, th {\n            border: 1px solid #bcbcbc;\n            padding: 5px 10px;\n        }\n\n        th {\n            background: #42b983;\n            font-size: 1.2rem;\n            font-weight: 400;\n            color: #fff;\n            cursor: pointer;\n        }\n\n        tr:nth-of-type(odd) {\n            background: #fff;\n        }\n\n        tr:nth-of-type(even) {\n            background: #eee;\n        }\n\n        .del {\n            color: red;\n        }\n\n        input {\n            border: 1px solid darkcyan;\n            line-height: 25px;\n            width: 200px;\n            color: #000;\n            font-weight: bold;\n            margin-top: 5px;\n            margin-left: 10px;\n        }\n\n        .add {\n            width: 800px;\n            margin: 0 auto;\n            text-align: center;\n        }\n\n        .addBtn {\n            background-color: #4CAF50; /* Green */\n            border: none;\n            color: white;\n            padding: 8px 32px;\n            font-size: 16px;\n            margin-right: 10px;\n        }\n    </style>\n</head>\n<body>\n<div id="app">\n    <h1>产品信息列表</h1>\n    <div class="counter">共有<strong>{{ counter }}</strong>件产品</div>\n    <table>\n        <thead>\n        <tr>\n            <th>序号</th>\n            <th>名称</th>\n            <th>型号</th>\n            <th>规格</th>\n            <th>操作</th>\n        </tr>\n        </thead>\n        <template v-for="(product,index) in products" :key="index">\n            <tr>\n                <td>\n                    {{ index + 1 }}\n                </td>\n                <td>\n                    {{ product.name }}\n                </td>\n                <td>\n                    {{ product.type }}\n                </td>\n                <td>\n                <span v-if="product.desc==\'\'">\n                 未填写规格\n                </span>\n                <span v-else>\n                   {{ product.desc }}\n                </span>\n                </td>\n                <td>\n                    <button class="del" @click=\'del(index)\'>删除</button>\n                </td>\n            </tr>\n        </template>\n    </table>\n    <div class="add">\n        <h1>新增产品信息</h1>\n        <div style="margin-left: 10px">\n            名称:<input name="name" type="text" v-model="product.name"\n                      placeholder="请输入产品名称"/><br/>\n            型号:<input name="type" type="text" v-model="product.type"\n                      placeholder="请输入产品型号"/><br/>\n            规格:<input name="desc" type="text" v-model="product.desc"\n                      placeholder="请输入产品规格"/>\n        </div>\n        <br/>\n        <button class="addBtn" type="submit" @click="add()">提交</button>\n    </div>\n</div>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                product: {\n                    name: \'\',\n                    type: \'\',\n                    desc: \'\',\n                },\n                products: [\n                    {name: \'安卓手机\', type: \'AZ321\', desc: \'6.8寸\'},\n                    {name: \'苹果手机\', type: \'PG222\', desc: \'4.8寸\'},\n                    {name: \'安卓平板\', type: \'PB666\', desc: \'9.8寸\'},\n                    {name: \'二手电视\', type: \'ER659\', desc: \'12寸\'},\n                    {name: \'洗衣机\', type: \'XY872\', desc: \'9.8斤\'}\n                ]\n            }\n        },\n        computed: {\n            counter() {\n                return this.products.length\n            }\n        },\n\n        methods: {\n            // 删除数据\n            del(index) {\n                this.products.splice(index, 1)\n            },\n            // 添加数据\n            add() {\n                if (this.product.name.trim() == \'\') {\n                    alert(\'产品名称不可为空，请输入.\')\n                } else if (this.product.type.trim() == \'\') {\n                    alert(\'产品型号不可为空，请输入.\')\n                } else {\n                    this.products.push(this.product)\n                    this.product = {}\n                }\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n\n\n运行结果为：\n\n\n\n\n# 自定义组件\n\n在一个页面中，如果有代码重复的内容，那你可以将其抽出来，用 Vue 注册成局部组件；在一个 Web 系统中，如果有多个页面有共同的代码，那你可以将其抽出来，用 Vue 注册成全局组件。\n\n组件可以扩展 HTML 元素，封装可重用的代码。让我们可以用独立可复用的小组件来构建大型应用。\n\n其实，如果你用第三方现成的组件库的话，自定义组件，用得很少，甚至不用，但这是一个知识点，还是学一下比较好。\n\n\n# 1 局部注册\n\n在一个页面中，将其重复的内容抽出来，注册成组件，比如 <demo>。在需要用的地方直接引进 <demo></demo> 这个组件即可，以此来达到复用的目标。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0组件注册</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<div id="app">\n    <demo></demo>\n    好多内容啊.........<br/>\n    <demo></demo>\n</div>\n<script>\n    // 创建一个Vue 应用\n    const app = Vue.createApp({})\n    \n    // 定义一个名为 demo 的新页面组件\n    app.component(\'demo\', {\n        data() {\n            return {\n                lang: "Vue3.0"\n            }\n        },\n        template: `<span style="color: darkgreen">\n        编程语言：{{ lang }}</span><br/>`\n    })\n    app.mount(\'#app\')\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n运行结果：\n\n\n\n\n# 2 全局注册\n\n如果在整个 Web 系统中，有重复代码存在的话，那可以将共同的内容，放到一个 js 文件中。之后，在需要用到的页面进行引进即可。\n\nconst ComponentA = {\n    template: `<span style="color: darkgreen">编程哪家好？</span>\n        <p>\n          PHP是世上最好的语言。<br/>\n          c#说，问过我没有。<br/>\n          Java路过，笑而不语。\n        </p>`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhtml 页面文件内容，注意引进 c.js 文件。\'lang\' -- <lang></lang>\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Vue3.0组件注册</title>\n    <script src="vue.global.js"><\/script>\n    <script src="c.js"><\/script>\n</head>\n<body>\n<div id="app">\n    <lang></lang>\n    <hr style="background-color:green;height: 1px"/>\n    <lang></lang>\n    <hr style="background-color:green;height: 1px"/>\n    <lang></lang>\n</div>\n<script>\n    const app = Vue.createApp({\n        components: {\n            \'lang\': ComponentA\n        }\n    })\n    app.mount(\'#app\')\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n运行结果为：\n\n\n\n\n# 异步请求和侦听器\n\n在 Web 技术栈中，异步请求是一直是神一样的存在。传统的网页不使用异步请求 (AJAX) 如果需要更新内容，必须重载整个网页面，消耗性能不说，用户体验大大的差。\n\nAJAX = 异步 JavaScript 和 XML，是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n由于 AJAX 是开发 Web 必备的，于是有人将其进行了封装，其中有一个和 Vue3.0 配合最好的家伙，叫作 axios。\n\n\n# 1 axios 应用\n\n * 引入 axios，不用什么脚手架，也不用什么 cdn，直接去 https://github.com/axios/axios 下载。\n * 解压缩文件，找到 dist 文件夹，将 axios.min.js 文件放到和 HTML 文件相同的目录下即可。\n * 在要使用的页面中，加上 <script src="axios.min.js"><\/script> 就好了。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <script src="vue.global.js"><\/script>\n    <script src="https://unpkg.com/axios@1.4.0/dist/axios.min.js"><\/script>\n  \n</head>\n<body>\n<div id="app">\n    <p>{{ weather }}</p>\n    <button @click="getWeather">获取成都天气信息</button>\n</div>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                weather: \'\'\n            }\n        },\n        methods: {\n            getWeather() {\n                this.answer = \'获取数据中..\'\n                axios\n                    .get(\'http://wthrcdn.etouch.cn/weather_mini?city=成都\')\n                    .then(response => {\n                        this.weather = response.data\n                    })\n                    .catch(error => {\n                        this.weather = \'获取不到：\' + error\n                    })\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 2 侦听器\n\n在输入框输入数据时，有时候，你需要实时获取到用户输入的每一个字符，才好在后台进行相关处理，像搜索引擎就是这样的。\n\n在 Vue3.0 中，侦听用户输入，使用 watch 方法。\n\n文本框输入一个广字，后台调用天气查询接口，这时有可能返回广州，也有可能返回广平等含有广字的城市的天气信息。当输入广州时，会再去查询一遍。侦听器一监听到有内容变化，就会去调用天气查询接口，再次查询数据。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <script src="vue.global.js"><\/script>\n    <script src="axios.min.js"><\/script>\n</head>\n<body>\n<div id="app">\n    <p>{{ weather }}</p>\n    <input v-model="city" placeholder="请输入城市名称"/>\n</div>\n<script>\n    Vue.createApp({\n        data() {\n            return {\n                weather: \'\',\n                city: \'\'\n            }\n        },\n        watch: {\n            city(newCity, oldQuestion) {\n                this.getWeather()\n            }\n        },\n        methods: {\n            getWeather() {\n                this.weather = \'查询\' + this.city + \'天气中..\'\n                axios\n                    .get(\'http://wthrcdn.etouch.cn/weather_mini?city=\' + this.city)\n                    .then(response => {\n                        this.weather = response.data\n                    })\n                    .catch(error => {\n                        this.weather = \'获取不到：\' + error\n                    })\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 组件库 element+\n\n\n# 官网\n\n一个 Vue 3 UI 框架 | Element Plus (element-plus.org)\n\nelement+ 是开源的前端组件库，有众多开发者在应用，是业界主流的 Web 端组件库之一。它有多个高质量组件，覆盖前端各类场景。性能极佳。组件体积小，支持主题定制和国际化等常用功能。element+ 可以友好的支持 Vue3.0。\n\n\n# 1 安装 element+\n\n虽然现在流行用 npm 命令、用所谓的脚手架创建项目，用命令行运行项目的方法，但我依然认为在学习阶段，应该怎么简单怎么来，最好不要在配置上浪费时间，消磨学习的兴趣。所以我推荐你直接用引入 CSS 和 JS 的方式。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>ElementPlus组件库</title>\n    \x3c!-- Import style 引入样式文件 --\x3e\n    <link rel="stylesheet" href="//unpkg.com/element-plus/dist/index.css" />\n    \x3c!-- Import Vue 3 --\x3e\n    \x3c!-- <script src="vue.global.js"><\/script> --\x3e\n    <script src="//unpkg.com/vue@3"><\/script>\n    \x3c!-- Import component library 引入组件库 --\x3e\n    <script src="//unpkg.com/element-plus"><\/script>\n</head>\n<body>\n<div id="app">\n    <el-row>\n        <el-button>默认按钮</el-button>\n        <el-button type="primary">主要按钮</el-button>\n        <el-button type="success">成功按钮</el-button>\n        <el-button type="info">信息按钮</el-button>\n        <el-button type="warning">警告按钮</el-button>\n        <el-button type="danger">危险按钮</el-button>\n    </el-row>\n</div>\n<script>\n    const app = Vue.createApp({});\n    app.use(ElementPlus);\n    app.mount("#app");\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 2 来点不一样的\n\n习惯了 HTML 的那些常规标签，总想找点不一样的，这下有了 element+，就可以实现了。我们来个不一样的选择标签，来个评分打星标签，再来一个物流进度时间线。\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>ElementPlus组件库</title>\n    \x3c!-- Import style --\x3e\n    <link rel="stylesheet" href="//unpkg.com/element-plus/dist/index.css" />\n    \x3c!-- Import Vue 3 --\x3e\n    <script src="vue.global.js"><\/script>\n    \x3c!-- Import component library --\x3e\n    <script src="//unpkg.com/element-plus"><\/script>\n</head>\n<body>\n    <div id="app">\n        <el-switch v-model="v1" active-color="#13ce66" inactive-color="#ff4949">\n        </el-switch>\n        <hr /> \n        <el-rate v-model="v2"></el-rate>\n        <hr /> \n        <el-progress type="circle" :percentage="25"></el-progress>\n        <br /><hr /> \n        <el-timeline>\n            <el-timeline-item v-for="(activity, index) in activities" :key="index" :timestamp="activity.timestamp"\n                :color="activity.color">\n                {{activity.content}}\n            </el-timeline-item>\n        </el-timeline>\n    </div>\n    <script>\n        const app = Vue.createApp({\n            data() {\n                return {\n                    v1: true,\n                    v2: \'\',\n                    activities: [{\n                        content: \'【城市】物流状态1\',\n                        timestamp: \'2020-10-10\',\n                        color: \'#0bbd87\'\n                    }, {\n                        content: \'【城市】物流状态2\',\n                        timestamp: \'2020-10-11\',\n                        color: \'#0bbd87\'\n                    }, {\n                        content: \'快件发货中\',\n                        timestamp: \'2020-10-12\'\n                    }]\n                }\n            }\n        });\n        app.use(ElementPlus);\n        app.mount("#app");\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n运行结果：\n\n\n\n\n# 电子地图\n\n在大数据时代，用电子地图展示数据的需求，已成为常规需求。\n\n其实，用电子地图，完全可以不用管 Vue 的，直接用 Javascript 就可以实现。\n\n\n# 1 获取 Appkey\n\n 1. 用你的百度账号，登录到百度 API key 的申请地址 https://lbsyun.baidu.com/apiconsole/key/create\n 2. 登录成功后，如果没有直接导航到【创建应用】节点的话，就手动点击【创建应用】。(在控制台中)\n 3. 填写应用名称：sales，应用类型：浏览器端。启用服务：全部勾上。Referer 白名单：填写半角*。\n 4. 填写好后，点击【提交】按钮。\n\n在返回的窗口中，会有 API key 这项内容，复制出来，保存在某个地方，稍后就会用到。\n\n\n# 2 电子地图\n\n代码里的 "你的key"，改成你申请到的。仔细阅读代码，你会发现，这里和 Vue3.0 没半毛钱关系。\n\n实现一个功能，看需求文档的要求，如果根本就不需要到 Vue3.0 的话，就不要硬用。好了，废话不多说，看代码吧。\n\n<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n    <meta charset="utf-8">\n    <title>地图展示</title>\n    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">\n    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">\n    <meta http-equiv="X-UA-Compatible" content="IE=Edge">\n    <style>\n        body,\n        html,\n        #container {\n            overflow: hidden;\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            font-family: "微软雅黑";\n        }\n    </style>\n    <script src="//api.map.baidu.com/api?type=webgl&v=1.0&ak=C3DLtVXcGrWnRzFRg8QglHIst2M87Dfx">\n    <\/script>\n</head>\n<body>\n<div id="container"></div>\n</body>\n</html>\n<script>\n    var map = new BMapGL.Map(\'container\');\n    map.centerAndZoom(new BMapGL.Point(102.54, 30.05), 12);\n    map.enableScrollWheelZoom(true);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n\n\n# 组合式 API\n\nVue 3 的组合式 API 是一种新的 API 风格，用于编写 Vue 组件。\n\nVue 3 的组合式 API 基于函数式编程的思想，将组件的逻辑拆分为独立的功能单元，称为"组合函数"。这些组合函数可以通过 setup() 函数在组件中进行定义和使用。\n\n使用组合式 API，可以将组件的相关逻辑聚合在一起，而不是按照选项属性（如 data、methods、computed 等）进行划分。这样可以更好地组织和管理组件的代码，使代码更具可读性和可维护性。\n\n组合式 API 提供了以下几个主要的特性：\n\n 1. setup() 函数：在组件中使用 setup() 函数来定义组合函数和其他响应式数据。setup() 函数在组件创建之前执行，并且可以返回一个对象，该对象包含组合函数和其他数据。\n 2. 组合函数：组合函数是一种用于定义组件逻辑的函数。它可以包含数据、计算属性、方法等，并且可以使用 Vue 提供的响应式 API（如 ref、reactive 等）来管理组件状态。\n 3. 生命周期钩子函数：Vue 3 的组合式 API 引入了新的生命周期钩子函数，如 onMounted、onUpdated、onUnmounted 等，用于在不同的组合函数中执行特定的操作。\n 4. 自定义逻辑复用：通过将相关的组合函数提取为可复用的函数，可以在多个组件之间共享逻辑，并实现更好的代码复用性。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <title>Vue 3 组合式 API 示例</title>\n    \x3c!-- <script src="https://unpkg.com/vue@next"><\/script> --\x3e\n    <script src="vue.global.js"><\/script>\n  </head>\n  <body>\n    <div id="app">\n      <p>当前计数值为：{{ count }}</p>\n      <button @click="increment">增加</button>\n      <button @click="decrement">减少</button>\n    </div>\n\n    <script>\n      const { ref } = Vue;\n\n      const app = Vue.createApp({\n        setup() {\n          // 使用 ref 定义 count 响应式数据\n          const count = ref(0);\n\n          // 定义增加计数的方法\n          function increment() {\n            count.value++;\n          }\n\n          // 定义减少计数的方法\n          function decrement() {\n            count.value--;\n          }\n\n          // 返回 count 和两个方法\n          return {\n            count,\n            increment,\n            decrement,\n          };\n        },\n      });\n\n      app.mount("#app");\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n',normalizedContent:'# vue3 入门\n\n\n# vue3 简介\n\n菜鸟教程：https://www.runoob.com/vue3/vue3-install.html\n\n\n\n从 2020 年 9 月份 vue3.0 发布以来，经过近两年的发展补充，vue3 的生态圈逐步完善，已经成熟到足以支撑日常项目的研发。\n\n而且，vue3 在 vue2 的基础上引入了 typescript 重构了大量的代码，增加了很多新的特性，并发布了新一代的工程化工具 vite 。这些新的改动，让 vue3 对我们的研发变得更加友好。\n\n\n# vue3 对研发更友好\n\n让我们来看一下，同样的项目，使用 vite 作为开发构建工具的 vue3 和使用 vue-cli 的 vue2 的运行对比。\n\n构建工具      启动时间     打包时间\nvite      135ms    13025ms\nvue-cli   1482ms   28186ms\n\n从上面的表格我们可以看到，vite 相对比 vue-cli 来说，启动项目时间缩短达到了 10 倍，打包时间也明显减小。\n\n同时，vue3 也提高了编译的效率。以往当我们的项目越来越大时，经常是一个小小的改动，甚至需要等待几分钟的编译时间才能看到页面效果。而 vite 内部使用了 esbuild 作为底层的依赖预编译工具，完全发挥了 go 语言和多线程的优势，同时利用现代浏览器原生支持 esm 特性，完全省略了打包的过程，极大的提高了编译运行的效率（关于 vite，我们会在其他章节详细介绍，这里只需要有个印象就可以了）。\n\n * 除了 vite 这个新工具以外，从代码层面，vue3 的 composition api 新特性也让我们的项目代码功能结构更加清晰，组件拆分复用更加灵活。\n\n * 从框架层面，vue3 框架的本身也使用 proxy 代替 object.defineproperty 重新实现了真正的响应式“代理”，并且将渲染逻辑拆分为【浏览器渲染】和【平台无关渲染】，这对于我们的跨端，跨框架组合开发来说有着非同凡响的意义，你能想象在 react 中使用 vue 的响应式吗，vue3 就替你创造了这个可能性。\n\n综上可见，vue3 做了如此多的改变，从编译运行、代码语法、框架结构等多个层面同时发力，给研发提供了编译更快、打包体积更小、写法更清晰的直观感受，那我们又有什么理由去拒绝 vue3 呢？\n\n\n# 如何学习 vue3？\n\n大部分的同学应该都有过 vue 的相关开发经验，而且 vue 也是流行框架中出了名的简单易学，所以从 vue2 到 vue3 的升级远远没有想象的那么困难。\n\n相信有部分同学阅读过 vue 原理的相关文章，比如响应式的实现原理，使用了 object.defineproperty 进行拦截代理等等，而在 vue3 中，设计者们对部分功能的原理进行了重构调整，我们在学习的过程中，可以从两个方面来深入剖析。\n\n 1. 在纵向上，与 vue2 的实现原理进行对比。\n\n这样可以帮助我们深刻的理解 vue3 的新特性原理，新语法为什么要这么实现，同时也能更清楚 vue2 的缺陷和短板，进一步的拓宽我们的知识面。\n\n如果大家过去只是单纯地使用 vue2，只是根据文档按部就班的进行开发，那么通过 vue3.0 再次学习的过程，我们可以从原理到基础 api，再到 vue-router、vuex 的引入，认真体会下 vue3 的渐进式设计。\n\n 2. 在横向上，与现有的热门框架 react ， angular 等对比，深入理解各个框架的侧重点和特色。\n\n这样可以进一步地体会 vue 本身的设计理念和均衡的特性，以及各个框架的优缺点，我们可以更好地明白各个框架的定位以及如何去根据项目来选择一个合适的前端框架。\n\n其实每个框架都有自己的核心点，只要抓住框架的几个重点，就像搭帐篷一样，就能支撑起我们自己的框架思维，学会去搭建自己的框架思维，那后面如果再有 vue4，vue5 或者其他新的框架，对于我们来说，都可以很快去接受并使用它们。\n\n\n# vue 能做啥？\n\n我们知道，html 文档是由节点构成的集合。html 文件节点包括【元素节点、文本节点和属性节点】。下面请仔细观察 html 文件的页面结构。\n\n<!doctype html> \n<html> \n  <head>     \n    <meta charset="utf-8">     \n    <title>vue3.0篇</title> \n  </head> \n  <body> \n    <h1>说编程</h1> \n    <a href="demo1.html">个人简介</a> \n  </body> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 1 文档结构\n\n\n# 1.1 html是一棵树\n\n观察了 html 页面结构之后，细心的你会发现："html 是一棵树"！\n\n没错，html 就是一棵由 html 标签组成的树。树干是 <html> 标签，树枝是节点，树叶是属性，树花是文本。\n\n\n\n\n# 1.2 浏览器如何砍树\n\n为了方便浏览器，砍(解析) html 这棵树，w3c(万维网联盟)定义了访问 html 的 dom 标准。dom(document object model)文档对象模型，定义了所有 html 元素的对象和属性，以及访问它们的方法。\n\njs 操作 dom 时，浏览器会从构建 dom 树开始从头到尾执行一遍流程（意味着每一次操作都需要重新计算）。比如在用户一次操作中，他/她需要更新 10 个 html 元素(dom节点)内容时，浏览器在收到第 1 个 dom 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行了 10 次操作。\n\n在第 1 次计算完之后，紧接着下一个 dom 更新请求时，之前节点的坐标值就变了。那么，进行第 2 次计算时，之前的操作相当于做了无用功，白白浪费了性能。频繁操作还会出现页面卡顿，影响用户体验的问题。\n\n\n# 1.3 在性能优化之后\n\n为了解决 dom 访问 html 文件时存在的性能问题，一帮技术牛人就开始琢磨......\n\n在 2009 年时，经过 misko hevery 等人的努力，终于研究出了一种 diff 算法，实现了那里需要更新就更新那里的愿望，为了方便分享喜悦，misko hevery 等人对其进行了扩展、升级、包装并给它取了一个好听的名字：angularjs。\n\n为了方便、保障 angularjs 能更好的用到谷歌产品中，谷歌对其进行了收购。于是，一款有着诸多特性，核心功能的是 mvc(model–view–controller)、模块化、自动化双向数据绑定、语义化标签、依赖注入等等的优秀前端 js 框架，由此诞生了。\n\n\n# 1.4 为何有 vue\n\n在 angular 流行的那些年，好多程序员都投入了好多精力去学习，也不管 angular 的 mvc 是否全部都能用得上。其实就算知道了，也无可奈何，理由你懂的。\n\n直到 2013，就职于 google creative lab，名叫尤雨溪的帅哥的出现，程序员用前端 js 框架，才发现根本不需要那么累。\n\n尤大大由于个人兴趣，对 angular 进行了改造，去掉了 angular mvc 中的 mv，只留下 v(view) 的内容。为了方便记忆，将其取名为 vue.js。\n\nvue.js(读音 /vjuː/, 类似于 view) 是一套构建用户界面的渐进式框架。vue 核心只关注视图层，采用自底向上增量开发的设计，目标是通过尽可能简单的 api 实现响应式的数据绑定和组合的视图组件。\n\nvue 从最初的实验阶段(2013年中到2014年2月)，0.x 阶段 (2014年2月到2015年10月)，1.x 阶段 (2015年10月到2016年9月)，2.x 阶段(2016年9月至2019年上半年)，到今天的 3.x 阶段，已经有足足 9 年多的时间了。\n\n\n# 感受 vue3\n\n\n# 1 如何使用 vue\n\n在使用 <script> 标签引入 vue 的情况下，有两种引入方式：\n\n * 通过 cdn 地址引入\n\n * 或直接本地 vue.js 文件引入。\n\n如果进行单文件组件(sfc)开发，则要复杂些，不是用 vite，就是用 cli 脚手架。\n\n对于初学者，建议从 <script> 标签引入 vue 开始学习。\n\n<script src="https://unpkg.com/vue@next"><\/script>\n\n\n1\n\n\n就是引用 cdn 的方式。从 https 名字，你就知道，这是引用网上的资源(受网络环境影响)。可网络差或断网的话，怎么办，不学了？\n\n所以，也可以回到以前的传统方法，就是直接到：\n\nhttps://cdn.jsdelivr.net/npm/vue@3.3.4/dist/\n\n下载 vue.global.js 文件，然后在要用 vue 的 html 文件中引用就好了!\n\n<script src="vue.global.js"><\/script>\n\n\n1\n\n\n\n# 2 vue3 倍轻松\n\n在 vue3 中，每个 vue 应用都是通过用 createapp 函数创建一个新的应用实例开始的，这种统一的应用方式，让你学起来更加轻松。\n\n学习 vue 3，就是对其生命周期中的函数，有的放矢，加加减减，或独立或联合。生命周期图，你不用记忆，也不用背诵，浏览一下就好，后面会逐步讲解的。\n\n\n\n> 用第 1 个框图中的 createapp 和 mount 搞个样例，让代码飘一会。\n\n<!doctype html>\n<html>\n\n<head>\n    <meta charset="utf-8">\n    <title>第1个vue 3程序</title>\n    <style>\n        .hello_div {\n            border: 1px solid darkgreen;\n            border-radius: 15px;\n            width: 850px;\n            line-height: 50px;\n            text-align: center;\n        }\n    </style>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="hello" class="hello_div"> 你好，{{ msg }} </div>\n    <script>\n        // 传统html写法\n        // let msg = \'vue.js 3\'\n        // // 找对人\n        // let hellodiv = document.getelementbyid(\'hello\')\n        // // 做对事\n        // hellodiv.innertext = `你好，${msg}`\n        const vue = vue.createapp({\n            data() {\n                return { msg: "vue 3" }\n            }\n        })\n        vue.mount("#hello") <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n输出结果\n\n\n\n\n# 3 vue3 三步曲\n\n应用 vue3，可按三步曲进行：\n\n 1. 创建 vue 实例；\n 2. 定义将要赋予元素的数据；\n 3. 将数据和元素进行绑定。\n\n定下这个调调之后，后面就是学习它的【语法(模板、条件和组件等)和生命周期函数的应用】了。\n\n为了方便和提高代码的可读性，定义数据和 vue 实例，常常放在一起声明。为了让你更清晰 vue 的意义，我就来个数据绑定的例子。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>第2个vue 3程序</title>\n    <style>\n        .input_div {\n            border: 1px solid darkgreen;\n            border-radius: 15px;\n            width: 850px;\n            line-height: 50px;\n            text-align: center;\n        }\n\n        input {\n            border: 1px solid salmon;\n            width: 200px;\n            height: 22px;\n        }\n    </style>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="hello" class="input_div"> \n      \t<input id="name" v-model="msg" placeholder="hello" />\n        <p>想学编程的人，快点来，<strong>{{ msg }}</strong>world。</p>\n    </div>\n    <script>\n        // 第1步：创建vue实例\n        // 第2步：定义数据\n        // 第3步：绑定元素     \n        vue.createapp({\n            data() {\n                return { msg: \'\' }\n            }\n        }).mount("#hello")\n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 核心语法\n\n想学一门编程语言，就要先整明白它的语法规则。vue 使用了基于 html 的模板语法，允许开发者声明式地将 dom 绑定至底层组件实例的数据。所有 vue 的模板都是合法的 html，所以能被遵循规范的浏览器和 html 解析器解析。\n\n\n# 1 文本插值\n\n数据绑定最常见的形式就是使用双大括号 {{}} 的文本插值，如果你要用不常见的，那可用 <span v-text=""></span> 的方式。\n\n在 vue 中，带有 v- 前缀的特殊属性，称为指令。\n\n无论选择哪一个插值方式绑定到组件(html标签)上，在组件实例上的值发生了改变，插值处的内容都会更新，这便是数据驱动的方式。\n\n<!doctype html>\n<html>\n\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0核心语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="hello"> \n      <input id="name" v-model="msg" placeholder="输入文本内容" />\n      <p>用双大括号实现文本插值：{{ msg }}</p>\n      <p>用v-text指定实现插值：<span v-text="msg"></span></p>\n    </div>\n    <script>\n        // 第1步：data数据；\n        // 第2步：vue实例，\n        // 第3步：绑定元素     \n        vue.createapp({\n            data() {\n                return { msg: \'\' }\n            }\n        }).mount("#hello") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 2 原始 html\n\n在开发过程中，有时会输出有格式的动态内容，比如输出带颜色文本。如果用插值的方式，输出的为文本内容，显然满足不了要求。这时就要用到 v-html 指令了。\n\n温馨提醒：原始 html，尽量不要用在输入上，因为它很容易导致 xss 攻击。\n\nxss 攻击通常指的是：通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页中。\n\n<!doctype html>\n<html>\n  \n  <head>\n    <meta charset="utf-8">\n    <title>vue3.0核心语法</title>\n    <script src="vue.global.js"><\/script>\n  </head>\n  \n  <body>\n    <div id="vh">\n      <p>文本插值结果: {{ msg }}</p>\n      <p>原始html结果: <span v-html="msg"></span></p>\n    </div>\n    <script>\n      // 第1步：data数据；\n      // 第2步：vue实例，\n      // 第3步：绑定元素     \n      vue.createapp({\n        data() {\n          return {\n            msg: \'<span style="color: red">vue.js 3.0</span>\'\n          }\n        }\n      }).mount("#vh") \n    <\/script>\n  </body>\n  \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 3 属性绑定\n\n在 vue 中，\n\n * 对 html 属性的绑定，采用 v-bind(可缩写为":")指令，\n * 对事件的绑定，采用 v-on(可缩写为"@")指令。\n\n这里说下 v-bind 的应用，v-on 在讲事件时再细讲。\n\n你可能会奇怪，绑定属性有什么用？我随便举一个例子，你就秒懂了。\n\n当美女程序员看我的文章时，系统就给她推荐有漂亮图表的文章链接地址；当男性程序员看我的文章时，系统就给推荐有漂亮mm的文章链接地址，以此来提高阅读量。\n\n\x3c!-- 完整语法 --\x3e <a v-bind:href="url"> ... </a>\n\n\x3c!-- 缩写 --\x3e <a :href="url"> ... </a>\n\n<!doctype html>\n<html>\n  \n  <head>\n    <meta charset="utf-8">\n    <title>vue3.0核心语法</title>\n    <script src="vue.global.js"><\/script>\n  </head>\n  \n  <body>\n    <div id="vh">\n      <p>文本插值结果: {{ msg }}</p>\n      <p>原始html结果: <span v-html="msg" ></span></p>\n      <a :href="site">跳转</a>\n    </div>\n    <script>\n      // 第1步：data数据；\n      // 第2步：vue实例，\n      // 第3步：绑定元素     \n      vue.createapp({\n        data() {\n          return {\n            msg: \'<span style="color: red">vue.js 3.0</span>\',\n            site: \'http://www.sohu.com\'\n          }\n        }\n      }).mount("#vh") \n    <\/script>\n  </body>\n  \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 条件渲染和 template\n\n所谓的条件，指的就是满足什么条件，允许做什么事，不满足时，是不允许做的。如共享单车，规定满 12 周岁或以上才可以骑行，没满的则不被允许。学每门编程语言，条件语句都是必须熟练掌握的，vue3.0 的也不例外。\n\n\n# 1 v-if 指令\n\n在 vue3.0 中，条件语句是通过 v-if 指令实现的。\n\n如果判断条件为 true，就执行 v-if 语句里的内容，否则什么都不执行。\n\n<!doctype html>\n<html>\n\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="app">\n        <h1 v-if=\'cool\'>前端编程</h1>\n    </div>\n    <script>\n        vue.createapp({\n            data() {\n                return { cool: true }\n            }\n        }).mount("#app") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n如果 v-if 为 false 时，你不想输出空气，不想什么都不执行，那就其后面加上 v-else 指令。\n\nv-if 和 v-else 搭在一起使用，规则是：v-if 的条件为 true 时，执行 v-if 里的内容，否则执行 v-else 里的。\n\n<!doctype html>\n<html>\n\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="app">\n        <h1 v-if=\'cool\'>前端编程</h1>\n        <h1 v-else>不学前端，还可以学后端嘛</h1>\n    </div>\n    <script>\n        vue.createapp({\n            data() {\n                return { cool: false }\n            }\n        }).mount("#app") <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<!doctype html>\n<html>\n\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="app">\n        <h1 v-if="program === \'vue3.0\'">vue3.0 很酷，很酷 </h1>\n        <h1 v-else-if="program === \'前端\'">前端，很酷</h1>\n        <h1 v-else-if="program === \'java\'">java，很酷</h1>\n        <h1 v-else-if="program === \'app\'">app，很酷</h1>\n        <h1 v-else>python，也酷</h1>\n    </div>\n    <script>\n        vue.createapp({\n            data() {\n                return {\n                    program: \'vue3.0\'\n                }\n            }\n        }).mount("#app") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 2 template\n\n长得有点(不是特别)酷的你，可能早就注意到了，v-if 指令，都是附加在一个元素上的；\n\n> 如果想要实现切换多个元素，该如何？\n\n可以将 v-if 放在 <template> 元素中。\n\n<!doctype html>\n<html>\n\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n</head>\n\n<body>\n    <div id="app">\n        <template v-if="show">\n            <h1>编程</h1>\n            <p>编程都用啥工具<br />\n                工具不重要，重要的是思想<br />\n                python，前端(小程序)、java和app 都是工具<br />\n                用啥都可以好程序</p>\n        </template>\n    </div>\n    <script>\n        vue.createapp({\n            data() {\n                return {\n                    show: true\n                }\n            }\n        }).mount("#app") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3 v-show 指令\n\n * 如果你要实现业务方面的条件判断，用 v-if 指令就可以了；\n * 如果只是想切换一下 css 的内容，那你可以用 v-show 指令。\n\nv-show 只是简单地切换元素的 css 属性值，不支持 v-else，也不支持 <template> 元素，它常用于隐藏或显示某个元素。\n\n<!doctype html>\n<html>\n\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0条件语法</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .show {\n            margin-top: 20px;\n            width: 600px;\n            height: 50px;\n            background: darkcyan;\n        }\n    </style>\n</head>\n\n<body>\n    <div id="app">\n        <input type="button" value="按下就报幕" v-on:click="show"> <br />\n        <div class="show" v-show="report">报幕~~~</div>\n    </div>\n    <script>\n        vue.createapp({\n            data() {\n                return {\n                    report: false\n                }\n            },\n            methods: {\n                show() {\n                    this.report = true;\n                }\n            }\n        }).mount("#app") \n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 循环渲染\n\n开发一个web系统，如果没有涉及到列表功能的话，那真的有点奇葩了，而循环输出列表内容，不用for循环语句的话，那我真不知道该用什么了。在vue3.0中，v-for指令基于一个数组来渲染输出一个列表内容。\n\n\n# 1 v-for 输出项\n\nvue 的 v-for 指令使用 item in items 形式的特殊语法，同其他编程语言(如python)并没有多大区别。\n\n其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0循环语法</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .lang {\n            border: 1px solid darkcyan;\n            width: 600px;\n            height: 200px;\n        }\n    </style>\n</head>\n<body>\n<div class="lang">\n    vue.js 3.0 系列教程\n    <ol id="program">\n        <li v-for="item in items">\n            {{ item.lang }}\n        </li>\n    </ol>\n</div>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                items: [{lang: \'python\'}, {lang: \'前端\'},\n                    {lang: \'vue3.0\'}, {lang: \'koa2\'},\n                    {lang: \'java\'}, {lang: \'app\'}]\n            }\n        }\n    }).mount("#program")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 2 索引和值\n\n数据列表在表格输出时，常常需要用到序号。\n\nv-for 指令支持输出下标，将下标+1，即可获得序号。\n\n为了更接近 javascript 迭代器的语法，vue3.0 支持用 of 替代 in 作为分隔。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0循环语法</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        h1 {\n            text-align: center;\n        }\n\n        table {\n            width: 600px;\n            margin: 0 auto;\n            text-align: center;\n            height: 200px;\n        }\n\n        td, th {\n            border: 1px solid #bcbcbc;\n            padding: 5px 10px;\n        }\n\n        th {\n            background: #42b983;\n            font-size: 1.2rem;\n            font-weight: 400;\n            color: #fff;\n            cursor: pointer;\n        }\n\n        tr:nth-of-type(odd) {\n            background: #fff;\n        }\n\n        tr:nth-of-type(even) {\n            background: #eee;\n        }\n    </style>\n</head>\n<body>\n<h1>vue.js 3.0 系列教程</h1>\n<table id="program">\n    <thead>\n    <tr>\n        <th>序号</th>\n        <th>编程语言</th>\n        <th>备注</th>\n    </tr>\n    </thead>\n    <tr v-for="(item,index) of items">\n        <td>{{ index + 1 }}</td>\n        <td>{{ item.lang }}</td>\n        <td>{{ item.remark }}</td>\n    </tr>\n</table>\n\n<script>\n    vue.createapp({\n        data() {\n            return {\n                items: [\n                    {lang: \'python\', remark: \'入门、数据分析、爬虫\'},\n                    {lang: \'前端\', remark: \'网页三贱客\'},\n                    {lang: \'vue3.0\', remark: \'能在项目中应用\'},\n                    {lang: \'koa2\', remark: \'企业实战项目\'},\n                    {lang: \'java\', remark: \'从0开始入门\'},\n                    {lang: \'app\', remark: \'安卓和ios等开发\'}]\n            }\n        }\n    }).mount("#program")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 3 v-for 和 v-if\n\n由于当 v-if 和 v-for 处于同一节点时，v-if 的优先级比 v-for 更高，这意味着 v-if 将没有权限访问 v-for 里的变量，就是说不可以将 v-if 和 v-for 放在同一个元素里。\n\n\x3c!-- v-for 和 v-if 不可以放在同一个元素内 --\x3e\n<li v-for="item in items" v-if="item==true">\n    {{ good }}\n</li>\n\n\n1\n2\n3\n4\n\n\n> 为了解决 v-for 和 v-if 同一水平的问题，你可以把 v-for 移动到 <template> 标签中进行修正。就是将 v-if 放到 v-for 内部去的意思。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0循环语法</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        h1 {\n            text-align: center;\n            color: darkorange;\n        }\n\n        table {\n            width: 600px;\n            margin: 0 auto;\n            text-align: center;\n            height: 200px;\n        }\n\n        td, th {\n            border: 1px solid #bcbcbc;\n            padding: 5px 10px;\n        }\n\n        th {\n            background: #42b983;\n            font-size: 1.2rem;\n            font-weight: 400;\n            color: #fff;\n            cursor: pointer;\n        }\n\n        tr:nth-of-type(odd) {\n            background: #fff;\n        }\n\n        tr:nth-of-type(even) {\n            background: #eee;\n        }\n    </style>\n</head>\n<body>\n<h1>vue.js 3.0 系列教程</h1>\n<table id="program">\n    <thead>\n    <tr>\n        <th>序号</th>\n        <th>编程语言</th>\n        <th>完成情况</th>\n    </tr>\n    </thead>\n    <template v-for="(item,index) in items">\n        <tr>\n            <td>\n                {{ index + 1 }}\n            </td>\n            <td>\n                {{ item.lang }}\n            </td>\n            <td>\n                <span v-if="item.todo==1">\n                    已完成\n                </span>\n                <span v-else-if="item.todo==2">\n                 进行中\n                </span>\n                <span v-else>\n                   将启动\n                </span>\n            </td>\n        </tr>\n    </template>\n</table>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                items: [\n                    {lang: \'python\', todo: 1,},\n                    {lang: \'前端\', todo: 1},\n                    {lang: \'vue3.0\', todo: 2},\n                    {lang: \'koa2\', todo: 3},\n                    {lang: \'java\', todo: 3},\n                    {lang: \'app\', todo: 3}]\n            }\n        }\n    }).mount("#program")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n\n# 样式绑定\n\n为了方便 css 对页面的美化，vue3.0 特意提供了操作元素的 class 和内联样式的指令。\n\n因为它们都是元素，所以我们可以用 v-bind(属性绑定) 进行处理。\n\n由于字符串拼接麻烦且易错，所有 vue3.0 在 v-bind 用于 class 和 style 时，做了专门的增强，表达式结果的类型除了字符串之外，还可以是对象或数组。\n\n\n# 1 class 指令\n\nvue 用 v-bind:class(简写为:class)指令，用于解决动态切换 class 的需求。\n\n如果你不清楚用在什么哪方面的需求，就想一下提示信息的应用，在错误发生时，用红色字体，否则用绿色。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0 class指令</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .b {\n            font-weight: bold;\n        }\n\n        .error {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n<span id="app">\n<h1 class="b" :class="{ \'error\': haserror }">红色字体，好看么？</h1>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                haserror: true\n            }\n        }\n    }).mount("#app") // 挂载后成为组件\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n渲染结果(生成的代码)\n\n<h1 class="b error">红色字体，好看么？</h1>\n\n\n1\n\n\n> 思考：如何通过单击按钮来切换颜色？\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0 class指令</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .b {\n            font-weight: bold;\n        }\n\n        .error {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n<span id="app">\n    <button @click="change">改变颜色</button>\n\t  <h1 class="b" :class="{ \'error\': haserror }">红色字体，好看么？</h1>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                haserror: true\n            }\n        },\n        methods:{\n            change(){\n                this.haserror = !this.haserror\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n> 如果你想同时满足多个 class，你可以用 class 的数组语法。这个语法，可读性更强一些。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0 class指令</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .b {\n            font-weight: bold;\n        }\n\n        .big-text {\n            font-size: 60px;\n        }\n\n        .error {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n<span id="app">\n<p class="b" :class="[fontsize, errorinfo]">\n    程序员<br/>\n    除了会编程之外，还会什么？<br/>\n    当然是敲代码了。\n</p>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                fontsize: \'big-text\',\n                errorinfo: \'error\'\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n渲染结果(生成的代码)\n\n<span id="app"><p class="b big-text error"> 程序员<br> \n  除了会编程之外，还会什么？<br> 当然是敲代码了。 </p></span>\n\n\n1\n2\n\n\n> 你可以用三元表达式，根据条件切换列表中的 class。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0 class指令</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .b {\n            font-weight: bold;\n            font-size: 50px;\n        }\n\n        .yes {\n            color: #008cba;\n        }\n\n        .no {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n<span id="app">\n<p class="b" :class="[iscool ? \'yes\' :\'no\']">\n    蓝色字体才好看。\n</p>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                iscool: true\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 2 内联样式\n\n在 html 中，在元素上用 style 的话，结果是不可改变的，为此 vue3.0 加上了:style 指令。\n\n注意，你别看这个指令看起来十分直观，看着非常像 css，但其实是一个 javascript 对象来的。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0 style指令</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<span id="app">\n<p :style="{ color: textcolor, fontsize: fontsize + \'px\' }">\n    程序员，都忙得跟狗一样，哈哈~\n</p>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                textcolor: \'#008cba\',\n                fontsize: 50\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 你可以用样式对象的方式。这样的写法，是不是更舒服了一些，输出结果和上面是一模一样的。\n\n<span id="app">\n<p :style="styleoj">\n    程序员，都忙得跟狗一样都忙得跟狗一样，哈哈~\n</p>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                styleoj: {\n                    color: \'#008cba\',\n                    fontsize: \'50px\'\n                }\n            }\n        }\n    }).mount("#app")\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 既然 class 可以用数组语法，:style 当然也可以。\n\n:style 的数组语法可以将多个样式对象应用到同一个元素上。输出结果和上面的还是一样的。\n\n<span id="app">\n<p :style="[textcolor, fontsize]">\n    程序员，都忙得跟狗一样，哈哈~\n</p>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                textcolor: {\n                    color: \'#008cba\',\n                },\n                fontsize: {\n                    \'font-size\': \'50px\'\n                }\n            }\n        }\n    }).mount("#app")\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 计算属性\n\n在如今编程都提出 mvc、mvp 或 mvvm 等模式的情况下，已经很少再将业务逻辑和视图层合在一起。\n\n在 vue3.0 中，在 html(相当于视图层)插值方式是可以负责计算(相当于业务逻辑)，但不提倡你这么用，因为 vue3.0 有计算属性。\n\n\n# 1 计算属性\n\n将计算放置在模板中，模板将不再是简单的和声明性的，此时，你必须先看一下它，然后才能意识到它执行的计算取决于 chen.lang。如果要在模板中多次包含此计算，则问题会变得更糟。\n\n所以，对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性，听到了没？如果没有的话，那就看看代码吧。计算属性放在 computed 里面，函数放在 methods 里面。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<span id="app">\n    <span>在插值中计算的结果：{{ chen.lang.length > 10 ? \'太多了\' : \'还好\' }}\n    </span>\n    <br/>\n    <span>获取计算属性的结果：{{ langcount }}</span>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                chen: {\n                    name: \'it界老家伙\',\n                    lang: [\n                        \'python\',\n                        \'前端\',\n                        \'小程序\',\n                        \'java\',\n                        \'android app\',\n                        \'ios app\'\n                    ]\n                }\n            }\n        },\n        computed: {\n            // 计算属性的 getter\n            langcount() {\n                return this.chen.lang.length > 10 ? \'太多了\' : \'还好\'\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n细心的朋友，可能就会问了，那我用函数计算行不行。如果不考虑性能的话，当然可以的。只是函数和计算属性的区别在于，计算属性有缓存的作用，而函数没有。\n\n在操作过程中，如果内容没有改变，计算属性不会重新计算，而函数每次都会进行计算。用函数计算的代码，我发出来，你自己拷贝进去就好。\n\n \x3c!--  新增函数计算部分  --\x3e\n    <br/>\n    <span>函数计算属性的结果：{{ langfun() }}</span>\n,\n        methods: {\n            // 函数中\n            langfun() {\n                return this.chen.lang.length > 10 ? \'太多了\' : \'还好\'\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2 计算属性的 setter\n\n计算属性默认只有 getter，如果你想要一个 setter 的话，手动加上就好。\n\n在函数里更新计算属性数据时，会调用 setter。你可以在 setter 里进行调整。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n<span id="app">\n<p>{{ fullname }}</p>\n<p>{{ firstname }}</p>\n<p>{{ lastname }}</p>\n<button @click="sayhello()">点击调用set方法</button>\n</span>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                firstname: \'程\',\n                lastname: \'绪媛\'\n            }\n        },\n\n        computed: {\n            // 计算属性\n            fullname: {\n                //getter\n                get() {\n                    return this.firstname + \'\' + this.lastname\n                },\n                //setter\n                set(newvalue) {\n                    const names = newvalue.split(\'或\')\n                    this.firstname = names[0]\n                    this.lastname = \'没有\' + names[names.length - 1]\n                }\n            }\n        },\n        methods: {\n            // sayhello: function() {\n            //     this.fullname = \'程绪媛\'\n            // }\n            sayhello() {\n                this.fullname = \'程绪媛\'\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n> 运行结果\n\n\n\n> 点击调用 set 方法后\n\n\n\n\n# 事件处理\n\n在 javascript 语言中，当用户与 ui 组件交互时，ui 组件能够激发一个相应事件。例如，用户按动按钮、滚动文本、移动鼠标或按下按键等，都将产生一个相应的事件。\n\nvue3.0 使用 v-on 指令(缩写为 @ 符号)来监听 dom 事件，并在触发事件时执行一些 javascript 函数。\n\n语法为 v-on:click="函数名" 或 @click="函数名"。\n\n\n# 1 事件处理\n\n如果你有看过前面的章节，应该知道响应用户操作事件的函数是放在 methods 里面的。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<span id="app">\n<button @click="say">说点什么</button>\n</span>\n<script>\n    vue.createapp({\n        data() {\n        },\n\n        methods: {\n            say() {\n               alert("艾边成，真酷!")\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 2 传递参数\n\nvue 事件绑定，除了支持直接绑定到一个方法外，也可以在内联 javascript 语句中调用方法。说白了，就是可以直接在函数中传递参数。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<span id="app">\n<button @click="say(\'老陈说\')">老陈说</button>\n<br/><br/>\n<button @click="say(\'老头说\')">老头说</button>\n</span>\n<script>\n    vue.createapp({\n        data() {\n        },\n\n        methods: {\n            say(title) {\n                alert(title + "，爱编程的人真酷!")\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 3 事件来源\n\n如果界面上有多个按钮或表单，你想根据用户的不同操作，响应不同的事件，这时你可以通过监听事件源的方式进行处理。\n\n在软件系统中，我们常常见到的打开、保存、导出、打印等多个按钮在同一个功能菜单时，就可以用这种方式。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .menu {\n            border: 1px solid darkgreen;\n            width: 100px;\n            height: 150px;\n            padding-top: 20px;\n            padding-left: 20px;\n        }\n    </style>\n</head>\n<body>\n<div class="menu" id="app">\n    <button name="save" @click="opt">保存</button>\n    <br/> <br/>\n    <button name="open" @click="opt">打开</button>\n    <br/> <br/>\n    <button name="print" @click="opt">打印</button>\n</div>\n<script>\n    vue.createapp({\n        data() {\n        },\n        methods: {\n            opt(event) {\n                let opt = event.target.name\n                let src = event.target.tagname\n                alert(\'知道你点了 \' + opt + \' \' \n                      + src + \',我马上处理.\')\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n输出结果：\n\n\n\n细心的人，可能会想到，如果想要监听事件源，又想要传递参数时，vue 又当如何处理，不要急，你想到的，我也想到了，vue 创始人也想到了。\n\n传递参数时，将 $event 参数也传过去就好了。\n\n<div class="menu" id="app">\n    <button name="save" @click="opt(\'保存\',$event)">保存</button>\n    <br/> <br/>\n    <button name="open" @click="opt(\'打开\',$event)">打开</button>\n    <br/> <br/>\n    <button name="print" @click="opt(\'打印\',$event)">打印</button>\n</div>\n<script>\n    vue.createapp({\n        data() {\n        },\n        methods: {\n            opt(name, event) {\n                let opt = event.target.name\n                let src = event.target.tagname\n                alert(\'知道你点了 \' + opt + \'(\' + name + \') \'\n                    + src + \',我马上处理.\')\n            }\n        },\n    }).mount("#app")\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n输出结果为：\n\n\n\n\n# 4 多事件处理\n\n一个操作，多个函数响应，这便是多事件也。在 vue3.0 中，这些函数都放在 @click 里并用逗号分隔即可。\n\n这种处理方式，真的很赞，就像你转发分享这篇文章一样。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .menu {\n            border: 1px solid darkgreen;\n            width: 100px;\n            height: 150px;\n            padding-top: 20px;\n            padding-left: 20px;\n        }\n    </style>\n</head>\n<body>\n<div class="menu" id="app">\n    <button @click="add(6),sub(3)">加减</button>\n</div>\n<script>\n    let result = 0\n    vue.createapp({\n\n        data() {\n        },\n        methods: {\n            add(num) {\n                result += num\n            },\n            sub(num) {\n                result -= num\n                alert(\'结果是：\' + result) // 结果是：3\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 5 按键修饰符\n\n不知你在用键盘输入多项内容之后，是否有按下回车键的习惯，如果没有，那证明你打字很慢，如果有，那证明你不是程序员，而是打字员(哈哈~~,什么鬼逻辑)。\n\n在较完善的系统中，当用户按下回车键(或其他键)时，都会有响应的。为了解决这个问题，vue 允许为 v-on 或者 @ 在监听键盘事件时添加按键修饰符。\n\nvue 为最常用的键提供了 .enter(回车) 、.tab 、 .delete (捕获“删除”和“退格”键)、.esc(取消) 、.up(上)、.down(下)、.left(左)、.right(右)等。\n\n例如：@keyup.enter="submit"\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="vue.global.js"><\/script>\n    <style>\n        .menu {\n            border: 1px solid darkgreen;\n            width: 100px;\n            height: 150px;\n            padding-top: 20px;\n            padding-left: 20px;\n        }\n    </style>\n</head>\n<body>\n<div class="menu" id="app">\n    <button @keyup.enter="submit" @click="submit" type="submit">确定</button>\n</div>\n<script>\n    let result = 0\n    vue.createapp({\n        data() {\n        },\n        methods: {\n            submit() {\n                alert(\'你明明按下了回车键，别耍赖,赶紧分享文章\')\n            }\n        },\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 表单输入\n\n在 vue3.0 中，事件处理用 v-on 指令，表单输入绑定则用 v-model 指令。\n\nv-model 指令在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\n\n# 1 文本输入\n\n在 html 标签中，文本输入有单行(text)和多行(textarea)输入。\n\n温馨提醒: v-model 会忽略所有表单元素的 value 的初始值而总是将当前活动实例的数据作为数据来源。你应该通过 javascript 该组件的 data 选项中声明初始值。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0表单绑定</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<div id="app">\n    <input v-model="msg" placeholder="单行输入"/>\n    <p>单行输入结果: {{ msg }}</p>\n    <hr style="background-color: #4caf50;height: 1px"/>\n    <textarea v-model="msg2" placeholder="多行输入"></textarea>\n    <p>多行输入结果: {{ msg2 }}</p>\n</div>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                msg: \'\',\n                msg2: \'\'\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 1.1 文本框的 number 修饰符\n\ntemplate : `\n            <div>\n              {{message}}\n              <input v-model.number="message" type="number" />\n              <button @click="getmessage">获取文本内容</button>\n            </div>  \n        `\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在文本框元素中使用 v-model.number ，得到的结果是一个数字类型的值，而不是字符串。\n\n# 1.2 文本框的 trim 修饰符\n\ntemplate : `\n            <div>\n              {{message}}\n              <input v-model.trim="message" />\n              <button @click="getmessage">获取文本内容</button>\n            </div>  \n        `\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在文本框元素中使用 v-model.trim ，得到的结果会去掉两端的空格、tab、回车等特殊字符。\n\n\n# 2 复选框 checkbox\n\n在开发产品时，单个复选框常在勾选协议中见到。\n\n# 2.1 单个 checkbox 与数据绑定\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <input type="checkbox" v-model="checkboxflag" />checkbox<br>\n        <button @click="getcheckboxflag">获取checkbox设置</button>\n    </div>  \n\n<script>\n  const app = vue.createapp({     // 创建一个vue应用实例\n  data() {\n    return {\n      checkboxflag: true,\n    }\n  },\n  methods: {\n    getcheckboxflag() {\n       console.info(this.checkboxflag)\n    }\n  },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n当 checkbox 被选中时，值是 true，否则值是 false\n\n\n\n# 2.2 自定义单个 checkbox 的值\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <input type="checkbox" v-model="checkboxflag2" true-value="选中" false-value="未选中" />checkbox<br>\n        <button @click="getcheckboxflag2">获取checkbox设置</button>\n    </div>  \n<script>\n  const app = vue.createapp({     // 创建一个vue应用实例\n    data() {\n        return {\n            checkboxflag2: "选中",\n        }\n    },\n    methods : {\n        getcheckboxflag2() {\n        console.info(this.checkboxflag2)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n使用 true-value 和 false-value 自定义 checkbox 的值\n\n\n\n# 2.3 一组 checkbox 与数据绑定\n\n一组复选框，常在选择个人兴趣爱好等见到。复选框，单选时，绑定到布尔值，多选时，绑定到同一个数组。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <input type="checkbox" v-model="checkboxarr" value="football" />足球<br>\n        <input type="checkbox" v-model="checkboxarr" value="basketball" />篮球<br>\n        <input type="checkbox" v-model="checkboxarr" value="tabletennis" />乒乓球<br>\n        <button @click="getcheckboxarr">获取checkbox设置</button>\n    </div>  \n<script>\n  const app = vue.createapp({     // 创建一个vue应用实例\n    data() {\n        return {\n            checkboxarr: [],\n        }\n    },\n    methods : {\n        getcheckboxarr() {\n            console.info(this.checkboxarr)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n一组 checkbox 与同一个数据 checkboxarr 绑定，得到的结果是一个数组\n\n\n\n\n# 3 单选框（radio）\n\n在开发产品时，单选按钮，用于多选一，在选择性别时常见。\n\n# 3.1 一组 radio 与数据绑定\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <input type="radio" v-model="radiovalue" value="football" />足球<br>\n        <input type="radio" v-model="radiovalue" value="basketball" />篮球<br>\n        <input type="radio" v-model="radiovalue" value="tabletennis" />乒乓球<br>\n        <button @click="getradiovalue">获取radio设置</button>\n    </div>  \n<script>\n  const app = vue.createapp({     // 创建一个vue应用实例\n    data() {\n        return {\n            radiovalue: "tabletennis",\n         }\n    },\n    methods : {\n        getradiovalue() {\n            console.info(this.radiovalue)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nradio 是单选（只能选择其中的一个），因此得到的值是一个 字符串\n\n\n\n\n# 4 select\n\n如果选择项很多，那可用多选下拉菜单 select，以节约布局空间。\n\n# 4.1 select 与数据绑定\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <select v-model="selectvalue">\n            <option value="football">足球</option>\n            <option value="basketball">篮球</option>\n            <option value="tabletennis">乒乓球</option>\n        </select>\n        <br>\n        <button @click="getradiovalue">获取select设置</button>\n    </div>  \n<script>\n  const app = vue.createapp({     // 创建一个vue应用实例\n    data() {\n        return {\n            selectvalue: "",\n        }\n    },\n    methods : {\n        getradiovalue() {\n            alert(this.selectvalue)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在 select 标签上使用 v-model 绑定数据 selectvalue\n\n\n\n# 4.2 select 的选项从数据获得\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <select v-model="selectvalue">\n            <option v-for="item in selectoptionarr" :value="item.value">{{item.text}}</option>\n        </select>\n        <br>\n        <button @click="getselectvalue">获取select设置</button>\n    </div>  \n<script>\n  const app = vue.createapp({     // 创建一个vue应用实例\n    data() {\n        return {\n            selectoptionarr: [\n                {text: "足球", value: "football"}, \n                {text: "篮球", value: "basketball"}, \n                {text: "乒乓球", value: "tabletennis"}\n            ],\n        }\n    },\n    methods : {\n        getselectvalue() {\n            alert(this.selectvalue)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n使用 v-for 得到 option 元素，运用数组的形式，效果和上一小节一致。\n\n# 4.3 select 的返回对象\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0计算属性</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n</head>\n<body>\n    <div id="app">\n        <select v-model="selectvalue">\n            <option v-for="item in selectoptionarr2" :value="item.value">{{item.text}}</option>\n        </select>\n        <br>\n        <button @click="getselectvalue">获取select设置</button>\n    </div>  \n<script>\n  const app = vue.createapp({     // 创建一个vue应用实例\n    data() {\n        return {\n            selectoptionarr2: [\n                {text: "足球", value: {name:"football", text:"足球"}}, \n                {text: "篮球", value: {name:"basketball", text:"篮球"}}, \n                {text: "乒乓球", value: {name:"tabletennis", text:"乒乓球"}}\n            ],\n        }\n    },\n    methods : {\n        getselectvalue() {\n            console.info(this.selectvalue)\n        },\n    },\n  }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\noption 绑定的数据 selectoptionarr2 中，value 是一个对象。这样 select 的返回值就是对应的对象。\n\n\n\n\n# vue3 小项目实战\n\n用所学过的 vue3.0 双大括号文本插值、条件、循环渲染指令、表单数据双向绑定、计算属性和事件响应等相关知识，来开发一个小项目，以此达到技术总结的意义。\n\n\n# 1 产品列表\n\n * 页面布局，用纯天然的 html+css 就好了。\n * 用插值和计算属性，输出产品总数量。\n * 用 v-for 循环渲染，输出产品信息。\n * 用 v-if 判断产品规格是否为空。\n * 用 v-on(缩写 @)进行事件绑定。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0小项目实战</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n    <style>\n        h1 {\n            text-align: center;\n            color: darkorange;\n            margin-top: 30px;\n        }\n\n        .counter {\n            text-align: center;\n            margin-bottom: 5px;\n        }\n\n\n        table {\n            width: 800px;\n            margin: 0 auto;\n            text-align: center;\n        }\n\n        td, th {\n            border: 1px solid #bcbcbc;\n            padding: 5px 10px;\n        }\n\n        th {\n            background: #42b983;\n            font-size: 1.2rem;\n            font-weight: 400;\n            color: #fff;\n            cursor: pointer;\n        }\n\n        tr:nth-of-type(odd) {\n            background: #fff;\n        }\n\n        tr:nth-of-type(even) {\n            background: #eee;\n        }\n\n        .del {\n            color: red;\n        }\n\n        input {\n            border: 1px solid darkcyan;\n            line-height: 25px;\n            width: 200px;\n            color: #000;\n            font-weight: bold;\n            margin-top: 5px;\n            margin-left: 10px;\n        }\n    </style>\n</head>\n<body>\n<div id="app">\n    <h1>产品信息列表</h1>\n    <div class="counter">共有<strong>{{ counter }}</strong>件产品</div>\n    <table>\n        <thead>\n        <tr>\n            <th>序号</th>\n            <th>名称</th>\n            <th>型号</th>\n            <th>规格</th>\n            <th>操作</th>\n        </tr>\n        </thead>\n        <template v-for="(product,index) in products" :key="index">\n            <tr>\n                <td>\n                    {{ index + 1 }}\n                </td>\n                <td>\n                    {{ product.name }}\n                </td>\n                <td>\n                    {{ product.type }}\n                </td>\n                <td>\n                <span v-if="product.desc==\'\'">\n                 未填写规格\n                </span>\n                <span v-else>\n                   {{ product.desc }}\n                </span>\n                </td>\n                <td>\n                    <button class="del" @click=\'del(index)\'>删除</button>\n                </td>\n            </tr>\n        </template>\n    </table>\n</div>\n<script>\n    // const { createapp } = vue\n    // createapp({...})\n    vue.createapp({\n        data() {\n            return {\n                product: {\n                    name: \'\',\n                    type: \'\',\n                    desc: \'\',\n                },\n                products: [\n                    {name: \'安卓手机\', type: \'az321\', desc: \'6.8寸\'},\n                    {name: \'苹果手机\', type: \'pg222\', desc: \'4.8寸\'},\n                    {name: \'安卓平板\', type: \'pb666\', desc: \'9.8寸\'},\n                    {name: \'二手电视\', type: \'er659\', desc: \'12寸\'},\n                    {name: \'洗衣机\', type: \'xy872\', desc: \'9.8斤\'}\n                ]\n            }\n        },\n        computed: {\n            counter() {\n                return this.products.length\n            }\n        },\n\n        methods: {\n            //删除数据\n            del(index) {\n                this.products.splice(index, 1)\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n\n\n\n# 2 新增产品\n\n在新增表单布局代码，实现新增产品功能的布局。\n\n * 用 v-model 指令，进行表单数据双向绑定；\n * 用 v-on(缩写@)进行事件绑定。\n * 在 method 里面添加 add 函数，进行表单是否为空校验，不通过就进行提示，通过就将信息添加到产品信息列表中。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0小项目实战</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n    <style>\n        h1 {\n            text-align: center;\n            color: darkorange;\n            margin-top: 30px;\n        }\n\n        .counter {\n            text-align: center;\n            margin-bottom: 5px;\n        }\n\n\n        table {\n            width: 800px;\n            margin: 0 auto;\n            text-align: center;\n        }\n\n        td, th {\n            border: 1px solid #bcbcbc;\n            padding: 5px 10px;\n        }\n\n        th {\n            background: #42b983;\n            font-size: 1.2rem;\n            font-weight: 400;\n            color: #fff;\n            cursor: pointer;\n        }\n\n        tr:nth-of-type(odd) {\n            background: #fff;\n        }\n\n        tr:nth-of-type(even) {\n            background: #eee;\n        }\n\n        .del {\n            color: red;\n        }\n\n        input {\n            border: 1px solid darkcyan;\n            line-height: 25px;\n            width: 200px;\n            color: #000;\n            font-weight: bold;\n            margin-top: 5px;\n            margin-left: 10px;\n        }\n\n        .add {\n            width: 800px;\n            margin: 0 auto;\n            text-align: center;\n        }\n\n        .addbtn {\n            background-color: #4caf50; /* green */\n            border: none;\n            color: white;\n            padding: 8px 32px;\n            font-size: 16px;\n            margin-right: 10px;\n        }\n    </style>\n</head>\n<body>\n<div id="app">\n    <h1>产品信息列表</h1>\n    <div class="counter">共有<strong>{{ counter }}</strong>件产品</div>\n    <table>\n        <thead>\n        <tr>\n            <th>序号</th>\n            <th>名称</th>\n            <th>型号</th>\n            <th>规格</th>\n            <th>操作</th>\n        </tr>\n        </thead>\n        <template v-for="(product,index) in products" :key="index">\n            <tr>\n                <td>\n                    {{ index + 1 }}\n                </td>\n                <td>\n                    {{ product.name }}\n                </td>\n                <td>\n                    {{ product.type }}\n                </td>\n                <td>\n                <span v-if="product.desc==\'\'">\n                 未填写规格\n                </span>\n                <span v-else>\n                   {{ product.desc }}\n                </span>\n                </td>\n                <td>\n                    <button class="del" @click=\'del(index)\'>删除</button>\n                </td>\n            </tr>\n        </template>\n    </table>\n    <div class="add">\n        <h1>新增产品信息</h1>\n        <div style="margin-left: 10px">\n            名称:<input name="name" type="text" v-model="product.name"\n                      placeholder="请输入产品名称"/><br/>\n            型号:<input name="type" type="text" v-model="product.type"\n                      placeholder="请输入产品型号"/><br/>\n            规格:<input name="desc" type="text" v-model="product.desc"\n                      placeholder="请输入产品规格"/>\n        </div>\n        <br/>\n        <button class="addbtn" type="submit" @click="add()">提交</button>\n    </div>\n</div>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                product: {\n                    name: \'\',\n                    type: \'\',\n                    desc: \'\',\n                },\n                products: [\n                    {name: \'安卓手机\', type: \'az321\', desc: \'6.8寸\'},\n                    {name: \'苹果手机\', type: \'pg222\', desc: \'4.8寸\'},\n                    {name: \'安卓平板\', type: \'pb666\', desc: \'9.8寸\'},\n                    {name: \'二手电视\', type: \'er659\', desc: \'12寸\'},\n                    {name: \'洗衣机\', type: \'xy872\', desc: \'9.8斤\'}\n                ]\n            }\n        },\n        computed: {\n            counter() {\n                return this.products.length\n            }\n        },\n\n        methods: {\n            // 删除数据\n            del(index) {\n                this.products.splice(index, 1)\n            },\n            // 添加数据\n            add() {\n                if (this.product.name.trim() == \'\') {\n                    alert(\'产品名称不可为空，请输入.\')\n                } else if (this.product.type.trim() == \'\') {\n                    alert(\'产品型号不可为空，请输入.\')\n                } else {\n                    this.products.push(this.product)\n                    this.product = {}\n                }\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n\n\n运行结果为：\n\n\n\n\n# 自定义组件\n\n在一个页面中，如果有代码重复的内容，那你可以将其抽出来，用 vue 注册成局部组件；在一个 web 系统中，如果有多个页面有共同的代码，那你可以将其抽出来，用 vue 注册成全局组件。\n\n组件可以扩展 html 元素，封装可重用的代码。让我们可以用独立可复用的小组件来构建大型应用。\n\n其实，如果你用第三方现成的组件库的话，自定义组件，用得很少，甚至不用，但这是一个知识点，还是学一下比较好。\n\n\n# 1 局部注册\n\n在一个页面中，将其重复的内容抽出来，注册成组件，比如 <demo>。在需要用的地方直接引进 <demo></demo> 这个组件即可，以此来达到复用的目标。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0组件注册</title>\n    <script src="vue.global.js"><\/script>\n</head>\n<body>\n<div id="app">\n    <demo></demo>\n    好多内容啊.........<br/>\n    <demo></demo>\n</div>\n<script>\n    // 创建一个vue 应用\n    const app = vue.createapp({})\n    \n    // 定义一个名为 demo 的新页面组件\n    app.component(\'demo\', {\n        data() {\n            return {\n                lang: "vue3.0"\n            }\n        },\n        template: `<span style="color: darkgreen">\n        编程语言：{{ lang }}</span><br/>`\n    })\n    app.mount(\'#app\')\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n运行结果：\n\n\n\n\n# 2 全局注册\n\n如果在整个 web 系统中，有重复代码存在的话，那可以将共同的内容，放到一个 js 文件中。之后，在需要用到的页面进行引进即可。\n\nconst componenta = {\n    template: `<span style="color: darkgreen">编程哪家好？</span>\n        <p>\n          php是世上最好的语言。<br/>\n          c#说，问过我没有。<br/>\n          java路过，笑而不语。\n        </p>`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhtml 页面文件内容，注意引进 c.js 文件。\'lang\' -- <lang></lang>\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>vue3.0组件注册</title>\n    <script src="vue.global.js"><\/script>\n    <script src="c.js"><\/script>\n</head>\n<body>\n<div id="app">\n    <lang></lang>\n    <hr style="background-color:green;height: 1px"/>\n    <lang></lang>\n    <hr style="background-color:green;height: 1px"/>\n    <lang></lang>\n</div>\n<script>\n    const app = vue.createapp({\n        components: {\n            \'lang\': componenta\n        }\n    })\n    app.mount(\'#app\')\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n运行结果为：\n\n\n\n\n# 异步请求和侦听器\n\n在 web 技术栈中，异步请求是一直是神一样的存在。传统的网页不使用异步请求 (ajax) 如果需要更新内容，必须重载整个网页面，消耗性能不说，用户体验大大的差。\n\najax = 异步 javascript 和 xml，是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n由于 ajax 是开发 web 必备的，于是有人将其进行了封装，其中有一个和 vue3.0 配合最好的家伙，叫作 axios。\n\n\n# 1 axios 应用\n\n * 引入 axios，不用什么脚手架，也不用什么 cdn，直接去 https://github.com/axios/axios 下载。\n * 解压缩文件，找到 dist 文件夹，将 axios.min.js 文件放到和 html 文件相同的目录下即可。\n * 在要使用的页面中，加上 <script src="axios.min.js"><\/script> 就好了。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n    <script src="vue.global.js"><\/script>\n    <script src="https://unpkg.com/axios@1.4.0/dist/axios.min.js"><\/script>\n  \n</head>\n<body>\n<div id="app">\n    <p>{{ weather }}</p>\n    <button @click="getweather">获取成都天气信息</button>\n</div>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                weather: \'\'\n            }\n        },\n        methods: {\n            getweather() {\n                this.answer = \'获取数据中..\'\n                axios\n                    .get(\'http://wthrcdn.etouch.cn/weather_mini?city=成都\')\n                    .then(response => {\n                        this.weather = response.data\n                    })\n                    .catch(error => {\n                        this.weather = \'获取不到：\' + error\n                    })\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 2 侦听器\n\n在输入框输入数据时，有时候，你需要实时获取到用户输入的每一个字符，才好在后台进行相关处理，像搜索引擎就是这样的。\n\n在 vue3.0 中，侦听用户输入，使用 watch 方法。\n\n文本框输入一个广字，后台调用天气查询接口，这时有可能返回广州，也有可能返回广平等含有广字的城市的天气信息。当输入广州时，会再去查询一遍。侦听器一监听到有内容变化，就会去调用天气查询接口，再次查询数据。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n    <script src="vue.global.js"><\/script>\n    <script src="axios.min.js"><\/script>\n</head>\n<body>\n<div id="app">\n    <p>{{ weather }}</p>\n    <input v-model="city" placeholder="请输入城市名称"/>\n</div>\n<script>\n    vue.createapp({\n        data() {\n            return {\n                weather: \'\',\n                city: \'\'\n            }\n        },\n        watch: {\n            city(newcity, oldquestion) {\n                this.getweather()\n            }\n        },\n        methods: {\n            getweather() {\n                this.weather = \'查询\' + this.city + \'天气中..\'\n                axios\n                    .get(\'http://wthrcdn.etouch.cn/weather_mini?city=\' + this.city)\n                    .then(response => {\n                        this.weather = response.data\n                    })\n                    .catch(error => {\n                        this.weather = \'获取不到：\' + error\n                    })\n            }\n        }\n    }).mount("#app")\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 组件库 element+\n\n\n# 官网\n\n一个 vue 3 ui 框架 | element plus (element-plus.org)\n\nelement+ 是开源的前端组件库，有众多开发者在应用，是业界主流的 web 端组件库之一。它有多个高质量组件，覆盖前端各类场景。性能极佳。组件体积小，支持主题定制和国际化等常用功能。element+ 可以友好的支持 vue3.0。\n\n\n# 1 安装 element+\n\n虽然现在流行用 npm 命令、用所谓的脚手架创建项目，用命令行运行项目的方法，但我依然认为在学习阶段，应该怎么简单怎么来，最好不要在配置上浪费时间，消磨学习的兴趣。所以我推荐你直接用引入 css 和 js 的方式。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>elementplus组件库</title>\n    \x3c!-- import style 引入样式文件 --\x3e\n    <link rel="stylesheet" href="//unpkg.com/element-plus/dist/index.css" />\n    \x3c!-- import vue 3 --\x3e\n    \x3c!-- <script src="vue.global.js"><\/script> --\x3e\n    <script src="//unpkg.com/vue@3"><\/script>\n    \x3c!-- import component library 引入组件库 --\x3e\n    <script src="//unpkg.com/element-plus"><\/script>\n</head>\n<body>\n<div id="app">\n    <el-row>\n        <el-button>默认按钮</el-button>\n        <el-button type="primary">主要按钮</el-button>\n        <el-button type="success">成功按钮</el-button>\n        <el-button type="info">信息按钮</el-button>\n        <el-button type="warning">警告按钮</el-button>\n        <el-button type="danger">危险按钮</el-button>\n    </el-row>\n</div>\n<script>\n    const app = vue.createapp({});\n    app.use(elementplus);\n    app.mount("#app");\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 2 来点不一样的\n\n习惯了 html 的那些常规标签，总想找点不一样的，这下有了 element+，就可以实现了。我们来个不一样的选择标签，来个评分打星标签，再来一个物流进度时间线。\n\n<!doctype html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <title>elementplus组件库</title>\n    \x3c!-- import style --\x3e\n    <link rel="stylesheet" href="//unpkg.com/element-plus/dist/index.css" />\n    \x3c!-- import vue 3 --\x3e\n    <script src="vue.global.js"><\/script>\n    \x3c!-- import component library --\x3e\n    <script src="//unpkg.com/element-plus"><\/script>\n</head>\n<body>\n    <div id="app">\n        <el-switch v-model="v1" active-color="#13ce66" inactive-color="#ff4949">\n        </el-switch>\n        <hr /> \n        <el-rate v-model="v2"></el-rate>\n        <hr /> \n        <el-progress type="circle" :percentage="25"></el-progress>\n        <br /><hr /> \n        <el-timeline>\n            <el-timeline-item v-for="(activity, index) in activities" :key="index" :timestamp="activity.timestamp"\n                :color="activity.color">\n                {{activity.content}}\n            </el-timeline-item>\n        </el-timeline>\n    </div>\n    <script>\n        const app = vue.createapp({\n            data() {\n                return {\n                    v1: true,\n                    v2: \'\',\n                    activities: [{\n                        content: \'【城市】物流状态1\',\n                        timestamp: \'2020-10-10\',\n                        color: \'#0bbd87\'\n                    }, {\n                        content: \'【城市】物流状态2\',\n                        timestamp: \'2020-10-11\',\n                        color: \'#0bbd87\'\n                    }, {\n                        content: \'快件发货中\',\n                        timestamp: \'2020-10-12\'\n                    }]\n                }\n            }\n        });\n        app.use(elementplus);\n        app.mount("#app");\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n运行结果：\n\n\n\n\n# 电子地图\n\n在大数据时代，用电子地图展示数据的需求，已成为常规需求。\n\n其实，用电子地图，完全可以不用管 vue 的，直接用 javascript 就可以实现。\n\n\n# 1 获取 appkey\n\n 1. 用你的百度账号，登录到百度 api key 的申请地址 https://lbsyun.baidu.com/apiconsole/key/create\n 2. 登录成功后，如果没有直接导航到【创建应用】节点的话，就手动点击【创建应用】。(在控制台中)\n 3. 填写应用名称：sales，应用类型：浏览器端。启用服务：全部勾上。referer 白名单：填写半角*。\n 4. 填写好后，点击【提交】按钮。\n\n在返回的窗口中，会有 api key 这项内容，复制出来，保存在某个地方，稍后就会用到。\n\n\n# 2 电子地图\n\n代码里的 "你的key"，改成你申请到的。仔细阅读代码，你会发现，这里和 vue3.0 没半毛钱关系。\n\n实现一个功能，看需求文档的要求，如果根本就不需要到 vue3.0 的话，就不要硬用。好了，废话不多说，看代码吧。\n\n<!doctype html>\n<html lang="zh-cn">\n<head>\n    <meta charset="utf-8">\n    <title>地图展示</title>\n    <meta http-equiv="content-type" content="text/html; charset=utf-8">\n    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <style>\n        body,\n        html,\n        #container {\n            overflow: hidden;\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            font-family: "微软雅黑";\n        }\n    </style>\n    <script src="//api.map.baidu.com/api?type=webgl&v=1.0&ak=c3dltvxcgrwnrzfrg8qglhist2m87dfx">\n    <\/script>\n</head>\n<body>\n<div id="container"></div>\n</body>\n</html>\n<script>\n    var map = new bmapgl.map(\'container\');\n    map.centerandzoom(new bmapgl.point(102.54, 30.05), 12);\n    map.enablescrollwheelzoom(true);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n\n\n# 组合式 api\n\nvue 3 的组合式 api 是一种新的 api 风格，用于编写 vue 组件。\n\nvue 3 的组合式 api 基于函数式编程的思想，将组件的逻辑拆分为独立的功能单元，称为"组合函数"。这些组合函数可以通过 setup() 函数在组件中进行定义和使用。\n\n使用组合式 api，可以将组件的相关逻辑聚合在一起，而不是按照选项属性（如 data、methods、computed 等）进行划分。这样可以更好地组织和管理组件的代码，使代码更具可读性和可维护性。\n\n组合式 api 提供了以下几个主要的特性：\n\n 1. setup() 函数：在组件中使用 setup() 函数来定义组合函数和其他响应式数据。setup() 函数在组件创建之前执行，并且可以返回一个对象，该对象包含组合函数和其他数据。\n 2. 组合函数：组合函数是一种用于定义组件逻辑的函数。它可以包含数据、计算属性、方法等，并且可以使用 vue 提供的响应式 api（如 ref、reactive 等）来管理组件状态。\n 3. 生命周期钩子函数：vue 3 的组合式 api 引入了新的生命周期钩子函数，如 onmounted、onupdated、onunmounted 等，用于在不同的组合函数中执行特定的操作。\n 4. 自定义逻辑复用：通过将相关的组合函数提取为可复用的函数，可以在多个组件之间共享逻辑，并实现更好的代码复用性。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <title>vue 3 组合式 api 示例</title>\n    \x3c!-- <script src="https://unpkg.com/vue@next"><\/script> --\x3e\n    <script src="vue.global.js"><\/script>\n  </head>\n  <body>\n    <div id="app">\n      <p>当前计数值为：{{ count }}</p>\n      <button @click="increment">增加</button>\n      <button @click="decrement">减少</button>\n    </div>\n\n    <script>\n      const { ref } = vue;\n\n      const app = vue.createapp({\n        setup() {\n          // 使用 ref 定义 count 响应式数据\n          const count = ref(0);\n\n          // 定义增加计数的方法\n          function increment() {\n            count.value++;\n          }\n\n          // 定义减少计数的方法\n          function decrement() {\n            count.value--;\n          }\n\n          // 返回 count 和两个方法\n          return {\n            count,\n            increment,\n            decrement,\n          };\n        },\n      });\n\n      app.mount("#app");\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n',charsets:{cjk:!0}},{title:"HTML与CSS",frontmatter:{title:"HTML与CSS",date:"2023-07-07T00:20:34.000Z",permalink:"/pages/99897f/"},regularPath:"/09.%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/01.HTML%E4%B8%8ECSS.html",relativePath:"09.前端学习/01.HTML与CSS.md",key:"v-5d79f192",path:"/pages/99897f/",headers:[{level:2,title:"1. HTML 元素",slug:"_1-html-元素",normalizedTitle:"1. html 元素",charIndex:909},{level:2,title:"2. HTML 页面",slug:"_2-html-页面",normalizedTitle:"2. html 页面",charIndex:1361},{level:2,title:"3. 常见元素",slug:"_3-常见元素",normalizedTitle:"3. 常见元素",charIndex:1762},{level:3,title:"1) 文本",slug:"_1-文本",normalizedTitle:"1) 文本",charIndex:1774},{level:4,title:"Heading",slug:"heading",normalizedTitle:"heading",charIndex:1783},{level:4,title:"Paragraph",slug:"paragraph",normalizedTitle:"paragraph",charIndex:1894},{level:4,title:"List",slug:"list",normalizedTitle:"list",charIndex:1923},{level:4,title:"Anchor",slug:"anchor",normalizedTitle:"anchor",charIndex:2413},{level:3,title:"2) 多媒体",slug:"_2-多媒体",normalizedTitle:"2) 多媒体",charIndex:2462},{level:4,title:"Image",slug:"image",normalizedTitle:"image",charIndex:2472},{level:4,title:"Video",slug:"video",normalizedTitle:"video",charIndex:2622},{level:4,title:"Audio",slug:"audio",normalizedTitle:"audio",charIndex:2664},{level:3,title:"3) 表单",slug:"_3-表单",normalizedTitle:"3) 表单",charIndex:2707},{level:4,title:"作用与语法",slug:"作用与语法",normalizedTitle:"作用与语法",charIndex:2716},{level:4,title:"常见的表单项",slug:"常见的表单项",normalizedTitle:"常见的表单项",charIndex:3117},{level:2,title:"4. HTTP 请求",slug:"_4-http-请求",normalizedTitle:"4. http 请求",charIndex:3618},{level:3,title:"1) 请求组成",slug:"_1-请求组成",normalizedTitle:"1) 请求组成",charIndex:3633},{level:3,title:"2) 请求方式与数据格式",slug:"_2-请求方式与数据格式",normalizedTitle:"2) 请求方式与数据格式",charIndex:3697},{level:4,title:"get 请求示例",slug:"get-请求示例",normalizedTitle:"get 请求示例",charIndex:3713},{level:4,title:"post 请求示例",slug:"post-请求示例",normalizedTitle:"post 请求示例",charIndex:3822},{level:4,title:"json 请求示例",slug:"json-请求示例",normalizedTitle:"json 请求示例",charIndex:4114},{level:4,title:"multipart 请求示例",slug:"multipart-请求示例",normalizedTitle:"multipart 请求示例",charIndex:4381},{level:4,title:"数据格式小结",slug:"数据格式小结",normalizedTitle:"数据格式小结",charIndex:4717},{level:3,title:"3) session 原理",slug:"_3-session-原理",normalizedTitle:"3) session 原理",charIndex:5178},{level:3,title:"4) jwt 原理",slug:"_4-jwt-原理",normalizedTitle:"4) jwt 原理",charIndex:5920},{level:2,title:"5. CSS",slug:"_5-css",normalizedTitle:"5. css",charIndex:6524},{level:3,title:"1) 选择器",slug:"_1-选择器",normalizedTitle:"1) 选择器",charIndex:6576},{level:3,title:"2) 属性和值",slug:"_2-属性和值",normalizedTitle:"2) 属性和值",charIndex:6683},{level:3,title:"3) 布局",slug:"_3-布局",normalizedTitle:"3) 布局",charIndex:6741}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"4 min read",minutes:3.985,time:239100,words:797},headersStr:"1. HTML 元素 2. HTML 页面 3. 常见元素 1) 文本 Heading Paragraph List Anchor 2) 多媒体 Image Video Audio 3) 表单 作用与语法 常见的表单项 4. HTTP 请求 1) 请求组成 2) 请求方式与数据格式 get 请求示例 post 请求示例 json 请求示例 multipart 请求示例 数据格式小结 3) session 原理 4) jwt 原理 5. CSS 1) 选择器 2) 属性和值 3) 布局",content:'# 前言\n\nJava 程序员一提起前端知识，心情那是五味杂陈，百感交集。\n\n * 说不学它吧，说不定进公司以后，就会被抓壮丁去时不时写点前端代码\n * 说学它吧，HTML、CSS、JavaScript 哪个不得下大功夫才能精通？\n * 学一点够不够用呢？如果只学基础的 JavaScript 是不够用的，前端都已经工程化了，Vue、React 这些框架你去看吧，光有点基础根本看不懂，甚至连前端页面路径在哪儿配置，如何跳转都不甚了解，所以得学，而且要学的还不少，请把前端当作 web 不可或缺的一部分来学习。\n * 学习前端好处挺多，我听说过这么一句挺有道理的话：一个程序员至少应该掌握一门静态语言，如 Java，还应该掌握一门动态语言，如 JavaScript。而且，你不觉得学了前端，就如打通了程序员的任督二脉，可以独立接活了嘛\n\n 1. HTML / CSS 这部分对咱们来说，不是重点，但又不能不讲，必学\n 2. JavaScript 这部分是重点，尤其是 ES6 以后的一些新语法，不理解这些，前端代码你根本看不懂，必学\n 3. Vue2，Vue3，React 这三章是三选一的关系，根据你入职公司的使用的前端技术不同，有针对地学习\n    * 后三章会涵盖 TypeScript、VueCli、Vuex、VueRouter、ElementUI、Vite、CreateReactApp、React、Redux、ReactRouter 等库和工具的使用\n 4. jquery 经过调研，还有一些学员毕业后确实会用到，所以也作为一个可选章节进行学习\n\n\n# HTML 与 CSS\n\nHTML 是什么：即 HyperText Markup language 超文本标记语言，咱们熟知的网页就是用它编写的，HTML 的作用是定义网页的内容和结构。\n\n * HyperText 是指用超链接的方式组织网页，把网页联系起来\n * Markup 是指用 <标签> 的方式赋予内容不同的功能和含义\n\nCSS 是什么：即 Cascading Style Sheets 级联（层叠）样式表，它描述了网页的表现与展示效果\n\n\n# 1. HTML 元素\n\nHTML 由一系列元素 elements 组成，例如\n\n<p>Hello, world!</p>\n\n\n1\n\n\n * 整体称之为元素\n\n * <p> 和 </p> 分别称为起始和结束标签\n\n * 标签包围起来的 Hello, world 称之为内容\n\n * p 是预先定义好的 html 标签，作用是将内容作为一个单独的段落\n\n元素还可以有属性，如\n\n<p id="p1">Hello, world!</p>\n\n\n1\n\n * 属性一般是预先定义好的，这里的 id 属性是给元素一个唯一的标识\n\n元素之间可以嵌套，如\n\n<p>HTML 是一门非常<b>强大</b>的语言</p>\n\n\n1\n\n\n错误嵌套写法：\n\n<p>HTML 是一门非常<b>强大的语言</p></b>\n\n\n1\n\n\n不包含内容的元素称之为空元素，如\n\n<img src="1.png">\n<img src="1.png"/>\n\n\n1\n2\n\n * img 作用是用来展示图片\n * src 属性用来指明图片路径\n\n\n# 2. HTML 页面\n\n前面介绍的只是单独的 HTML 元素，它们可以充当一份完整的 HTML 页面的组成部分\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8">\n    <title>测试页面</title>\n  </head>\n  <body>\n    <p id="p1">Hello, world!</p>\n    <img src="1.png">\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * html 元素囊括了页面中所有其它元素，整个页面只需一个，称为根元素\n * head 元素包含的是那些不用于展现内容的元素，如 title，link，meta 等\n * body 元素包含了对用户展现内容的元素，例如后面会学到的用于展示文本、图片、视频、音频的各种元素\n\n\n# 3. 常见元素\n\n\n# 1) 文本\n\n# Heading\n\n<h1>1号标题</h1>\n<h2>2号标题</h2>\n<h3>3号标题</h3>\n<h4>4号标题</h4>\n<h5>5号标题</h5>\n<h6>6号标题</h6>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# Paragraph\n\n<p>段落</p>\n\n\n1\n\n\n# List\n\n无序列表 unordered list\n\n<ul>\n    <li>列表项1</li>\n    <li>列表项2</li>\n    <li>列表项3</li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\n有序列表\n\n<ol>\n    <li>列表项1</li>\n    <li>列表项2</li>\n    <li>列表项3</li>\n</ol>\n\n\n1\n2\n3\n4\n5\n\n\n多级列表\n\n<ul>\n    <li>\n    \t北京市\n        <ul>\n            <li>海淀区</li>\n            <li>朝阳区</li>\n            <li>昌平区</li>\n        </ul>\n    </li>\n    <li>\n    \t河北省\n        <ul>\n            <li>石家庄</li>\n            <li>保定</li>\n        </ul>\n    </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# Anchor\n\n锚，超链接\n\n<a href="网页地址">超链接文本</a>\n\n\n1\n\n\n\n# 2) 多媒体\n\n# Image\n\n<img src="文件路径">\n\n\n1\n\n\nsrc 格式有 3 种\n\n * 文件地址\n\n * data URL，格式如下\n   \n   data:媒体类型;base64,数据\n   \n   \n   1\n   \n\n * object URL，需要配合 javascript 使用\n\n# Video\n\n<video src="文件路径"></video>\n\n\n1\n\n\n# Audio\n\n<audio src="文件路径"></audio>\n\n\n1\n\n\n\n# 3) 表单\n\n# 作用与语法\n\n表单的作用：收集用户填入的数据，并将这些数据提交给服务器\n\n表单的语法\n\n<form action="服务器地址" method="请求方式" enctype="数据格式">\n    \x3c!-- 表单项 --\x3e\n    \n    <input type="submit" value="提交按钮">\n</form>\n\n\n1\n2\n3\n4\n5\n\n * method 请求方式有\n   * get （默认）提交时，数据跟在 URL 地址之后\n   * post 提交时，数据在请求体内\n * enctype 在 post 请求时，指定请求体的数据格式\n   * application/x-www-form-urlencoded（默认）\n   * multipart/form-data\n * 其中表单项提供多种收集数据的方式\n   * 有 name 属性的表单项数据，才会被发送给服务器\n\n# 常见的表单项\n\n文本框\n\n<input type="text" name="uesrname">\n\n\n1\n\n\n密码框\n\n<input type="password" name="password">\n\n\n1\n\n\n隐藏框\n\n<input type="hidden" name="id">\n\n\n1\n\n\n日期框\n\n<input type="date" name="birthday">\n\n\n1\n\n\n单选\n\n<input type="radio" name="sex" value="男" checked>\n<input type="radio" name="sex" value="女">\n\n\n1\n2\n\n\n多选\n\n<input type="checkbox" name="fav" value="唱歌">\n<input type="checkbox" name="fav" value="逛街">\n<input type="checkbox" name="fav" value="游戏">\n\n\n1\n2\n3\n\n\n文件上传\n\n<input type="file" name="avatar">\n\n\n1\n\n\n\n# 4. HTTP 请求\n\n\n# 1) 请求组成\n\n请求由三部分组成\n\n 1. 请求行\n 2. 请求头\n 3. 请求体\n\n可以用 telnet 程序测试\n\n\n# 2) 请求方式与数据格式\n\n# get 请求示例\n\nGET /test2?name=%E5%BC%A0&age=20 HTTP/1.1\nHost: localhost\n\n\n1\n2\n\n * %E5%BC%A0 是【张】经过 URL 编码后的结果\n\n# post 请求示例\n\nPOST /test2 HTTP/1.1\nHost: localhost\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 21\n\nname=%E5%BC%A0&age=18\n\n\n1\n2\n3\n4\n5\n6\n\n\napplication/x-www-form-urlencoed 格式细节：\n\n * 参数分成名字和值，中间用 = 分隔\n * 多个参数使用 & 进行分隔\n * 【张】等特殊字符需要用 encodeURIComponent() 编码为 【%E5%BC%A0】后才能发送\n\n# json 请求示例\n\nPOST /test3 HTTP/1.1\nHost: localhost\nContent-Type: application/json\nContent-Length: 25\n\n{"name":"zhang","age":18}\n\n\n1\n2\n3\n4\n5\n6\n\n\njson 对象格式\n\n{"属性名":属性值}\n\n\n1\n\n\n其中属性值可以是\n\n * 字符串 ""\n * 数字\n * true, false\n * null\n * 对象\n * 数组\n\njson 数组格式\n\n[元素1, 元素2, ...]\n\n\n1\n\n\n# multipart 请求示例\n\nPOST /test2 HTTP/1.1\nHost: localhost\nContent-Type: multipart/form-data; boundary=123\nContent-Length: 125\n\n--123\nContent-Disposition: form-data; name="name"\n\nlisi\n--123\nContent-Disposition: form-data; name="age"\n\n30\n--123--\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * boundary=123 用来定义分隔符\n * 起始分隔符是 --分隔符\n * 结束分隔符是 --分隔符--\n\n# 数据格式小结\n\n客户端发送\n\n * 编码\n   * application/x-www-form-urlencoded ：url 编码\n   * application/json：utf-8 编码\n   * multipart/form-data：每部分编码可以不同\n * 表单只支持以 application/x-www-form-urlencoded 和 multipart/form-data 格式发送数据\n * 文件上传需要用 multipart/form-data 格式\n * js 代码可以支持任意格式发送数据\n\n服务端接收\n\n * 对 application/x-www-form-urlencoded 和 multipart/form-data 格式的数据，Spring 接收方式是统一的，只需要用 java bean 的属性名对应请求参数名即可\n * 对于 applicaiton/json 格式的数据，Spring 接收需要使用 @RequestBody 注解 + java bean 的方式\n\n\n# 3) session 原理\n\nHttp 无状态，有会话\n\n * 无状态是指，请求之间相互独立，第一次请求的数据，第二次请求不能重用\n * 有会话是指，客户端和服务端都有相应的技术，可以暂存数据，让数据在请求间共享\n\n服务端使用了 session 技术来暂存数据\n\n存\n\nGET /s1?name=zhang HTTP/1.1\nHost: localhost\n\n\n1\n2\n\n\n取\n\nGET /s2 HTTP/1.1\nHost: localhost\nCookie: JSESSIONID=560FA845D02AE09B176E1BC5D9816A5D\n\n\n1\n2\n3\n\n\nsession 技术实现身份验证\n\nsequenceDiagram\nparticipant Client\nparticipant L as LoginController\nparticipant i as LoginInterceptor\nparticipant Session\nrect rgb(200, 223, 255)\nClient ->> +L : 登录请求\nL ->> L : 检查用户名，密码，验证通过\nL ->> +Session : 存入用户名\nSession --\x3e> -L: \nL --\x3e> -Client: 登录成功\nend\nrect rgb(200, 190, 255)\nClient ->> +i : 其它请求\ni ->> +Session : 获取用户名\nSession --\x3e> -i : \ni ->> i: 用户名存在，放行\ni --\x3e> -Client : \nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 4) jwt 原理\n\njwt 技术实现身份验证\n\nsequenceDiagram\nparticipant Client\nparticipant L as LoginController\nparticipant i as LoginInterceptor\n\nrect rgb(200, 223, 255)\nClient ->> +L : 登录请求\nL ->> L : 检查用户名，密码，验证通过\nL --\x3e> -Client : 登录成功，返回token\nend\n\nrect rgb(150, 190, 155)\nClient ->> +i : 其它请求，携带token\ni ->> i : 校验token，校验无误，放行\ni --\x3e> -Client : \nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n生成 token\n\nGET /j1?name=zhang&pass=123 HTTP/1.1\nHost: localhost\n\n\n1\n2\n\n\n校验 token\n\nGET /j2 HTTP/1.1\nHost: localhost\nAuthorization: eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiJ9._1-P_TLlzQPb1_lCyGwplMZaKQ8Mcw_plBbYPZ3OX28\n\n\n1\n2\n3\n\n\n\n# 5. CSS\n\n即 Cascading Style Sheets，它描述了网页的表现与展示效果\n\n\n# 1) 选择器\n\n * type 选择器 - 根据标签名进行匹配（元素选择器）\n\n * class 选择器 - 根据元素的 class 属性进行匹配\n\n * id 选择器 - 根据元素的 id 属性进行匹配\n\n\n# 2) 属性和值\n\n * background-color : red;\n * ...\n * display\n\n\n# 3) 布局\n\n与布局相关的 html 元素\n\n * div\n * template',normalizedContent:'# 前言\n\njava 程序员一提起前端知识，心情那是五味杂陈，百感交集。\n\n * 说不学它吧，说不定进公司以后，就会被抓壮丁去时不时写点前端代码\n * 说学它吧，html、css、javascript 哪个不得下大功夫才能精通？\n * 学一点够不够用呢？如果只学基础的 javascript 是不够用的，前端都已经工程化了，vue、react 这些框架你去看吧，光有点基础根本看不懂，甚至连前端页面路径在哪儿配置，如何跳转都不甚了解，所以得学，而且要学的还不少，请把前端当作 web 不可或缺的一部分来学习。\n * 学习前端好处挺多，我听说过这么一句挺有道理的话：一个程序员至少应该掌握一门静态语言，如 java，还应该掌握一门动态语言，如 javascript。而且，你不觉得学了前端，就如打通了程序员的任督二脉，可以独立接活了嘛\n\n 1. html / css 这部分对咱们来说，不是重点，但又不能不讲，必学\n 2. javascript 这部分是重点，尤其是 es6 以后的一些新语法，不理解这些，前端代码你根本看不懂，必学\n 3. vue2，vue3，react 这三章是三选一的关系，根据你入职公司的使用的前端技术不同，有针对地学习\n    * 后三章会涵盖 typescript、vuecli、vuex、vuerouter、elementui、vite、createreactapp、react、redux、reactrouter 等库和工具的使用\n 4. jquery 经过调研，还有一些学员毕业后确实会用到，所以也作为一个可选章节进行学习\n\n\n# html 与 css\n\nhtml 是什么：即 hypertext markup language 超文本标记语言，咱们熟知的网页就是用它编写的，html 的作用是定义网页的内容和结构。\n\n * hypertext 是指用超链接的方式组织网页，把网页联系起来\n * markup 是指用 <标签> 的方式赋予内容不同的功能和含义\n\ncss 是什么：即 cascading style sheets 级联（层叠）样式表，它描述了网页的表现与展示效果\n\n\n# 1. html 元素\n\nhtml 由一系列元素 elements 组成，例如\n\n<p>hello, world!</p>\n\n\n1\n\n\n * 整体称之为元素\n\n * <p> 和 </p> 分别称为起始和结束标签\n\n * 标签包围起来的 hello, world 称之为内容\n\n * p 是预先定义好的 html 标签，作用是将内容作为一个单独的段落\n\n元素还可以有属性，如\n\n<p id="p1">hello, world!</p>\n\n\n1\n\n * 属性一般是预先定义好的，这里的 id 属性是给元素一个唯一的标识\n\n元素之间可以嵌套，如\n\n<p>html 是一门非常<b>强大</b>的语言</p>\n\n\n1\n\n\n错误嵌套写法：\n\n<p>html 是一门非常<b>强大的语言</p></b>\n\n\n1\n\n\n不包含内容的元素称之为空元素，如\n\n<img src="1.png">\n<img src="1.png"/>\n\n\n1\n2\n\n * img 作用是用来展示图片\n * src 属性用来指明图片路径\n\n\n# 2. html 页面\n\n前面介绍的只是单独的 html 元素，它们可以充当一份完整的 html 页面的组成部分\n\n<!doctype html>\n<html>\n  <head>\n    <meta charset="utf-8">\n    <title>测试页面</title>\n  </head>\n  <body>\n    <p id="p1">hello, world!</p>\n    <img src="1.png">\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * html 元素囊括了页面中所有其它元素，整个页面只需一个，称为根元素\n * head 元素包含的是那些不用于展现内容的元素，如 title，link，meta 等\n * body 元素包含了对用户展现内容的元素，例如后面会学到的用于展示文本、图片、视频、音频的各种元素\n\n\n# 3. 常见元素\n\n\n# 1) 文本\n\n# heading\n\n<h1>1号标题</h1>\n<h2>2号标题</h2>\n<h3>3号标题</h3>\n<h4>4号标题</h4>\n<h5>5号标题</h5>\n<h6>6号标题</h6>\n\n\n1\n2\n3\n4\n5\n6\n\n\n# paragraph\n\n<p>段落</p>\n\n\n1\n\n\n# list\n\n无序列表 unordered list\n\n<ul>\n    <li>列表项1</li>\n    <li>列表项2</li>\n    <li>列表项3</li>\n</ul>\n\n\n1\n2\n3\n4\n5\n\n\n有序列表\n\n<ol>\n    <li>列表项1</li>\n    <li>列表项2</li>\n    <li>列表项3</li>\n</ol>\n\n\n1\n2\n3\n4\n5\n\n\n多级列表\n\n<ul>\n    <li>\n    \t北京市\n        <ul>\n            <li>海淀区</li>\n            <li>朝阳区</li>\n            <li>昌平区</li>\n        </ul>\n    </li>\n    <li>\n    \t河北省\n        <ul>\n            <li>石家庄</li>\n            <li>保定</li>\n        </ul>\n    </li>\n</ul>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# anchor\n\n锚，超链接\n\n<a href="网页地址">超链接文本</a>\n\n\n1\n\n\n\n# 2) 多媒体\n\n# image\n\n<img src="文件路径">\n\n\n1\n\n\nsrc 格式有 3 种\n\n * 文件地址\n\n * data url，格式如下\n   \n   data:媒体类型;base64,数据\n   \n   \n   1\n   \n\n * object url，需要配合 javascript 使用\n\n# video\n\n<video src="文件路径"></video>\n\n\n1\n\n\n# audio\n\n<audio src="文件路径"></audio>\n\n\n1\n\n\n\n# 3) 表单\n\n# 作用与语法\n\n表单的作用：收集用户填入的数据，并将这些数据提交给服务器\n\n表单的语法\n\n<form action="服务器地址" method="请求方式" enctype="数据格式">\n    \x3c!-- 表单项 --\x3e\n    \n    <input type="submit" value="提交按钮">\n</form>\n\n\n1\n2\n3\n4\n5\n\n * method 请求方式有\n   * get （默认）提交时，数据跟在 url 地址之后\n   * post 提交时，数据在请求体内\n * enctype 在 post 请求时，指定请求体的数据格式\n   * application/x-www-form-urlencoded（默认）\n   * multipart/form-data\n * 其中表单项提供多种收集数据的方式\n   * 有 name 属性的表单项数据，才会被发送给服务器\n\n# 常见的表单项\n\n文本框\n\n<input type="text" name="uesrname">\n\n\n1\n\n\n密码框\n\n<input type="password" name="password">\n\n\n1\n\n\n隐藏框\n\n<input type="hidden" name="id">\n\n\n1\n\n\n日期框\n\n<input type="date" name="birthday">\n\n\n1\n\n\n单选\n\n<input type="radio" name="sex" value="男" checked>\n<input type="radio" name="sex" value="女">\n\n\n1\n2\n\n\n多选\n\n<input type="checkbox" name="fav" value="唱歌">\n<input type="checkbox" name="fav" value="逛街">\n<input type="checkbox" name="fav" value="游戏">\n\n\n1\n2\n3\n\n\n文件上传\n\n<input type="file" name="avatar">\n\n\n1\n\n\n\n# 4. http 请求\n\n\n# 1) 请求组成\n\n请求由三部分组成\n\n 1. 请求行\n 2. 请求头\n 3. 请求体\n\n可以用 telnet 程序测试\n\n\n# 2) 请求方式与数据格式\n\n# get 请求示例\n\nget /test2?name=%e5%bc%a0&age=20 http/1.1\nhost: localhost\n\n\n1\n2\n\n * %e5%bc%a0 是【张】经过 url 编码后的结果\n\n# post 请求示例\n\npost /test2 http/1.1\nhost: localhost\ncontent-type: application/x-www-form-urlencoded\ncontent-length: 21\n\nname=%e5%bc%a0&age=18\n\n\n1\n2\n3\n4\n5\n6\n\n\napplication/x-www-form-urlencoed 格式细节：\n\n * 参数分成名字和值，中间用 = 分隔\n * 多个参数使用 & 进行分隔\n * 【张】等特殊字符需要用 encodeuricomponent() 编码为 【%e5%bc%a0】后才能发送\n\n# json 请求示例\n\npost /test3 http/1.1\nhost: localhost\ncontent-type: application/json\ncontent-length: 25\n\n{"name":"zhang","age":18}\n\n\n1\n2\n3\n4\n5\n6\n\n\njson 对象格式\n\n{"属性名":属性值}\n\n\n1\n\n\n其中属性值可以是\n\n * 字符串 ""\n * 数字\n * true, false\n * null\n * 对象\n * 数组\n\njson 数组格式\n\n[元素1, 元素2, ...]\n\n\n1\n\n\n# multipart 请求示例\n\npost /test2 http/1.1\nhost: localhost\ncontent-type: multipart/form-data; boundary=123\ncontent-length: 125\n\n--123\ncontent-disposition: form-data; name="name"\n\nlisi\n--123\ncontent-disposition: form-data; name="age"\n\n30\n--123--\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * boundary=123 用来定义分隔符\n * 起始分隔符是 --分隔符\n * 结束分隔符是 --分隔符--\n\n# 数据格式小结\n\n客户端发送\n\n * 编码\n   * application/x-www-form-urlencoded ：url 编码\n   * application/json：utf-8 编码\n   * multipart/form-data：每部分编码可以不同\n * 表单只支持以 application/x-www-form-urlencoded 和 multipart/form-data 格式发送数据\n * 文件上传需要用 multipart/form-data 格式\n * js 代码可以支持任意格式发送数据\n\n服务端接收\n\n * 对 application/x-www-form-urlencoded 和 multipart/form-data 格式的数据，spring 接收方式是统一的，只需要用 java bean 的属性名对应请求参数名即可\n * 对于 applicaiton/json 格式的数据，spring 接收需要使用 @requestbody 注解 + java bean 的方式\n\n\n# 3) session 原理\n\nhttp 无状态，有会话\n\n * 无状态是指，请求之间相互独立，第一次请求的数据，第二次请求不能重用\n * 有会话是指，客户端和服务端都有相应的技术，可以暂存数据，让数据在请求间共享\n\n服务端使用了 session 技术来暂存数据\n\n存\n\nget /s1?name=zhang http/1.1\nhost: localhost\n\n\n1\n2\n\n\n取\n\nget /s2 http/1.1\nhost: localhost\ncookie: jsessionid=560fa845d02ae09b176e1bc5d9816a5d\n\n\n1\n2\n3\n\n\nsession 技术实现身份验证\n\nsequencediagram\nparticipant client\nparticipant l as logincontroller\nparticipant i as logininterceptor\nparticipant session\nrect rgb(200, 223, 255)\nclient ->> +l : 登录请求\nl ->> l : 检查用户名，密码，验证通过\nl ->> +session : 存入用户名\nsession --\x3e> -l: \nl --\x3e> -client: 登录成功\nend\nrect rgb(200, 190, 255)\nclient ->> +i : 其它请求\ni ->> +session : 获取用户名\nsession --\x3e> -i : \ni ->> i: 用户名存在，放行\ni --\x3e> -client : \nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 4) jwt 原理\n\njwt 技术实现身份验证\n\nsequencediagram\nparticipant client\nparticipant l as logincontroller\nparticipant i as logininterceptor\n\nrect rgb(200, 223, 255)\nclient ->> +l : 登录请求\nl ->> l : 检查用户名，密码，验证通过\nl --\x3e> -client : 登录成功，返回token\nend\n\nrect rgb(150, 190, 155)\nclient ->> +i : 其它请求，携带token\ni ->> i : 校验token，校验无误，放行\ni --\x3e> -client : \nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n生成 token\n\nget /j1?name=zhang&pass=123 http/1.1\nhost: localhost\n\n\n1\n2\n\n\n校验 token\n\nget /j2 http/1.1\nhost: localhost\nauthorization: eyjhbgcioijiuzi1nij9.eyjzdwiioijhzg1pbij9._1-p_tllzqpb1_lcygwplmzakq8mcw_plbbypz3ox28\n\n\n1\n2\n3\n\n\n\n# 5. css\n\n即 cascading style sheets，它描述了网页的表现与展示效果\n\n\n# 1) 选择器\n\n * type 选择器 - 根据标签名进行匹配（元素选择器）\n\n * class 选择器 - 根据元素的 class 属性进行匹配\n\n * id 选择器 - 根据元素的 id 属性进行匹配\n\n\n# 2) 属性和值\n\n * background-color : red;\n * ...\n * display\n\n\n# 3) 布局\n\n与布局相关的 html 元素\n\n * div\n * template',charsets:{cjk:!0}},{title:"Vue3 进阶",frontmatter:{title:"Vue3 进阶",date:"2023-07-08T15:36:48.000Z",permalink:"/pages/ca4cfb/"},regularPath:"/09.%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/08.Vue3%E8%BF%9B%E9%98%B6.html",relativePath:"09.前端学习/08.Vue3进阶.md",key:"v-711839c2",path:"/pages/ca4cfb/",headers:[{level:2,title:"任务一 创建 Vite + Vue3 单页应用",slug:"任务一-创建-vite-vue3-单页应用",normalizedTitle:"任务一 创建 vite + vue3 单页应用",charIndex:2},{level:3,title:"单页应用",slug:"单页应用",normalizedTitle:"单页应用",charIndex:21},{level:3,title:"Vue 3 对单页应用开发的支持",slug:"vue-3-对单页应用开发的支持",normalizedTitle:"vue 3 对单页应用开发的支持",charIndex:2168},{level:3,title:"安装 Node.js",slug:"安装-node-js",normalizedTitle:"安装 node.js",charIndex:3038},{level:4,title:"一、下载 Node.js",slug:"一、下载-node-js",normalizedTitle:"一、下载 node.js",charIndex:3162},{level:4,title:"二、安装 Node.js",slug:"二、安装-node-js",normalizedTitle:"二、安装 node.js",charIndex:3231},{level:4,title:"三、测试安装是否成功",slug:"三、测试安装是否成功",normalizedTitle:"三、测试安装是否成功",charIndex:3368},{level:3,title:"创建 Vite+Vue3 单页应用",slug:"创建-vite-vue3-单页应用",normalizedTitle:"创建 vite+vue3 单页应用",charIndex:3479},{level:4,title:"一、创建项目",slug:"一、创建项目",normalizedTitle:"一、创建项目",charIndex:3805},{level:4,title:"二、安装依赖",slug:"二、安装依赖",normalizedTitle:"二、安装依赖",charIndex:5598},{level:3,title:"运行单页应用",slug:"运行单页应用",normalizedTitle:"运行单页应用",charIndex:5922},{level:4,title:"一、启动项目服务端",slug:"一、启动项目服务端",normalizedTitle:"一、启动项目服务端",charIndex:5932},{level:4,title:"二、从浏览器访问应用",slug:"二、从浏览器访问应用",normalizedTitle:"二、从浏览器访问应用",charIndex:6189},{level:2,title:"任务二 了解组合式 API",slug:"任务二-了解组合式-api",normalizedTitle:"任务二 了解组合式 api",charIndex:6272},{level:3,title:"使用 setup 函数",slug:"使用-setup-函数",normalizedTitle:"使用 setup 函数",charIndex:6602},{level:3,title:"使用 script setup",slug:"使用-script-setup",normalizedTitle:"使用 script setup",charIndex:8286},{level:3,title:"引入 TypeScript",slug:"引入-typescript",normalizedTitle:"引入 typescript",charIndex:9509},{level:2,title:"响应式",slug:"响应式",normalizedTitle:"响应式",charIndex:2332},{level:3,title:"Vue 3 的响应式原理",slug:"vue-3-的响应式原理",normalizedTitle:"vue 3 的响应式原理",charIndex:10595},{level:3,title:"Vue 3 的响应式 API",slug:"vue-3-的响应式-api",normalizedTitle:"vue 3 的响应式 api",charIndex:11233},{level:2,title:"任务三 用 reactive 设置响应式数据",slug:"任务三-用-reactive-设置响应式数据",normalizedTitle:"任务三 用 reactive 设置响应式数据",charIndex:12219},{level:3,title:"reactive 函数的原理及注意事项",slug:"reactive-函数的原理及注意事项",normalizedTitle:"reactive 函数的原理及注意事项",charIndex:12246},{level:3,title:"reactive 的使用举例",slug:"reactive-的使用举例",normalizedTitle:"reactive 的使用举例",charIndex:13129},{level:4,title:"一、reactive 作用于普通的 JavaScript 对象",slug:"一、reactive-作用于普通的-javascript-对象",normalizedTitle:"一、reactive 作用于普通的 javascript 对象",charIndex:13147},{level:4,title:"二、reactive 作用于数组",slug:"二、reactive-作用于数组",normalizedTitle:"二、reactive 作用于数组",charIndex:14493},{level:2,title:"任务四 用 ref 设置响应式数据",slug:"任务四-用-ref-设置响应式数据",normalizedTitle:"任务四 用 ref 设置响应式数据",charIndex:15804},{level:3,title:"ref 的原理及注意事项",slug:"ref-的原理及注意事项",normalizedTitle:"ref 的原理及注意事项",charIndex:15826},{level:3,title:"ref 的使用举例",slug:"ref-的使用举例",normalizedTitle:"ref 的使用举例",charIndex:17042},{level:2,title:"任务五 toRef() 与 toRefs()",slug:"任务五-toref-与-torefs",normalizedTitle:"任务五 toref() 与 torefs()",charIndex:19070},{level:3,title:"toRef() 的使用场景",slug:"toref-的使用场景",normalizedTitle:"toref() 的使用场景",charIndex:19097},{level:4,title:"1 问题引入",slug:"_1-问题引入",normalizedTitle:"1 问题引入",charIndex:19114},{level:4,title:"2 解决办法",slug:"_2-解决办法",normalizedTitle:"2 解决办法",charIndex:19807},{level:4,title:"3 继续改进",slug:"_3-继续改进",normalizedTitle:"3 继续改进",charIndex:20561},{level:3,title:"toRefs() 的使用场景",slug:"torefs-的使用场景",normalizedTitle:"torefs() 的使用场景",charIndex:21470},{level:4,title:"一、问题引入",slug:"一、问题引入",normalizedTitle:"一、问题引入",charIndex:21488},{level:4,title:"二、解决办法",slug:"二、解决办法",normalizedTitle:"二、解决办法",charIndex:21599},{level:2,title:"任务六 computed 与计算属性",slug:"任务六-computed-与计算属性",normalizedTitle:"任务六 computed 与计算属性",charIndex:22686},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:22709},{level:3,title:"使用计算属性",slug:"使用计算属性",normalizedTitle:"使用计算属性",charIndex:22972}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"13 min read",minutes:12.495,time:749699.9999999999,words:2499},headersStr:"任务一 创建 Vite + Vue3 单页应用 单页应用 Vue 3 对单页应用开发的支持 安装 Node.js 一、下载 Node.js 二、安装 Node.js 三、测试安装是否成功 创建 Vite+Vue3 单页应用 一、创建项目 二、安装依赖 运行单页应用 一、启动项目服务端 二、从浏览器访问应用 任务二 了解组合式 API 使用 setup 函数 使用 script setup 引入 TypeScript 响应式 Vue 3 的响应式原理 Vue 3 的响应式 API 任务三 用 reactive 设置响应式数据 reactive 函数的原理及注意事项 reactive 的使用举例 一、reactive 作用于普通的 JavaScript 对象 二、reactive 作用于数组 任务四 用 ref 设置响应式数据 ref 的原理及注意事项 ref 的使用举例 任务五 toRef() 与 toRefs() toRef() 的使用场景 1 问题引入 2 解决办法 3 继续改进 toRefs() 的使用场景 一、问题引入 二、解决办法 任务六 computed 与计算属性 基本概念 使用计算属性",content:"# 任务一 创建 Vite + Vue3 单页应用\n\nVue 3 是一个流行的 JavaScript 前端框架，用于构建单页应用程序（SPA）。\n\n下面是一些创建 Vue 3 单页应用程序的方式：\n\n * Vue CLI：Vue CLI 是一个命令行界面工具，用于创建和管理 Vue 应用程序。它可以自动生成一个基于 webpack 的项目模板，提供了一些内置的插件和特性，例如 Babel、ESLint、TypeScript 等。使用 Vue CLI 可以方便地创建 Vue 单页应用程序。\n * 手动设置：你可以手动设置一个 Vue 3 单页应用程序。这需要你手动创建 webpack 配置文件，并安装和配置必要的插件和库，如 vue-loader、babel-loader 等。这种方式更加灵活，但需要更多的配置和知识。\n * 使用 Vite：Vite 是一个现代化的构建工具，用于构建 Vue 应用程序。它使用现代化的技术和原生 ES 模块作为基础，提供了一种快速、轻量级的开发体验。你可以使用 Vite 创建一个 Vue 3 单页应用程序，只需运行几个命令即可。\n\n在本任务中，我们将使用 Vite 来创建 Vue 3 单页应用程序，因为它能够大幅简化开发流程。不过，如果您需要更加灵活的控制和定制，手动设置也是一个不错的选择。\n\n\n# 单页应用\n\n单页应用（Single Page Application，SPA）是一种 Web 应用程序的架构模式，它使用动态加载的 HTML、CSS 和 JavaScript，以及 AJAX 和 WebSockets 等技术实现无刷新页面的单页应用。\n\n> 核心思想\n\n单页应用的核心思想是：将所有的页面都加载到一个单一的 HTML 页面中，通过 JavaScript 操作 DOM 实现页面的动态变化。\n\n> 数据交互过程\n\n当用户与应用程序交互时，JavaScript 会通过 AJAX 或 WebSockets 等技术请求后端 API 获取数据，然后在前端通过 Vue、React 等前端框架对数据进行处理，最终更新视图，从而实现页面的刷新和动态变化。\n\n> 优点\n\n单页应用的优点是：\n\n * 可以提高页面的加载速度和用户体验，因为只需要加载一次 HTML、CSS 和 JavaScript 等资源，之后就可以在前端通过 JavaScript 动态更新页面内容，而不需要重新加载整个页面。\n * 此外，单页应用还可以提高开发效率，因为前端可以采用组件化开发方式，将页面拆分为多个组件，每个组件可以独立开发和测试，最终再将这些组件拼接成完整的页面。\n\n> 缺点\n\n但是，单页应用也有一些缺点。\n\n * 首先，由于 SPA 的内容是通过 JavaScript 动态加载的，对于 SEO 来说并不友好。\n * 其次，SPA 需要处理前后端分离的问题，需要前端开发人员和后端开发人员共同协作完成。此外，单页应用需要处理浏览器历史记录和 URL 路由等问题，需要使用一些第三方库或框架来处理这些问题。\n\n> 多页应用\n\n相比之下，多页应用（MPA）的优点是：对 SEO 友好，因为每个页面都有自己的 URL 地址和内容，便于搜索引擎进行抓取和索引。此外，多页应用还可以采用传统的服务器渲染方式，在后端渲染页面，以提高页面的加载速度和 SEO 效果。\n\n但是，多页应用的缺点是：页面切换需要重新加载整个页面，页面刷新和交互体验相对较差。此外，多页应用需要在前端和后端进行模板渲染，代码复杂度相对较高，开发效率相对较低。\n\n因此，选择单页应用（SPA）还是多页应用（MPA）取决于项目的具体需求和情况。如果项目注重用户体验和开发效率，且对 SEO 不是特别敏感，可以选择 SPA。\n\n> 为什么 SPA 对 SEO 不友好？\n\n在这句话中，SEO 指的是搜索引擎优化（Search Engine Optimization），即通过优化网站以提高其在搜索引擎中的排名和可见性。\n\n\"对于 SEO 来说并不友好\"指的是：单页面应用（SPA）对于传统的搜索引擎优化方法不太友好。\n\n原因：\n\nSPA 是一种通过 JavaScript 动态加载内容的网页应用，它使用 AJAX 和前端路由等技术实现页面的无刷新加载和内容的动态更新。\n\n由于 SPA 的内容大部分是在客户端通过 JavaScript 生成和加载的，而传统的搜索引擎爬虫通常只会抓取和索引【静态 HTML 页面】，因此无法直接获取和理解 SPA 中的内容。\n\n这导致了 SPA 在搜索引擎中的可见性和排名受到一定影响。因为搜索引擎无法像普通的 HTML 页面那样直接抓取和索引【SPA 的内容】，所以对于那些依赖搜索引擎流量的网站来说，SPA 可能无法获得足够的有机流量。\n\n解决方法:\n\n然而，随着搜索引擎的发展，一些搜索引擎（如Google）已经可以执行 JavaScript 并抓取 SPA 的内容。同时，也出现了一些技术和方法来解决 SPA 的 SEO 问题，例如使用预渲染技术、动态生成静态页面、使用服务器端渲染（SSR）等。这些方法可以帮助 SPA 在搜索引擎中获得更好的可见性和排名，提高其对 SEO 的友好程度。\n\n\n# Vue 3 对单页应用开发的支持\n\nVue.js 是一个用于构建现代 web 应用的渐进式框架，它对开发单页应用提供了很多支持。我们习惯把 Vue.js 2.x 和 Vue.js 3.x 版本分别简称为 Vue2 和 Vue 3。\n\n以下是一些 Vue 3 的特性，它们可以帮助开发者更容易地创建和维护单页应用：\n\n * 使用了响应式数据绑定和组件化的思想，让开发者可以快速构建高效的用户界面。\n * 组合式 API：这是 Vue 3 的一个新特性，它允许开发者使用函数式的方式来组织和复用组件的逻辑，而不是依赖于选项式 API 的 data、methods、computed 等属性。这样可以让组件的代码更加清晰和模块化，也可以避免命名冲突和数据依赖的问题。\n * 优化的虚拟 DOM：虚拟 DOM 是 Vue 的核心特性之一，它可以让开发者使用声明式的语法来渲染界面，而不需要直接操作 DOM。Vue 3 对虚拟 DOM 进行了优化，使其更加高效和灵活。例如，Vue 3 引入了静态标记（hoisting）、片段（fragments）、模块化运行时（tree-shaking）等技术，来减少不必要的渲染和内存占用。\n * 支持 TypeScript：TypeScript 是一种在 JavaScript 基础上增加了类型检查和其他特性的编程语言，它可以提高代码的可读性和可维护性，也可以避免一些常见的错误。Vue 3 完全支持 TypeScript，不仅在源码层面使用了 TypeScript，还提供了完善的类型声明文件，让开发者可以在编辑器中享受到智能提示和错误检测的功能。\n * 更多的内置组件和指令：Vue 3 提供了一些新的内置组件和指令，来增强 SPA 的交互和功能。例如，<teleport> 组件可以让开发者将子组件渲染到任意位置，<suspense> 组件可以让开发者处理异步组件的加载状态。\n\n总之，Vue3+vite 是一种非常适合开发单页应用的技术栈，它可以让开发者享受到最新的前端技术和最佳的开发体验。\n\n\n# 安装 Node.js\n\n创建 vite+Vue3 项目需要安装 16.0 或更高版本的 Node.js。您可以在命令行中运行 node -v 命令来检查您是否已安装了 node 环境。如果没有安装或版本不对的话，可以按照下面的步骤进行安装。\n\n# 一、下载 Node.js\n\n下载地址：https://nodejs.org/zh-cn/download/\n\n下载长期维护版：\n\n\n\n# 二、安装 Node.js\n\n以 Windows 系统为例，下载 Node.js 安装包后，双击一路安装即可。安装过程，除了 Node.js 外，还会一并安装 npm 包管理器。启动 Node.js 和 npm 的命令分别是：\n\nnode   \nnpm \n\n\n1\n2\n\n\n# 三、测试安装是否成功\n\n安装完成后，注意测试安装是否成功，测试命令：\n\nnode -v\nnpm -v\n\n\n1\n2\n\n\n如果显示出 Node.js 和 npm 的版本号，表明安装成功。否则，需要检查环境变量的配置。\n\n\n# 创建 Vite+Vue3 单页应用\n\nVue CLI 和 Vite 都是用于创建 Vue 项目的构建工具。\n\nVue CLI 是一个基于 Webpack 的构建工具，它提供了一个完整的项目脚手架，包括开发服务器、热重载、代码分割、ESLint 等等。\n\nVite 是一个基于 ES 模块的构建工具，它使用浏览器原生的 ES 模块加载器来提供快速的开发体验。Vite 提供了零配置的开发环境，无需安装和配置 webpack 等复杂的工具，只需一个 vite.config.js 文件即可启动一个本地服务器，因此它可以更快地启动和重载。Vite 支持 typescript、css 预处理器、jsx 等常用的功能，并且在生产环境中也可以更快地构建。\n\n# 一、创建项目\n\n使用 npm 或 pnpm 命令均可创建 Vite+Vue3 单页应用：\n\nnpm init vue@latest\n或\npnpm create vue@latest\n\n\n1\n2\n3\n\n\n这一命令将会安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。\n\n建议采用 pnpm create vue@latest 进行创建。如果没有安装 pnpm 的话，可以先安装 pnpm，安装命令为：\n\nnpm install pnpm -g\n\n\n1\n\n\n这里使用 pnpm create vue@latest 命令创建 Vue3 项目的过程中，您将会看到一些如 TypeScript 和测试支持之类的可选功能提示：\n\n可按需要进行选择安装，这里我们选择 TypeScript、Vue Router、Pinia，其余的功能可以留待以后需要时再进行安装。\n\n✔ Project name: … <your-project-name>\n✔ Add TypeScript? … No / Yes -- y\n✔ Add JSX Support? … No / Yes\n✔ Add Vue Router for Single Page Application development? … No / Yes -- y\n✔ Add Pinia for state management? … No / Yes -- y\n✔ Add Vitest for Unit Testing? … No / Yes\n✔ Add an End-to-End Testing Solution? › No\n✔ Add ESLint for code quality? … No / Yes\n\nScaffolding project in ./<your-project-name>...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果我们在上面第一步 Project name 处输入项目名称 RealWorld-frontend 的话，项目创建成功后，会显示如下命令序列，提示您如何进行后续操作。\n\ncd realworld-frontend\npnpm install\npnpm dev\n\n\n1\n2\n3\n\n\n项目结构如下：\n\n├── public/                  // 公共资源目录\n│   └── favicon.ico          // 网站图标\n├── src/                     // 项目源码目录\n│   ├── assets/              // 静态资源目录（如图片、字体等）\n│   ├── components/          // 组件目录\n│   ├── router/              // 路由目录\n│   ├── stores/              // 状态管理目录\n│   ├── views/               // 视图目录\n│   ├── App.vue              // 根组件\n│   └── main.ts              // 项目入口文件\n├── .gitignore               // Git 忽略文件列表\n├── env.d.ts。               // 为用户自定义环境变量提供 TypeScript 智能提示\n├── index.html           \t\t // 入口 HTML 文件\n├── package.json             // 项目配置文件\n├── README.md                // 项目说明文件\n├── tsconfig.json            // TypeScript 配置文件\n├── tsconfig.node.json       // 为 Node.js 环境提供单独的TypeScript编译选项\n└── vite.config.js\t\t\t\t\t // Vite的配置文件，用于配置开发环境和生产环境的各种选项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 二、安装依赖\n\n按命令序列的前两条命令进行操作：\n\ncd realworld-frontend\t # 进入项目文件夹\npnpm install  # 安装依赖（推荐）\n\n\n1\n2\n\n\n依赖安装完成后，项目文件夹 RealWorld-frontend 中将多出一个子文件夹 node_modules：\n\n├── node_modules/            // 第三方依赖包目录\n├── public/                  \n├── src/                     \n│   ...\n\n\n1\n2\n3\n4\n\n\nnode_modules 文件夹里面就是按照 package.json 的指示下载的各种依赖。\n\n\n# 运行单页应用\n\n# 一、启动项目服务端\n\n项目服务端先启动起来，才能对浏览器端提供网页服务。启动命令为：pnpm dev 或 npm run dev\n\n启动成功后，屏幕显示：\n\n  VITE v4.2.1  ready in 416 ms\n\n  ➜  Local:   http://localhost:5173/\n  ➜  Network: use --host to expose\n  ➜  press h to show help\n\n\n1\n2\n3\n4\n5\n\n\n表明项目服务端已经运行在 5173 端口，等待浏览器的访问。\n\n# 二、从浏览器访问应用\n\n按住 Ctrl 键，并用鼠标单击链接 http://localhost:5173/，将在浏览器中打开应用的首页，内容如下图所示。\n\n\n\n\n# 任务二 了解组合式 API\n\n当使用 Vue 2 的 Options API 进行大型项目开发时，可能会遇到代码复杂度高、难以维护的问题。为了解决这个问题，Vue 3 提供了一种新的组件编写方式：组合式 API 和 setup() 函数。\n\n * 组合式 API 允许按照逻辑组织代码，而不是按照生命周期函数或选项来组织代码，从而提高了代码的可读性和可维护性。\n * setup() 函数在组件创建和挂载之前运行，用于设置组件的响应式数据、计算属性、方法和监听器等。在 setup() 函数中，可以使用 Vue 3 的组合式 API 如 ref、reactive、computed、watchEffect 等来实现组件的逻辑，从而更好地组织项目代码。\n\n\n# 使用 setup 函数\n\nVue 3 中的 setup() 函数是使用组合式 API 编写组件的入口函数，它会在组件实例创建之前被调用。\n\n在 setup() 函数内部，可以通过使用 Vue 3 提供的一系列组合式 API 来定义组件的响应式数据、计算属性、方法等等，并将它们返回给组件的模板中使用。setup() 函数返回的对象会被用作组件实例的数据对象，可以在模板中直接访问。\n\n以下是一个简单的例子，演示了如何使用 Vue 3 的 setup() 函数 和 reactive() 来创建一个响应式的计数器：\n\n<template>\n    <div>\n        <p>当前计数：{{ state.count }}</p>\n        <button @click=\"increment\">+ 1</button>\n    </div>\n</template>\n  \n<script>\nimport { reactive } from 'vue'\n\nexport default {\n    setup() {\n        const state = reactive({\n            count: 0\n        })\n\n        const increment = () => {\n            state.count++\n        }\n\n        return {\n            state,\n            increment\n        }\n    }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n在上述代码中，\n\n 1. 我们首先引入了 Vue 3 提供的 reactive 函数，用于创建响应式对象。\n 2. 在 setup() 函数中，我们使用 reactive 函数创建了一个名为 state 的响应式对象，包含了一个 count 属性。\n 3. 接着，我们定义了一个名为 increment 的方法，用于将 state 对象的 count 属性 +1。\n 4. 最后，我们将 state 和 increment 作为对象返回，供模板中使用。\n\n由于使用了 reactive 函数，state 对象是响应式的，因此它的值会自动更新到模板中。当state.count 属性更新时，模板中的数据也会更新。\n\n同样的响应式也可以通过 ref() 实现：\n\n<template>\n    <div>\n        <p>当前计数：{{ count }}</p>\n        <button @click=\"increment\">+1</button>\n    </div>\n</template>\n<script>\nimport { ref } from 'vue'\n\nexport default {\n    setup() {\n        const count = ref(0)\n\n        const increment = () => {\n            count.value++\n        }\n\n        return {\n            count,\n            increment\n        }\n    }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n由于 setup() 函数的执行时机早于 Vue 2 中的 created 钩子函数，可以在其中进行一些更早的初始化操作，提高组件的性能。\n\n总之，setup() 函数是 Vue 3 中使用组合式 API编写组件的重要入口函数，通过它可以更加自由地组织组件的逻辑，使得代码更加清晰易懂。\n\n\n# 使用 script setup\n\n * <script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖，用于简化组件的编写和组织。\n * 当同时使用 SFC 与组合式 API 时该语法是默认推荐。它允许在一个 <script> 标签内使用 Composition API，而不需要定义 setup() 函数或返回语句。\n * 它还提供了一些额外的功能，如自动导入和导出组件属性、响应式声明、类型推断等。\n\n使用 <script setup> 可以让组件的代码更加清晰和高效。相比于普通的 <script> 语法，它具有更多优势：\n\n * 更少的样板内容，更简洁的代码。\n * 能够使用纯 TypeScript 声明 props 和自定义事件。\n * 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。\n * 更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。\n\n下面是一个使用 <script setup> 的示例组件：\n\n<template>\n  <div>\n    <h1>{{ title }}</h1>\n    <button @click=\"increment\">Count: {{ count }}</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\n// 自动导出为组件属性\nconst title = 'Hello Vue 3'\n\n// 响应式声明\nconst count = ref(0)\n\n// 普通函数\nfunction increment() {\n  count.value++\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n用 <script setup> 语法糖改写目标 1 的代码：\n\n<template>\n  <div>\n    <p>当前计数：{{ count }}</p>\n    <button @click=\"increment\">+1</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nconst increment = () => {\n  count.value++\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可见，在 <script setup> 中 setup() 函数不用再写了，定义的变量和函数会自动暴露给模板，并且不需要再用 return 语句将它们导出。这样可以更简洁地编写 Vue 组件。\n\n\n# 引入 TypeScript\n\n在创建 Vue 3 + Vite 项目时，如果已经选择并安装了 “Add TypeScript”，那么就可以采用 TypeScript 编写组件，目标 2 中的代码用 TypeScript 可以改写为：\n\n<template>\n  <div>\n    <p>当前计数：{{ count }}</p>\n    <button @click=\"increment\">+1</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\n\nconst count = ref<number>(0)\n\nconst increment = () => {\n  count.value++\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * <script setup> 中的脚本可以使用 TypeScript 或 JavaScript 编写。这里我们写成 <script setup lang=\"ts\">，其中 lang=\"ts\" 是告诉 Vue 3，该组件的脚本使用 TypeScript 编写。使用 TypeScript 可以提供更好的类型检查和代码提示，以及更好的代码可维护性和可读性。根据在 lang 属性中指定的语言类型，Vue 3 会相应地对组件进行编译处理。如果没有指定 lang 属性，则默认使用 JavaScript 编写脚本。\n * 在这里，ref<number>(0) 表示将数字类型的值 0 转换为响应式对象。<number> 是 TypeScript 中的类型注解，用于指定 count 的类型为数字。这样在开发过程中，如果不小心给 count 赋予非数字类型的值，TypeScript 编译器就会提示错误。\n\n\n# 响应式\n\n所谓响应式，就是当我们修改数据后，可以自动做某些事情；对应到组件的渲染，就是修改数据后，能自动触发组件的重新渲染。这其实是一种状态驱动，让用户界面随着数据变化而自动更新的编程范式。\n\n响应式的核心思想是将数据和视图绑定在一起，当数据发生变化时，视图也会相应地变化，而不需要手动操作 DOM 元素。\n\n响应式的优点是可以简化前端开发的复杂度，提高用户体验和性能，避免不必要的重绘和重排。响应式的实现方式有多种，比如使用观察者模式、发布订阅模式、虚拟 DOM 等。响应式的代表框架有 React、Vue.js、Angular 等。\n\n\n# Vue 3 的响应式原理\n\nVue 3 的响应式原理是：基于 ES6 的 Proxy 和 Reflect 特性实现的，它可以对对象的各种操作进行拦截和处理，从而实现数据和视图的双向绑定。这个方法的本质是劫持了数据对象的读写。当我们访问数据时，会触发 getter 执行依赖收集；修改数据时，会触发 setter 派发通知。\n\nVue 3 的响应式原理主要包括以下几个步骤：\n\n 1. 创建一个响应式对象，使用 Proxy 对目标对象进行代理，拦截它的 get 和 set 操作，同时使用 Reflect 对操作进行反射，保证原对象的行为不受影响。\n\n 2. 在 get 操作中，收集依赖，即将当前的渲染函数或者副作用函数添加到目标对象的依赖集合中，这样当目标对象发生变化时，就可以通知这些函数进行更新。\n\n 3. 在 set 操作中，触发更新，即遍历目标对象的依赖集合，调用其中的函数，让它们重新执行，从而更新视图或者产生其他效果。\n\n 4. 重复以上步骤，实现数据和视图的动态响应。\n\nVue 3 的响应式原理相比于 Vue 2 的 Object.defineProperty 方式，有以下优势：\n\n * 可以拦截更多的操作，如 delete、has、ownKeys 等，提高了灵活性和兼容性。\n * 可以对数组和嵌套对象进行响应式处理，无需额外的处理逻辑。\n * 可以避免原对象被污染，保持了数据的纯净性。\n * 可以提高性能，减少了不必要的依赖收集和更新触发。\n\n\n# Vue 3 的响应式 API\n\nVue 3 的响应式 api 是一组新的功能，用于创建和管理响应式数据。\n\n它们可以让我们在组件中更灵活地组织和复用逻辑，也可以与其他 Vue 特性（如计算属性、侦听器、生命周期钩子等）配合使用。\n\nVue 3 的响应式 api 主要包括以下几个部分：\n\n 1. ref：用于创建一个响应式的值，可以是基本类型或对象类型。ref 返回一个包含 .value 属性的对象，通过这个属性可以访问或修改原始值。ref 也可以用于绑定模板中的 DOM 元素，通过 .value 获取元素的引用。\n 2. reactive：用于创建一个响应式的对象，可以是普通对象、数组或类实例。reactive 返回一个代理对象，通过这个对象可以访问或修改原始对象的属性。reactive 不会改变原始对象的结构和身份，只是在访问和修改时触发响应式效果。\n 3. computed：用于创建一个响应式的计算属性，可以根据其他响应式数据（如ref或reactive）动态地计算出一个值。computed 返回一个包含 .value 属性的对象，通过这个属性可以访问计算出的值。computed 也可以接受一个包含 get 和 set 函数的对象，实现可写的计算属性。\n 4. watch：用于监听一个或多个响应式数据（如ref或reactive）的变化，并执行相应的回调函数。watch 可以接受一个源数据或一个返回源数据的函数作为第一个参数，以及一个回调函数作为第二个参数。watch 也可以接受一个包含多个源数据和回调函数的数组作为参数，实现同时监听多个数据。\n 5. watchEffect：用于监听一个副作用函数中使用到的所有响应式数据的变化，并重新执行该函数。watchEffect 接受一个副作用函数作为参数，该函数会在首次调用时立即执行，并在后续任何依赖数据变化时重新执行。\n 6. toRefs：用于将一个响应式对象（如reactive）转换为一个普通对象，该对象的每个属性都是一个 ref，指向原始对象的对应属性。toRefs 可以保持原始对象的响应性，同时避免解构时丢失响应性。\n 7. toRaw：用于将一个响应式对象（如reactive）转换为原始对象，取消其响应性。toRaw 可以在需要直接操作原始对象而不触发响应式效果时使用。\n\n\n# 任务三 用 reactive 设置响应式数据\n\n\n# reactive 函数的原理及注意事项\n\n在 Vue 3 中，我们可以使用 Composition API 中的 reactive 函数来构建响应式对象。\n\n这个函数接收一个普通对象作为参数，并返回一个响应式代理对象。这个代理对象包含了原始对象的所有属性，并且这些属性都是响应式的。当我们访问代理对象的属性时，实际上是在访问原始对象的属性，因此会触发 getter 执行依赖收集。当我们修改代理对象的属性时，实际上是在修改原始对象的属性，因此会触发 setter 派发通知。这种方式比 Vue 2.x 中使用的 Object.defineProperty() 实现响应式更加高效和灵活。\n\n * 在使用 reactive 时，需要注意以下几点：\n\n * 只有在组件的 setup 函数中才能使用 reactive 函数。\n\n * 只有通过 reactive 函数创建的对象才是响应式数据对象，直接修改普通 JavaScript 对象的属性不会触发视图更新。\n\n * reactive 函数只能处理对象类型数据，如果需要处理其他类型数据，可以使用 ref 函数。\n\n * reactive 返回的是一个 Proxy 对象，而不是原始对象。\n\n * reactive 返回的 Proxy 对象可以直接访问原始对象的属性和方法。\n\n * reactive 返回的 Proxy 对象可以直接修改原始对象的属性和方法。\n\n * reactive 返回的 Proxy 对象可以直接监听原始对象的变化。\n\n * 在模板中使用响应式对象的属性时，需要使用 两个花括号 语法来绑定数据，例如\n   \n   {{ state.list }}\n   \n   \n   1\n   \n\n * 响应式对象的属性需要在对象创建时就定义好，不能在后面动态添加或删除属性。如果需要动态添加或删除属性，可以使用 reactive 函数创建一个新的响应式对象。\n\n * 在开发时，建议使用 toRefs 函数将响应式对象转换成普通对象的引用。这可以使代码更加清晰易懂，同时也能避免一些潜在的问题。\n\n\n# reactive 的使用举例\n\n# 一、reactive 作用于普通的 JavaScript 对象\n\n在 Vue 3 中，reactive 函数可以将一个普通的 JavaScript 对象转换成一个响应式数据对象，使得对象的属性可以被监听到变化并且自动更新视图。下面是 reactive 作用于对象的示例代码及注意事项：\n\n<template>\n    <button @click=\"changeName\">修改name</button><br>\n    <button @click=\"changeAge\">修改age</button><br>\n    <button @click=\"changeGender\">修改gender</button><br>\n    {{ state.person.name }} - {{ state.person.age }} - {{ state.person.gender }}\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst state = reactive({\n    person: {\n        name: 'Tom',\n        age: 18,\n        gender: 'male'\n    }\n})\n\n// 修改响应式对象的name\nfunction changeName() {\n    state.person.name = \"Linda\";\n    console.log(state.person.name) // 输出 Linda\n}\n\n// 修改响应式对象的age\nfunction changeAge() {\n    state.person.age++\n    console.log(state.person.age) // 输出 19\n}\n\n// 修改响应式对象的gender\nfunction changeGender() {\n    state.person.gender = \"female\"\n    console.log(state.person.gender) // 输出 female\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n注意事项：\n\n * 对于一个普通的 JavaScript 对象，通过 reactive 函数可以将其转换成一个响应式数据对象，使得对象的属性可以被监听到变化并且自动更新视图。\n * 只有通过 reactive 函数创建的对象才是响应式数据对象，直接修改普通 JavaScript 对象的属性不会触发视图更新。\n * 响应式对象的属性需要在对象创建时就定义好，不能在后面动态添加或删除属性。如果需要动态添加或删除属性，可以使用 reactive 函数创建一个新的响应式对象。\n * 响应式对象的属性值如果是一个对象，需要使用 reactive 函数将其转换成响应式对象，否则其属性变化不会触发视图更新。\n\n# 二、reactive 作用于数组\n\n在 Vue 3 中，reactive 函数也可以将一个普通的 JavaScript 数组转换成一个响应式数组，使得数组元素的变化可以被监听到并且自动更新视图。下面是一个 reactive 作用于数组的示例代码：\n\n<template>\n    <button @click=\"change\">修改元素</button><br>\n    <button @click=\"add\">添加元素</button><br>\n    <button @click=\"del\">删除元素</button><br>\n    {{ state.list }}\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst state = reactive({\n    list: ['apple', 'banana', 'orange']\n});\n\n// 修改响应式数组的元素\nfunction change() {\n    state.list[0] = 'pear'\n    console.log(state.list)  // 输出 Proxy(Array) {0: 'pear', 1: 'banana', 2: 'orange'}\n}\n\n// 向响应式数组中添加元素\nfunction add() {\n    state.list.push('grape')\n    console.log(state.list)  // 输出 Proxy(Array) {0: 'pear', 1: 'banana', 2: 'orange', 3: 'grape'}\n}\n\n// 从响应式数组中删除元素\nfunction del() {\n    state.list.splice(1, 1)\n    console.log(state.list)  // 输出 Proxy(Array) {0: 'pear', 1: 'orange', 2: 'grape'}\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n注意事项：\n\n * 响应式数组的元素操作需要使用 JavaScript 数组的操作方法，如 push()、pop()、shift()、unshift()、splice() 等。\n * 对响应式数组的操作会自动触发视图更新，无需手动调用。\n * 如果直接修改响应式数组的长度，例如 state.list.length = 2，则会导致视图无法更新，需要使用数组的操作方法进行操作。\n * 对响应式数组进行操作时，需要保证操作前后引用的是同一个数组对象，否则会导致视图无法更新。例如，不要使用 state.list = [] 的方式清空数组，而应该使用 state.list.splice(0, state.list.length) 的方式清空数组。\n\n\n# 任务四 用 ref 设置响应式数据\n\n\n# ref 的原理及注意事项\n\n在 Vue 3 中，ref 是一个函数，用于创建一个响应式数据对象，它可以将一个普通的 JavaScript 值转换成一个响应式数据对象，并提供了对该数据对象的访问和修改方法，使得修改该对象的值可以自动触发视图更新。（包裹一个值，这个值可以是对象类型也可以是基本类型，最终都会被转化成一个响应式对象）\n\nref 是基于 reactive 实现的。具体来说，ref 函数接受一个普通值作为参数，内部会使用 reactive 创建一个响应式对象来包裹这个值。当我们通过 .value 访问 ref 对象时，实际上是访问这个内部的响应式对象的值。\n\n举个例子，以下代码展示了 ref 的实现原理：\n\nimport { reactive } from 'vue'\n\nfunction ref(value) {\n  const obj = reactive({ value })\n\n  return {\n    get value() {\n      return obj.value\n    },\n    set value(newValue) {\n      obj.value = newValue\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面的代码中，ref 函数接受一个值作为参数，并使用 reactive 函数创建了一个包含该值的响应式对象 obj，然后返回一个包含 get 和 set 方法的对象，这两个方法用来获取和设置 obj.value 属性的值。\n\n当我们访问 ref 对象时，实际上是在访问这个对象的 value 属性，这个属性通过 get 方法返回 obj.value，当我们修改 ref 对象的值时，实际上是在修改这个对象内部响应式对象的值，这个操作通过 set 方法实现。\n\n因此，可以说 ref 是基于 reactive 实现的，它们都是 Vue 3 中用于创建响应式数据对象的重要函数。\n\n> 在 Vue 3 中既然有了 reactive，为何还要 ref 呢？\n\n当我们只想让某个变量实现响应式的时候，采用 reactive 就会比较麻烦，因此 Vue 3 提供了 ref 方法进行简单值的监听，但并不是说 ref 只能传入简单值，它的底层是 reactive，所以 reactive 有的，ref 都有。\n\n请牢牢记住：\n\n * ref 本质也是 reactive，ref(obj) 等价于 reactive({value: obj})。\n * 在 Vue 组件的 <script>...<\/script> 标签中使用 ref 的值，必须通过 .value 获取。\n * 在 Vue 组件的 <template>...</template> 标签中直接使用 ref 的值，不用也不能通过 .value 获取。\n\n\n# ref 的使用举例\n\n> 我们将前面用 reactive 实现的代码改为 ref 再实现一次：\n\n<template>\n    <button @click=\"changeName\">修改name</button><br>\n    <button @click=\"changeAge\">修改age</button><br>\n    <button @click=\"changeGender\">修改gender</button><br>\n    {{ name }} - {{ age }} - {{ gender }}\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\n// 包裹基本类型\nconst name = ref('Tom');\nconst age = ref(18);\nconst gender = ref('male');\n\n// 修改ref对象的name\nfunction changeName() {\n    name.value = \"Linda\";\n    console.log(name.value); // 输出 Linda\n}\n\n// 修改ref对象的age\nfunction changeAge() {\n    age.value++;\n    console.log(age.value); // 输出 19\n}\n\n// 修改ref对象的gender\nfunction changeGender() {\n    gender.value = \"female\";\n    console.log(gender.value); // 输出 female\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n在上面的代码中，我们使用 ref 分别创建了三个响应式数据 name、age 和 gender，它们的初始值分别为 'Tom'、18 和 'male'。同时，我们也将修改数据的三个函数 changeName、changeAge 和 changeGender 进行了相应的修改，使用 ref 对象的 .value 属性来修改值。\n\n通过这种方式，我们可以将原本使用 reactive 实现的代码转换为使用 ref 实现的代码，这样做可以使代码更加简洁和直观，同时也方便我们进行数据的管理和修改。\n\n> 前面说过，ref 函数并不只限于定义简单值，它仍然可以作用于对象。现在我们用 ref(obj) 的方式改写刚才的代码：\n\n<template>\n    <button @click=\"changeName\">修改name</button><br>\n    <button @click=\"changeAge\">修改age</button><br>\n    <button @click=\"changeGender\">修改gender</button><br>\n    {{ person.name }} - {{ person.age }} - {{ person.gender }}\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst person = ref({\n    name: 'Tom',\n    age: 18,\n    gender: 'male'\n});\n\n// 修改ref对象的name\nfunction changeName() {\n    person.value.name = \"Linda\"\n    console.log(person.value.name) // 输出 Linda\n}\n\n// 修改ref对象的age\nfunction changeAge() {\n    person.value.age++;\n    console.log(person.value.age) // 输出 19\n}\n\n// 修改ref对象的gender\nfunction changeGender() {\n    person.value.gender = \"female\"\n    console.log(person.value.gender) // 输出 female\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n在修改 person 对象的属性时，需要使用 person.value 来访问内部的对象。\n\n\n# 任务五 toRef() 与 toRefs()\n\n\n# toRef() 的使用场景\n\n# 1 问题引入\n\n先来看看下面的代码有什么问题：\n\n<template>\n  <div>\n    <p>Name: {{ user.name }}</p>\n    <p>Age: {{ user.age }}</p>\n    <p>Gender: {{ user.gender }}</p>\n    <button @click=\"changeInfo\">Change Info</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n\ninterface User {\n  name: string;\n  age: number;\n  gender: string;\n}\n\nconst user: User = {\n  name: 'John',\n  age: 25,\n  gender: 'male',\n}\n\nfunction changeInfo() {\n  user.name = 'Mary'\n  user.age = 30\n  user.gender = 'female'\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n这段代码存在的问题是：在 Vue3 中使用了非响应式的对象 user。由于 user 对象是普通的 JavaScript 对象，而不是 Vue 的响应式对象，所以当 changeInfo() 函数修改了 user 对象的属性时，界面不会更新。\n\n# 2 解决办法\n\n解决方法是使用 Vue 的响应式对象来代替普通 JavaScript 对象，例如使用 reactive() 函数来创建一个响应式对象。可以将 user 对象改为以下代码：\n\n<template>\n  <div>\n    <p>Name: {{ user.name }}</p>\n    <p>Age: {{ user.age }}</p>\n    <p>Gender: {{ user.gender }}</p>\n    <button @click=\"changeInfo\">Change Info</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { reactive } from 'vue'\ninterface User {\n  name: string;\n  age: number;\n  gender: string;\n}\n\nconst user = reactive({\n  name: 'John',\n  age: 25,\n  gender: 'male',\n})\n\nfunction changeInfo() {\n  user.name = 'Mary'\n  user.age = 30\n  user.gender = 'female'\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n这段代码确实实现了页面的同步更新，但模板里反复使用 user.前缀 显得有些冗余，如何减少模板中重复使用 user.前缀 的情况，从而提高了代码的可读性呢？\n\n# 3 继续改进\n\ntoRef 是 Vue3 中的一个工具函数，用于将响应式对象上的一个属性转换为一个单独的 ref 对象。我们尝试用它来减少模板中 user. 前缀的重复使用，代码如下：\n\n<template>\n  <div>\n    <p>Name: {{ name }}</p> // 少了前缀\n    <p>Age: {{ age }}</p>\n    <p>Gender: {{ gender }}</p>\n    <button @click=\"changeInfo\">Change Info</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { reactive, toRef } from 'vue'\n\ninterface User {\n  name: string;\n  age: number;\n  gender: string;\n}\n\nconst user: User = reactive({\n  name: 'John',\n  age: 25,\n  gender: 'male',\n});\n\nconst name = toRef(user, 'name')\nconst age = toRef(user, 'age')\nconst gender = toRef(user, 'gender')\n\nfunction changeInfo() {\n  name.value = 'Mary'\n  age.value = 30\n  gender.value = 'female'\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n当我们使用 toRef() 将一个响应式对象 user 的属性转化为 ref 后，该 ref 会与源对象的属性保持同步。这样创建的 ref 对象与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。\n\n\n# toRefs() 的使用场景\n\n# 一、问题引入\n\n在上面示例 3 的代码中，如果对象的属性很多，每个属性都要保持响应性，那么势必多次调用 toRef() 函数，有没有什么办法可以一次性将响应式对象上的所有属性都转换为 ref 对象，从而简化代码呢？\n\n# 二、解决办法\n\n使用 Vue3 的 toRefs() 函数可以一次性将响应式对象上的所有属性都转换为 ref 对象，并使用对象解构语法来进一步简化代码，代码如下：\n\n<template>\n  <div>\n    <p>Name: {{ name }}</p>\n    <p>Age: {{ age }}</p>\n    <p>Gender: {{ gender }}</p>\n    <button @click=\"changeInfo\">Change Info</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { reactive, toRefs } from 'vue'\n\ninterface User {\n  name: string;\n  age: number;\n  gender: string;\n}\n\nconst user: User = reactive({\n  name: 'John',\n  age: 25,\n  gender: 'male',\n})\n\nconst stateRefs = toRefs(user)\nconst { name, age, gender } = stateRefs\n\nfunction changeInfo() {\n  name.value = 'Mary'\n  age.value = 30\n  gender.value = 'female'\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n这段代码中使用 toRefs(user) 将响应式对象 user 中的所有属性（即name、age和gender）转换成对应的 ref 对象，并返回一个由这些 ref 对象组成的对象，这些 ref 对象的变化也会影响原响应式对象的属性。\n\n然后使用对象解构将它们分别赋值给 name、age 和 gender，这样，我们在模板中就可以直接访问这三个变量，而不用写成 stateRefs.name、stateRefs.age 和 stateRefs.gender 的形式。在 changeInfo 函数中，直接修改 name.value、age.value 和 gender.value 的值，这些值的变化会直接反映到原响应式对象 user 的属性上，从而触发页面的更新。\n\n\n# 任务六 computed 与计算属性\n\n\n# 基本概念\n\ncomputed 函数，是一个响应式 API，类似于 Vue2.x 中的 computed 属性。使用 computed 函数可以让代码更加简洁和高效。\n\ncomputed 函数的值就是计算属性。computed 函数可以使用响应式依赖来创建计算属性，计算属性会自动追踪响应式依赖，在其任何响应式依赖项更改时自动重新计算。\n\n在模板中绑定计算属性，当计算属性的值发生变化时，会触发组件的重新渲染。在模板中绑定计算属性的另一个好处是，可以在模板中声明性地指定复杂的逻辑，而不必手动更新值或在代码中执行计算。\n\n\n# 使用计算属性\n\n计算属性的使用场景。\n\n例如，考虑一个简单的 Vue 3 组件，该组件显示一个商品列表和这些商品的总数：\n\n<template>\n  <div>\n    <div v-if=\"isLoading\">Loading...</div>\n    <div v-else>\n      <ul>\n        <li v-for=\"item in goods\" :key=\"item.id\">{{ item.name }}</li>\n      </ul>\n      <p>商品总数: {{ totalGoods }}</p>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\n\ninterface Item {\n  id: number;\n  name: string;\n  price: number;\n}\n\nconst goods = ref<Item[]>([]);\n\nconst isLoading = computed(() => {\n  return goods.value.length === 0\n})\n\nconst totalGoods = computed(() => {\n  return goods.value.length\n})\n\nconst baseUrl = 'http://localhost:3000'\n\nconst fetchGoods = async () => {\n  try {\n    const res = await fetch(baseUrl + '/goods')\n    const data = await res.json()\n    goods.value = data as Item[]\n  } catch (e) {\n    throw new Error('an error happened' + e)\n  }\n}\n\nfetchGoods()\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n在这个例子中，totalGoods 计算属性函数负责计算 goods 数组中的商品总数。isLoading 计算属性基于 goods 数组的长度返回一个布尔值，指示组件是否处于加载状态。\n\n请注意，这里使用计算属性 isLoading 来定义应用程序是否正在加载。通常，很多开发人员会定义 isLoading 变量，并在调用 fetchGoods 时将变量 isLoading 设置为 true，然后在 API 请求完成后再将其设置为 false。比如：\n\n<script setup lang=\"ts\">\n\nconst isLoading = ref(true)\n// ...\nconst fetchGoods = async () => {\n  try {\n    isLoading.value = true\n    // 网络访问的代码 \n    // ...\n    isLoading.value = false\n  } catch (e) {\n  \t// ...\n  }\n}\n\nfetchGoods()\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n相对于 Goods02.vue，Goods.vue 使用计算属性实现了 Loading 的显示逻辑与商品数据获取逻辑之间的解耦。",normalizedContent:"# 任务一 创建 vite + vue3 单页应用\n\nvue 3 是一个流行的 javascript 前端框架，用于构建单页应用程序（spa）。\n\n下面是一些创建 vue 3 单页应用程序的方式：\n\n * vue cli：vue cli 是一个命令行界面工具，用于创建和管理 vue 应用程序。它可以自动生成一个基于 webpack 的项目模板，提供了一些内置的插件和特性，例如 babel、eslint、typescript 等。使用 vue cli 可以方便地创建 vue 单页应用程序。\n * 手动设置：你可以手动设置一个 vue 3 单页应用程序。这需要你手动创建 webpack 配置文件，并安装和配置必要的插件和库，如 vue-loader、babel-loader 等。这种方式更加灵活，但需要更多的配置和知识。\n * 使用 vite：vite 是一个现代化的构建工具，用于构建 vue 应用程序。它使用现代化的技术和原生 es 模块作为基础，提供了一种快速、轻量级的开发体验。你可以使用 vite 创建一个 vue 3 单页应用程序，只需运行几个命令即可。\n\n在本任务中，我们将使用 vite 来创建 vue 3 单页应用程序，因为它能够大幅简化开发流程。不过，如果您需要更加灵活的控制和定制，手动设置也是一个不错的选择。\n\n\n# 单页应用\n\n单页应用（single page application，spa）是一种 web 应用程序的架构模式，它使用动态加载的 html、css 和 javascript，以及 ajax 和 websockets 等技术实现无刷新页面的单页应用。\n\n> 核心思想\n\n单页应用的核心思想是：将所有的页面都加载到一个单一的 html 页面中，通过 javascript 操作 dom 实现页面的动态变化。\n\n> 数据交互过程\n\n当用户与应用程序交互时，javascript 会通过 ajax 或 websockets 等技术请求后端 api 获取数据，然后在前端通过 vue、react 等前端框架对数据进行处理，最终更新视图，从而实现页面的刷新和动态变化。\n\n> 优点\n\n单页应用的优点是：\n\n * 可以提高页面的加载速度和用户体验，因为只需要加载一次 html、css 和 javascript 等资源，之后就可以在前端通过 javascript 动态更新页面内容，而不需要重新加载整个页面。\n * 此外，单页应用还可以提高开发效率，因为前端可以采用组件化开发方式，将页面拆分为多个组件，每个组件可以独立开发和测试，最终再将这些组件拼接成完整的页面。\n\n> 缺点\n\n但是，单页应用也有一些缺点。\n\n * 首先，由于 spa 的内容是通过 javascript 动态加载的，对于 seo 来说并不友好。\n * 其次，spa 需要处理前后端分离的问题，需要前端开发人员和后端开发人员共同协作完成。此外，单页应用需要处理浏览器历史记录和 url 路由等问题，需要使用一些第三方库或框架来处理这些问题。\n\n> 多页应用\n\n相比之下，多页应用（mpa）的优点是：对 seo 友好，因为每个页面都有自己的 url 地址和内容，便于搜索引擎进行抓取和索引。此外，多页应用还可以采用传统的服务器渲染方式，在后端渲染页面，以提高页面的加载速度和 seo 效果。\n\n但是，多页应用的缺点是：页面切换需要重新加载整个页面，页面刷新和交互体验相对较差。此外，多页应用需要在前端和后端进行模板渲染，代码复杂度相对较高，开发效率相对较低。\n\n因此，选择单页应用（spa）还是多页应用（mpa）取决于项目的具体需求和情况。如果项目注重用户体验和开发效率，且对 seo 不是特别敏感，可以选择 spa。\n\n> 为什么 spa 对 seo 不友好？\n\n在这句话中，seo 指的是搜索引擎优化（search engine optimization），即通过优化网站以提高其在搜索引擎中的排名和可见性。\n\n\"对于 seo 来说并不友好\"指的是：单页面应用（spa）对于传统的搜索引擎优化方法不太友好。\n\n原因：\n\nspa 是一种通过 javascript 动态加载内容的网页应用，它使用 ajax 和前端路由等技术实现页面的无刷新加载和内容的动态更新。\n\n由于 spa 的内容大部分是在客户端通过 javascript 生成和加载的，而传统的搜索引擎爬虫通常只会抓取和索引【静态 html 页面】，因此无法直接获取和理解 spa 中的内容。\n\n这导致了 spa 在搜索引擎中的可见性和排名受到一定影响。因为搜索引擎无法像普通的 html 页面那样直接抓取和索引【spa 的内容】，所以对于那些依赖搜索引擎流量的网站来说，spa 可能无法获得足够的有机流量。\n\n解决方法:\n\n然而，随着搜索引擎的发展，一些搜索引擎（如google）已经可以执行 javascript 并抓取 spa 的内容。同时，也出现了一些技术和方法来解决 spa 的 seo 问题，例如使用预渲染技术、动态生成静态页面、使用服务器端渲染（ssr）等。这些方法可以帮助 spa 在搜索引擎中获得更好的可见性和排名，提高其对 seo 的友好程度。\n\n\n# vue 3 对单页应用开发的支持\n\nvue.js 是一个用于构建现代 web 应用的渐进式框架，它对开发单页应用提供了很多支持。我们习惯把 vue.js 2.x 和 vue.js 3.x 版本分别简称为 vue2 和 vue 3。\n\n以下是一些 vue 3 的特性，它们可以帮助开发者更容易地创建和维护单页应用：\n\n * 使用了响应式数据绑定和组件化的思想，让开发者可以快速构建高效的用户界面。\n * 组合式 api：这是 vue 3 的一个新特性，它允许开发者使用函数式的方式来组织和复用组件的逻辑，而不是依赖于选项式 api 的 data、methods、computed 等属性。这样可以让组件的代码更加清晰和模块化，也可以避免命名冲突和数据依赖的问题。\n * 优化的虚拟 dom：虚拟 dom 是 vue 的核心特性之一，它可以让开发者使用声明式的语法来渲染界面，而不需要直接操作 dom。vue 3 对虚拟 dom 进行了优化，使其更加高效和灵活。例如，vue 3 引入了静态标记（hoisting）、片段（fragments）、模块化运行时（tree-shaking）等技术，来减少不必要的渲染和内存占用。\n * 支持 typescript：typescript 是一种在 javascript 基础上增加了类型检查和其他特性的编程语言，它可以提高代码的可读性和可维护性，也可以避免一些常见的错误。vue 3 完全支持 typescript，不仅在源码层面使用了 typescript，还提供了完善的类型声明文件，让开发者可以在编辑器中享受到智能提示和错误检测的功能。\n * 更多的内置组件和指令：vue 3 提供了一些新的内置组件和指令，来增强 spa 的交互和功能。例如，<teleport> 组件可以让开发者将子组件渲染到任意位置，<suspense> 组件可以让开发者处理异步组件的加载状态。\n\n总之，vue3+vite 是一种非常适合开发单页应用的技术栈，它可以让开发者享受到最新的前端技术和最佳的开发体验。\n\n\n# 安装 node.js\n\n创建 vite+vue3 项目需要安装 16.0 或更高版本的 node.js。您可以在命令行中运行 node -v 命令来检查您是否已安装了 node 环境。如果没有安装或版本不对的话，可以按照下面的步骤进行安装。\n\n# 一、下载 node.js\n\n下载地址：https://nodejs.org/zh-cn/download/\n\n下载长期维护版：\n\n\n\n# 二、安装 node.js\n\n以 windows 系统为例，下载 node.js 安装包后，双击一路安装即可。安装过程，除了 node.js 外，还会一并安装 npm 包管理器。启动 node.js 和 npm 的命令分别是：\n\nnode   \nnpm \n\n\n1\n2\n\n\n# 三、测试安装是否成功\n\n安装完成后，注意测试安装是否成功，测试命令：\n\nnode -v\nnpm -v\n\n\n1\n2\n\n\n如果显示出 node.js 和 npm 的版本号，表明安装成功。否则，需要检查环境变量的配置。\n\n\n# 创建 vite+vue3 单页应用\n\nvue cli 和 vite 都是用于创建 vue 项目的构建工具。\n\nvue cli 是一个基于 webpack 的构建工具，它提供了一个完整的项目脚手架，包括开发服务器、热重载、代码分割、eslint 等等。\n\nvite 是一个基于 es 模块的构建工具，它使用浏览器原生的 es 模块加载器来提供快速的开发体验。vite 提供了零配置的开发环境，无需安装和配置 webpack 等复杂的工具，只需一个 vite.config.js 文件即可启动一个本地服务器，因此它可以更快地启动和重载。vite 支持 typescript、css 预处理器、jsx 等常用的功能，并且在生产环境中也可以更快地构建。\n\n# 一、创建项目\n\n使用 npm 或 pnpm 命令均可创建 vite+vue3 单页应用：\n\nnpm init vue@latest\n或\npnpm create vue@latest\n\n\n1\n2\n3\n\n\n这一命令将会安装并执行 create-vue，它是 vue 官方的项目脚手架工具。\n\n建议采用 pnpm create vue@latest 进行创建。如果没有安装 pnpm 的话，可以先安装 pnpm，安装命令为：\n\nnpm install pnpm -g\n\n\n1\n\n\n这里使用 pnpm create vue@latest 命令创建 vue3 项目的过程中，您将会看到一些如 typescript 和测试支持之类的可选功能提示：\n\n可按需要进行选择安装，这里我们选择 typescript、vue router、pinia，其余的功能可以留待以后需要时再进行安装。\n\n✔ project name: … <your-project-name>\n✔ add typescript? … no / yes -- y\n✔ add jsx support? … no / yes\n✔ add vue router for single page application development? … no / yes -- y\n✔ add pinia for state management? … no / yes -- y\n✔ add vitest for unit testing? … no / yes\n✔ add an end-to-end testing solution? › no\n✔ add eslint for code quality? … no / yes\n\nscaffolding project in ./<your-project-name>...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果我们在上面第一步 project name 处输入项目名称 realworld-frontend 的话，项目创建成功后，会显示如下命令序列，提示您如何进行后续操作。\n\ncd realworld-frontend\npnpm install\npnpm dev\n\n\n1\n2\n3\n\n\n项目结构如下：\n\n├── public/                  // 公共资源目录\n│   └── favicon.ico          // 网站图标\n├── src/                     // 项目源码目录\n│   ├── assets/              // 静态资源目录（如图片、字体等）\n│   ├── components/          // 组件目录\n│   ├── router/              // 路由目录\n│   ├── stores/              // 状态管理目录\n│   ├── views/               // 视图目录\n│   ├── app.vue              // 根组件\n│   └── main.ts              // 项目入口文件\n├── .gitignore               // git 忽略文件列表\n├── env.d.ts。               // 为用户自定义环境变量提供 typescript 智能提示\n├── index.html           \t\t // 入口 html 文件\n├── package.json             // 项目配置文件\n├── readme.md                // 项目说明文件\n├── tsconfig.json            // typescript 配置文件\n├── tsconfig.node.json       // 为 node.js 环境提供单独的typescript编译选项\n└── vite.config.js\t\t\t\t\t // vite的配置文件，用于配置开发环境和生产环境的各种选项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 二、安装依赖\n\n按命令序列的前两条命令进行操作：\n\ncd realworld-frontend\t # 进入项目文件夹\npnpm install  # 安装依赖（推荐）\n\n\n1\n2\n\n\n依赖安装完成后，项目文件夹 realworld-frontend 中将多出一个子文件夹 node_modules：\n\n├── node_modules/            // 第三方依赖包目录\n├── public/                  \n├── src/                     \n│   ...\n\n\n1\n2\n3\n4\n\n\nnode_modules 文件夹里面就是按照 package.json 的指示下载的各种依赖。\n\n\n# 运行单页应用\n\n# 一、启动项目服务端\n\n项目服务端先启动起来，才能对浏览器端提供网页服务。启动命令为：pnpm dev 或 npm run dev\n\n启动成功后，屏幕显示：\n\n  vite v4.2.1  ready in 416 ms\n\n  ➜  local:   http://localhost:5173/\n  ➜  network: use --host to expose\n  ➜  press h to show help\n\n\n1\n2\n3\n4\n5\n\n\n表明项目服务端已经运行在 5173 端口，等待浏览器的访问。\n\n# 二、从浏览器访问应用\n\n按住 ctrl 键，并用鼠标单击链接 http://localhost:5173/，将在浏览器中打开应用的首页，内容如下图所示。\n\n\n\n\n# 任务二 了解组合式 api\n\n当使用 vue 2 的 options api 进行大型项目开发时，可能会遇到代码复杂度高、难以维护的问题。为了解决这个问题，vue 3 提供了一种新的组件编写方式：组合式 api 和 setup() 函数。\n\n * 组合式 api 允许按照逻辑组织代码，而不是按照生命周期函数或选项来组织代码，从而提高了代码的可读性和可维护性。\n * setup() 函数在组件创建和挂载之前运行，用于设置组件的响应式数据、计算属性、方法和监听器等。在 setup() 函数中，可以使用 vue 3 的组合式 api 如 ref、reactive、computed、watcheffect 等来实现组件的逻辑，从而更好地组织项目代码。\n\n\n# 使用 setup 函数\n\nvue 3 中的 setup() 函数是使用组合式 api 编写组件的入口函数，它会在组件实例创建之前被调用。\n\n在 setup() 函数内部，可以通过使用 vue 3 提供的一系列组合式 api 来定义组件的响应式数据、计算属性、方法等等，并将它们返回给组件的模板中使用。setup() 函数返回的对象会被用作组件实例的数据对象，可以在模板中直接访问。\n\n以下是一个简单的例子，演示了如何使用 vue 3 的 setup() 函数 和 reactive() 来创建一个响应式的计数器：\n\n<template>\n    <div>\n        <p>当前计数：{{ state.count }}</p>\n        <button @click=\"increment\">+ 1</button>\n    </div>\n</template>\n  \n<script>\nimport { reactive } from 'vue'\n\nexport default {\n    setup() {\n        const state = reactive({\n            count: 0\n        })\n\n        const increment = () => {\n            state.count++\n        }\n\n        return {\n            state,\n            increment\n        }\n    }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n在上述代码中，\n\n 1. 我们首先引入了 vue 3 提供的 reactive 函数，用于创建响应式对象。\n 2. 在 setup() 函数中，我们使用 reactive 函数创建了一个名为 state 的响应式对象，包含了一个 count 属性。\n 3. 接着，我们定义了一个名为 increment 的方法，用于将 state 对象的 count 属性 +1。\n 4. 最后，我们将 state 和 increment 作为对象返回，供模板中使用。\n\n由于使用了 reactive 函数，state 对象是响应式的，因此它的值会自动更新到模板中。当state.count 属性更新时，模板中的数据也会更新。\n\n同样的响应式也可以通过 ref() 实现：\n\n<template>\n    <div>\n        <p>当前计数：{{ count }}</p>\n        <button @click=\"increment\">+1</button>\n    </div>\n</template>\n<script>\nimport { ref } from 'vue'\n\nexport default {\n    setup() {\n        const count = ref(0)\n\n        const increment = () => {\n            count.value++\n        }\n\n        return {\n            count,\n            increment\n        }\n    }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n由于 setup() 函数的执行时机早于 vue 2 中的 created 钩子函数，可以在其中进行一些更早的初始化操作，提高组件的性能。\n\n总之，setup() 函数是 vue 3 中使用组合式 api编写组件的重要入口函数，通过它可以更加自由地组织组件的逻辑，使得代码更加清晰易懂。\n\n\n# 使用 script setup\n\n * <script setup> 是在单文件组件 (sfc) 中使用组合式 api 的编译时语法糖，用于简化组件的编写和组织。\n * 当同时使用 sfc 与组合式 api 时该语法是默认推荐。它允许在一个 <script> 标签内使用 composition api，而不需要定义 setup() 函数或返回语句。\n * 它还提供了一些额外的功能，如自动导入和导出组件属性、响应式声明、类型推断等。\n\n使用 <script setup> 可以让组件的代码更加清晰和高效。相比于普通的 <script> 语法，它具有更多优势：\n\n * 更少的样板内容，更简洁的代码。\n * 能够使用纯 typescript 声明 props 和自定义事件。\n * 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。\n * 更好的 ide 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。\n\n下面是一个使用 <script setup> 的示例组件：\n\n<template>\n  <div>\n    <h1>{{ title }}</h1>\n    <button @click=\"increment\">count: {{ count }}</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\n// 自动导出为组件属性\nconst title = 'hello vue 3'\n\n// 响应式声明\nconst count = ref(0)\n\n// 普通函数\nfunction increment() {\n  count.value++\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n用 <script setup> 语法糖改写目标 1 的代码：\n\n<template>\n  <div>\n    <p>当前计数：{{ count }}</p>\n    <button @click=\"increment\">+1</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nconst increment = () => {\n  count.value++\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n可见，在 <script setup> 中 setup() 函数不用再写了，定义的变量和函数会自动暴露给模板，并且不需要再用 return 语句将它们导出。这样可以更简洁地编写 vue 组件。\n\n\n# 引入 typescript\n\n在创建 vue 3 + vite 项目时，如果已经选择并安装了 “add typescript”，那么就可以采用 typescript 编写组件，目标 2 中的代码用 typescript 可以改写为：\n\n<template>\n  <div>\n    <p>当前计数：{{ count }}</p>\n    <button @click=\"increment\">+1</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\n\nconst count = ref<number>(0)\n\nconst increment = () => {\n  count.value++\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * <script setup> 中的脚本可以使用 typescript 或 javascript 编写。这里我们写成 <script setup lang=\"ts\">，其中 lang=\"ts\" 是告诉 vue 3，该组件的脚本使用 typescript 编写。使用 typescript 可以提供更好的类型检查和代码提示，以及更好的代码可维护性和可读性。根据在 lang 属性中指定的语言类型，vue 3 会相应地对组件进行编译处理。如果没有指定 lang 属性，则默认使用 javascript 编写脚本。\n * 在这里，ref<number>(0) 表示将数字类型的值 0 转换为响应式对象。<number> 是 typescript 中的类型注解，用于指定 count 的类型为数字。这样在开发过程中，如果不小心给 count 赋予非数字类型的值，typescript 编译器就会提示错误。\n\n\n# 响应式\n\n所谓响应式，就是当我们修改数据后，可以自动做某些事情；对应到组件的渲染，就是修改数据后，能自动触发组件的重新渲染。这其实是一种状态驱动，让用户界面随着数据变化而自动更新的编程范式。\n\n响应式的核心思想是将数据和视图绑定在一起，当数据发生变化时，视图也会相应地变化，而不需要手动操作 dom 元素。\n\n响应式的优点是可以简化前端开发的复杂度，提高用户体验和性能，避免不必要的重绘和重排。响应式的实现方式有多种，比如使用观察者模式、发布订阅模式、虚拟 dom 等。响应式的代表框架有 react、vue.js、angular 等。\n\n\n# vue 3 的响应式原理\n\nvue 3 的响应式原理是：基于 es6 的 proxy 和 reflect 特性实现的，它可以对对象的各种操作进行拦截和处理，从而实现数据和视图的双向绑定。这个方法的本质是劫持了数据对象的读写。当我们访问数据时，会触发 getter 执行依赖收集；修改数据时，会触发 setter 派发通知。\n\nvue 3 的响应式原理主要包括以下几个步骤：\n\n 1. 创建一个响应式对象，使用 proxy 对目标对象进行代理，拦截它的 get 和 set 操作，同时使用 reflect 对操作进行反射，保证原对象的行为不受影响。\n\n 2. 在 get 操作中，收集依赖，即将当前的渲染函数或者副作用函数添加到目标对象的依赖集合中，这样当目标对象发生变化时，就可以通知这些函数进行更新。\n\n 3. 在 set 操作中，触发更新，即遍历目标对象的依赖集合，调用其中的函数，让它们重新执行，从而更新视图或者产生其他效果。\n\n 4. 重复以上步骤，实现数据和视图的动态响应。\n\nvue 3 的响应式原理相比于 vue 2 的 object.defineproperty 方式，有以下优势：\n\n * 可以拦截更多的操作，如 delete、has、ownkeys 等，提高了灵活性和兼容性。\n * 可以对数组和嵌套对象进行响应式处理，无需额外的处理逻辑。\n * 可以避免原对象被污染，保持了数据的纯净性。\n * 可以提高性能，减少了不必要的依赖收集和更新触发。\n\n\n# vue 3 的响应式 api\n\nvue 3 的响应式 api 是一组新的功能，用于创建和管理响应式数据。\n\n它们可以让我们在组件中更灵活地组织和复用逻辑，也可以与其他 vue 特性（如计算属性、侦听器、生命周期钩子等）配合使用。\n\nvue 3 的响应式 api 主要包括以下几个部分：\n\n 1. ref：用于创建一个响应式的值，可以是基本类型或对象类型。ref 返回一个包含 .value 属性的对象，通过这个属性可以访问或修改原始值。ref 也可以用于绑定模板中的 dom 元素，通过 .value 获取元素的引用。\n 2. reactive：用于创建一个响应式的对象，可以是普通对象、数组或类实例。reactive 返回一个代理对象，通过这个对象可以访问或修改原始对象的属性。reactive 不会改变原始对象的结构和身份，只是在访问和修改时触发响应式效果。\n 3. computed：用于创建一个响应式的计算属性，可以根据其他响应式数据（如ref或reactive）动态地计算出一个值。computed 返回一个包含 .value 属性的对象，通过这个属性可以访问计算出的值。computed 也可以接受一个包含 get 和 set 函数的对象，实现可写的计算属性。\n 4. watch：用于监听一个或多个响应式数据（如ref或reactive）的变化，并执行相应的回调函数。watch 可以接受一个源数据或一个返回源数据的函数作为第一个参数，以及一个回调函数作为第二个参数。watch 也可以接受一个包含多个源数据和回调函数的数组作为参数，实现同时监听多个数据。\n 5. watcheffect：用于监听一个副作用函数中使用到的所有响应式数据的变化，并重新执行该函数。watcheffect 接受一个副作用函数作为参数，该函数会在首次调用时立即执行，并在后续任何依赖数据变化时重新执行。\n 6. torefs：用于将一个响应式对象（如reactive）转换为一个普通对象，该对象的每个属性都是一个 ref，指向原始对象的对应属性。torefs 可以保持原始对象的响应性，同时避免解构时丢失响应性。\n 7. toraw：用于将一个响应式对象（如reactive）转换为原始对象，取消其响应性。toraw 可以在需要直接操作原始对象而不触发响应式效果时使用。\n\n\n# 任务三 用 reactive 设置响应式数据\n\n\n# reactive 函数的原理及注意事项\n\n在 vue 3 中，我们可以使用 composition api 中的 reactive 函数来构建响应式对象。\n\n这个函数接收一个普通对象作为参数，并返回一个响应式代理对象。这个代理对象包含了原始对象的所有属性，并且这些属性都是响应式的。当我们访问代理对象的属性时，实际上是在访问原始对象的属性，因此会触发 getter 执行依赖收集。当我们修改代理对象的属性时，实际上是在修改原始对象的属性，因此会触发 setter 派发通知。这种方式比 vue 2.x 中使用的 object.defineproperty() 实现响应式更加高效和灵活。\n\n * 在使用 reactive 时，需要注意以下几点：\n\n * 只有在组件的 setup 函数中才能使用 reactive 函数。\n\n * 只有通过 reactive 函数创建的对象才是响应式数据对象，直接修改普通 javascript 对象的属性不会触发视图更新。\n\n * reactive 函数只能处理对象类型数据，如果需要处理其他类型数据，可以使用 ref 函数。\n\n * reactive 返回的是一个 proxy 对象，而不是原始对象。\n\n * reactive 返回的 proxy 对象可以直接访问原始对象的属性和方法。\n\n * reactive 返回的 proxy 对象可以直接修改原始对象的属性和方法。\n\n * reactive 返回的 proxy 对象可以直接监听原始对象的变化。\n\n * 在模板中使用响应式对象的属性时，需要使用 两个花括号 语法来绑定数据，例如\n   \n   {{ state.list }}\n   \n   \n   1\n   \n\n * 响应式对象的属性需要在对象创建时就定义好，不能在后面动态添加或删除属性。如果需要动态添加或删除属性，可以使用 reactive 函数创建一个新的响应式对象。\n\n * 在开发时，建议使用 torefs 函数将响应式对象转换成普通对象的引用。这可以使代码更加清晰易懂，同时也能避免一些潜在的问题。\n\n\n# reactive 的使用举例\n\n# 一、reactive 作用于普通的 javascript 对象\n\n在 vue 3 中，reactive 函数可以将一个普通的 javascript 对象转换成一个响应式数据对象，使得对象的属性可以被监听到变化并且自动更新视图。下面是 reactive 作用于对象的示例代码及注意事项：\n\n<template>\n    <button @click=\"changename\">修改name</button><br>\n    <button @click=\"changeage\">修改age</button><br>\n    <button @click=\"changegender\">修改gender</button><br>\n    {{ state.person.name }} - {{ state.person.age }} - {{ state.person.gender }}\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst state = reactive({\n    person: {\n        name: 'tom',\n        age: 18,\n        gender: 'male'\n    }\n})\n\n// 修改响应式对象的name\nfunction changename() {\n    state.person.name = \"linda\";\n    console.log(state.person.name) // 输出 linda\n}\n\n// 修改响应式对象的age\nfunction changeage() {\n    state.person.age++\n    console.log(state.person.age) // 输出 19\n}\n\n// 修改响应式对象的gender\nfunction changegender() {\n    state.person.gender = \"female\"\n    console.log(state.person.gender) // 输出 female\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n注意事项：\n\n * 对于一个普通的 javascript 对象，通过 reactive 函数可以将其转换成一个响应式数据对象，使得对象的属性可以被监听到变化并且自动更新视图。\n * 只有通过 reactive 函数创建的对象才是响应式数据对象，直接修改普通 javascript 对象的属性不会触发视图更新。\n * 响应式对象的属性需要在对象创建时就定义好，不能在后面动态添加或删除属性。如果需要动态添加或删除属性，可以使用 reactive 函数创建一个新的响应式对象。\n * 响应式对象的属性值如果是一个对象，需要使用 reactive 函数将其转换成响应式对象，否则其属性变化不会触发视图更新。\n\n# 二、reactive 作用于数组\n\n在 vue 3 中，reactive 函数也可以将一个普通的 javascript 数组转换成一个响应式数组，使得数组元素的变化可以被监听到并且自动更新视图。下面是一个 reactive 作用于数组的示例代码：\n\n<template>\n    <button @click=\"change\">修改元素</button><br>\n    <button @click=\"add\">添加元素</button><br>\n    <button @click=\"del\">删除元素</button><br>\n    {{ state.list }}\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst state = reactive({\n    list: ['apple', 'banana', 'orange']\n});\n\n// 修改响应式数组的元素\nfunction change() {\n    state.list[0] = 'pear'\n    console.log(state.list)  // 输出 proxy(array) {0: 'pear', 1: 'banana', 2: 'orange'}\n}\n\n// 向响应式数组中添加元素\nfunction add() {\n    state.list.push('grape')\n    console.log(state.list)  // 输出 proxy(array) {0: 'pear', 1: 'banana', 2: 'orange', 3: 'grape'}\n}\n\n// 从响应式数组中删除元素\nfunction del() {\n    state.list.splice(1, 1)\n    console.log(state.list)  // 输出 proxy(array) {0: 'pear', 1: 'orange', 2: 'grape'}\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n注意事项：\n\n * 响应式数组的元素操作需要使用 javascript 数组的操作方法，如 push()、pop()、shift()、unshift()、splice() 等。\n * 对响应式数组的操作会自动触发视图更新，无需手动调用。\n * 如果直接修改响应式数组的长度，例如 state.list.length = 2，则会导致视图无法更新，需要使用数组的操作方法进行操作。\n * 对响应式数组进行操作时，需要保证操作前后引用的是同一个数组对象，否则会导致视图无法更新。例如，不要使用 state.list = [] 的方式清空数组，而应该使用 state.list.splice(0, state.list.length) 的方式清空数组。\n\n\n# 任务四 用 ref 设置响应式数据\n\n\n# ref 的原理及注意事项\n\n在 vue 3 中，ref 是一个函数，用于创建一个响应式数据对象，它可以将一个普通的 javascript 值转换成一个响应式数据对象，并提供了对该数据对象的访问和修改方法，使得修改该对象的值可以自动触发视图更新。（包裹一个值，这个值可以是对象类型也可以是基本类型，最终都会被转化成一个响应式对象）\n\nref 是基于 reactive 实现的。具体来说，ref 函数接受一个普通值作为参数，内部会使用 reactive 创建一个响应式对象来包裹这个值。当我们通过 .value 访问 ref 对象时，实际上是访问这个内部的响应式对象的值。\n\n举个例子，以下代码展示了 ref 的实现原理：\n\nimport { reactive } from 'vue'\n\nfunction ref(value) {\n  const obj = reactive({ value })\n\n  return {\n    get value() {\n      return obj.value\n    },\n    set value(newvalue) {\n      obj.value = newvalue\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面的代码中，ref 函数接受一个值作为参数，并使用 reactive 函数创建了一个包含该值的响应式对象 obj，然后返回一个包含 get 和 set 方法的对象，这两个方法用来获取和设置 obj.value 属性的值。\n\n当我们访问 ref 对象时，实际上是在访问这个对象的 value 属性，这个属性通过 get 方法返回 obj.value，当我们修改 ref 对象的值时，实际上是在修改这个对象内部响应式对象的值，这个操作通过 set 方法实现。\n\n因此，可以说 ref 是基于 reactive 实现的，它们都是 vue 3 中用于创建响应式数据对象的重要函数。\n\n> 在 vue 3 中既然有了 reactive，为何还要 ref 呢？\n\n当我们只想让某个变量实现响应式的时候，采用 reactive 就会比较麻烦，因此 vue 3 提供了 ref 方法进行简单值的监听，但并不是说 ref 只能传入简单值，它的底层是 reactive，所以 reactive 有的，ref 都有。\n\n请牢牢记住：\n\n * ref 本质也是 reactive，ref(obj) 等价于 reactive({value: obj})。\n * 在 vue 组件的 <script>...<\/script> 标签中使用 ref 的值，必须通过 .value 获取。\n * 在 vue 组件的 <template>...</template> 标签中直接使用 ref 的值，不用也不能通过 .value 获取。\n\n\n# ref 的使用举例\n\n> 我们将前面用 reactive 实现的代码改为 ref 再实现一次：\n\n<template>\n    <button @click=\"changename\">修改name</button><br>\n    <button @click=\"changeage\">修改age</button><br>\n    <button @click=\"changegender\">修改gender</button><br>\n    {{ name }} - {{ age }} - {{ gender }}\n</template>\n\n<script setup>\nimport { ref } from 'vue';\n\n// 包裹基本类型\nconst name = ref('tom');\nconst age = ref(18);\nconst gender = ref('male');\n\n// 修改ref对象的name\nfunction changename() {\n    name.value = \"linda\";\n    console.log(name.value); // 输出 linda\n}\n\n// 修改ref对象的age\nfunction changeage() {\n    age.value++;\n    console.log(age.value); // 输出 19\n}\n\n// 修改ref对象的gender\nfunction changegender() {\n    gender.value = \"female\";\n    console.log(gender.value); // 输出 female\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n在上面的代码中，我们使用 ref 分别创建了三个响应式数据 name、age 和 gender，它们的初始值分别为 'tom'、18 和 'male'。同时，我们也将修改数据的三个函数 changename、changeage 和 changegender 进行了相应的修改，使用 ref 对象的 .value 属性来修改值。\n\n通过这种方式，我们可以将原本使用 reactive 实现的代码转换为使用 ref 实现的代码，这样做可以使代码更加简洁和直观，同时也方便我们进行数据的管理和修改。\n\n> 前面说过，ref 函数并不只限于定义简单值，它仍然可以作用于对象。现在我们用 ref(obj) 的方式改写刚才的代码：\n\n<template>\n    <button @click=\"changename\">修改name</button><br>\n    <button @click=\"changeage\">修改age</button><br>\n    <button @click=\"changegender\">修改gender</button><br>\n    {{ person.name }} - {{ person.age }} - {{ person.gender }}\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst person = ref({\n    name: 'tom',\n    age: 18,\n    gender: 'male'\n});\n\n// 修改ref对象的name\nfunction changename() {\n    person.value.name = \"linda\"\n    console.log(person.value.name) // 输出 linda\n}\n\n// 修改ref对象的age\nfunction changeage() {\n    person.value.age++;\n    console.log(person.value.age) // 输出 19\n}\n\n// 修改ref对象的gender\nfunction changegender() {\n    person.value.gender = \"female\"\n    console.log(person.value.gender) // 输出 female\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n在修改 person 对象的属性时，需要使用 person.value 来访问内部的对象。\n\n\n# 任务五 toref() 与 torefs()\n\n\n# toref() 的使用场景\n\n# 1 问题引入\n\n先来看看下面的代码有什么问题：\n\n<template>\n  <div>\n    <p>name: {{ user.name }}</p>\n    <p>age: {{ user.age }}</p>\n    <p>gender: {{ user.gender }}</p>\n    <button @click=\"changeinfo\">change info</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n\ninterface user {\n  name: string;\n  age: number;\n  gender: string;\n}\n\nconst user: user = {\n  name: 'john',\n  age: 25,\n  gender: 'male',\n}\n\nfunction changeinfo() {\n  user.name = 'mary'\n  user.age = 30\n  user.gender = 'female'\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n这段代码存在的问题是：在 vue3 中使用了非响应式的对象 user。由于 user 对象是普通的 javascript 对象，而不是 vue 的响应式对象，所以当 changeinfo() 函数修改了 user 对象的属性时，界面不会更新。\n\n# 2 解决办法\n\n解决方法是使用 vue 的响应式对象来代替普通 javascript 对象，例如使用 reactive() 函数来创建一个响应式对象。可以将 user 对象改为以下代码：\n\n<template>\n  <div>\n    <p>name: {{ user.name }}</p>\n    <p>age: {{ user.age }}</p>\n    <p>gender: {{ user.gender }}</p>\n    <button @click=\"changeinfo\">change info</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { reactive } from 'vue'\ninterface user {\n  name: string;\n  age: number;\n  gender: string;\n}\n\nconst user = reactive({\n  name: 'john',\n  age: 25,\n  gender: 'male',\n})\n\nfunction changeinfo() {\n  user.name = 'mary'\n  user.age = 30\n  user.gender = 'female'\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n这段代码确实实现了页面的同步更新，但模板里反复使用 user.前缀 显得有些冗余，如何减少模板中重复使用 user.前缀 的情况，从而提高了代码的可读性呢？\n\n# 3 继续改进\n\ntoref 是 vue3 中的一个工具函数，用于将响应式对象上的一个属性转换为一个单独的 ref 对象。我们尝试用它来减少模板中 user. 前缀的重复使用，代码如下：\n\n<template>\n  <div>\n    <p>name: {{ name }}</p> // 少了前缀\n    <p>age: {{ age }}</p>\n    <p>gender: {{ gender }}</p>\n    <button @click=\"changeinfo\">change info</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { reactive, toref } from 'vue'\n\ninterface user {\n  name: string;\n  age: number;\n  gender: string;\n}\n\nconst user: user = reactive({\n  name: 'john',\n  age: 25,\n  gender: 'male',\n});\n\nconst name = toref(user, 'name')\nconst age = toref(user, 'age')\nconst gender = toref(user, 'gender')\n\nfunction changeinfo() {\n  name.value = 'mary'\n  age.value = 30\n  gender.value = 'female'\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n当我们使用 toref() 将一个响应式对象 user 的属性转化为 ref 后，该 ref 会与源对象的属性保持同步。这样创建的 ref 对象与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。\n\n\n# torefs() 的使用场景\n\n# 一、问题引入\n\n在上面示例 3 的代码中，如果对象的属性很多，每个属性都要保持响应性，那么势必多次调用 toref() 函数，有没有什么办法可以一次性将响应式对象上的所有属性都转换为 ref 对象，从而简化代码呢？\n\n# 二、解决办法\n\n使用 vue3 的 torefs() 函数可以一次性将响应式对象上的所有属性都转换为 ref 对象，并使用对象解构语法来进一步简化代码，代码如下：\n\n<template>\n  <div>\n    <p>name: {{ name }}</p>\n    <p>age: {{ age }}</p>\n    <p>gender: {{ gender }}</p>\n    <button @click=\"changeinfo\">change info</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { reactive, torefs } from 'vue'\n\ninterface user {\n  name: string;\n  age: number;\n  gender: string;\n}\n\nconst user: user = reactive({\n  name: 'john',\n  age: 25,\n  gender: 'male',\n})\n\nconst staterefs = torefs(user)\nconst { name, age, gender } = staterefs\n\nfunction changeinfo() {\n  name.value = 'mary'\n  age.value = 30\n  gender.value = 'female'\n}\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n这段代码中使用 torefs(user) 将响应式对象 user 中的所有属性（即name、age和gender）转换成对应的 ref 对象，并返回一个由这些 ref 对象组成的对象，这些 ref 对象的变化也会影响原响应式对象的属性。\n\n然后使用对象解构将它们分别赋值给 name、age 和 gender，这样，我们在模板中就可以直接访问这三个变量，而不用写成 staterefs.name、staterefs.age 和 staterefs.gender 的形式。在 changeinfo 函数中，直接修改 name.value、age.value 和 gender.value 的值，这些值的变化会直接反映到原响应式对象 user 的属性上，从而触发页面的更新。\n\n\n# 任务六 computed 与计算属性\n\n\n# 基本概念\n\ncomputed 函数，是一个响应式 api，类似于 vue2.x 中的 computed 属性。使用 computed 函数可以让代码更加简洁和高效。\n\ncomputed 函数的值就是计算属性。computed 函数可以使用响应式依赖来创建计算属性，计算属性会自动追踪响应式依赖，在其任何响应式依赖项更改时自动重新计算。\n\n在模板中绑定计算属性，当计算属性的值发生变化时，会触发组件的重新渲染。在模板中绑定计算属性的另一个好处是，可以在模板中声明性地指定复杂的逻辑，而不必手动更新值或在代码中执行计算。\n\n\n# 使用计算属性\n\n计算属性的使用场景。\n\n例如，考虑一个简单的 vue 3 组件，该组件显示一个商品列表和这些商品的总数：\n\n<template>\n  <div>\n    <div v-if=\"isloading\">loading...</div>\n    <div v-else>\n      <ul>\n        <li v-for=\"item in goods\" :key=\"item.id\">{{ item.name }}</li>\n      </ul>\n      <p>商品总数: {{ totalgoods }}</p>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, ref } from 'vue'\n\ninterface item {\n  id: number;\n  name: string;\n  price: number;\n}\n\nconst goods = ref<item[]>([]);\n\nconst isloading = computed(() => {\n  return goods.value.length === 0\n})\n\nconst totalgoods = computed(() => {\n  return goods.value.length\n})\n\nconst baseurl = 'http://localhost:3000'\n\nconst fetchgoods = async () => {\n  try {\n    const res = await fetch(baseurl + '/goods')\n    const data = await res.json()\n    goods.value = data as item[]\n  } catch (e) {\n    throw new error('an error happened' + e)\n  }\n}\n\nfetchgoods()\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n在这个例子中，totalgoods 计算属性函数负责计算 goods 数组中的商品总数。isloading 计算属性基于 goods 数组的长度返回一个布尔值，指示组件是否处于加载状态。\n\n请注意，这里使用计算属性 isloading 来定义应用程序是否正在加载。通常，很多开发人员会定义 isloading 变量，并在调用 fetchgoods 时将变量 isloading 设置为 true，然后在 api 请求完成后再将其设置为 false。比如：\n\n<script setup lang=\"ts\">\n\nconst isloading = ref(true)\n// ...\nconst fetchgoods = async () => {\n  try {\n    isloading.value = true\n    // 网络访问的代码 \n    // ...\n    isloading.value = false\n  } catch (e) {\n  \t// ...\n  }\n}\n\nfetchgoods()\n\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n相对于 goods02.vue，goods.vue 使用计算属性实现了 loading 的显示逻辑与商品数据获取逻辑之间的解耦。",charsets:{cjk:!0}},{title:"黑马Vue3",frontmatter:{title:"黑马Vue3",date:"2023-07-07T00:13:02.000Z",permalink:"/pages/50e8d3/"},regularPath:"/09.%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/10.%E9%BB%91%E9%A9%ACVue3.html",relativePath:"09.前端学习/10.黑马Vue3.md",key:"v-71e9447e",path:"/pages/50e8d3/",headers:[{level:2,title:"1. TypeScript",slug:"_1-typescript",normalizedTitle:"1. typescript",charIndex:19},{level:3,title:"1) 动态类型的问题",slug:"_1-动态类型的问题",normalizedTitle:"1) 动态类型的问题",charIndex:37},{level:3,title:"2) 入门",slug:"_2-入门",normalizedTitle:"2) 入门",charIndex:576},{level:3,title:"3) 类型",slug:"_3-类型",normalizedTitle:"3) 类型",charIndex:1243},{level:4,title:"标注位置",slug:"标注位置",normalizedTitle:"标注位置",charIndex:1821},{level:5,title:"标注变量",slug:"标注变量",normalizedTitle:"标注变量",charIndex:1829},{level:5,title:"标注参数",slug:"标注参数",normalizedTitle:"标注参数",charIndex:1945},{level:5,title:"标注返回值",slug:"标注返回值",normalizedTitle:"标注返回值",charIndex:2158},{level:4,title:"复杂类型",slug:"复杂类型",normalizedTitle:"复杂类型",charIndex:1554},{level:5,title:"type",slug:"type",normalizedTitle:"type",charIndex:408},{level:5,title:"interface",slug:"interface",normalizedTitle:"interface",charIndex:873},{level:5,title:"可选属性",slug:"可选属性",normalizedTitle:"可选属性",charIndex:2750},{level:5,title:"鸭子类型",slug:"鸭子类型",normalizedTitle:"鸭子类型",charIndex:2964},{level:4,title:"方法类型",slug:"方法类型",normalizedTitle:"方法类型",charIndex:3185},{level:4,title:"字面量类型",slug:"字面量类型",normalizedTitle:"字面量类型",charIndex:1664},{level:4,title:"nullish 类型",slug:"nullish-类型",normalizedTitle:"nullish 类型",charIndex:3669},{level:4,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:1770},{level:3,title:"4) 意义",slug:"_4-意义",normalizedTitle:"4) 意义",charIndex:4631},{level:4,title:"更好理解框架",slug:"更好理解框架",normalizedTitle:"更好理解框架",charIndex:4640},{level:4,title:"更好的提示",slug:"更好的提示",normalizedTitle:"更好的提示",charIndex:4907},{level:3,title:"5) 类",slug:"_5-类",normalizedTitle:"5) 类",charIndex:5092},{level:4,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:5179},{level:4,title:"只读属性",slug:"只读属性",normalizedTitle:"只读属性",charIndex:5593},{level:4,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:3185},{level:4,title:"get，set",slug:"get-set",normalizedTitle:"get，set",charIndex:6048},{level:4,title:"类与接口",slug:"类与接口",normalizedTitle:"类与接口",charIndex:6466},{level:4,title:"继承与接口",slug:"继承与接口",normalizedTitle:"继承与接口",charIndex:6881},{level:4,title:"方法重写",slug:"方法重写",normalizedTitle:"方法重写",charIndex:7270},{level:2,title:"2. Vue3 基础",slug:"_2-vue3-基础",normalizedTitle:"2. vue3 基础",charIndex:7530},{level:3,title:"1) 环境准备",slug:"_1-环境准备",normalizedTitle:"1) 环境准备",charIndex:7763},{level:4,title:"创建项目",slug:"创建项目",normalizedTitle:"创建项目",charIndex:7774},{level:4,title:"编码 IDE",slug:"编码-ide",normalizedTitle:"编码 ide",charIndex:7882},{level:4,title:"安装 devtools",slug:"安装-devtools",normalizedTitle:"安装 devtools",charIndex:8009},{level:4,title:"修改端口",slug:"修改端口",normalizedTitle:"修改端口",charIndex:8095},{level:4,title:"配置代理",slug:"配置代理",normalizedTitle:"配置代理",charIndex:8399},{level:4,title:"项目结构",slug:"项目结构",normalizedTitle:"项目结构",charIndex:8877},{level:3,title:"2) Vue 组件",slug:"_2-vue-组件",normalizedTitle:"2) vue 组件",charIndex:9279},{level:4,title:"main.ts",slug:"main-ts",normalizedTitle:"main.ts",charIndex:9923},{level:4,title:"ref 与 reactive",slug:"ref-与-reactive",normalizedTitle:"ref 与 reactive",charIndex:10674},{level:4,title:"属性绑定",slug:"属性绑定",normalizedTitle:"属性绑定",charIndex:11492},{level:4,title:"事件绑定",slug:"事件绑定",normalizedTitle:"事件绑定",charIndex:11702},{level:4,title:"表单绑定",slug:"表单绑定",normalizedTitle:"表单绑定",charIndex:12079},{level:4,title:"计算属性",slug:"计算属性",normalizedTitle:"计算属性",charIndex:13632},{level:4,title:"xhr",slug:"xhr",normalizedTitle:"xhr",charIndex:8426},{level:4,title:"axios",slug:"axios",normalizedTitle:"axios",charIndex:16043},{level:5,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:14821},{level:5,title:"环境变量",slug:"环境变量",normalizedTitle:"环境变量",charIndex:17595},{level:5,title:"baseURL",slug:"baseurl",normalizedTitle:"baseurl",charIndex:18390},{level:5,title:"拦截器",slug:"拦截器",normalizedTitle:"拦截器",charIndex:18812},{level:4,title:"条件与列表",slug:"条件与列表",normalizedTitle:"条件与列表",charIndex:20159},{level:4,title:"监听器",slug:"监听器",normalizedTitle:"监听器",charIndex:23326},{level:4,title:"vueuse",slug:"vueuse",normalizedTitle:"vueuse",charIndex:23915},{level:4,title:"useRequest",slug:"userequest",normalizedTitle:"userequest",charIndex:23309},{level:4,title:"usePagination",slug:"usepagination",normalizedTitle:"usepagination",charIndex:25684},{level:4,title:"子组件",slug:"子组件",normalizedTitle:"子组件",charIndex:28176},{level:5,title:"例1",slug:"例1",normalizedTitle:"例1",charIndex:15744},{level:5,title:"例2",slug:"例2",normalizedTitle:"例2",charIndex:15903},{level:2,title:"3. Vue 进阶",slug:"_3-vue-进阶",normalizedTitle:"3. vue 进阶",charIndex:31939},{level:3,title:"1) Antdv",slug:"_1-antdv",normalizedTitle:"1) antdv",charIndex:31953},{level:4,title:"表格",slug:"表格",normalizedTitle:"表格",charIndex:32265},{level:4,title:"分页",slug:"分页",normalizedTitle:"分页",charIndex:21276},{level:4,title:"搜索、删除",slug:"搜索、删除",normalizedTitle:"搜索、删除",charIndex:35019},{level:4,title:"新增、修改",slug:"新增、修改",normalizedTitle:"新增、修改",charIndex:40248},{level:4,title:"全局消息",slug:"全局消息",normalizedTitle:"全局消息",charIndex:43098},{level:4,title:"表单校验",slug:"表单校验",normalizedTitle:"表单校验",charIndex:42913},{level:3,title:"2) vue-router",slug:"_2-vue-router",normalizedTitle:"2) vue-router",charIndex:46109},{level:4,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:583},{level:4,title:"创建 router",slug:"创建-router",normalizedTitle:"创建 router",charIndex:46163},{level:4,title:"动态导入",slug:"动态导入",normalizedTitle:"动态导入",charIndex:47257},{level:4,title:"嵌套路由",slug:"嵌套路由",normalizedTitle:"嵌套路由",charIndex:47692},{level:4,title:"重定向",slug:"重定向",normalizedTitle:"重定向",charIndex:48457},{level:4,title:"主页布局",slug:"主页布局",normalizedTitle:"主页布局",charIndex:49524},{level:4,title:"侧边栏菜单",slug:"侧边栏菜单",normalizedTitle:"侧边栏菜单",charIndex:50724},{level:4,title:"菜单图标",slug:"菜单图标",normalizedTitle:"菜单图标",charIndex:51829},{level:4,title:"二次封装图标组件",slug:"二次封装图标组件",normalizedTitle:"二次封装图标组件",charIndex:53530},{level:5,title:"方法1，使用 vue 组件",slug:"方法1-使用-vue-组件",normalizedTitle:"方法1，使用 vue 组件",charIndex:53909},{level:5,title:"方法2，使用函数式组件",slug:"方法2-使用函数式组件",normalizedTitle:"方法2，使用函数式组件",charIndex:54557},{level:5,title:"方法3，使用 jsx 组件",slug:"方法3-使用-jsx-组件",normalizedTitle:"方法3，使用 jsx 组件",charIndex:55362},{level:4,title:"动态路由与菜单",slug:"动态路由与菜单",normalizedTitle:"动态路由与菜单",charIndex:56636},{level:5,title:"路由文件",slug:"路由文件",normalizedTitle:"路由文件",charIndex:56647},{level:5,title:"登录组件",slug:"登录组件",normalizedTitle:"登录组件",charIndex:58441},{level:5,title:"主页组件",slug:"主页组件",normalizedTitle:"主页组件",charIndex:60841},{level:4,title:"token 使用",slug:"token-使用",normalizedTitle:"token 使用",charIndex:62940},{level:3,title:"3) pinia",slug:"_3-pinia",normalizedTitle:"3) pinia",charIndex:63104},{level:4,title:"安装",slug:"安装-2",normalizedTitle:"安装",charIndex:583},{level:4,title:"定义Store",slug:"定义store",normalizedTitle:"定义store",charIndex:63421},{level:3,title:"后记",slug:"后记",normalizedTitle:"后记",charIndex:66463}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"33 min read",minutes:33,time:198e4,words:6600},headersStr:"1. TypeScript 1) 动态类型的问题 2) 入门 3) 类型 标注位置 标注变量 标注参数 标注返回值 复杂类型 type interface 可选属性 鸭子类型 方法类型 字面量类型 nullish 类型 泛型 4) 意义 更好理解框架 更好的提示 5) 类 基本语法 只读属性 方法 get，set 类与接口 继承与接口 方法重写 2. Vue3 基础 1) 环境准备 创建项目 编码 IDE 安装 devtools 修改端口 配置代理 项目结构 2) Vue 组件 main.ts ref 与 reactive 属性绑定 事件绑定 表单绑定 计算属性 xhr axios 基本用法 环境变量 baseURL 拦截器 条件与列表 监听器 vueuse useRequest usePagination 子组件 例1 例2 3. Vue 进阶 1) Antdv 表格 分页 搜索、删除 新增、修改 全局消息 表单校验 2) vue-router 安装 创建 router 动态导入 嵌套路由 重定向 主页布局 侧边栏菜单 菜单图标 二次封装图标组件 方法1，使用 vue 组件 方法2，使用函数式组件 方法3，使用 jsx 组件 动态路由与菜单 路由文件 登录组件 主页组件 token 使用 3) pinia 安装 定义Store 后记",content:'# 黑马 Vue3 学习小结\n\n\n# 1. TypeScript\n\n\n# 1) 动态类型的问题\n\n前面我们讲过 js 属于动态类型语言，例如\n\nfunction test(obj) {    \n}\n\n\n1\n2\n\n\nobj 可能只是个字符串\n\ntest(\'hello, world\')\n\n\n1\n\n\nobj 也有可能是个函数\n\ntest(()=>console.log(\'hello, world\'))\n\n\n1\n\n\nobj 类型不确定，就给后期使用者带来了麻烦，一旦参数传不对，代码就崩溃了\n\n动态类型意味着\n\n * 运行代码时才知道发生什么 (running the code to see what happens)\n\n静态类型意味着\n\n * 在代码运行前，就对它的行为做出预测 (make predications about what code is expected before it runs)\n\n下面的 typescript 代码，就在代码运行前对参数加入了约束限制\n\nfunction test(msg : string) {\n}\n\n\n1\n2\n\n * 限制了参数只能做 string 那些事\n\nfunction test(msg : Function) {\n  msg()\n}\n\n\n1\n2\n3\n\n * 限制了参数只能做函数那些事\n\n\n# 2) 入门\n\n安装 typescript 编译器\n\nnpm install -g typescript\n\n\n1\n\n\n编写 ts 代码\n\nfunction hello(msg: string) {\n  console.log(msg)\n}\n\nhello(\'hello,world\')\n\n\n1\n2\n3\n4\n5\n\n\n执行 tsc 编译命令\n\ntsc xxx.ts\n\n\n1\n\n\n编译生成 js 代码，编译后进行了类型擦除\n\nfunction hello(msg) {\n    console.log(msg);\n}\nhello(\'hello,world\');\n\n\n1\n2\n3\n4\n\n\n再来一个例子，用 interface 定义用户类型\n\ninterface User {\n  name: string,\n  age: number\n}\n\nfunction test(u: User): void {\n  console.log(u.name)\n  console.log(u.age)\n}\n\ntest({ name: \'zhangs\', age: 18 })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n编译后\n\nfunction test(u) {\n    console.log(u.name);\n    console.log(u.age);\n}\ntest({ name: \'zhangs\', age: 18 });\n\n\n1\n2\n3\n4\n5\n\n\n可见，typescript 属于编译时实施类型检查（静态类型）的技术\n\n\n# 3) 类型\n\n类型          例                                  备注\n字符串类型       string                             \n数字类型        number                             \n布尔类型        boolean                            \n数组类型        number[],string[],boolean[] 依此类推   \n任意类型        any                                相当于又回到了没有类型的时代\n复杂类型        type 与 interface                   \n函数类型        () => void                         对函数的参数和返回值进行说明\n字面量类型       "a"|"b"|"c"                        限制变量或参数的取值\nnullish类型   null 与 undefined                   \n泛型          <T>，<T extends 父类型>                \n\n# 标注位置\n\n# 标注变量\n\nlet message: string = \'hello,world\'\n\n\n1\n\n * 一般可以省略，因为可以根据后面的字面量推断出前面变量类型\n\nlet message = \'hello,world\'\n\n\n1\n\n\n# 标注参数\n\nfunction greet(name: string) {\n    \n}\n\n\n1\n2\n3\n\n\n很多时候，都能够推断出参数类型\n\nconst names = [\'Alice\', \'Bob\', \'Eve\']\nconst lowercaseNames = names.map((e: string) => e.toLowerCase())\n\n\n1\n2\n\n * 可以用类型推断，推断出 e 是 string 类型\n\n# 标注返回值\n\nfunction add(a: number, b: number) : number {\n    return a + b\n}\n\n\n1\n2\n3\n\n * 一般也可以省略，因为可以根据返回值做类型推断\n\n# 复杂类型\n\n# type\n\ntype Cat = {\n  name: string,\n  age: number\n}\n\nconst c1: Cat = { name: \'小白\', age: 1 }\nconst c2: Cat = { name: \'小花\' }\t\t\t\t\t  // 错误: 缺少 age 属性\nconst c3: Cat = { name: \'小黑\', age: 1, sex: \'公\' } // 错误: 多出 sex 属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# interface\n\ninterface Cat {\n  name: string,\n  age: number\n}\n\nconst c1: Cat = { name: \'小白\', age: 1 }\nconst c2: Cat = { name: \'小花\' }\t\t\t\t\t  // 错误: 缺少 age 属性\nconst c3: Cat = { name: \'小黑\', age: 1, sex: \'公\' } // 错误: 多出 sex 属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 可选属性\n\n如果需要某个属性可选，可以用下面的语法\n\ninterface Cat {\n  name: string,\n  age?: number\n}\n\nconst c1: Cat = { name: \'小白\', age: 1 }\nconst c2: Cat = { name: \'小花\' }\t\t\t\t\t  // 正确: age 属性可选\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 可选属性要注意处理 undefined 值\n\n# 鸭子类型\n\ninterface Cat {\n  name: string\n}\n\nfunction test(cat: Cat) {\n  console.log(cat.name)\n}\n\nconst c1 = { name: \'小白\', age: 1 } \ntest(c1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * const c1 并没有声明类型为 Cat，但它与 Cat 类型有一样的属性，也可以被当作是 Cat 类型\n\n# 方法类型\n\ninterface Api {\n  foo(): void,\n  bar(str: string): string\n}\n\nfunction test(api: Api) {\n  api.foo()\n  console.log(api.bar(\'hello\'))\n}\n\ntest({\n  foo() { console.log(\'ok\') },\n  bar(str: string) { return str.toUpperCase() }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 字面量类型\n\nfunction printText(s: string, alignment: "left" | "right" | "center") {\n  console.log(s, alignment)\n}\n\nprintText(\'hello\', \'left\')\nprintText(\'hello\', \'aaa\') // 错误: 取值只能是 left | right | center\n\n\n1\n2\n3\n4\n5\n6\n\n\n# nullish 类型\n\nfunction test(x?: string | null) {\n  console.log(x?.toUpperCase())\n}\n\ntest(\'aaa\')\ntest(null)\ntest()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * x?: string | null 表示可能是 undefined 或者是 string 或者是 null\n\n# 泛型\n\n下面的几个类型声明显然有一定的相似性\n\ninterface RefString {\n  value: string\n}\n\ninterface RefNumber {\n  value: number\n}\n\ninterface RefBoolean {\n  value: boolean\n}\n\nconst r1: RefString = { value: \'hello\' }\nconst r2: RefNumber = { value: 123 }\nconst r3: RefBoolean = { value: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n可以改进为\n\ninterface Ref<T> {\n  value: T\n}\n\nconst r1: Ref<string> = { value: \'hello\' }\nconst r2: Ref<number> = { value: 123 }\nconst r3: Ref<boolean> = { value: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 泛型的要点就是 <类型参数>，把【类型】也当作一个变化的要素，像参数一样传递过来，这样就可以派生出结构相似的新类型\n\n函数定义也支持泛型\n\nfunction ref<T>(n: T): Ref<T> {\n  return { value: n }\n}\n\nconst v1 = ref("hello"); \t// Ref<string>\nconst v2 = ref(123.3333);\t// Ref<number>\n\nv1.value.toLocaleLowerCase()\nv2.value.toFixed(2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4) 意义\n\n# 更好理解框架\n\n现在越来越多的前端框架采用 typescript，如果懂 typescript 语法，可以更好地阅读框架代码\n\n以 Map 为例\n\nconst map = new Map<string, string>()\nmap\n  .set("a", "b")\n  .set("c", "d")\n\nmap.forEach((value,key,m)=>{\n  console.log(value, key)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 注意编译需要 tsc --target es6 .\\xxx.ts\n\n# 更好的提示\n\n例如，从服务器返回的一段 json，如果不用 typescript，则编辑器也不能给出准确的提示\n\ninterface User {\n  name: string,\n  age: number\n}\n\nconst user: User = JSON.parse(`{ "name":"张三", "age":18 }`)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5) 类\n\n> 关于 TypeScript 与 JavaScript 中的类语法不是重点，class 相关语法只是起到辅助作用，更重要的是前面讲的 interface\n\n# 基本语法\n\nclass User {\n    name: string;\n    \n    constructor(name: string) {\n        this.name = name\n    }\n}\n\nconst u = new User(\'张三\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n其实会被编译成这个样子（默认 --target=es3）\n\nvar User = /** @class */ (function () {\n    function User(name) {\n        this.name = name;\n    }\n    return User;\n}());\nvar u = new User(\'张三\');\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n所以 js 中的 class，并不等价于 java 中的 class，它还是基于原型实现的，原理参考第二章（036、037）\n\n# 只读属性\n\nclass User {\n  readonly name: string;\n  \n  constructor(name: string) {\n      this.name = name\n  }\n}\n\nconst u = new User(\'张三\')\nu.name = \'李四\'\t\t\t\t// 编译错误\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * readonly 是 typescript 特有的，表示该属性只读\n\n# 方法\n\nclass User {\n  readonly name: string;\n  \n  constructor(name: string) {\n      this.name = name\n  }\n\n  study() {\n    console.log(`[${this.name}]正在学习`)\n  }\n}\n\nconst u = new User(\'张三\')\nu.study()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# get，set\n\nclass User {\n  _name: string;\n\n  constructor(name: string) {\n    this._name = name\n  }\n\n  get name() {\n    return this._name\n  }\n\n  set name(name: string) {\n    this._name = name\n  }\n}\n\nconst u = new User(\'张三\')\nconsole.log(u.name)\nu.name = \'李四\'\nconsole.log(u.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 注意，需要在编译时加上 tsc --target es6 .\\xxx.ts 选项\n * es6 等价于 es2015，再此之上还有 es2016 ... es2022\n\n# 类与接口\n\ninterface User {\n  name: string\n  study(course: string): void\n}\n\nclass UserImpl implements User {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  study(course: string) {\n    console.log(`[${this.name}]正在学习[${course}]`)\n  }\n  foo() { }\n}\n\nconst user: User = new UserImpl(\'张三\')\nuser.study(\'Typescript\')\nuser.foo() // 错误，必须是接口中定义的方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 继承与接口\n\ninterface Flyable {\n  fly(): void\n}\n\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nclass Bird extends Animal implements Flyable {\n  fly() {\n    console.log(`${this.name}在飞翔`)\n  }\n}\n\nconst b: Flyable & Animal = new Bird("小花")\nb.fly()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * Flyable & Animal 表示变量是 flyable 类型，同时也是 Animal 类型\n\n# 方法重写\n\nclass Father {\n  study(): void {\n    console.log(`father study`)\n  }\n}\n\nclass Son extends Father {  \n  study(): void {\n    super.study()\n    console.log(`son study`)\n  }\n}\n\nconst f: Father = new Son()\nf.study()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2. Vue3 基础\n\n技术选型\n\n * Vue\n   * 选项式 API 还是 组合式 API✔️\n   * HTML 还是 单文件组件✔️\n * 语法\n   * javascript 还是 typescript✔️\n * 构建工具\n   * @vue/cli 还是 vite✔️\n * 路由\n   * vue-router✔️\n * 共享存储\n   * vuex 还是 pinia✔️\n * 视图组件\n   * ElementUI 还是 Antdv✔️\n\n\n# 1) 环境准备\n\n# 创建项目\n\n采用 vite 作为前端项目的打包，构建工具\n\nnpm init vite@latest\n\n\n1\n\n\n按提示操作\n\ncd 项目目录\nnpm install\nnpm run dev\n\n\n1\n2\n3\n\n\n# 编码 IDE\n\n推荐采用微软的 VSCode 作为开发工具，到它的官网 Visual Studio Code - Code Editing. Redefined 下载安装即可\n\n\n\n要对 *.vue 做语法支持，还要安装一个 Volar 插件\n\n\n\n# 安装 devtools\n\n * devtools 插件网址：https://devtools.vuejs.org/guide/installation.html\n\n\n\n# 修改端口\n\n打开项目根目录下 vite.config.ts\n\nimport { defineConfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  server: {\n    port: 7070\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 文档地址：配置 Vite {#configuring-vite} | Vite中文网 (vitejs.cn)\n\n# 配置代理\n\n为了避免前后端服务器联调时， fetch、xhr 请求产生跨域问题，需要配置代理，同样是修改项目根目录下 vite.config.ts\n\nimport { defineConfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  server: {\n    port: 7070,\n    proxy: {\n      \'/api\': {\n        target: \'http://localhost:8080\',\n        changeOrigin: true\n      }\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 文档地址：配置 Vite {#configuring-vite} | Vite中文网 (vitejs.cn)\n\n# 项目结构\n\nindex.html\npackage.json\ntsconfig.json\nvite.config.ts\n├─public\n└─src\n    ├─assets\n    ├─components\n    ├─model\n    ├─router\n    ├─store\n    └─views\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * index.html 为主页面\n * package.json npm 配置文件\n * tsconfig.json typescript 配置文件\n * vite.config.ts vite 配置文件\n * public 静态资源\n * src/components 可重用组件\n * src/model 模型定义\n * src/router 路由\n * src/store 共享存储\n * src/views 视图组件\n\n\n# 2) Vue 组件\n\nVue 的组件文件以 .vue 结尾，每个组件由三部分组成\n\n<script setup lang="ts"><\/script>\n\n<template></template>\n\n<style scoped></style>\n\n\n1\n2\n3\n4\n5\n\n * script 代码部分，控制模板的数据来源和行为\n * template 模板部分，由它生成 html 代码\n * style 样式部分，一般不咋关心\n\n根组件是 src/App.vue，先来个 Hello,world 例子\n\n<script setup lang="ts">\nimport { ref } from "vue";\nlet msg = ref("hello"); // 把数据变成响应式的\n\nfunction change() {\n  msg.value = "world";\n  console.log(msg);\n}\n<\/script>\n<template>\n  <h1>{{ msg }}</h1>\n  <input type="button" value="修改msg" @click="change" />\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * {{msg}} 用来把一个变量绑定到页面上某个位置\n * 绑定的变量必须用 ref 函数来封装\n   * ref 返回的是【响应式】数据，即数据一旦变化，页面展示也跟着变化\n\n# main.ts\n\nimport { createApp } from \'vue\'\nimport \'./style.css\'\nimport App from \'./App.vue\'\n\ncreateApp(App)\n  .mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n\n * createApp 是创建一个 Vue 应用程序，它接收的参数 App 即之前我们看到的根组件\n * mount 就是把根组件生成的 html 代码片段【挂载】到 index.html 中 id 为 app 的 html 元素上\n\n可以修改自己的组件文件，挂载到主页面\n\n新建 src/views/E0.vue，内容如下\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst msg = ref(\'Hello, World!!\')\n<\/script>\n<template>\n  <h1>{{ msg }}</h1>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n修改 main.ts 将自己的组件文件挂载\n\nimport { createApp } from \'vue\'\nimport \'./style.css\'\n// import App from \'./App.vue\'\nimport E0 from \'./views/E0.vue\'\n\ncreateApp(E0).mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n\n * 以后我们用这样的方式演示课堂案例\n\n打开浏览器控制台，进入 Vue 的开发工具，尝试做如下修改\n\n\n\n当把 msg 的值由 "Hello, World" 改为 "你好" 时，会发现页面展示同步发生了变化\n\n# ref 与 reactive\n\nvue 提供了两个函数，都可以将数据变为【响应式】的\n\n<script setup lang="ts">\nimport { ref, reactive } from \'vue\'\nconst msg = ref(\'Hello, World\')\nconst user = reactive({ name: \'张三\' })\n<\/script>\n\n<template>\n  <h2>{{msg}}</h2>\n  <h2>{{user.name}}</h2>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * ref 能将任意类型的数据变为【响应式】的\n * reactive 只能将对象类型变为【响应式】，对基本类型无效（例如 string，number，boolean）\n\n还有一点不同\n\n<script setup lang="ts">\nimport { ref, reactive } from \'vue\'\nconst u1 = ref({ name: \'张三\' })\nconst u2 = reactive({ name: \'张三\' })\n\nfunction test() {\n  console.log(u1.value)\n  console.log(u2)\n}\n\ntest()\n<\/script>\n  \n<template>\n  <h2>{{u1.name}}</h2>\n  <h2>{{u2.name}}</h2>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 在 template 模板中使用 ref 包装的数据，直接写【变量名】就可以了\n * 但在代码中要使用 ref 包装的数据，必须用【变量名.value】才能访问到\n * reactive 包装的数据，在模板中和代码中都是一致的\n\n# 属性绑定\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst path = ref(\'/src/assets/vue.svg\')\n\n<\/script>\n\n<template>\n  <img :src="path" alt="">\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 【:属性名】用来将标签属性与【响应式】变量绑定\n\n# 事件绑定\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst count = ref(0)\nfunction dec() {\n  count.value--\n}\nfunction inc() {\n  count.value++\n}\n<\/script>\n\n<template>\n  <input type="button" value="-" @click="dec">\n  <h2>{{count}}</h2>\n  <input type="button" value="+" @click="inc">\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 【@事件名】用来将标签属性与函数绑定，事件发生后执行函数内代码\n\n# 表单绑定\n\n<script setup lang="ts">\nimport { ref } from "vue";\nconst user = ref({\n  name:\'张三\',\n  age:18,\n  sex:\'男\',\n  fav:[\'游泳\',\'打球\']\n})\n\nfunction saveUser() {\n  console.log(user.value)\n}\n<\/script>\n\n<template>\n  <div class="outer">\n    <div>\n      <label for="">请输入姓名</label>\n      <input type="text" v-model="user.name"/>\n    </div>\n    <div>\n      <label for="">请输入年龄</label>\n      <input type="text" v-model="user.age"/>\n    </div>\n    <div>\n      <label for="">请选择性别</label>\n      男 <input type="radio" value="男" v-model="user.sex"/> \n      女 <input type="radio" value="女" v-model="user.sex"/>\n    </div>\n    <div>\n      <label for="">请选择爱好</label>\n      游泳 <input type="checkbox" value="游泳" v-model="user.fav"/> \n      打球 <input type="checkbox" value="打球" v-model="user.fav"/> \n      健身 <input type="checkbox" value="健身" v-model="user.fav"/>\n    </div>\n    <div>\n      <input type="button" value="保存" @click="saveUser">\n    </div>\n  </div>\n</template>\n\n<style scoped>\n  div {\n    margin-bottom: 8px;\n  }\n  .outer {\n    width: 100%;\n    position: relative;\n    padding-left: 80px;\n  }\n  label {\n    text-align: left;\n    width: 100px;\n    display: inline-block;\n    position: absolute;\n    left :0;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n * 用 v-model 实现双向绑定，即\n   * javascript 数据可以同步到表单标签\n   * 反过来用户在表单标签输入的新值也会同步到 javascript 这边\n * 双向绑定只适用于表单这种带【输入】功能的标签，其它标签的数据绑定，单向就足够了\n * 复选框这种标签，双向绑定的 javascript 数据类型一般用数组\n\n# 计算属性\n\n有时在数据展示时要做简单的计算\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst firstName = ref(\'三\')\nconst lastName = ref(\'张\')\n\n<\/script>\n\n<template>\n  <h2>{{lastName + firstName}}</h2>\n  <h3>{{lastName + firstName}}</h3>\n  <h4>{{lastName + firstName}}</h4>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n看起来较为繁琐，可以用计算属性改进\n\n<script setup lang="ts">\nimport { ref, computed } from \'vue\'\nconst firstName = ref(\'三\')\nconst lastName = ref(\'张\')\nconst fullName = computed(() => {\n  console.log(\'enter\')\n  return lastName.value + firstName.value\n})\n<\/script>\n\n<template>\n  <h2>{{fullName}}</h2>\n  <h3>{{fullName}}</h3>\n  <h4>{{fullName}}</h4>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * fullName 即为计算属性，它具备缓存功能，即 firstName 和 lastName 的值发生了变化，才会重新计算\n * 如果用函数实现相同功能，则没有缓存功能\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst firstName = ref(\'三\')\nconst lastName = ref(\'张\')\nfunction fullName() {\n  console.log(\'enter\')\n  return lastName.value + firstName.value\n}\n<\/script>\n  \n<template>\n  <h2>{{fullName()}}</h2>\n  <h3>{{fullName()}}</h3>\n  <h4>{{fullName()}}</h4>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# xhr\n\n浏览器中有两套 API 可以和后端交互，发送请求、接收响应，fetch api 前面我们已经介绍过了，另一套 api 是 xhr，基本用法如下\n\nconst xhr = new XMLHttpRequest()\nxhr.onload = function() {\n    console.log(xhr.response)\n}\nxhr.open(\'GET\', \'http://localhost:8080/api/students\')\nxhr.responseType = "json"\nxhr.send()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但这套 api 虽然功能强大，但比较老，不直接支持 Promise，因此有必要对其进行改造\n\nfunction get(url: string) {\n  return new Promise((resolve, reject)=>{\n    const xhr = new XMLHttpRequest()\n    xhr.onload = function() {\n      if(xhr.status === 200){\n        resolve(xhr.response)\n      } else if(xhr.status === 404) {\n        reject(xhr.response)\n      } // 其它情况也需考虑，这里简化处理\n    }\n    xhr.open(\'GET\', url)\n    xhr.responseType = \'json\'\n    xhr.send()\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * Promise 对象适合用来封装异步操作，并可以配合 await 一齐使用\n * Promise 在构造时，需要一个箭头函数，箭头函数有两个参数 resolve 和 reject\n   * resolve 是异步操作成功时被调用，把成功的结果传递给它，最后会作为 await 的结果返回\n   * reject 在异步操作失败时被调用，把失败的结果传递给它，最后在 catch 块被捉住\n * await 会一直等到 Promise 内调用了 resolve 或 reject 才会继续向下运行\n\n调用示例1：同步接收结果，不走代理\n\ntry {\n  const resp = await get("http://localhost:8080/api/students")\n  console.log(resp)\n} catch (e) {\n  console.error(e)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用示例2：走代理\n\ntry {\n  const resp = await get(\'/api/students\')\n  console.log(resp)  \n} catch(e) {\n  console.log(e)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 走代理明显慢不少\n\n# axios\n\n# 基本用法\n\naxios 就是对 xhr api 的封装，手法与前面例子类似\n\n安装\n\nnpm install axios\n\n\n1\n\n\n一个简单的例子\n\n<script setup lang="ts">\nimport { ref, onMounted } from "vue";\nimport axios from "axios";\n\nlet count = ref(0);\n\nasync function getStudents() {\n  try {\n    const resp = await axios.get("/api/students");\n    count.value = resp.data.data.length;\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nonMounted(() => {\n  getStudents()\n})\n<\/script>\n\n<template>\n  <h2>学生人数为：{{ count }}</h2>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * onMounted 指 vue 组件生成的 html 代码片段，挂载完毕后被执行\n\n再来看一个 post 例子\n\n<script setup lang="ts">\nimport { ref } from "vue";\nimport axios from "axios";\n\nconst student = ref({\n  name: \'\',\n  sex: \'男\',\n  age: 18\n})\n\nasync function addStudent() {\n  console.log(student.value)\n  const resp = await axios.post(\'/api/students\', student.value)\n  console.log(resp.data.data)\n}\n<\/script>\n\n<template>\n  <div>\n    <div>\n      <input type="text" placeholder="请输入姓名" v-model="student.name"/>\n    </div>\n    <div>\n      <label for="">请选择性别</label>\n      男 <input type="radio" value="男" v-model="student.sex"/> \n      女 <input type="radio" value="女" v-model="student.sex"/>\n    </div>\n    <div>\n      <input type="number" placeholder="请输入年龄" v-model="student.age"/>\n    </div>\n    <div>\n      <input type="button" value="添加" @click="addStudent"/>\n    </div>\n  </div>\n</template>\n<style scoped>\ndiv {\n  font-size: 14px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n# 环境变量\n\n * 开发环境下，联调的后端服务器地址是 http://localhost:8080，\n * 上线改为生产环境后，后端服务器地址为 http://itheima.com\n\n这就要求我们区分开发环境和生产环境，这件事交给构建工具 vite 来做\n\n默认情况下，vite 支持上面两种环境，分别对应根目录下两个配置文件\n\n * .env.development - 开发环境\n * .env.production - 生产环境\n\n针对以上需求，分别在两个文件中加入\n\nVITE_BACKEND_API_BASE_URL = \'http://localhost:8080\'\n\n\n1\n\n\n和\n\nVITE_BACKEND_API_BASE_URL = \'http://itheima.com\'\n\n\n1\n\n\n然后在代码中使用 vite 给我们提供的特殊对象 import.meta.env，就可以获取到 VITE_BACKEND_API_BASE_URL 在不同环境下的值\n\nimport.meta.env.VITE_BACKEND_API_BASE_URL\n\n\n1\n\n\n默认情况下，不能智能提示自定义的环境变量，做如下配置：新增文件 src/env.d.ts 并添加如下内容\n\n/// <reference types="vite/client" />\n\ninterface ImportMetaEnv {\n  readonly VITE_BACKEND_API_BASE_URL: string\n  // 更多环境变量...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 参考文档地址 环境变量和模式 | Vite 官方中文文档 (vitejs.dev)\n\n# baseURL\n\n可以自己创建一个 axios 对象，方便添加默认设置，新建文件 /src/api/request.ts\n\n// 创建新的 axios 对象\nimport axios from \'axios\'\nconst _axios = axios.create({\n  baseURL: import.meta.env.VITE_BACKEND_API_BASE_URL\n})\n\nexport default _axios\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后在其它组件中引用这个 ts 文件，例如 /src/views/E8.vue，就不用自己拼接路径前缀了\n\n<script setup lang="ts">\nimport axios from \'../api/request\'\n// ...\nawait axios.post(\'/api/students\', ...)    \n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n# 拦截器\n\n// 创建新的 axios 对象\nimport axios from \'axios\'\nconst _axios = axios.create({\n  baseURL: import.meta.env.VITE_BACKEND_API_BASE_URL\n})\n\n// 请求拦截器\n_axios.interceptors.request.use(\n  (config)=>{ // 统一添加请求头\n    config.headers = {\n      Authorization: \'aaa.bbb.ccc\'\n    }\n    return config\n  },\n  (error)=>{ // 请求出错时的处理\n    return Promise.reject(error)\n  }\n)\n\n// 响应拦截器\n_axios.interceptors.response.use(\n  (response)=>{ // 状态码  2xx\n    // 这里的code是自定义的错误码\n    if(response.data.code === 200) {\n      return response\n    }     \n    else if(response.data.code === 401) {       \n      // 情况1\n      return Promise.resolve({})\n    }\n    // ... \n  },\n  (error)=>{ // 状态码 > 2xx, 400,401,403,404,500\n    console.error(error) // 处理了异常\n    if(error.response.status === 400) {\n      // 情况1\n    } else if(error.response.status === 401) {\n      // 情况2\n    } \n    // ...\n    return Promise.resolve({})\n  }\n)\n\nexport default _axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n处理响应时，又分成两种情况\n\n 1. 后端返回的是标准响应状态码，这时会走响应拦截器第二个箭头函数，用 error.response.status 做分支判断\n 2. 后端返回的响应状态码总是200，用自定义错误码表示出错，这时会走响应拦截器第一个箭头函数，用 response.data.code 做分支判断\n\n另外\n\n * Promise.reject(error) 类似于将异常继续向上抛出，异常由调用者（Vue组件）来配合 try ... catch 来处理\n * Promise.resolve({}) 表示错误已解决，返回一个空对象，调用者中接到这个空对象时，需要配合 ?. 来避免访问不存在的属性\n\n# 条件与列表\n\n首先，新增模型数据 src/model/Model8080.ts\n\nexport interface Student {\n  id: number;\n  name: string;\n  sex: string;\n  age: number;\n}\n\n// 如果 spring 错误，返回的对象格式\nexport interface SpringError {\n  timestamp: string,\n  status: number,\n  error: string,\n  message: string,\n  path: string\n}\n\n// 如果 spring 成功，返回 list 情况\nexport interface SpringList<T> {\n  data: T[],\n  message?: string,\n  code: number\n}\n\n// 如果 spring 成功，返回 page 情况\nexport interface SpringPage<T> {\n  data: { list: T[], total: number },\n  message?: string,\n  code: number\n}\n\n// 如果 spring 成功，返回 string 情况\nexport interface SpringString {\n  data: string,\n  message?: string,\n  code: number\n}\n\nimport { AxiosResponse } from \'axios\'\nexport interface AxiosRespError extends AxiosResponse<SpringError> { }\nexport interface AxiosRespList<T> extends AxiosResponse<SpringList<T>> { }\nexport interface AxiosRespPage<T> extends AxiosResponse<SpringPage<T>> { }\nexport interface AxiosRespString extends AxiosResponse<SpringString> { }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n其中\n\n * AxiosRespPage 代表分页时的响应类型\n * AxiosRespList 代表返回集合时的响应类型\n * AxiosRespString 代表返回字符串时的响应类型\n * AxiosRespError 代表 Spring 出错时时的响应类型\n\n<script lang="ts" setup>\nimport { ref, onMounted } from "vue";\nimport axios from "../api/request";\nimport { Student, SpringList } from "../model/Model8080";\n\n// 说明 students 数组类型为 Student[]\nconst students = ref<Student[]>([]);\n\nasync function getStudents() {\n  // 说明 resp.data 类型是 SpringList<Student>\n  const resp = await axios.get<SpringList<Student>>("/api/students");  \n  console.log(resp.data.data);\n  students.value = resp.data.data;\n}\n\nonMounted(() => getStudents());\n<\/script>\n<template>\n  <div class="outer">\n    <div class="title">学生列表</div>\n    <div class="thead">\n      <div class="row bold">\n        <div class="col">编号</div>\n        <div class="col">姓名</div>\n        <div class="col">性别</div>\n        <div class="col">年龄</div>\n      </div>\n    </div>\n    <div class="tbody">\n      <div v-if="students.length === 0">暂无数据</div>\n      <template v-else>\n        <div class="row" v-for="s of students" :key="s.id">\n          <div class="col">{{ s.id }}</div>\n          <div class="col">{{ s.name }}</div>\n          <div class="col">{{ s.sex }}</div>\n          <div class="col">{{ s.age }}</div>\n        </div>\n      </template>\n    </div>\n  </div>\n</template>\n<style scoped>\n.outer {\n  font-family: 华文行楷;\n  font-size: 20px;\n  width: 500px;\n}\n\n.title {\n  margin-bottom: 10px;\n  font-size: 30px;\n  color: #333;\n  text-align: center;\n}\n\n.row {\n  background-color: #fff;\n  display: flex;\n  justify-content: center;\n}\n\n.col {\n  border: 1px solid #f0f0f0;\n  width: 15%;\n  height: 35px;\n  text-align: center;\n  line-height: 35px;\n}\n\n.bold .col {\n  background-color: #f1f1f1;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n * 加入泛型是为了更好的提示\n * v-if 与 v-else 不能和 v-for 处于同一标签\n * template 标签还有一个用途，就是用它少生成一层真正 html 代码\n * 可以看到将结果封装为响应式数据还是比较繁琐的，后面会使用 useRequest 改进\n\n# 监听器\n\n利用监听器，可以在【响应式】的基础上添加一些副作用，把更多的东西变成【响应式的】\n\n * 原本只是数据变化 => 页面更新\n\n * watch 可以在数据变化时 => 其它更新\n\n<template>\n  <input type="text" v-model="name" />\n</template>\n\n<script setup lang="ts">\nimport { ref, watch } from "vue";\nfunction useStorage(name: string) {\n  const data = ref(sessionStorage.getItem(name) ?? "");\n  watch(data, (newValue) => {\n    sessionStorage.setItem(name, newValue);\n  });\n  return data;\n}\nconst name = useStorage("name");\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 名称为 useXXXX 的函数，作用是返回带扩展功能的【响应式】数据\n * localStorage 即使浏览器关闭，数据还在\n * sessionStorage 数据工作在浏览器活动期间\n\n# vueuse\n\n安装\n\nnpm install @vueuse/core\n\n\n1\n\n\n一些函数的用法\n\n<template>\n  <h3>X: {{x}}</h3>\n  <h3>Y: {{y}}</h3>\n\n  <h3>{{count}}</h3>\n  <input type="button" @click="inc()" value="+">\n  <input type="button" @click="dec()" value="-">\n\n  <input type="text" v-model="name">\n</template>\n<script setup lang="ts">\nimport { useMouse, useCounter, useStorage } from \'@vueuse/core\'\n\nconst {x, y} = useMouse()\n\nconst {count, inc, dec} = useCounter()\n\nconst name = useStorage("name", "")\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# useRequest\n\n响应式的 axios 封装，官网地址 一个 Vue 请求库 | VueRequest (attojs.org)\n\n首先安装 vue-request\n\nnpm install vue-request@next\n\n\n1\n\n\n组件\n\n<template>\n  <h3 v-if="students.length === 0">暂无数据</h3>\n  <ul v-else>\n    <li v-for="s of students" :key="s.id">\n      <span>{{s.name}}</span>\n      <span>{{s.sex}}</span>\n      <span>{{s.age}}</span>\n    </li>\n  </ul>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request"\nimport { useRequest } from \'vue-request\'\nimport { computed } from \'vue\'\nimport { AxiosRespList, Student } from \'../model/Model8080\'\n\n// data 代表就是 axios 的响应对象\nconst { data } = useRequest<AxiosRespList<Student>>(() => axios.get(\'/api/students\'))\n\nconst students = computed(()=>{\n  return data?.value?.data.data || []\n})\n<\/script>\n<style scoped>\nul li {\n  list-style: none;\n  font-family: "华文行楷";\n}\n\nli span:nth-child(1) {\n  font-size: 24px;\n}\nli span:nth-child(2) {\n  font-size: 12px;\n  color: crimson;\n  vertical-align: bottom;\n}\nli span:nth-child(3) {\n  font-size: 12px;\n  color: darkblue;\n  vertical-align: top;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n * data.value 的取值一开始是 undefined，随着响应返回变成 axios 的响应对象\n * 用 computed 进行适配\n\n# usePagination\n\n在 src/model/Model8080.ts 中补充类型说明\n\nexport interface StudentQueryDto {\n  name?: string,\n  sex?: string,\n  age?: string, // 18,20\n  page: number,\n  size: number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * js 中类似于 18,20 这样以逗号分隔字符串，会在 get 传参时转换为 java 中的整数数组\n\n编写组件\n\n<template>\n  <input type="text" placeholder="请输入姓名" v-model="dto.name">\n  <select v-model="dto.sex">\n    <option value="" selected>请选择性别</option>\n    <option value="男">男</option>\n    <option value="女">女</option>\n  </select>\n  <input type="text" placeholder="请输入年龄范围" v-model="dto.age">\n  <br>\n  <input type="text" placeholder="请输入页码" v-model="dto.page">\n  <input type="text" placeholder="请输入页大小" v-model="dto.size">\n  <input type="button" value="搜索" @click="search">\n  <hr>\n  <h3 v-if="students.length === 0">暂无数据</h3>\n  <ul v-else>\n    <li v-for="s of students" :key="s.id">\n      <span>{{s.name}}</span>\n      <span>{{s.sex}}</span>\n      <span>{{s.age}}</span>\n    </li>\n  </ul>\n  <hr>\n  总记录数{{total}} 总页数{{totalPage}}\n</template>\n<script setup lang="ts">\nimport axios from "../api/request"\nimport { usePagination } from \'vue-request\'\nimport { computed, ref } from \'vue\'\nimport { AxiosRespPage, Student, StudentQueryDto } from \'../model/Model8080\'\n\nconst dto = ref<StudentQueryDto>({name:\'\', sex:\'\', age:\'\', page:1, size:5})\n\n// data 代表就是 axios 的响应对象\n// 泛型参数1: 响应类型\n// 泛型参数2: 请求类型\nconst { data, total, totalPage, run } = usePagination<AxiosRespPage<Student>, StudentQueryDto[]>(\n  (d) => axios.get(\'/api/students/q\', {params: d}), // 箭头函数\n  {\n    defaultParams: [ dto.value ], // 默认参数, 会作为参数传递给上面的箭头函数\n    pagination: {\n      currentKey: \'page\', // 指明当前页属性\n      pageSizeKey: \'size\', // 指明页大小属性\n      totalKey: \'data.data.total\' // 指明总记录数属性\n    } \n  } // 选项\n)\n\nconst students = computed(()=>{\n  return data?.value?.data.data.list || []\n})\n\nfunction search() {\n  run(dto.value) // 会作为参数传递给usePagination的箭头函数\n}\n<\/script>\n<style scoped>\nul li {\n  list-style: none;\n  font-family: "华文行楷";\n}\n\nli span:nth-child(1) {\n  font-size: 24px;\n}\nli span:nth-child(2) {\n  font-size: 12px;\n  color: crimson;\n  vertical-align: bottom;\n}\nli span:nth-child(3) {\n  font-size: 12px;\n  color: darkblue;\n  vertical-align: top;\n}\ninput,select {\n  width: 100px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n * usePagination 只需要定义一次，后续还想用它内部的 axios 发请求，只需调用 run 函数\n\n# 子组件\n\n# 例1\n\n定义子组件 Child1\n\n<template>\n  <div class="container">\n    <div class="card">\n      <div>\n        <p class="name">{{name}}</p>\n        <p class="location">{{country}}</p>\n      </div>\n      <img :src="avatar || \'/src/assets/vue.svg\'"/>\n    </div>\n  </div>\n</template>\n<script setup lang="ts">\n// 定义属性,  编译宏\ndefineProps<{name:string,country:string,avatar?:string}>()\n<\/script>\n<style scoped>\n.container {\n  width: 100%;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-evenly;\n  flex-direction: row-reverse;\n}\n.name {\n  font-weight: bold;\n}\n.location {\n  font-size: 0.8em;\n  color: #6d597a;\n}\n.card {\n  display: flex;\n  justify-content: space-evenly;\n  padding: 1em;\n  margin: 1rem;\n  border-radius: 5px;\n  background: #fff;\n  width: 200px;\n  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);\n}\n\n.card:hover {\n  transform: rotate(-5deg);\n}\n\n.card img {\n  margin-left: 1em;\n  border-radius: 50%;\n  max-width: 55px;\n  max-height: 55px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n父组件引用\n\n<template>\n  <Child1 name="张三" country="中国" avatar="/src/assets/vue.svg"></Child1>\n  <Child1 name="李四" country="印度" avatar="/vite.svg"></Child1>\n  <Child1 name="王五" country="韩国" ></Child1>\n</template>\n<script lang="ts" setup>\nimport Child1 from \'../components/Child1.vue\';\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 例2\n\n首先添加类型说明 model/ModelRandomUser.ts\n\nimport { AxiosResponse } from "axios";\nexport interface AxiosRespResults extends AxiosResponse<Results>{}\n\nexport interface Results {\n  info: {\n    page: number,\n    results: number\n  },\n  results: Result[]\n}\n\nexport interface Result {\n  gender: \'male\' | \'female\',\n  name: {\n    first: string,\n    last: string\n  },\n  location: {\n    country: string\n  },\n  picture: {\n    medium: string\n  },\n  login: {\n    username: string\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n子组件不变，父组件使用子组件\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <Child1 v-for="u of users" \n    :name="u.name.first" \n    :country="u.location.country" \n    :avatar="u.picture.medium"\n    :key="u.login.username"></Child1>\n</template>\n<script setup lang="ts">\nimport axios from "axios";\nimport { useRequest } from "vue-request";\nimport { computed } from "vue";\nimport { AxiosRespResults } from \'../model/ModelRandomUser\'\nimport Child1 from "../components/Child1.vue";\n\nconst { data } = useRequest<AxiosRespResults>(\n  ()=>axios.get(\'https://randomuser.me/api/?results=3\')\n)\n\nconst users = computed(()=>{\n  return data.value?.data.results || []\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n如果觉得 Result 数据结构嵌套太复杂，还可以做一个类型映射\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <Child1 v-for="u of users" \n    :name="u.name" \n    :country="u.country" \n    :avatar="u.avatar"\n    :key="u.username"></Child1>\n</template>\n<script setup lang="ts">\nimport axios from "axios";\nimport { useRequest } from "vue-request";\nimport { computed } from "vue";\nimport { AxiosRespResults, Result } from \'../model/ModelRandomUser\'\nimport Child1 from "../components/Child1.vue";\n\nconst { data } = useRequest<AxiosRespResults>(\n  ()=>axios.get(\'https://randomuser.me/api/?results=3\')\n)\n\nconst users = computed(()=>{\n  return data.value?.data.results.map(resultToUser) || []\n})\n\ninterface User {\n  name: string,\n  country: string,\n  avatar: string,\n  username: string\n}\nfunction resultToUser(r:Result):User {\n  return {\n    name: r.name.first,\n    country: r.location.country,\n    avatar: r.picture.medium,\n    username: r.login.username\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n * resultToUser 将 Result 类型映射为 User 类型\n\n\n# 3. Vue 进阶\n\n\n# 1) Antdv\n\n添加必要插件\n\nnpm install ant-design-vue\n\n\n1\n\n * ant-design-vue 组件库插件\n\n引入 antdv 功能，修改 main.ts\n\nimport { createApp } from \'vue\'\nimport \'./style.css\'\nimport App from \'./App.vue\'\nimport antd from \'ant-design-vue\'\nimport \'ant-design-vue/dist/antd.css\'\n\ncreateApp(App).use(antd).mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 表格\n\n<template>\n  \x3c!-- <a-table :columns="columns" :dataSource="students" rowKey="id"></a-table> --\x3e\n  <a-table :columns="columns" :dataSource="students" :rowKey="rowKey"></a-table>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { useRequest } from "vue-request";\nimport { AxiosRespList, Student } from "../model/Model8080";\n\nconst {data} = useRequest<AxiosRespList<Student>>(\n  ()=>axios.get(\'/api/students\')\n)\n\nconst students = computed(()=>{\n  return data.value?.data.data || []\n})\n\nfunction rowKey(r:Student) {\n  return r.id\n}\n\nconst columns = ref([\n  {\n    title:\'编号\',\n    dataIndex:\'id\'\n  },\n  {\n    title:\'姓名\',\n    dataIndex:\'name\'\n  },\n  {\n    title:\'性别\',\n    dataIndex:\'sex\'\n  },\n  {\n    title:\'年龄\',\n    dataIndex:\'age\'\n  }\n])\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 分页\n\n<template>\n  <a-table :columns="columns" :data-source="students" row-key="id"\n   :pagination="pagination" @change="tableChange"></a-table>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { usePagination } from "vue-request";\nimport { AxiosRespPage, Student, StudentQueryDto } from "../model/Model8080";\nimport { PaginationProps } from "ant-design-vue";\nimport DateBody from "ant-design-vue/lib/vc-picker/panels/DatePanel/DateBody";\n\nconst dto = ref({page: 1, size: 5})\n\nconst {data, total, run} = usePagination<AxiosRespPage<Student>, StudentQueryDto[]>(\n  (d)=> axios.get(\'/api/students/q\', {params:d}),\n  {\n    defaultParams: [dto.value],\n    pagination: {\n      currentKey: "page",\n      pageSizeKey: \'size\',\n      totalKey: \'data.data.total\'\n    }\n  }\n)\n\n// 在页号或页大小改变时调用\nfunction tableChange(pagination: PaginationProps) { \n  console.log(pagination)\n  dto.value.page = pagination.current ?? 1\n  dto.value.size = pagination.pageSize ?? 5\n  run(dto.value)\n}\n\nconst pagination = computed<PaginationProps>(()=>{\n  return {\n    current: dto.value.page, // 当前页\n    pageSize: dto.value.size, // 页大小\n    total: total.value,       // 总记录数\n    showSizeChanger: true,    // 显示页大小的下拉列表\n    pageSizeOptions: ["1","2","3","4","5"] // 自定义下拉列表内容\n  }\n})\n\nconst students = computed(()=>{\n  return data.value?.data.data.list || []\n})\n\nconst columns = ref([\n  {\n    title: "编号",\n    dataIndex: "id",\n  },\n  {\n    title: "姓名",\n    dataIndex: "name",\n  },\n  {\n    title: "性别",\n    dataIndex: "sex",\n  },\n  {\n    title: "年龄",\n    dataIndex: "age",\n  },\n]);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n# 搜索、删除\n\n<template>\n  <a-row>\n    <a-col :span="2">\n      <a-button type="primary" size="small">新增</a-button>\n    </a-col>\n    <a-col :span="4">\n      <a-popconfirm title="确认要删除选中学生吗?"\n        ok-text="确定" cancel-text="取消" @confirm="onDeleteIds"\n        @visibleChange="onVisibleChange" :visible="visible">\n        <a-button type="primary" size="small">删除选中</a-button>\n      </a-popconfirm>\n    </a-col>\n    <a-col :span="4">\n    </a-col>\n    <a-col :span="4">\n      <a-input v-model:value="dto.name" placeholder="输姓名" size="small"></a-input>\n    </a-col>\n    <a-col :span="4">\n      <a-select v-model:value="dto.sex" placeholder="选性别" :allowClear="true" size="small">\n        <a-select-option value="男">男</a-select-option>\n        <a-select-option value="女">女</a-select-option>\n      </a-select>\n    </a-col>\n    <a-col :span="4">\n      <a-select v-model:value="dto.age" placeholder="选年龄" :allowClear="true" size="small">\n        <a-select-option value="0,20">20以下</a-select-option>\n        <a-select-option value="21,30">21~30</a-select-option>\n        <a-select-option value="31,40">31~40</a-select-option>\n        <a-select-option value="40,120">40以上</a-select-option>\n      </a-select>\n    </a-col>\n    <a-col :span="2">\n      <a-button @click="tableChange" type="primary" size="small">搜索</a-button>\n    </a-col>\n  </a-row>\n  <hr>\n  <a-table :columns="columns" :data-source="students" row-key="id"\n    :pagination="pagination" @change="tableChange"\n    :row-selection="{selectedRowKeys:ids,onChange:onSelectChange}">\n    <template #bodyCell="{column, record}">\n      <template v-if="column.dataIndex===\'name\'">\n      {{record.name + (record.sex===\'男\'?\'(大侠)\':\'(女侠)\')}}\n      </template>\n\n      <template v-else-if="column.dataIndex===\'operation\'">\n      <a>修改</a>\n      <a-divider type="vertical"></a-divider>\n      <a-popconfirm title="确认要删除该学生吗?"\n        ok-text="确定" cancel-text="取消" @confirm="onDelete(record.id)">\n        <a>删除</a>   \n      </a-popconfirm>         \n      </template>\n    </template>\n  </a-table>\n  \n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { usePagination, useRequest } from "vue-request";\nimport { AxiosRespPage, AxiosRespString, Student, StudentQueryDto } from "../model/Model8080";\nimport { PaginationProps } from "ant-design-vue";\n\n// >>>>>>>>>>>>>> 搜索功能开始\nconst dto = ref({page: 1, size: 5, name: \'\', sex: null, age: null})\n\nconst {data, total, run: search} = usePagination<AxiosRespPage<Student>, StudentQueryDto[]>(\n  (d) => axios.get(\'/api/students/q\', {params:d}),\n  {\n    defaultParams: [dto.value],\n    pagination: {\n      currentKey: "page",\n      pageSizeKey: \'size\',\n      totalKey: \'data.data.total\'\n    }\n  }\n)\n\nfunction tableChange(pagination: PaginationProps) { \n  // console.log(pagination)\n  dto.value.page = pagination.current ?? 1\n  dto.value.size = pagination.pageSize ?? 5\n  search(dto.value)\n}\n\nconst pagination = computed<PaginationProps>(()=>{\n  return {\n    current: dto.value.page, // 当前页\n    pageSize: dto.value.size, // 页大小\n    total: total.value,       // 总记录数\n    showSizeChanger: true,    // 显示页大小的下拉列表\n    pageSizeOptions: ["1","2","3","4","5"] // 自定义下拉列表内容\n  }\n})\n\nconst students = computed(()=>{\n  return data.value?.data.data.list || []\n})\n// <<<<<<<<<<<<<< 搜索功能结束\n\n\n// >>>>>>>>>>>>>> 删除功能开始\nasync function onDelete(id:number) {\n  // console.log("学生id是:"+id)\n  await deleteById(id)      // 删除请求 删除响应\n  search(dto.value)        //                   查询请求 查询响应\n}\n\nconst { runAsync: deleteById } = useRequest<AxiosRespString, number[]>(\n  (id) => axios.delete(`/api/students/${id}`),\n  {\n    manual: true\n  }\n)\n// <<<<<<<<<<<<<< 删除功能结束\n\n// >>>>>>>>>>>>>> 删除选中开始\nconst ids = ref<number[]>([])\n\nfunction onSelectChange(keys:number[]) {\n  // console.log(keys)\n  ids.value = keys\n}\n\nasync function onDeleteIds() {\n  await deleteByIds(ids.value)\n  ids.value = []\n  search(dto.value)\n}\n\nconst { runAsync: deleteByIds } = useRequest<AxiosRespString, number[][]>(\n  (ids)=>axios.delete(\'/api/students\', {data: ids}),\n  {\n    manual: true\n  }\n)\n\nconst visible = ref(false)\n\nfunction onVisibleChange(v:boolean) {\n  if(!v) { // 希望隐藏\n    visible.value = false\n  } else { // 希望显示\n    visible.value = ids.value.length > 0\n  }\n}\n// <<<<<<<<<<<<<< 删除选中结束\n\nconst columns = ref([\n  {\n    title: "编号",\n    dataIndex: "id",\n  },\n  {\n    title: "姓名",\n    dataIndex: "name",\n  },\n  {\n    title: "性别",\n    dataIndex: "sex",\n  },\n  {\n    title: "年龄",\n    dataIndex: "age",\n  },\n  {\n    title: \'操作\',\n    dataIndex: \'operation\'\n  }\n]);\n<\/script>\n<style scoped>\n  .ant-input, .ant-select {\n    width: 80px;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n\n\n# 新增、修改\n\n子组件\n\n<template>\n  <a-modal :visible="visible" :title="title" \n    @ok="onOk" @cancel="onCancel">\n    <a-form>\n      <a-form-item label="编号" v-if="id">\n        <a-input readonly v-model:value="id"></a-input>\n      </a-form-item>\n      <a-form-item label="姓名">\n        <a-input v-model:value="dto.name"></a-input>\n      </a-form-item>\n      <a-form-item label="性别">\n        <a-radio-group v-model:value="dto.sex">\n          <a-radio-button value="男">男</a-radio-button>\n          <a-radio-button value="女">女</a-radio-button>\n        </a-radio-group>\n      </a-form-item>\n      <a-form-item label="年龄">\n        <a-input-number v-model:value="dto.age"></a-input-number>\n      </a-form-item>\n    </a-form>\n  </a-modal>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { useRequest } from "vue-request";\nimport { StudentSaveDto, AxiosRespString } from "../model/Model8080";\nimport { Form } from \'ant-design-vue\'\n\n// 定义属性\nconst props = defineProps<{id:number, dto:StudentSaveDto, visible:boolean}>()\n\nconst title = computed(()=> props.id===0?\'新增学生\':\'修改学生\')\n\n// 定义事件\nconst emit = defineEmits([\'update:visible\', \'saved\'])\n\nasync function onOk() {\n  if(props.id === 0) {\n    await insert(props.dto)\n  } else {\n    await update(props.dto)\n  }\n  emit(\'saved\')\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false) \n}\n\nfunction onCancel() {\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false)\n}\n\nconst {runAsync:insert} = useRequest<AxiosRespString,StudentSaveDto[]>(\n  (dto)=>axios.post(\'/api/students\', dto),\n  {\n    manual: true\n  }\n)\n\nconst {runAsync:update} = useRequest<AxiosRespString,StudentSaveDto[]>(\n  (dto)=>axios.put(`/api/students/${props.id}`, dto),\n  {\n    manual: true\n  }\n)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n父组件使用子组件\n\n<A4Save :id="id" :dto="saveDto" v-model:visible="saveVisible"></A4Save>\n\n<script setup lang="ts">\n// ...\n// >>>>>>>>>>>>>> 新增、修改开始\nconst saveVisible = ref(false)\nconst id = ref(0)\nconst saveDto = reactive({name:\'\', sex:\'男\', age:18})\n\nfunction onInsert() {\n  saveVisible.value = true\n  id.value = 0\n  Object.assign(saveDto, {name:\'\', sex:\'男\', age:18})\n}\n\nfunction onUpdate(record: Student) {\n  saveVisible.value = true\n  id.value = record.id\n  Object.assign(saveDto, record)\n}\n\nfunction onSaved() {\n  search(dto.value)\n}    \n// <<<<<<<<<<<<<< 新增、修改结束\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n * saveDto 使用 reactive 包装，是为了解决后续表单校验失效问题\n\n * Object.assign 是将源对象（参数2）的属性值赋值给目标对象（参数1）的同名属性，效果等价于\n   \n   saveDto.name = record.name\n   saveDto.sex = record.sex\n   saveDto.age = record.age\n   \n   \n   1\n   2\n   3\n   \n\n# 全局消息\n\n在 request.ts 中对响应消息统一处理\n\nimport { message } from \'ant-design-vue\'\n\n// ...\n// 响应拦截器\n_axios.interceptors.response.use(\n  (response)=>{ // 状态码  2xx\n    if(response.data.message) {\n      message.success(response.data.message, 3)\n    }    \n    // ... \n  },\n  (error)=>{ // 状态码 > 2xx, 400,401,403,404,500\n    // ...\n  }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 表单校验\n\n<template>\n  <a-modal :visible="visible" :title="title" \n    @ok="onOk" @cancel="onCancel">\n    <a-form>\n      <a-form-item label="编号" v-if="id">\n        <a-input readonly v-model:value="id"></a-input>\n      </a-form-item>\n      <a-form-item label="姓名" v-bind="validateInfos.name">\n        <a-input v-model:value="dto.name"></a-input>\n      </a-form-item>\n      <a-form-item label="性别" v-bind="validateInfos.sex">\n        <a-radio-group v-model:value="dto.sex">\n          <a-radio-button value="男">男</a-radio-button>\n          <a-radio-button value="女">女</a-radio-button>\n        </a-radio-group>\n      </a-form-item>\n      <a-form-item label="年龄" v-bind="validateInfos.age">\n        <a-input-number v-model:value="dto.age"></a-input-number>\n      </a-form-item>\n    </a-form>\n  </a-modal>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { useRequest } from "vue-request";\nimport { StudentSaveDto, AxiosRespString } from "../model/Model8080";\nimport { Form } from \'ant-design-vue\'\n\n// 定义属性\nconst props = defineProps<{id:number, dto:StudentSaveDto, visible:boolean}>()\n\nconst title = computed(()=> props.id===0?\'新增学生\':\'修改学生\')\n\n// 定义事件\nconst emit = defineEmits([\'update:visible\', \'saved\'])\n\nasync function onOk() {\n  try {\n    // 提交前校验\n    await validate()\n    if(props.id === 0) {\n      await insert(props.dto)\n    } else {\n      await update(props.dto)\n    }\n    emit(\'saved\')\n    // 发送事件给父组件, 希望把 visible 改为 false\n    emit(\'update:visible\', false) \n  } catch (e) {\n    console.error(e)\n  }\n}\n\nfunction onCancel() {\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false)\n}\n\nconst {runAsync:insert} = useRequest<AxiosRespString,StudentSaveDto[]>(\n  (dto)=>axios.post(\'/api/students\', dto),\n  {\n    manual: true\n  }\n)\n\nconst {runAsync:update} = useRequest<AxiosRespString,StudentSaveDto[]>(\n  (dto)=>axios.put(`/api/students/${props.id}`, dto),\n  {\n    manual: true\n  }\n)\n\nconst rules = ref({\n  name: [\n    {required: true, message:\'姓名必须\'},\n    {min:2, message:\'字符数至少为2\'}\n  ],\n  sex: [\n    {required: true, message:\'性别必须\'}\n  ],\n  age: [\n    {required: true, message:\'年龄必须\'},\n    {min:10, message:\'年龄最小为10岁\', type:\'number\'},\n    {max:120, message:\'年龄最大为120岁\', type:\'number\'}\n  ]\n})\n\n// 参数1: 待校验的数据\n// 参数2: 校验规则\nconst { validateInfos, validate } = Form.useForm(props.dto, rules)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n\n# 2) vue-router\n\n# 安装\n\nnpm install vue-router@4\n\n\n1\n\n\n# 创建 router\n\n首先创建一个 /src/router/a5router.ts 文件，在其中定义路由\n\nimport {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\n// 路由 => 路径和组件之间的对应关系\nconst routes = [\n  {\n    path: \'/a1\',\n    component: A51\n  },\n  {\n    path: \'/a2\', \n    component: A52\n  }\n]\n\nconst router = createRouter({ \n  history: createWebHashHistory(), // 路径格式\n  routes: routes // 路由数组\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n * createWebHashHistory 是用 # 符号作为【单页面】跳转技术，上面两个路由访问时路径格式为\n   \n   * http://localhost:7070/#/a1\n   * http://localhost:7070/#/a2\n\n * 每个路由都有两个必须属性\n   \n   * path：路径\n   \n   * component：组件\n\n * createRouter 用来创建 router 对象，作为默认导出\n\n需要在 main.ts 中导入 router 对象：\n\n// ...\nimport A5 from \'./views/A5.vue\'  // vue-router\nimport router from \'./router/a5router\'\ncreateApp(A5).use(antdv).use(router).mount(\'#app\')\n\n\n1\n2\n3\n4\n\n\nA5 是根组件，不必在 router 中定义，但需要在其中定义 router-view，用来控制路由跳转后，A51、A52 这些组件的显示位置，内容如下\n\n<template>\n  <div class="a5">\n    <router-view></router-view>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n\n\n效果如下\n\n\n\n\n\n# 动态导入\n\nimport {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () => import(\'../views/A53.vue\')\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 用 import 关键字导入，效果是打包时会将组件的 js 代码都打包成一个大的 js 文件，如果组件非常多，会影响页面加载速度\n * 而 import 函数导入（动态导入），则是按需加载，即\n   * 当路由跳转到 /a3 路径时，才会去加载 A53 组件对应的 js 代码\n   * vue-router 官方推荐采用动态导入\n\n# 嵌套路由\n\n如果希望再嵌套更深层次的路由跳转，例如：希望在 A53 组件内再进行路由跳转\n\n\n\n首先，修改 A53.vue\n\n<template>\n  <div class="a53">\n    <router-view></router-view>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n\n\n其次，再修改 /src/router/a5router.ts 文件 内容\n\nimport {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () => import(\'../views/A53.vue\'),\n    children: [\n      {\n        path: \'student\',\n        component: () => import(\'../views/A531.vue\')\n      },\n      {\n        path: \'teacher\',\n        component: () => import(\'../views/A532.vue\')\n      }\n    ]\n  }\n]\n\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n将来访问 /a3/student 时，效果为\n\n\n\n访问 /a3/teacher 时，效果为\n\n\n\n# 重定向\n\n用法1\n\nimport {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () => import(\'../views/A53.vue\'),\n    redirect: \'/a3/student\', // 重定向到另外路径\n    children: [\n      {\n        path: \'student\',\n        component: () => import(\'../views/A531.vue\')\n      },\n      {\n        path: \'teacher\',\n        component: () => import(\'../views/A532.vue\')\n      }\n    ]\n  }\n]\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n效果是，页面输入 /a3，紧接着会重定向跳转到 /a3/student\n\n用法2\n\nimport {createRouter, createWebHashHistory} from \'vue-router\'\nimport A51 from \'../views/A51.vue\'\nimport A52 from \'../views/A52.vue\'\nconst routes = [\n  {\n    path: \'/a1\',\n    component: A51\n  },\n  {\n    path: \'/a2\', \n    component: A52\n  },\n  // ...\n  {\n    path: \'/:pathMatcher(.*)*\', // 可以匹配剩余的路径\n    redirect: \'/a2\'\n  }\n]\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n效果是，当页面输入一个不存在路径 /aaa 时，会被 path: \'/:pathMatcher(.*)*\' 匹配到，然后重定向跳转到 A52 组件去\n\n# 主页布局\n\n借助 antdv 的 layout 组件，可以实现主页【上】【左】【右】布局\n\n<template>\n  <div class="a53">\n    <a-layout>\n      <a-layout-header></a-layout-header>\n      <a-layout>\n        <a-layout-sider></a-layout-sider>\n        <a-layout-content>\n          <router-view></router-view>\n        </a-layout-content>\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n<style scoped>\n.a53 {\n  height: 100%;\n  background-color: rgb(220, 225, 255);\n  background-image: url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\'%3E%3Ctext x=\'35\' y=\'10\' font-size=\'14\' font-family=\'system-ui, sans-serif\' text-anchor=\'middle\' dominant-baseline=\'middle\'%3EA53(主页)%3C/text%3E%3C/svg%3E");\n  padding: 20px;\n  box-sizing: border-box;\n}\n.ant-layout-header {\n  height: 50px;\n  background-color:darkseagreen;\n}\n\n.ant-layout-sider {\n  background-color:lightsalmon;\n}\n\n.ant-layout-content {\n  background-color: aliceblue;\n}\n\n.ant-layout-footer {\n  background-color:darkslateblue;\n  height: 30px;\n}\n\n.ant-layout {\n  height: 100%;\n}\n\n.ant-layout-has-sider {\n  height: calc(100% - 50px);\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n# 侧边栏菜单\n\n<template>\n  <div class="a53">\n    <a-layout>\n      <a-layout-header></a-layout-header>\n      <a-layout>\n        <a-layout-sider>\n          <a-menu theme="dark" mode="inline">\n            <a-menu-item :key="1">\n              <router-link to="/a3/student">菜单1</router-link>\n            </a-menu-item>\n            <a-menu-item :key="2">\n              <router-link to="/a3/teacher">菜单2</router-link>\n            </a-menu-item>\n            <a-menu-item :key="3">菜单3</a-menu-item>\n            <a-sub-menu :key="4" title="菜单4">\n              <a-menu-item :key="41">菜单41</a-menu-item>\n              <a-menu-item :key="42">菜单42</a-menu-item>\n            </a-sub-menu>\n          </a-menu>\n        </a-layout-sider>\n        <a-layout-content>\n          <router-view></router-view>\n        </a-layout-content>\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * a-menu-item 与 a-sub-menu 都必须为 key 属性唯一赋值，否则会产生混乱\n * router-link 标签用来切换路由，to 是目标路由的路径\n * theme 属性定义菜单的主题（默认亮色主题，dark 为暗色主题）\n * mode 属性定义子菜单的展示模式（默认弹出，inline 显示在下方）\n\n# 菜单图标\n\n安装图标依赖\n\nnpm install @ant-design/icons-vue\n\n\n1\n\n\n菜单中使用图标\n\n<template>\n  <div class="a53">\n    <a-layout>\n      <a-layout-header></a-layout-header>\n      <a-layout>\n        <a-layout-sider>\n          <a-menu theme="dark" mode="inline">\n            <a-menu-item :key="1">\n              <template #icon>\n                <highlight-outlined />\n              </template>\n              <router-link to="/a3/student">菜单1</router-link>\n            </a-menu-item>\n            <a-menu-item :key="2">\n              <template #icon>\n                <align-center-outlined />\n              </template>\n              <router-link to="/a3/teacher">菜单2</router-link>\n            </a-menu-item>\n            <a-menu-item :key="3">\n              <template #icon>\n                <strikethrough-outlined />\n              </template>\n              菜单3</a-menu-item>\n            <a-sub-menu :key="4" title="菜单4">\n              <template #icon>\n                <sort-descending-outlined />\n              </template>\n              <a-menu-item :key="41">菜单41</a-menu-item>\n              <a-menu-item :key="42">菜单42</a-menu-item>\n            </a-sub-menu>\n          </a-menu>\n        </a-layout-sider>\n        <a-layout-content>\n          <router-view></router-view>\n        </a-layout-content>\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n<script setup lang="ts">\nimport {HighlightOutlined, AlignCenterOutlined, StrikethroughOutlined, SortDescendingOutlined} from \'@ant-design/icons-vue\'\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n * 图标组件没有全局绑定，需要 import 之后才能使用\n * 用 <template #icon></template> 插槽，才能确定图标展示的位置（菜单文字之前）\n\n# 二次封装图标组件\n\n最终希望用统一的图标组件去使用图标，图标名只是作为一个属性值传递进去，例如：\n\n使用者\n\n<template>\n  <a-icon icon="highlight-outlined"></a-icon>\n  <a-icon icon="align-center-outlined"></a-icon>\n  <a-icon icon="strikethrough-outlined"></a-icon>\n  <a-icon icon="sort-descending-outlined"></a-icon>\n</template>\n<script setup lang="ts">\nimport AIcon from \'../components/AIcon1.vue\'\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 方法1，使用 vue 组件\n\n<script lang="ts" setup>\nimport {HighlightOutlined, AlignCenterOutlined, StrikethroughOutlined, SortDescendingOutlined} from \'@ant-design/icons-vue\'\nconst props = defineProps<{icon:string}>()\n<\/script>\n<template>\n  <highlight-outlined v-if="icon===\'highlight-outlined\'"></highlight-outlined>\n  <align-center-outlined v-else-if="icon===\'align-center-outlined\'"></align-center-outlined>\n  <strikethrough-outlined v-else-if="icon===\'strikethrough-outlined\'"></strikethrough-outlined>\n  <sort-descending-outlined v-else-if="icon===\'sort-descending-outlined\'"></sort-descending-outlined>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 缺点：实现太笨\n\n# 方法2，使用函数式组件\n\nimport { h } from "vue"\nimport * as Icons from \'@ant-design/icons-vue\'\n\ninterface Module {\n  [p:string]: any\n}\n\n// 参数1: 组件属性\nconst AIcon = (props:{icon:string}) => {\n  // console.log(props.icon)\n  // console.log(Icons)\n  // 参数1: 组件对象\n  const im: Module = Icons\n  return h(im[toCamelCase(props.icon)])\n}\n\nexport default AIcon\n\n// 将-分隔的单词转换为大驼峰命名的单词\nfunction toCamelCase(str: string) { // highlight-outlined\n  return str.split(\'-\') // [\'highlight\', \'outlined\']\n    .map((e)=> e.charAt(0).toUpperCase() + e.slice(1) ) // [\'Highlight\', \'Outlined\']\n    .join(\'\')\n}\n/*\nIcons 的结构如下\n{\n  HighlightOutlined: HighlightOutlined组件对象,\n  MonitorOutlined: MonitorOutlined组件对象,\n  ...\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 需要动态生成标签的时候，可以考虑使用函数式组件\n\n# 方法3，使用 jsx 组件\n\n首先，安装\n\nnpm install @vitejs/plugin-vue-jsx -D\n\n\n1\n\n\n配置 vite.config.ts\n\nimport { defineConfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\nimport vueJsx from \'@vitejs/plugin-vue-jsx\'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue(), vueJsx()]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n编写一个 Hi.tsx 组件\n\nexport default {\n  props: {\n    msg: String\n  },\n  setup(props: { msg: string }) {\n    return () => <h5>{props.msg}</h5>\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后被其它组件使用\n\n<script setup lang="ts">\nimport Hi from \'../components/Hi\'\n<\/script>\n\n<template>\n  <Hi msg="Hello,World"></Hi>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n用 jsx 实现图标组件\n\nimport * as Icons from \'@ant-design/icons-vue\'\n\ninterface Module {\n  [p:string]: any\n}\n\nfunction toCamelCase(str: string) { // highlight-outlined\n  return str\n    .split("-") // [\'highlight\', \'outlined\']\n    .map((e) => e.charAt(0).toUpperCase() + e.slice(1)) // [\'Highlight\', \'Outlined\']\n    .join(""); // HighlightOutlined\n}\n\nexport default {\n  props: {\n    icon: String\n  },\n  setup(props: {icon: string}) {\n    const im: Module = Icons\n    const tag = im[toCamelCase(props.icon)] // 图标组件\n    // HighlightOutlined\n    return ()=> <tag></tag> // 返回组件标签\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 动态路由与菜单\n\n# 路由文件\n\na6router.js\n\nimport { createRouter, createWebHashHistory } from \'vue-router\'\nimport { useStorage } from \'@vueuse/core\'\nimport { Route, Menu } from \'../model/Model8080\'\nconst clientRoutes = [\n  {\n    path: \'/login\',\n    name: \'login\',\n    component: () => import(\'../views/A6Login.vue\')\n  },\n  {\n    path: \'/404\',\n    name: \'404\',\n    component: () => import(\'../views/A6NotFound.vue\')\n  },\n  {\n    path: \'/\',\n    name: \'main\',\n    component: () => import(\'../views/A6Main.vue\')\n  },\n  {\n    path: \'/:pathMatcher(.*)*\',\n    name: \'remaining\',\n    redirect: \'/404\'\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: clientRoutes\n})\n\nexport const serverMenus = useStorage<Menu[]>(\'serverMenus\', [])\nconst serverRoutes = useStorage<Route[]>(\'serverRoutes\', [])\naddServerRoutes(serverRoutes.value)\n\nexport function addServerRoutes(routeList: Route[]) {\n  for (const r of routeList) {\n    if (r.parentName) {\n      router.addRoute(r.parentName, {\n        path: r.path,\n        component: () => import(r.component),\n        name: r.name\n      })\n    }\n  }\n  serverRoutes.value = routeList\n}\n\nexport function resetRoutes() {\n  for (const r of clientRoutes) {\n    router.addRoute(r)\n  }\n  serverRoutes.value = null\n  serverMenus.value = null\n}\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n本文件重要的函数及变量\n\n * addServerRoutes 函数向路由表中添加由服务器提供的路由，路由分成两部分\n   * clientRoutes 这是客户端固定的路由\n   * serverRoutes 这是服务器变化的路由，存储于 localStorage\n * resetRoutes 函数用来将路由重置为 clientRoutes\n   * vue-router@4 中的 addRoute 方法会【覆盖】同名路由，这是这种实现的关键\n   * 因此，服务器返回的路由最好是 main 的子路由，这样重置时就会比较简单，用之前的 main 一覆盖就完事了\n * serverMenus 变量记录服务器变化的菜单，存储于 localStorage\n\n# 登录组件\n\n动态路由应当在登录时生成，A6Login.vue\n\n<template>\n  <div class="login">\n    <a-form :label-col="{ span: 6 }" autocomplete="off">\n      <a-form-item label="用户名" v-bind="validateInfos.username">\n        <a-input v-model:value="dto.username" />\n      </a-form-item>\n      <a-form-item label="密码" v-bind="validateInfos.password">\n        <a-input-password v-model:value="dto.password" />\n      </a-form-item>\n      <a-form-item :wrapper-col="{ offset: 6, span: 16 }">\n        <a-button type="primary" @click="onClick">Submit</a-button>\n      </a-form-item>      \n    </a-form>\n  </div>\n</template>\n<script setup lang="ts">\nimport { ref, onMounted } from \'vue\'\nimport { Form } from \'ant-design-vue\'\nimport { useRouter } from \'vue-router\'\nimport axios from \'../api/request\'\nimport { useRequest } from \'vue-request\'\nimport { AxiosRespToken, LoginDto, AxiosRespMenuAndRoute } from \'../model/Model8080\'\nimport { resetRoutes, addServerRoutes, serverMenus } from \'../router/a6router\'\nconst dto = ref({username:\'\', password:\'\'})\nconst rules = ref({\n  username: [\n    {required: true, message:\'用户名必填\'}\n  ],\n  password:[\n    {required: true, message:\'密码必填\'}\n  ]\n})\nconst { validateInfos, validate } = Form.useForm(dto, rules)\nconst router = useRouter()\nconst { runAsync:login } = useRequest<AxiosRespToken, LoginDto[]>((dto)=> axios.post(\'/api/loginJwt\', dto), {manual:true})\nconst { runAsync:menu } = useRequest<AxiosRespMenuAndRoute, string[]>((username)=> axios.get(`/api/menu/${username}`), {manual:true})\nasync function onClick() {\n  try {\n    await validate()\n    const loginResp = await login(dto.value\n    if(loginResp.data.code === 200) { // 登录成功\n      const token = loginResp.data.data.token\n      const menuResp = await menu(dto.value.username)\n      const routeList = menuResp.data.data.routeList\n      addServerRoutes(routeList)\n      serverMenus.value = menuResp.data.data.menuTree\n      router.push(\'/\')\n    })\n  } catch (e) {\n    console.error(e)\n  }\n}\nonMounted(()=>{\n  resetRoutes()\n})\n<\/script>\n<style scoped>\n.login{\n  margin: 200px auto;\n  width: 25%;\n  padding: 20px;\n  height: 180px;\n  background-color: antiquewhite;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n * 登录成功后去请求 /api/menu/{username} 获取该用户的菜单和路由\n * router.push 方法用来以编程方式跳转至主页路由\n\n# 主页组件\n\nA6Main.vue\n\n<template>\n  <div class="a6main">\n    <a-layout>\n      <a-layout-header>\n      </a-layout-header>\n      <a-layout>\n        <a-layout-sider>\n          <a-menu mode="inline" theme="dark">\n            <template v-for="m1 of serverMenus">\n              <a-sub-menu v-if="m1.children" :key="m1.id" :title="m1.title">\n                <template #icon><a-icon :icon="m1.icon"></a-icon></template>\n                <a-menu-item v-for="m2 of m1.children" :key="m2.id">\n                  <template #icon><a-icon :icon="m2.icon"></a-icon></template>\n                  <router-link v-if="m2.routePath" :to="m2.routePath">{{m2.title}}</router-link>\n                  <span v-else>{{m2.title}}</span>\n                </a-menu-item>\n              </a-sub-menu>\n              <a-menu-item v-else :key="m1.id">\n                <template #icon><a-icon :icon="m1.icon"></a-icon></template>\n                <router-link v-if="m1.routePath" :to="m1.routePath">{{m1.title}}</router-link>\n                <span v-else>{{m1.title}}</span>\n              </a-menu-item>\n            </template>            \n          </a-menu>\n        </a-layout-sider>\n        <a-layout-content>\n          <router-view></router-view>\n        </a-layout-content>\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n<script setup lang="ts">\nimport AIcon from \'../components/AIcon3\' // jsx icon 组件\nimport { serverMenus } from \'../router/a6router\'\n<\/script>\n<style scoped>\n.a6main {\n  height: 100%;\n  background-color: rgb(220, 225, 255);\n  box-sizing: border-box;\n}\n.ant-layout-header {\n  height: 50px;\n  background-color:darkseagreen;\n}\n\n.ant-layout-sider {\n  background-color:lightsalmon;\n}\n\n.ant-layout-content {\n  background-color: aliceblue;\n}\n\n.ant-layout-footer {\n  background-color:darkslateblue;\n  height: 30px;\n}\n\n.ant-layout {\n  height: 100%;\n}\n\n.ant-layout-has-sider {\n  height: calc(100% - 50px);\n}\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n# token 使用\n\n 1. 获取用户信息，例如服务器端可以把用户名、该用户的路由、菜单信息都统一从 token 返回\n 2. 前端路由跳转依据，例如跳转前检查 token，如果不存在，表示未登录，就避免跳转至某些路由\n 3. 后端 api 访问依据，例如每次发请求携带 token，后端需要身份校验的 api 需要用到\n\n\n# 3) pinia\n\n需求：在组件 p1 里更新了数据，主页组件也同步更新显示\n\n\n\n * storage 虽然可以实现多个组件的数据共享，但是需要【主动访问】才能获取更新后的数据\n * 本例中由于没有涉及主页组件的 mounted 操作，因此并不会【主动】获取 storage 的数据\n\n# 安装\n\nnpm install pinia\n\n\n1\n\n\n在 main.ts 中引入\n\nimport { createPinia } from \'pinia\'\n\n// ...\ncreateApp(A6).use(antdv).use(router).use(createPinia()).mount(\'#app\')\n\n\n1\n2\n3\n4\n\n\n# 定义Store\n\n再新建 store 目录来管理共享数据，下面是 /src/store/UserInfo.ts\n\nimport axios from \'../api/request\'\nimport { defineStore } from "pinia"\nimport { UserInfoDto } from \'../model/Model8080\'\n\nexport const useUserInfo = defineStore(\'userInfo\', {\n  state: () => {\n    return { username: \'\', name: \'\', sex: \'\' }\n  },\n  actions: {\n    async get(username: string) {\n      const resp = await axios.get(`/api/info/${username}`)\n      Object.assign(this, resp.data.data)\n    },\n    async update(dto: UserInfoDto) {\n      await axios.post(\'/api/info\', dto)\n      Object.assign(this, dto)\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n * 定义了 useUserInfo 函数，用来获取共享数据，它可能用于多个组件\n   \n   * 命名习惯上，函数变量以 use 打头\n\n * state 定义数据格式\n\n * actions 定义操作数据的方法\n   \n   * get 方法用来获取用户信息\n   \n   * update 方法用来修改用户信息\n\n * 由于 useRequest 必须放在 setup 函数内，这里简化起见，直接使用了 axios\n\n获取用户信息\n\n<template>\n  <div class="a6main">\n    <a-layout>\n      <a-layout-header>\n        <span>{{serverUsername}} 【{{userInfo.name}} - {{userInfo.sex}}】</span>\n      </a-layout-header>\n      <a-layout>\n        \x3c!-- ... --\x3e\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n<script setup lang="ts">\nimport { onMounted } from \'vue\';\nimport AIcon from \'../components/AIcon3\' // jsx icon 组件\nimport { serverMenus, serverUsername } from \'../router/a6router\'\nimport { useUserInfo } from \'../store/UserInfo\'\nconst userInfo = useUserInfo()\n\nonMounted(()=>{\n  userInfo.get(serverUsername.value)\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n修改用户信息\n\n<template>\n  <div class="a6p1">\n    <h3>修改用户信息</h3>\n    <hr>\n    <a-form>\n      <a-form-item label="用户名">\n        <a-input readonly v-model:value="dto.username"></a-input>\n      </a-form-item>\n      <a-form-item label="姓名" v-bind="validateInfos.name">\n        <a-input v-model:value="dto.name"></a-input>\n      </a-form-item>\n      <a-form-item label="性别">\n        <a-radio-group v-model:value="dto.sex">\n          <a-radio-button value="男">男</a-radio-button>\n          <a-radio-button value="女">女</a-radio-button>\n        </a-radio-group>\n      </a-form-item>\n    </a-form>\n    <a-button type="primary" @click="onClick">确定</a-button>\n  </div>\n</template>\n<script setup lang="ts">\nimport { Form } from \'ant-design-vue\'\nimport { onMounted, ref } from \'vue\'\nimport { UserInfoDto } from \'../model/Model8080\'\nimport { useUserInfo } from \'../store/UserInfo\';\nconst dto = ref<UserInfoDto>({ username: \'\', name: \'\', sex: \'\' })\nconst userInfo = useUserInfo()\nonMounted(()=>{\n  Object.assign(dto.value, userInfo)\n})\nconst rules = ref({\n  name: [\n    {required: true, message:\'姓名必填\'}\n  ]\n})\nconst { validateInfos, validate } = Form.useForm(dto, rules)\nasync function onClick() {\n  try {\n    await validate()\n    await userInfo.update(dto.value)\n  } catch (e) {\n    console.error(e)\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 不能直接把 userInfo 绑定到表单，需要 dto 中转一下\n * userInfo.update 和 useInfo.get 返回的都是 Promise 对象，可以配合 await 一起用\n\n\n# 后记\n\nvite + vue3 + vue-router + ts 还没有太多成熟的项目范例，可以参考 GitHub - sendya/preview-pro: Use pro-layout in vitejs. preview https://sendya.github.io/preview-pro/index.html，它提供了基本的布局和样例代码',normalizedContent:'# 黑马 vue3 学习小结\n\n\n# 1. typescript\n\n\n# 1) 动态类型的问题\n\n前面我们讲过 js 属于动态类型语言，例如\n\nfunction test(obj) {    \n}\n\n\n1\n2\n\n\nobj 可能只是个字符串\n\ntest(\'hello, world\')\n\n\n1\n\n\nobj 也有可能是个函数\n\ntest(()=>console.log(\'hello, world\'))\n\n\n1\n\n\nobj 类型不确定，就给后期使用者带来了麻烦，一旦参数传不对，代码就崩溃了\n\n动态类型意味着\n\n * 运行代码时才知道发生什么 (running the code to see what happens)\n\n静态类型意味着\n\n * 在代码运行前，就对它的行为做出预测 (make predications about what code is expected before it runs)\n\n下面的 typescript 代码，就在代码运行前对参数加入了约束限制\n\nfunction test(msg : string) {\n}\n\n\n1\n2\n\n * 限制了参数只能做 string 那些事\n\nfunction test(msg : function) {\n  msg()\n}\n\n\n1\n2\n3\n\n * 限制了参数只能做函数那些事\n\n\n# 2) 入门\n\n安装 typescript 编译器\n\nnpm install -g typescript\n\n\n1\n\n\n编写 ts 代码\n\nfunction hello(msg: string) {\n  console.log(msg)\n}\n\nhello(\'hello,world\')\n\n\n1\n2\n3\n4\n5\n\n\n执行 tsc 编译命令\n\ntsc xxx.ts\n\n\n1\n\n\n编译生成 js 代码，编译后进行了类型擦除\n\nfunction hello(msg) {\n    console.log(msg);\n}\nhello(\'hello,world\');\n\n\n1\n2\n3\n4\n\n\n再来一个例子，用 interface 定义用户类型\n\ninterface user {\n  name: string,\n  age: number\n}\n\nfunction test(u: user): void {\n  console.log(u.name)\n  console.log(u.age)\n}\n\ntest({ name: \'zhangs\', age: 18 })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n编译后\n\nfunction test(u) {\n    console.log(u.name);\n    console.log(u.age);\n}\ntest({ name: \'zhangs\', age: 18 });\n\n\n1\n2\n3\n4\n5\n\n\n可见，typescript 属于编译时实施类型检查（静态类型）的技术\n\n\n# 3) 类型\n\n类型          例                                  备注\n字符串类型       string                             \n数字类型        number                             \n布尔类型        boolean                            \n数组类型        number[],string[],boolean[] 依此类推   \n任意类型        any                                相当于又回到了没有类型的时代\n复杂类型        type 与 interface                   \n函数类型        () => void                         对函数的参数和返回值进行说明\n字面量类型       "a"|"b"|"c"                        限制变量或参数的取值\nnullish类型   null 与 undefined                   \n泛型          <t>，<t extends 父类型>                \n\n# 标注位置\n\n# 标注变量\n\nlet message: string = \'hello,world\'\n\n\n1\n\n * 一般可以省略，因为可以根据后面的字面量推断出前面变量类型\n\nlet message = \'hello,world\'\n\n\n1\n\n\n# 标注参数\n\nfunction greet(name: string) {\n    \n}\n\n\n1\n2\n3\n\n\n很多时候，都能够推断出参数类型\n\nconst names = [\'alice\', \'bob\', \'eve\']\nconst lowercasenames = names.map((e: string) => e.tolowercase())\n\n\n1\n2\n\n * 可以用类型推断，推断出 e 是 string 类型\n\n# 标注返回值\n\nfunction add(a: number, b: number) : number {\n    return a + b\n}\n\n\n1\n2\n3\n\n * 一般也可以省略，因为可以根据返回值做类型推断\n\n# 复杂类型\n\n# type\n\ntype cat = {\n  name: string,\n  age: number\n}\n\nconst c1: cat = { name: \'小白\', age: 1 }\nconst c2: cat = { name: \'小花\' }\t\t\t\t\t  // 错误: 缺少 age 属性\nconst c3: cat = { name: \'小黑\', age: 1, sex: \'公\' } // 错误: 多出 sex 属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# interface\n\ninterface cat {\n  name: string,\n  age: number\n}\n\nconst c1: cat = { name: \'小白\', age: 1 }\nconst c2: cat = { name: \'小花\' }\t\t\t\t\t  // 错误: 缺少 age 属性\nconst c3: cat = { name: \'小黑\', age: 1, sex: \'公\' } // 错误: 多出 sex 属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 可选属性\n\n如果需要某个属性可选，可以用下面的语法\n\ninterface cat {\n  name: string,\n  age?: number\n}\n\nconst c1: cat = { name: \'小白\', age: 1 }\nconst c2: cat = { name: \'小花\' }\t\t\t\t\t  // 正确: age 属性可选\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 可选属性要注意处理 undefined 值\n\n# 鸭子类型\n\ninterface cat {\n  name: string\n}\n\nfunction test(cat: cat) {\n  console.log(cat.name)\n}\n\nconst c1 = { name: \'小白\', age: 1 } \ntest(c1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * const c1 并没有声明类型为 cat，但它与 cat 类型有一样的属性，也可以被当作是 cat 类型\n\n# 方法类型\n\ninterface api {\n  foo(): void,\n  bar(str: string): string\n}\n\nfunction test(api: api) {\n  api.foo()\n  console.log(api.bar(\'hello\'))\n}\n\ntest({\n  foo() { console.log(\'ok\') },\n  bar(str: string) { return str.touppercase() }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 字面量类型\n\nfunction printtext(s: string, alignment: "left" | "right" | "center") {\n  console.log(s, alignment)\n}\n\nprinttext(\'hello\', \'left\')\nprinttext(\'hello\', \'aaa\') // 错误: 取值只能是 left | right | center\n\n\n1\n2\n3\n4\n5\n6\n\n\n# nullish 类型\n\nfunction test(x?: string | null) {\n  console.log(x?.touppercase())\n}\n\ntest(\'aaa\')\ntest(null)\ntest()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * x?: string | null 表示可能是 undefined 或者是 string 或者是 null\n\n# 泛型\n\n下面的几个类型声明显然有一定的相似性\n\ninterface refstring {\n  value: string\n}\n\ninterface refnumber {\n  value: number\n}\n\ninterface refboolean {\n  value: boolean\n}\n\nconst r1: refstring = { value: \'hello\' }\nconst r2: refnumber = { value: 123 }\nconst r3: refboolean = { value: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n可以改进为\n\ninterface ref<t> {\n  value: t\n}\n\nconst r1: ref<string> = { value: \'hello\' }\nconst r2: ref<number> = { value: 123 }\nconst r3: ref<boolean> = { value: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 泛型的要点就是 <类型参数>，把【类型】也当作一个变化的要素，像参数一样传递过来，这样就可以派生出结构相似的新类型\n\n函数定义也支持泛型\n\nfunction ref<t>(n: t): ref<t> {\n  return { value: n }\n}\n\nconst v1 = ref("hello"); \t// ref<string>\nconst v2 = ref(123.3333);\t// ref<number>\n\nv1.value.tolocalelowercase()\nv2.value.tofixed(2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4) 意义\n\n# 更好理解框架\n\n现在越来越多的前端框架采用 typescript，如果懂 typescript 语法，可以更好地阅读框架代码\n\n以 map 为例\n\nconst map = new map<string, string>()\nmap\n  .set("a", "b")\n  .set("c", "d")\n\nmap.foreach((value,key,m)=>{\n  console.log(value, key)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 注意编译需要 tsc --target es6 .\\xxx.ts\n\n# 更好的提示\n\n例如，从服务器返回的一段 json，如果不用 typescript，则编辑器也不能给出准确的提示\n\ninterface user {\n  name: string,\n  age: number\n}\n\nconst user: user = json.parse(`{ "name":"张三", "age":18 }`)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5) 类\n\n> 关于 typescript 与 javascript 中的类语法不是重点，class 相关语法只是起到辅助作用，更重要的是前面讲的 interface\n\n# 基本语法\n\nclass user {\n    name: string;\n    \n    constructor(name: string) {\n        this.name = name\n    }\n}\n\nconst u = new user(\'张三\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n其实会被编译成这个样子（默认 --target=es3）\n\nvar user = /** @class */ (function () {\n    function user(name) {\n        this.name = name;\n    }\n    return user;\n}());\nvar u = new user(\'张三\');\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n所以 js 中的 class，并不等价于 java 中的 class，它还是基于原型实现的，原理参考第二章（036、037）\n\n# 只读属性\n\nclass user {\n  readonly name: string;\n  \n  constructor(name: string) {\n      this.name = name\n  }\n}\n\nconst u = new user(\'张三\')\nu.name = \'李四\'\t\t\t\t// 编译错误\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * readonly 是 typescript 特有的，表示该属性只读\n\n# 方法\n\nclass user {\n  readonly name: string;\n  \n  constructor(name: string) {\n      this.name = name\n  }\n\n  study() {\n    console.log(`[${this.name}]正在学习`)\n  }\n}\n\nconst u = new user(\'张三\')\nu.study()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# get，set\n\nclass user {\n  _name: string;\n\n  constructor(name: string) {\n    this._name = name\n  }\n\n  get name() {\n    return this._name\n  }\n\n  set name(name: string) {\n    this._name = name\n  }\n}\n\nconst u = new user(\'张三\')\nconsole.log(u.name)\nu.name = \'李四\'\nconsole.log(u.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 注意，需要在编译时加上 tsc --target es6 .\\xxx.ts 选项\n * es6 等价于 es2015，再此之上还有 es2016 ... es2022\n\n# 类与接口\n\ninterface user {\n  name: string\n  study(course: string): void\n}\n\nclass userimpl implements user {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  study(course: string) {\n    console.log(`[${this.name}]正在学习[${course}]`)\n  }\n  foo() { }\n}\n\nconst user: user = new userimpl(\'张三\')\nuser.study(\'typescript\')\nuser.foo() // 错误，必须是接口中定义的方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 继承与接口\n\ninterface flyable {\n  fly(): void\n}\n\nclass animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nclass bird extends animal implements flyable {\n  fly() {\n    console.log(`${this.name}在飞翔`)\n  }\n}\n\nconst b: flyable & animal = new bird("小花")\nb.fly()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * flyable & animal 表示变量是 flyable 类型，同时也是 animal 类型\n\n# 方法重写\n\nclass father {\n  study(): void {\n    console.log(`father study`)\n  }\n}\n\nclass son extends father {  \n  study(): void {\n    super.study()\n    console.log(`son study`)\n  }\n}\n\nconst f: father = new son()\nf.study()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2. vue3 基础\n\n技术选型\n\n * vue\n   * 选项式 api 还是 组合式 api✔️\n   * html 还是 单文件组件✔️\n * 语法\n   * javascript 还是 typescript✔️\n * 构建工具\n   * @vue/cli 还是 vite✔️\n * 路由\n   * vue-router✔️\n * 共享存储\n   * vuex 还是 pinia✔️\n * 视图组件\n   * elementui 还是 antdv✔️\n\n\n# 1) 环境准备\n\n# 创建项目\n\n采用 vite 作为前端项目的打包，构建工具\n\nnpm init vite@latest\n\n\n1\n\n\n按提示操作\n\ncd 项目目录\nnpm install\nnpm run dev\n\n\n1\n2\n3\n\n\n# 编码 ide\n\n推荐采用微软的 vscode 作为开发工具，到它的官网 visual studio code - code editing. redefined 下载安装即可\n\n\n\n要对 *.vue 做语法支持，还要安装一个 volar 插件\n\n\n\n# 安装 devtools\n\n * devtools 插件网址：https://devtools.vuejs.org/guide/installation.html\n\n\n\n# 修改端口\n\n打开项目根目录下 vite.config.ts\n\nimport { defineconfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\n\n// https://vitejs.dev/config/\nexport default defineconfig({\n  plugins: [vue()],\n  server: {\n    port: 7070\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 文档地址：配置 vite {#configuring-vite} | vite中文网 (vitejs.cn)\n\n# 配置代理\n\n为了避免前后端服务器联调时， fetch、xhr 请求产生跨域问题，需要配置代理，同样是修改项目根目录下 vite.config.ts\n\nimport { defineconfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\n\n// https://vitejs.dev/config/\nexport default defineconfig({\n  plugins: [vue()],\n  server: {\n    port: 7070,\n    proxy: {\n      \'/api\': {\n        target: \'http://localhost:8080\',\n        changeorigin: true\n      }\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 文档地址：配置 vite {#configuring-vite} | vite中文网 (vitejs.cn)\n\n# 项目结构\n\nindex.html\npackage.json\ntsconfig.json\nvite.config.ts\n├─public\n└─src\n    ├─assets\n    ├─components\n    ├─model\n    ├─router\n    ├─store\n    └─views\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * index.html 为主页面\n * package.json npm 配置文件\n * tsconfig.json typescript 配置文件\n * vite.config.ts vite 配置文件\n * public 静态资源\n * src/components 可重用组件\n * src/model 模型定义\n * src/router 路由\n * src/store 共享存储\n * src/views 视图组件\n\n\n# 2) vue 组件\n\nvue 的组件文件以 .vue 结尾，每个组件由三部分组成\n\n<script setup lang="ts"><\/script>\n\n<template></template>\n\n<style scoped></style>\n\n\n1\n2\n3\n4\n5\n\n * script 代码部分，控制模板的数据来源和行为\n * template 模板部分，由它生成 html 代码\n * style 样式部分，一般不咋关心\n\n根组件是 src/app.vue，先来个 hello,world 例子\n\n<script setup lang="ts">\nimport { ref } from "vue";\nlet msg = ref("hello"); // 把数据变成响应式的\n\nfunction change() {\n  msg.value = "world";\n  console.log(msg);\n}\n<\/script>\n<template>\n  <h1>{{ msg }}</h1>\n  <input type="button" value="修改msg" @click="change" />\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * {{msg}} 用来把一个变量绑定到页面上某个位置\n * 绑定的变量必须用 ref 函数来封装\n   * ref 返回的是【响应式】数据，即数据一旦变化，页面展示也跟着变化\n\n# main.ts\n\nimport { createapp } from \'vue\'\nimport \'./style.css\'\nimport app from \'./app.vue\'\n\ncreateapp(app)\n  .mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n\n * createapp 是创建一个 vue 应用程序，它接收的参数 app 即之前我们看到的根组件\n * mount 就是把根组件生成的 html 代码片段【挂载】到 index.html 中 id 为 app 的 html 元素上\n\n可以修改自己的组件文件，挂载到主页面\n\n新建 src/views/e0.vue，内容如下\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst msg = ref(\'hello, world!!\')\n<\/script>\n<template>\n  <h1>{{ msg }}</h1>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n修改 main.ts 将自己的组件文件挂载\n\nimport { createapp } from \'vue\'\nimport \'./style.css\'\n// import app from \'./app.vue\'\nimport e0 from \'./views/e0.vue\'\n\ncreateapp(e0).mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n\n * 以后我们用这样的方式演示课堂案例\n\n打开浏览器控制台，进入 vue 的开发工具，尝试做如下修改\n\n\n\n当把 msg 的值由 "hello, world" 改为 "你好" 时，会发现页面展示同步发生了变化\n\n# ref 与 reactive\n\nvue 提供了两个函数，都可以将数据变为【响应式】的\n\n<script setup lang="ts">\nimport { ref, reactive } from \'vue\'\nconst msg = ref(\'hello, world\')\nconst user = reactive({ name: \'张三\' })\n<\/script>\n\n<template>\n  <h2>{{msg}}</h2>\n  <h2>{{user.name}}</h2>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * ref 能将任意类型的数据变为【响应式】的\n * reactive 只能将对象类型变为【响应式】，对基本类型无效（例如 string，number，boolean）\n\n还有一点不同\n\n<script setup lang="ts">\nimport { ref, reactive } from \'vue\'\nconst u1 = ref({ name: \'张三\' })\nconst u2 = reactive({ name: \'张三\' })\n\nfunction test() {\n  console.log(u1.value)\n  console.log(u2)\n}\n\ntest()\n<\/script>\n  \n<template>\n  <h2>{{u1.name}}</h2>\n  <h2>{{u2.name}}</h2>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 在 template 模板中使用 ref 包装的数据，直接写【变量名】就可以了\n * 但在代码中要使用 ref 包装的数据，必须用【变量名.value】才能访问到\n * reactive 包装的数据，在模板中和代码中都是一致的\n\n# 属性绑定\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst path = ref(\'/src/assets/vue.svg\')\n\n<\/script>\n\n<template>\n  <img :src="path" alt="">\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 【:属性名】用来将标签属性与【响应式】变量绑定\n\n# 事件绑定\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst count = ref(0)\nfunction dec() {\n  count.value--\n}\nfunction inc() {\n  count.value++\n}\n<\/script>\n\n<template>\n  <input type="button" value="-" @click="dec">\n  <h2>{{count}}</h2>\n  <input type="button" value="+" @click="inc">\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 【@事件名】用来将标签属性与函数绑定，事件发生后执行函数内代码\n\n# 表单绑定\n\n<script setup lang="ts">\nimport { ref } from "vue";\nconst user = ref({\n  name:\'张三\',\n  age:18,\n  sex:\'男\',\n  fav:[\'游泳\',\'打球\']\n})\n\nfunction saveuser() {\n  console.log(user.value)\n}\n<\/script>\n\n<template>\n  <div class="outer">\n    <div>\n      <label for="">请输入姓名</label>\n      <input type="text" v-model="user.name"/>\n    </div>\n    <div>\n      <label for="">请输入年龄</label>\n      <input type="text" v-model="user.age"/>\n    </div>\n    <div>\n      <label for="">请选择性别</label>\n      男 <input type="radio" value="男" v-model="user.sex"/> \n      女 <input type="radio" value="女" v-model="user.sex"/>\n    </div>\n    <div>\n      <label for="">请选择爱好</label>\n      游泳 <input type="checkbox" value="游泳" v-model="user.fav"/> \n      打球 <input type="checkbox" value="打球" v-model="user.fav"/> \n      健身 <input type="checkbox" value="健身" v-model="user.fav"/>\n    </div>\n    <div>\n      <input type="button" value="保存" @click="saveuser">\n    </div>\n  </div>\n</template>\n\n<style scoped>\n  div {\n    margin-bottom: 8px;\n  }\n  .outer {\n    width: 100%;\n    position: relative;\n    padding-left: 80px;\n  }\n  label {\n    text-align: left;\n    width: 100px;\n    display: inline-block;\n    position: absolute;\n    left :0;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n * 用 v-model 实现双向绑定，即\n   * javascript 数据可以同步到表单标签\n   * 反过来用户在表单标签输入的新值也会同步到 javascript 这边\n * 双向绑定只适用于表单这种带【输入】功能的标签，其它标签的数据绑定，单向就足够了\n * 复选框这种标签，双向绑定的 javascript 数据类型一般用数组\n\n# 计算属性\n\n有时在数据展示时要做简单的计算\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst firstname = ref(\'三\')\nconst lastname = ref(\'张\')\n\n<\/script>\n\n<template>\n  <h2>{{lastname + firstname}}</h2>\n  <h3>{{lastname + firstname}}</h3>\n  <h4>{{lastname + firstname}}</h4>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n看起来较为繁琐，可以用计算属性改进\n\n<script setup lang="ts">\nimport { ref, computed } from \'vue\'\nconst firstname = ref(\'三\')\nconst lastname = ref(\'张\')\nconst fullname = computed(() => {\n  console.log(\'enter\')\n  return lastname.value + firstname.value\n})\n<\/script>\n\n<template>\n  <h2>{{fullname}}</h2>\n  <h3>{{fullname}}</h3>\n  <h4>{{fullname}}</h4>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * fullname 即为计算属性，它具备缓存功能，即 firstname 和 lastname 的值发生了变化，才会重新计算\n * 如果用函数实现相同功能，则没有缓存功能\n\n<script setup lang="ts">\nimport { ref } from \'vue\'\nconst firstname = ref(\'三\')\nconst lastname = ref(\'张\')\nfunction fullname() {\n  console.log(\'enter\')\n  return lastname.value + firstname.value\n}\n<\/script>\n  \n<template>\n  <h2>{{fullname()}}</h2>\n  <h3>{{fullname()}}</h3>\n  <h4>{{fullname()}}</h4>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# xhr\n\n浏览器中有两套 api 可以和后端交互，发送请求、接收响应，fetch api 前面我们已经介绍过了，另一套 api 是 xhr，基本用法如下\n\nconst xhr = new xmlhttprequest()\nxhr.onload = function() {\n    console.log(xhr.response)\n}\nxhr.open(\'get\', \'http://localhost:8080/api/students\')\nxhr.responsetype = "json"\nxhr.send()\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但这套 api 虽然功能强大，但比较老，不直接支持 promise，因此有必要对其进行改造\n\nfunction get(url: string) {\n  return new promise((resolve, reject)=>{\n    const xhr = new xmlhttprequest()\n    xhr.onload = function() {\n      if(xhr.status === 200){\n        resolve(xhr.response)\n      } else if(xhr.status === 404) {\n        reject(xhr.response)\n      } // 其它情况也需考虑，这里简化处理\n    }\n    xhr.open(\'get\', url)\n    xhr.responsetype = \'json\'\n    xhr.send()\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * promise 对象适合用来封装异步操作，并可以配合 await 一齐使用\n * promise 在构造时，需要一个箭头函数，箭头函数有两个参数 resolve 和 reject\n   * resolve 是异步操作成功时被调用，把成功的结果传递给它，最后会作为 await 的结果返回\n   * reject 在异步操作失败时被调用，把失败的结果传递给它，最后在 catch 块被捉住\n * await 会一直等到 promise 内调用了 resolve 或 reject 才会继续向下运行\n\n调用示例1：同步接收结果，不走代理\n\ntry {\n  const resp = await get("http://localhost:8080/api/students")\n  console.log(resp)\n} catch (e) {\n  console.error(e)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n调用示例2：走代理\n\ntry {\n  const resp = await get(\'/api/students\')\n  console.log(resp)  \n} catch(e) {\n  console.log(e)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 走代理明显慢不少\n\n# axios\n\n# 基本用法\n\naxios 就是对 xhr api 的封装，手法与前面例子类似\n\n安装\n\nnpm install axios\n\n\n1\n\n\n一个简单的例子\n\n<script setup lang="ts">\nimport { ref, onmounted } from "vue";\nimport axios from "axios";\n\nlet count = ref(0);\n\nasync function getstudents() {\n  try {\n    const resp = await axios.get("/api/students");\n    count.value = resp.data.data.length;\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nonmounted(() => {\n  getstudents()\n})\n<\/script>\n\n<template>\n  <h2>学生人数为：{{ count }}</h2>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * onmounted 指 vue 组件生成的 html 代码片段，挂载完毕后被执行\n\n再来看一个 post 例子\n\n<script setup lang="ts">\nimport { ref } from "vue";\nimport axios from "axios";\n\nconst student = ref({\n  name: \'\',\n  sex: \'男\',\n  age: 18\n})\n\nasync function addstudent() {\n  console.log(student.value)\n  const resp = await axios.post(\'/api/students\', student.value)\n  console.log(resp.data.data)\n}\n<\/script>\n\n<template>\n  <div>\n    <div>\n      <input type="text" placeholder="请输入姓名" v-model="student.name"/>\n    </div>\n    <div>\n      <label for="">请选择性别</label>\n      男 <input type="radio" value="男" v-model="student.sex"/> \n      女 <input type="radio" value="女" v-model="student.sex"/>\n    </div>\n    <div>\n      <input type="number" placeholder="请输入年龄" v-model="student.age"/>\n    </div>\n    <div>\n      <input type="button" value="添加" @click="addstudent"/>\n    </div>\n  </div>\n</template>\n<style scoped>\ndiv {\n  font-size: 14px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n# 环境变量\n\n * 开发环境下，联调的后端服务器地址是 http://localhost:8080，\n * 上线改为生产环境后，后端服务器地址为 http://itheima.com\n\n这就要求我们区分开发环境和生产环境，这件事交给构建工具 vite 来做\n\n默认情况下，vite 支持上面两种环境，分别对应根目录下两个配置文件\n\n * .env.development - 开发环境\n * .env.production - 生产环境\n\n针对以上需求，分别在两个文件中加入\n\nvite_backend_api_base_url = \'http://localhost:8080\'\n\n\n1\n\n\n和\n\nvite_backend_api_base_url = \'http://itheima.com\'\n\n\n1\n\n\n然后在代码中使用 vite 给我们提供的特殊对象 import.meta.env，就可以获取到 vite_backend_api_base_url 在不同环境下的值\n\nimport.meta.env.vite_backend_api_base_url\n\n\n1\n\n\n默认情况下，不能智能提示自定义的环境变量，做如下配置：新增文件 src/env.d.ts 并添加如下内容\n\n/// <reference types="vite/client" />\n\ninterface importmetaenv {\n  readonly vite_backend_api_base_url: string\n  // 更多环境变量...\n}\n\ninterface importmeta {\n  readonly env: importmetaenv\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 参考文档地址 环境变量和模式 | vite 官方中文文档 (vitejs.dev)\n\n# baseurl\n\n可以自己创建一个 axios 对象，方便添加默认设置，新建文件 /src/api/request.ts\n\n// 创建新的 axios 对象\nimport axios from \'axios\'\nconst _axios = axios.create({\n  baseurl: import.meta.env.vite_backend_api_base_url\n})\n\nexport default _axios\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n然后在其它组件中引用这个 ts 文件，例如 /src/views/e8.vue，就不用自己拼接路径前缀了\n\n<script setup lang="ts">\nimport axios from \'../api/request\'\n// ...\nawait axios.post(\'/api/students\', ...)    \n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n# 拦截器\n\n// 创建新的 axios 对象\nimport axios from \'axios\'\nconst _axios = axios.create({\n  baseurl: import.meta.env.vite_backend_api_base_url\n})\n\n// 请求拦截器\n_axios.interceptors.request.use(\n  (config)=>{ // 统一添加请求头\n    config.headers = {\n      authorization: \'aaa.bbb.ccc\'\n    }\n    return config\n  },\n  (error)=>{ // 请求出错时的处理\n    return promise.reject(error)\n  }\n)\n\n// 响应拦截器\n_axios.interceptors.response.use(\n  (response)=>{ // 状态码  2xx\n    // 这里的code是自定义的错误码\n    if(response.data.code === 200) {\n      return response\n    }     \n    else if(response.data.code === 401) {       \n      // 情况1\n      return promise.resolve({})\n    }\n    // ... \n  },\n  (error)=>{ // 状态码 > 2xx, 400,401,403,404,500\n    console.error(error) // 处理了异常\n    if(error.response.status === 400) {\n      // 情况1\n    } else if(error.response.status === 401) {\n      // 情况2\n    } \n    // ...\n    return promise.resolve({})\n  }\n)\n\nexport default _axios\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n处理响应时，又分成两种情况\n\n 1. 后端返回的是标准响应状态码，这时会走响应拦截器第二个箭头函数，用 error.response.status 做分支判断\n 2. 后端返回的响应状态码总是200，用自定义错误码表示出错，这时会走响应拦截器第一个箭头函数，用 response.data.code 做分支判断\n\n另外\n\n * promise.reject(error) 类似于将异常继续向上抛出，异常由调用者（vue组件）来配合 try ... catch 来处理\n * promise.resolve({}) 表示错误已解决，返回一个空对象，调用者中接到这个空对象时，需要配合 ?. 来避免访问不存在的属性\n\n# 条件与列表\n\n首先，新增模型数据 src/model/model8080.ts\n\nexport interface student {\n  id: number;\n  name: string;\n  sex: string;\n  age: number;\n}\n\n// 如果 spring 错误，返回的对象格式\nexport interface springerror {\n  timestamp: string,\n  status: number,\n  error: string,\n  message: string,\n  path: string\n}\n\n// 如果 spring 成功，返回 list 情况\nexport interface springlist<t> {\n  data: t[],\n  message?: string,\n  code: number\n}\n\n// 如果 spring 成功，返回 page 情况\nexport interface springpage<t> {\n  data: { list: t[], total: number },\n  message?: string,\n  code: number\n}\n\n// 如果 spring 成功，返回 string 情况\nexport interface springstring {\n  data: string,\n  message?: string,\n  code: number\n}\n\nimport { axiosresponse } from \'axios\'\nexport interface axiosresperror extends axiosresponse<springerror> { }\nexport interface axiosresplist<t> extends axiosresponse<springlist<t>> { }\nexport interface axiosresppage<t> extends axiosresponse<springpage<t>> { }\nexport interface axiosrespstring extends axiosresponse<springstring> { }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n其中\n\n * axiosresppage 代表分页时的响应类型\n * axiosresplist 代表返回集合时的响应类型\n * axiosrespstring 代表返回字符串时的响应类型\n * axiosresperror 代表 spring 出错时时的响应类型\n\n<script lang="ts" setup>\nimport { ref, onmounted } from "vue";\nimport axios from "../api/request";\nimport { student, springlist } from "../model/model8080";\n\n// 说明 students 数组类型为 student[]\nconst students = ref<student[]>([]);\n\nasync function getstudents() {\n  // 说明 resp.data 类型是 springlist<student>\n  const resp = await axios.get<springlist<student>>("/api/students");  \n  console.log(resp.data.data);\n  students.value = resp.data.data;\n}\n\nonmounted(() => getstudents());\n<\/script>\n<template>\n  <div class="outer">\n    <div class="title">学生列表</div>\n    <div class="thead">\n      <div class="row bold">\n        <div class="col">编号</div>\n        <div class="col">姓名</div>\n        <div class="col">性别</div>\n        <div class="col">年龄</div>\n      </div>\n    </div>\n    <div class="tbody">\n      <div v-if="students.length === 0">暂无数据</div>\n      <template v-else>\n        <div class="row" v-for="s of students" :key="s.id">\n          <div class="col">{{ s.id }}</div>\n          <div class="col">{{ s.name }}</div>\n          <div class="col">{{ s.sex }}</div>\n          <div class="col">{{ s.age }}</div>\n        </div>\n      </template>\n    </div>\n  </div>\n</template>\n<style scoped>\n.outer {\n  font-family: 华文行楷;\n  font-size: 20px;\n  width: 500px;\n}\n\n.title {\n  margin-bottom: 10px;\n  font-size: 30px;\n  color: #333;\n  text-align: center;\n}\n\n.row {\n  background-color: #fff;\n  display: flex;\n  justify-content: center;\n}\n\n.col {\n  border: 1px solid #f0f0f0;\n  width: 15%;\n  height: 35px;\n  text-align: center;\n  line-height: 35px;\n}\n\n.bold .col {\n  background-color: #f1f1f1;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n * 加入泛型是为了更好的提示\n * v-if 与 v-else 不能和 v-for 处于同一标签\n * template 标签还有一个用途，就是用它少生成一层真正 html 代码\n * 可以看到将结果封装为响应式数据还是比较繁琐的，后面会使用 userequest 改进\n\n# 监听器\n\n利用监听器，可以在【响应式】的基础上添加一些副作用，把更多的东西变成【响应式的】\n\n * 原本只是数据变化 => 页面更新\n\n * watch 可以在数据变化时 => 其它更新\n\n<template>\n  <input type="text" v-model="name" />\n</template>\n\n<script setup lang="ts">\nimport { ref, watch } from "vue";\nfunction usestorage(name: string) {\n  const data = ref(sessionstorage.getitem(name) ?? "");\n  watch(data, (newvalue) => {\n    sessionstorage.setitem(name, newvalue);\n  });\n  return data;\n}\nconst name = usestorage("name");\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 名称为 usexxxx 的函数，作用是返回带扩展功能的【响应式】数据\n * localstorage 即使浏览器关闭，数据还在\n * sessionstorage 数据工作在浏览器活动期间\n\n# vueuse\n\n安装\n\nnpm install @vueuse/core\n\n\n1\n\n\n一些函数的用法\n\n<template>\n  <h3>x: {{x}}</h3>\n  <h3>y: {{y}}</h3>\n\n  <h3>{{count}}</h3>\n  <input type="button" @click="inc()" value="+">\n  <input type="button" @click="dec()" value="-">\n\n  <input type="text" v-model="name">\n</template>\n<script setup lang="ts">\nimport { usemouse, usecounter, usestorage } from \'@vueuse/core\'\n\nconst {x, y} = usemouse()\n\nconst {count, inc, dec} = usecounter()\n\nconst name = usestorage("name", "")\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# userequest\n\n响应式的 axios 封装，官网地址 一个 vue 请求库 | vuerequest (attojs.org)\n\n首先安装 vue-request\n\nnpm install vue-request@next\n\n\n1\n\n\n组件\n\n<template>\n  <h3 v-if="students.length === 0">暂无数据</h3>\n  <ul v-else>\n    <li v-for="s of students" :key="s.id">\n      <span>{{s.name}}</span>\n      <span>{{s.sex}}</span>\n      <span>{{s.age}}</span>\n    </li>\n  </ul>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request"\nimport { userequest } from \'vue-request\'\nimport { computed } from \'vue\'\nimport { axiosresplist, student } from \'../model/model8080\'\n\n// data 代表就是 axios 的响应对象\nconst { data } = userequest<axiosresplist<student>>(() => axios.get(\'/api/students\'))\n\nconst students = computed(()=>{\n  return data?.value?.data.data || []\n})\n<\/script>\n<style scoped>\nul li {\n  list-style: none;\n  font-family: "华文行楷";\n}\n\nli span:nth-child(1) {\n  font-size: 24px;\n}\nli span:nth-child(2) {\n  font-size: 12px;\n  color: crimson;\n  vertical-align: bottom;\n}\nli span:nth-child(3) {\n  font-size: 12px;\n  color: darkblue;\n  vertical-align: top;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n * data.value 的取值一开始是 undefined，随着响应返回变成 axios 的响应对象\n * 用 computed 进行适配\n\n# usepagination\n\n在 src/model/model8080.ts 中补充类型说明\n\nexport interface studentquerydto {\n  name?: string,\n  sex?: string,\n  age?: string, // 18,20\n  page: number,\n  size: number\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * js 中类似于 18,20 这样以逗号分隔字符串，会在 get 传参时转换为 java 中的整数数组\n\n编写组件\n\n<template>\n  <input type="text" placeholder="请输入姓名" v-model="dto.name">\n  <select v-model="dto.sex">\n    <option value="" selected>请选择性别</option>\n    <option value="男">男</option>\n    <option value="女">女</option>\n  </select>\n  <input type="text" placeholder="请输入年龄范围" v-model="dto.age">\n  <br>\n  <input type="text" placeholder="请输入页码" v-model="dto.page">\n  <input type="text" placeholder="请输入页大小" v-model="dto.size">\n  <input type="button" value="搜索" @click="search">\n  <hr>\n  <h3 v-if="students.length === 0">暂无数据</h3>\n  <ul v-else>\n    <li v-for="s of students" :key="s.id">\n      <span>{{s.name}}</span>\n      <span>{{s.sex}}</span>\n      <span>{{s.age}}</span>\n    </li>\n  </ul>\n  <hr>\n  总记录数{{total}} 总页数{{totalpage}}\n</template>\n<script setup lang="ts">\nimport axios from "../api/request"\nimport { usepagination } from \'vue-request\'\nimport { computed, ref } from \'vue\'\nimport { axiosresppage, student, studentquerydto } from \'../model/model8080\'\n\nconst dto = ref<studentquerydto>({name:\'\', sex:\'\', age:\'\', page:1, size:5})\n\n// data 代表就是 axios 的响应对象\n// 泛型参数1: 响应类型\n// 泛型参数2: 请求类型\nconst { data, total, totalpage, run } = usepagination<axiosresppage<student>, studentquerydto[]>(\n  (d) => axios.get(\'/api/students/q\', {params: d}), // 箭头函数\n  {\n    defaultparams: [ dto.value ], // 默认参数, 会作为参数传递给上面的箭头函数\n    pagination: {\n      currentkey: \'page\', // 指明当前页属性\n      pagesizekey: \'size\', // 指明页大小属性\n      totalkey: \'data.data.total\' // 指明总记录数属性\n    } \n  } // 选项\n)\n\nconst students = computed(()=>{\n  return data?.value?.data.data.list || []\n})\n\nfunction search() {\n  run(dto.value) // 会作为参数传递给usepagination的箭头函数\n}\n<\/script>\n<style scoped>\nul li {\n  list-style: none;\n  font-family: "华文行楷";\n}\n\nli span:nth-child(1) {\n  font-size: 24px;\n}\nli span:nth-child(2) {\n  font-size: 12px;\n  color: crimson;\n  vertical-align: bottom;\n}\nli span:nth-child(3) {\n  font-size: 12px;\n  color: darkblue;\n  vertical-align: top;\n}\ninput,select {\n  width: 100px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n * usepagination 只需要定义一次，后续还想用它内部的 axios 发请求，只需调用 run 函数\n\n# 子组件\n\n# 例1\n\n定义子组件 child1\n\n<template>\n  <div class="container">\n    <div class="card">\n      <div>\n        <p class="name">{{name}}</p>\n        <p class="location">{{country}}</p>\n      </div>\n      <img :src="avatar || \'/src/assets/vue.svg\'"/>\n    </div>\n  </div>\n</template>\n<script setup lang="ts">\n// 定义属性,  编译宏\ndefineprops<{name:string,country:string,avatar?:string}>()\n<\/script>\n<style scoped>\n.container {\n  width: 100%;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-evenly;\n  flex-direction: row-reverse;\n}\n.name {\n  font-weight: bold;\n}\n.location {\n  font-size: 0.8em;\n  color: #6d597a;\n}\n.card {\n  display: flex;\n  justify-content: space-evenly;\n  padding: 1em;\n  margin: 1rem;\n  border-radius: 5px;\n  background: #fff;\n  width: 200px;\n  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);\n}\n\n.card:hover {\n  transform: rotate(-5deg);\n}\n\n.card img {\n  margin-left: 1em;\n  border-radius: 50%;\n  max-width: 55px;\n  max-height: 55px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n父组件引用\n\n<template>\n  <child1 name="张三" country="中国" avatar="/src/assets/vue.svg"></child1>\n  <child1 name="李四" country="印度" avatar="/vite.svg"></child1>\n  <child1 name="王五" country="韩国" ></child1>\n</template>\n<script lang="ts" setup>\nimport child1 from \'../components/child1.vue\';\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 例2\n\n首先添加类型说明 model/modelrandomuser.ts\n\nimport { axiosresponse } from "axios";\nexport interface axiosrespresults extends axiosresponse<results>{}\n\nexport interface results {\n  info: {\n    page: number,\n    results: number\n  },\n  results: result[]\n}\n\nexport interface result {\n  gender: \'male\' | \'female\',\n  name: {\n    first: string,\n    last: string\n  },\n  location: {\n    country: string\n  },\n  picture: {\n    medium: string\n  },\n  login: {\n    username: string\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n子组件不变，父组件使用子组件\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <child1 v-for="u of users" \n    :name="u.name.first" \n    :country="u.location.country" \n    :avatar="u.picture.medium"\n    :key="u.login.username"></child1>\n</template>\n<script setup lang="ts">\nimport axios from "axios";\nimport { userequest } from "vue-request";\nimport { computed } from "vue";\nimport { axiosrespresults } from \'../model/modelrandomuser\'\nimport child1 from "../components/child1.vue";\n\nconst { data } = userequest<axiosrespresults>(\n  ()=>axios.get(\'https://randomuser.me/api/?results=3\')\n)\n\nconst users = computed(()=>{\n  return data.value?.data.results || []\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n如果觉得 result 数据结构嵌套太复杂，还可以做一个类型映射\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <child1 v-for="u of users" \n    :name="u.name" \n    :country="u.country" \n    :avatar="u.avatar"\n    :key="u.username"></child1>\n</template>\n<script setup lang="ts">\nimport axios from "axios";\nimport { userequest } from "vue-request";\nimport { computed } from "vue";\nimport { axiosrespresults, result } from \'../model/modelrandomuser\'\nimport child1 from "../components/child1.vue";\n\nconst { data } = userequest<axiosrespresults>(\n  ()=>axios.get(\'https://randomuser.me/api/?results=3\')\n)\n\nconst users = computed(()=>{\n  return data.value?.data.results.map(resulttouser) || []\n})\n\ninterface user {\n  name: string,\n  country: string,\n  avatar: string,\n  username: string\n}\nfunction resulttouser(r:result):user {\n  return {\n    name: r.name.first,\n    country: r.location.country,\n    avatar: r.picture.medium,\n    username: r.login.username\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n * resulttouser 将 result 类型映射为 user 类型\n\n\n# 3. vue 进阶\n\n\n# 1) antdv\n\n添加必要插件\n\nnpm install ant-design-vue\n\n\n1\n\n * ant-design-vue 组件库插件\n\n引入 antdv 功能，修改 main.ts\n\nimport { createapp } from \'vue\'\nimport \'./style.css\'\nimport app from \'./app.vue\'\nimport antd from \'ant-design-vue\'\nimport \'ant-design-vue/dist/antd.css\'\n\ncreateapp(app).use(antd).mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 表格\n\n<template>\n  \x3c!-- <a-table :columns="columns" :datasource="students" rowkey="id"></a-table> --\x3e\n  <a-table :columns="columns" :datasource="students" :rowkey="rowkey"></a-table>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { userequest } from "vue-request";\nimport { axiosresplist, student } from "../model/model8080";\n\nconst {data} = userequest<axiosresplist<student>>(\n  ()=>axios.get(\'/api/students\')\n)\n\nconst students = computed(()=>{\n  return data.value?.data.data || []\n})\n\nfunction rowkey(r:student) {\n  return r.id\n}\n\nconst columns = ref([\n  {\n    title:\'编号\',\n    dataindex:\'id\'\n  },\n  {\n    title:\'姓名\',\n    dataindex:\'name\'\n  },\n  {\n    title:\'性别\',\n    dataindex:\'sex\'\n  },\n  {\n    title:\'年龄\',\n    dataindex:\'age\'\n  }\n])\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 分页\n\n<template>\n  <a-table :columns="columns" :data-source="students" row-key="id"\n   :pagination="pagination" @change="tablechange"></a-table>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { usepagination } from "vue-request";\nimport { axiosresppage, student, studentquerydto } from "../model/model8080";\nimport { paginationprops } from "ant-design-vue";\nimport datebody from "ant-design-vue/lib/vc-picker/panels/datepanel/datebody";\n\nconst dto = ref({page: 1, size: 5})\n\nconst {data, total, run} = usepagination<axiosresppage<student>, studentquerydto[]>(\n  (d)=> axios.get(\'/api/students/q\', {params:d}),\n  {\n    defaultparams: [dto.value],\n    pagination: {\n      currentkey: "page",\n      pagesizekey: \'size\',\n      totalkey: \'data.data.total\'\n    }\n  }\n)\n\n// 在页号或页大小改变时调用\nfunction tablechange(pagination: paginationprops) { \n  console.log(pagination)\n  dto.value.page = pagination.current ?? 1\n  dto.value.size = pagination.pagesize ?? 5\n  run(dto.value)\n}\n\nconst pagination = computed<paginationprops>(()=>{\n  return {\n    current: dto.value.page, // 当前页\n    pagesize: dto.value.size, // 页大小\n    total: total.value,       // 总记录数\n    showsizechanger: true,    // 显示页大小的下拉列表\n    pagesizeoptions: ["1","2","3","4","5"] // 自定义下拉列表内容\n  }\n})\n\nconst students = computed(()=>{\n  return data.value?.data.data.list || []\n})\n\nconst columns = ref([\n  {\n    title: "编号",\n    dataindex: "id",\n  },\n  {\n    title: "姓名",\n    dataindex: "name",\n  },\n  {\n    title: "性别",\n    dataindex: "sex",\n  },\n  {\n    title: "年龄",\n    dataindex: "age",\n  },\n]);\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n# 搜索、删除\n\n<template>\n  <a-row>\n    <a-col :span="2">\n      <a-button type="primary" size="small">新增</a-button>\n    </a-col>\n    <a-col :span="4">\n      <a-popconfirm title="确认要删除选中学生吗?"\n        ok-text="确定" cancel-text="取消" @confirm="ondeleteids"\n        @visiblechange="onvisiblechange" :visible="visible">\n        <a-button type="primary" size="small">删除选中</a-button>\n      </a-popconfirm>\n    </a-col>\n    <a-col :span="4">\n    </a-col>\n    <a-col :span="4">\n      <a-input v-model:value="dto.name" placeholder="输姓名" size="small"></a-input>\n    </a-col>\n    <a-col :span="4">\n      <a-select v-model:value="dto.sex" placeholder="选性别" :allowclear="true" size="small">\n        <a-select-option value="男">男</a-select-option>\n        <a-select-option value="女">女</a-select-option>\n      </a-select>\n    </a-col>\n    <a-col :span="4">\n      <a-select v-model:value="dto.age" placeholder="选年龄" :allowclear="true" size="small">\n        <a-select-option value="0,20">20以下</a-select-option>\n        <a-select-option value="21,30">21~30</a-select-option>\n        <a-select-option value="31,40">31~40</a-select-option>\n        <a-select-option value="40,120">40以上</a-select-option>\n      </a-select>\n    </a-col>\n    <a-col :span="2">\n      <a-button @click="tablechange" type="primary" size="small">搜索</a-button>\n    </a-col>\n  </a-row>\n  <hr>\n  <a-table :columns="columns" :data-source="students" row-key="id"\n    :pagination="pagination" @change="tablechange"\n    :row-selection="{selectedrowkeys:ids,onchange:onselectchange}">\n    <template #bodycell="{column, record}">\n      <template v-if="column.dataindex===\'name\'">\n      {{record.name + (record.sex===\'男\'?\'(大侠)\':\'(女侠)\')}}\n      </template>\n\n      <template v-else-if="column.dataindex===\'operation\'">\n      <a>修改</a>\n      <a-divider type="vertical"></a-divider>\n      <a-popconfirm title="确认要删除该学生吗?"\n        ok-text="确定" cancel-text="取消" @confirm="ondelete(record.id)">\n        <a>删除</a>   \n      </a-popconfirm>         \n      </template>\n    </template>\n  </a-table>\n  \n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { usepagination, userequest } from "vue-request";\nimport { axiosresppage, axiosrespstring, student, studentquerydto } from "../model/model8080";\nimport { paginationprops } from "ant-design-vue";\n\n// >>>>>>>>>>>>>> 搜索功能开始\nconst dto = ref({page: 1, size: 5, name: \'\', sex: null, age: null})\n\nconst {data, total, run: search} = usepagination<axiosresppage<student>, studentquerydto[]>(\n  (d) => axios.get(\'/api/students/q\', {params:d}),\n  {\n    defaultparams: [dto.value],\n    pagination: {\n      currentkey: "page",\n      pagesizekey: \'size\',\n      totalkey: \'data.data.total\'\n    }\n  }\n)\n\nfunction tablechange(pagination: paginationprops) { \n  // console.log(pagination)\n  dto.value.page = pagination.current ?? 1\n  dto.value.size = pagination.pagesize ?? 5\n  search(dto.value)\n}\n\nconst pagination = computed<paginationprops>(()=>{\n  return {\n    current: dto.value.page, // 当前页\n    pagesize: dto.value.size, // 页大小\n    total: total.value,       // 总记录数\n    showsizechanger: true,    // 显示页大小的下拉列表\n    pagesizeoptions: ["1","2","3","4","5"] // 自定义下拉列表内容\n  }\n})\n\nconst students = computed(()=>{\n  return data.value?.data.data.list || []\n})\n// <<<<<<<<<<<<<< 搜索功能结束\n\n\n// >>>>>>>>>>>>>> 删除功能开始\nasync function ondelete(id:number) {\n  // console.log("学生id是:"+id)\n  await deletebyid(id)      // 删除请求 删除响应\n  search(dto.value)        //                   查询请求 查询响应\n}\n\nconst { runasync: deletebyid } = userequest<axiosrespstring, number[]>(\n  (id) => axios.delete(`/api/students/${id}`),\n  {\n    manual: true\n  }\n)\n// <<<<<<<<<<<<<< 删除功能结束\n\n// >>>>>>>>>>>>>> 删除选中开始\nconst ids = ref<number[]>([])\n\nfunction onselectchange(keys:number[]) {\n  // console.log(keys)\n  ids.value = keys\n}\n\nasync function ondeleteids() {\n  await deletebyids(ids.value)\n  ids.value = []\n  search(dto.value)\n}\n\nconst { runasync: deletebyids } = userequest<axiosrespstring, number[][]>(\n  (ids)=>axios.delete(\'/api/students\', {data: ids}),\n  {\n    manual: true\n  }\n)\n\nconst visible = ref(false)\n\nfunction onvisiblechange(v:boolean) {\n  if(!v) { // 希望隐藏\n    visible.value = false\n  } else { // 希望显示\n    visible.value = ids.value.length > 0\n  }\n}\n// <<<<<<<<<<<<<< 删除选中结束\n\nconst columns = ref([\n  {\n    title: "编号",\n    dataindex: "id",\n  },\n  {\n    title: "姓名",\n    dataindex: "name",\n  },\n  {\n    title: "性别",\n    dataindex: "sex",\n  },\n  {\n    title: "年龄",\n    dataindex: "age",\n  },\n  {\n    title: \'操作\',\n    dataindex: \'operation\'\n  }\n]);\n<\/script>\n<style scoped>\n  .ant-input, .ant-select {\n    width: 80px;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n\n\n# 新增、修改\n\n子组件\n\n<template>\n  <a-modal :visible="visible" :title="title" \n    @ok="onok" @cancel="oncancel">\n    <a-form>\n      <a-form-item label="编号" v-if="id">\n        <a-input readonly v-model:value="id"></a-input>\n      </a-form-item>\n      <a-form-item label="姓名">\n        <a-input v-model:value="dto.name"></a-input>\n      </a-form-item>\n      <a-form-item label="性别">\n        <a-radio-group v-model:value="dto.sex">\n          <a-radio-button value="男">男</a-radio-button>\n          <a-radio-button value="女">女</a-radio-button>\n        </a-radio-group>\n      </a-form-item>\n      <a-form-item label="年龄">\n        <a-input-number v-model:value="dto.age"></a-input-number>\n      </a-form-item>\n    </a-form>\n  </a-modal>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { userequest } from "vue-request";\nimport { studentsavedto, axiosrespstring } from "../model/model8080";\nimport { form } from \'ant-design-vue\'\n\n// 定义属性\nconst props = defineprops<{id:number, dto:studentsavedto, visible:boolean}>()\n\nconst title = computed(()=> props.id===0?\'新增学生\':\'修改学生\')\n\n// 定义事件\nconst emit = defineemits([\'update:visible\', \'saved\'])\n\nasync function onok() {\n  if(props.id === 0) {\n    await insert(props.dto)\n  } else {\n    await update(props.dto)\n  }\n  emit(\'saved\')\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false) \n}\n\nfunction oncancel() {\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false)\n}\n\nconst {runasync:insert} = userequest<axiosrespstring,studentsavedto[]>(\n  (dto)=>axios.post(\'/api/students\', dto),\n  {\n    manual: true\n  }\n)\n\nconst {runasync:update} = userequest<axiosrespstring,studentsavedto[]>(\n  (dto)=>axios.put(`/api/students/${props.id}`, dto),\n  {\n    manual: true\n  }\n)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n父组件使用子组件\n\n<a4save :id="id" :dto="savedto" v-model:visible="savevisible"></a4save>\n\n<script setup lang="ts">\n// ...\n// >>>>>>>>>>>>>> 新增、修改开始\nconst savevisible = ref(false)\nconst id = ref(0)\nconst savedto = reactive({name:\'\', sex:\'男\', age:18})\n\nfunction oninsert() {\n  savevisible.value = true\n  id.value = 0\n  object.assign(savedto, {name:\'\', sex:\'男\', age:18})\n}\n\nfunction onupdate(record: student) {\n  savevisible.value = true\n  id.value = record.id\n  object.assign(savedto, record)\n}\n\nfunction onsaved() {\n  search(dto.value)\n}    \n// <<<<<<<<<<<<<< 新增、修改结束\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n * savedto 使用 reactive 包装，是为了解决后续表单校验失效问题\n\n * object.assign 是将源对象（参数2）的属性值赋值给目标对象（参数1）的同名属性，效果等价于\n   \n   savedto.name = record.name\n   savedto.sex = record.sex\n   savedto.age = record.age\n   \n   \n   1\n   2\n   3\n   \n\n# 全局消息\n\n在 request.ts 中对响应消息统一处理\n\nimport { message } from \'ant-design-vue\'\n\n// ...\n// 响应拦截器\n_axios.interceptors.response.use(\n  (response)=>{ // 状态码  2xx\n    if(response.data.message) {\n      message.success(response.data.message, 3)\n    }    \n    // ... \n  },\n  (error)=>{ // 状态码 > 2xx, 400,401,403,404,500\n    // ...\n  }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 表单校验\n\n<template>\n  <a-modal :visible="visible" :title="title" \n    @ok="onok" @cancel="oncancel">\n    <a-form>\n      <a-form-item label="编号" v-if="id">\n        <a-input readonly v-model:value="id"></a-input>\n      </a-form-item>\n      <a-form-item label="姓名" v-bind="validateinfos.name">\n        <a-input v-model:value="dto.name"></a-input>\n      </a-form-item>\n      <a-form-item label="性别" v-bind="validateinfos.sex">\n        <a-radio-group v-model:value="dto.sex">\n          <a-radio-button value="男">男</a-radio-button>\n          <a-radio-button value="女">女</a-radio-button>\n        </a-radio-group>\n      </a-form-item>\n      <a-form-item label="年龄" v-bind="validateinfos.age">\n        <a-input-number v-model:value="dto.age"></a-input-number>\n      </a-form-item>\n    </a-form>\n  </a-modal>\n</template>\n<script setup lang="ts">\nimport axios from "../api/request";\nimport { ref, computed } from "vue";\nimport { userequest } from "vue-request";\nimport { studentsavedto, axiosrespstring } from "../model/model8080";\nimport { form } from \'ant-design-vue\'\n\n// 定义属性\nconst props = defineprops<{id:number, dto:studentsavedto, visible:boolean}>()\n\nconst title = computed(()=> props.id===0?\'新增学生\':\'修改学生\')\n\n// 定义事件\nconst emit = defineemits([\'update:visible\', \'saved\'])\n\nasync function onok() {\n  try {\n    // 提交前校验\n    await validate()\n    if(props.id === 0) {\n      await insert(props.dto)\n    } else {\n      await update(props.dto)\n    }\n    emit(\'saved\')\n    // 发送事件给父组件, 希望把 visible 改为 false\n    emit(\'update:visible\', false) \n  } catch (e) {\n    console.error(e)\n  }\n}\n\nfunction oncancel() {\n  // 发送事件给父组件, 希望把 visible 改为 false\n  emit(\'update:visible\', false)\n}\n\nconst {runasync:insert} = userequest<axiosrespstring,studentsavedto[]>(\n  (dto)=>axios.post(\'/api/students\', dto),\n  {\n    manual: true\n  }\n)\n\nconst {runasync:update} = userequest<axiosrespstring,studentsavedto[]>(\n  (dto)=>axios.put(`/api/students/${props.id}`, dto),\n  {\n    manual: true\n  }\n)\n\nconst rules = ref({\n  name: [\n    {required: true, message:\'姓名必须\'},\n    {min:2, message:\'字符数至少为2\'}\n  ],\n  sex: [\n    {required: true, message:\'性别必须\'}\n  ],\n  age: [\n    {required: true, message:\'年龄必须\'},\n    {min:10, message:\'年龄最小为10岁\', type:\'number\'},\n    {max:120, message:\'年龄最大为120岁\', type:\'number\'}\n  ]\n})\n\n// 参数1: 待校验的数据\n// 参数2: 校验规则\nconst { validateinfos, validate } = form.useform(props.dto, rules)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\n\n# 2) vue-router\n\n# 安装\n\nnpm install vue-router@4\n\n\n1\n\n\n# 创建 router\n\n首先创建一个 /src/router/a5router.ts 文件，在其中定义路由\n\nimport {createrouter, createwebhashhistory} from \'vue-router\'\nimport a51 from \'../views/a51.vue\'\nimport a52 from \'../views/a52.vue\'\n// 路由 => 路径和组件之间的对应关系\nconst routes = [\n  {\n    path: \'/a1\',\n    component: a51\n  },\n  {\n    path: \'/a2\', \n    component: a52\n  }\n]\n\nconst router = createrouter({ \n  history: createwebhashhistory(), // 路径格式\n  routes: routes // 路由数组\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n * createwebhashhistory 是用 # 符号作为【单页面】跳转技术，上面两个路由访问时路径格式为\n   \n   * http://localhost:7070/#/a1\n   * http://localhost:7070/#/a2\n\n * 每个路由都有两个必须属性\n   \n   * path：路径\n   \n   * component：组件\n\n * createrouter 用来创建 router 对象，作为默认导出\n\n需要在 main.ts 中导入 router 对象：\n\n// ...\nimport a5 from \'./views/a5.vue\'  // vue-router\nimport router from \'./router/a5router\'\ncreateapp(a5).use(antdv).use(router).mount(\'#app\')\n\n\n1\n2\n3\n4\n\n\na5 是根组件，不必在 router 中定义，但需要在其中定义 router-view，用来控制路由跳转后，a51、a52 这些组件的显示位置，内容如下\n\n<template>\n  <div class="a5">\n    <router-view></router-view>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n\n\n效果如下\n\n\n\n\n\n# 动态导入\n\nimport {createrouter, createwebhashhistory} from \'vue-router\'\nimport a51 from \'../views/a51.vue\'\nimport a52 from \'../views/a52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () => import(\'../views/a53.vue\')\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 用 import 关键字导入，效果是打包时会将组件的 js 代码都打包成一个大的 js 文件，如果组件非常多，会影响页面加载速度\n * 而 import 函数导入（动态导入），则是按需加载，即\n   * 当路由跳转到 /a3 路径时，才会去加载 a53 组件对应的 js 代码\n   * vue-router 官方推荐采用动态导入\n\n# 嵌套路由\n\n如果希望再嵌套更深层次的路由跳转，例如：希望在 a53 组件内再进行路由跳转\n\n\n\n首先，修改 a53.vue\n\n<template>\n  <div class="a53">\n    <router-view></router-view>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n\n\n其次，再修改 /src/router/a5router.ts 文件 内容\n\nimport {createrouter, createwebhashhistory} from \'vue-router\'\nimport a51 from \'../views/a51.vue\'\nimport a52 from \'../views/a52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () => import(\'../views/a53.vue\'),\n    children: [\n      {\n        path: \'student\',\n        component: () => import(\'../views/a531.vue\')\n      },\n      {\n        path: \'teacher\',\n        component: () => import(\'../views/a532.vue\')\n      }\n    ]\n  }\n]\n\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n将来访问 /a3/student 时，效果为\n\n\n\n访问 /a3/teacher 时，效果为\n\n\n\n# 重定向\n\n用法1\n\nimport {createrouter, createwebhashhistory} from \'vue-router\'\nimport a51 from \'../views/a51.vue\'\nimport a52 from \'../views/a52.vue\'\nconst routes = [\n  // ...\n  {\n    path: \'/a3\',\n    component: () => import(\'../views/a53.vue\'),\n    redirect: \'/a3/student\', // 重定向到另外路径\n    children: [\n      {\n        path: \'student\',\n        component: () => import(\'../views/a531.vue\')\n      },\n      {\n        path: \'teacher\',\n        component: () => import(\'../views/a532.vue\')\n      }\n    ]\n  }\n]\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n效果是，页面输入 /a3，紧接着会重定向跳转到 /a3/student\n\n用法2\n\nimport {createrouter, createwebhashhistory} from \'vue-router\'\nimport a51 from \'../views/a51.vue\'\nimport a52 from \'../views/a52.vue\'\nconst routes = [\n  {\n    path: \'/a1\',\n    component: a51\n  },\n  {\n    path: \'/a2\', \n    component: a52\n  },\n  // ...\n  {\n    path: \'/:pathmatcher(.*)*\', // 可以匹配剩余的路径\n    redirect: \'/a2\'\n  }\n]\n// ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n效果是，当页面输入一个不存在路径 /aaa 时，会被 path: \'/:pathmatcher(.*)*\' 匹配到，然后重定向跳转到 a52 组件去\n\n# 主页布局\n\n借助 antdv 的 layout 组件，可以实现主页【上】【左】【右】布局\n\n<template>\n  <div class="a53">\n    <a-layout>\n      <a-layout-header></a-layout-header>\n      <a-layout>\n        <a-layout-sider></a-layout-sider>\n        <a-layout-content>\n          <router-view></router-view>\n        </a-layout-content>\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n<style scoped>\n.a53 {\n  height: 100%;\n  background-color: rgb(220, 225, 255);\n  background-image: url("data:image/svg+xml,%3csvg xmlns=\'http://www.w3.org/2000/svg\'%3e%3ctext x=\'35\' y=\'10\' font-size=\'14\' font-family=\'system-ui, sans-serif\' text-anchor=\'middle\' dominant-baseline=\'middle\'%3ea53(主页)%3c/text%3e%3c/svg%3e");\n  padding: 20px;\n  box-sizing: border-box;\n}\n.ant-layout-header {\n  height: 50px;\n  background-color:darkseagreen;\n}\n\n.ant-layout-sider {\n  background-color:lightsalmon;\n}\n\n.ant-layout-content {\n  background-color: aliceblue;\n}\n\n.ant-layout-footer {\n  background-color:darkslateblue;\n  height: 30px;\n}\n\n.ant-layout {\n  height: 100%;\n}\n\n.ant-layout-has-sider {\n  height: calc(100% - 50px);\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n# 侧边栏菜单\n\n<template>\n  <div class="a53">\n    <a-layout>\n      <a-layout-header></a-layout-header>\n      <a-layout>\n        <a-layout-sider>\n          <a-menu theme="dark" mode="inline">\n            <a-menu-item :key="1">\n              <router-link to="/a3/student">菜单1</router-link>\n            </a-menu-item>\n            <a-menu-item :key="2">\n              <router-link to="/a3/teacher">菜单2</router-link>\n            </a-menu-item>\n            <a-menu-item :key="3">菜单3</a-menu-item>\n            <a-sub-menu :key="4" title="菜单4">\n              <a-menu-item :key="41">菜单41</a-menu-item>\n              <a-menu-item :key="42">菜单42</a-menu-item>\n            </a-sub-menu>\n          </a-menu>\n        </a-layout-sider>\n        <a-layout-content>\n          <router-view></router-view>\n        </a-layout-content>\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * a-menu-item 与 a-sub-menu 都必须为 key 属性唯一赋值，否则会产生混乱\n * router-link 标签用来切换路由，to 是目标路由的路径\n * theme 属性定义菜单的主题（默认亮色主题，dark 为暗色主题）\n * mode 属性定义子菜单的展示模式（默认弹出，inline 显示在下方）\n\n# 菜单图标\n\n安装图标依赖\n\nnpm install @ant-design/icons-vue\n\n\n1\n\n\n菜单中使用图标\n\n<template>\n  <div class="a53">\n    <a-layout>\n      <a-layout-header></a-layout-header>\n      <a-layout>\n        <a-layout-sider>\n          <a-menu theme="dark" mode="inline">\n            <a-menu-item :key="1">\n              <template #icon>\n                <highlight-outlined />\n              </template>\n              <router-link to="/a3/student">菜单1</router-link>\n            </a-menu-item>\n            <a-menu-item :key="2">\n              <template #icon>\n                <align-center-outlined />\n              </template>\n              <router-link to="/a3/teacher">菜单2</router-link>\n            </a-menu-item>\n            <a-menu-item :key="3">\n              <template #icon>\n                <strikethrough-outlined />\n              </template>\n              菜单3</a-menu-item>\n            <a-sub-menu :key="4" title="菜单4">\n              <template #icon>\n                <sort-descending-outlined />\n              </template>\n              <a-menu-item :key="41">菜单41</a-menu-item>\n              <a-menu-item :key="42">菜单42</a-menu-item>\n            </a-sub-menu>\n          </a-menu>\n        </a-layout-sider>\n        <a-layout-content>\n          <router-view></router-view>\n        </a-layout-content>\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n<script setup lang="ts">\nimport {highlightoutlined, aligncenteroutlined, strikethroughoutlined, sortdescendingoutlined} from \'@ant-design/icons-vue\'\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n * 图标组件没有全局绑定，需要 import 之后才能使用\n * 用 <template #icon></template> 插槽，才能确定图标展示的位置（菜单文字之前）\n\n# 二次封装图标组件\n\n最终希望用统一的图标组件去使用图标，图标名只是作为一个属性值传递进去，例如：\n\n使用者\n\n<template>\n  <a-icon icon="highlight-outlined"></a-icon>\n  <a-icon icon="align-center-outlined"></a-icon>\n  <a-icon icon="strikethrough-outlined"></a-icon>\n  <a-icon icon="sort-descending-outlined"></a-icon>\n</template>\n<script setup lang="ts">\nimport aicon from \'../components/aicon1.vue\'\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 方法1，使用 vue 组件\n\n<script lang="ts" setup>\nimport {highlightoutlined, aligncenteroutlined, strikethroughoutlined, sortdescendingoutlined} from \'@ant-design/icons-vue\'\nconst props = defineprops<{icon:string}>()\n<\/script>\n<template>\n  <highlight-outlined v-if="icon===\'highlight-outlined\'"></highlight-outlined>\n  <align-center-outlined v-else-if="icon===\'align-center-outlined\'"></align-center-outlined>\n  <strikethrough-outlined v-else-if="icon===\'strikethrough-outlined\'"></strikethrough-outlined>\n  <sort-descending-outlined v-else-if="icon===\'sort-descending-outlined\'"></sort-descending-outlined>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 缺点：实现太笨\n\n# 方法2，使用函数式组件\n\nimport { h } from "vue"\nimport * as icons from \'@ant-design/icons-vue\'\n\ninterface module {\n  [p:string]: any\n}\n\n// 参数1: 组件属性\nconst aicon = (props:{icon:string}) => {\n  // console.log(props.icon)\n  // console.log(icons)\n  // 参数1: 组件对象\n  const im: module = icons\n  return h(im[tocamelcase(props.icon)])\n}\n\nexport default aicon\n\n// 将-分隔的单词转换为大驼峰命名的单词\nfunction tocamelcase(str: string) { // highlight-outlined\n  return str.split(\'-\') // [\'highlight\', \'outlined\']\n    .map((e)=> e.charat(0).touppercase() + e.slice(1) ) // [\'highlight\', \'outlined\']\n    .join(\'\')\n}\n/*\nicons 的结构如下\n{\n  highlightoutlined: highlightoutlined组件对象,\n  monitoroutlined: monitoroutlined组件对象,\n  ...\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 需要动态生成标签的时候，可以考虑使用函数式组件\n\n# 方法3，使用 jsx 组件\n\n首先，安装\n\nnpm install @vitejs/plugin-vue-jsx -d\n\n\n1\n\n\n配置 vite.config.ts\n\nimport { defineconfig } from \'vite\'\nimport vue from \'@vitejs/plugin-vue\'\nimport vuejsx from \'@vitejs/plugin-vue-jsx\'\n\n// https://vitejs.dev/config/\nexport default defineconfig({\n  plugins: [vue(), vuejsx()]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n编写一个 hi.tsx 组件\n\nexport default {\n  props: {\n    msg: string\n  },\n  setup(props: { msg: string }) {\n    return () => <h5>{props.msg}</h5>\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后被其它组件使用\n\n<script setup lang="ts">\nimport hi from \'../components/hi\'\n<\/script>\n\n<template>\n  <hi msg="hello,world"></hi>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n用 jsx 实现图标组件\n\nimport * as icons from \'@ant-design/icons-vue\'\n\ninterface module {\n  [p:string]: any\n}\n\nfunction tocamelcase(str: string) { // highlight-outlined\n  return str\n    .split("-") // [\'highlight\', \'outlined\']\n    .map((e) => e.charat(0).touppercase() + e.slice(1)) // [\'highlight\', \'outlined\']\n    .join(""); // highlightoutlined\n}\n\nexport default {\n  props: {\n    icon: string\n  },\n  setup(props: {icon: string}) {\n    const im: module = icons\n    const tag = im[tocamelcase(props.icon)] // 图标组件\n    // highlightoutlined\n    return ()=> <tag></tag> // 返回组件标签\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 动态路由与菜单\n\n# 路由文件\n\na6router.js\n\nimport { createrouter, createwebhashhistory } from \'vue-router\'\nimport { usestorage } from \'@vueuse/core\'\nimport { route, menu } from \'../model/model8080\'\nconst clientroutes = [\n  {\n    path: \'/login\',\n    name: \'login\',\n    component: () => import(\'../views/a6login.vue\')\n  },\n  {\n    path: \'/404\',\n    name: \'404\',\n    component: () => import(\'../views/a6notfound.vue\')\n  },\n  {\n    path: \'/\',\n    name: \'main\',\n    component: () => import(\'../views/a6main.vue\')\n  },\n  {\n    path: \'/:pathmatcher(.*)*\',\n    name: \'remaining\',\n    redirect: \'/404\'\n  }\n]\n\nconst router = createrouter({\n  history: createwebhashhistory(),\n  routes: clientroutes\n})\n\nexport const servermenus = usestorage<menu[]>(\'servermenus\', [])\nconst serverroutes = usestorage<route[]>(\'serverroutes\', [])\naddserverroutes(serverroutes.value)\n\nexport function addserverroutes(routelist: route[]) {\n  for (const r of routelist) {\n    if (r.parentname) {\n      router.addroute(r.parentname, {\n        path: r.path,\n        component: () => import(r.component),\n        name: r.name\n      })\n    }\n  }\n  serverroutes.value = routelist\n}\n\nexport function resetroutes() {\n  for (const r of clientroutes) {\n    router.addroute(r)\n  }\n  serverroutes.value = null\n  servermenus.value = null\n}\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n本文件重要的函数及变量\n\n * addserverroutes 函数向路由表中添加由服务器提供的路由，路由分成两部分\n   * clientroutes 这是客户端固定的路由\n   * serverroutes 这是服务器变化的路由，存储于 localstorage\n * resetroutes 函数用来将路由重置为 clientroutes\n   * vue-router@4 中的 addroute 方法会【覆盖】同名路由，这是这种实现的关键\n   * 因此，服务器返回的路由最好是 main 的子路由，这样重置时就会比较简单，用之前的 main 一覆盖就完事了\n * servermenus 变量记录服务器变化的菜单，存储于 localstorage\n\n# 登录组件\n\n动态路由应当在登录时生成，a6login.vue\n\n<template>\n  <div class="login">\n    <a-form :label-col="{ span: 6 }" autocomplete="off">\n      <a-form-item label="用户名" v-bind="validateinfos.username">\n        <a-input v-model:value="dto.username" />\n      </a-form-item>\n      <a-form-item label="密码" v-bind="validateinfos.password">\n        <a-input-password v-model:value="dto.password" />\n      </a-form-item>\n      <a-form-item :wrapper-col="{ offset: 6, span: 16 }">\n        <a-button type="primary" @click="onclick">submit</a-button>\n      </a-form-item>      \n    </a-form>\n  </div>\n</template>\n<script setup lang="ts">\nimport { ref, onmounted } from \'vue\'\nimport { form } from \'ant-design-vue\'\nimport { userouter } from \'vue-router\'\nimport axios from \'../api/request\'\nimport { userequest } from \'vue-request\'\nimport { axiosresptoken, logindto, axiosrespmenuandroute } from \'../model/model8080\'\nimport { resetroutes, addserverroutes, servermenus } from \'../router/a6router\'\nconst dto = ref({username:\'\', password:\'\'})\nconst rules = ref({\n  username: [\n    {required: true, message:\'用户名必填\'}\n  ],\n  password:[\n    {required: true, message:\'密码必填\'}\n  ]\n})\nconst { validateinfos, validate } = form.useform(dto, rules)\nconst router = userouter()\nconst { runasync:login } = userequest<axiosresptoken, logindto[]>((dto)=> axios.post(\'/api/loginjwt\', dto), {manual:true})\nconst { runasync:menu } = userequest<axiosrespmenuandroute, string[]>((username)=> axios.get(`/api/menu/${username}`), {manual:true})\nasync function onclick() {\n  try {\n    await validate()\n    const loginresp = await login(dto.value\n    if(loginresp.data.code === 200) { // 登录成功\n      const token = loginresp.data.data.token\n      const menuresp = await menu(dto.value.username)\n      const routelist = menuresp.data.data.routelist\n      addserverroutes(routelist)\n      servermenus.value = menuresp.data.data.menutree\n      router.push(\'/\')\n    })\n  } catch (e) {\n    console.error(e)\n  }\n}\nonmounted(()=>{\n  resetroutes()\n})\n<\/script>\n<style scoped>\n.login{\n  margin: 200px auto;\n  width: 25%;\n  padding: 20px;\n  height: 180px;\n  background-color: antiquewhite;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n * 登录成功后去请求 /api/menu/{username} 获取该用户的菜单和路由\n * router.push 方法用来以编程方式跳转至主页路由\n\n# 主页组件\n\na6main.vue\n\n<template>\n  <div class="a6main">\n    <a-layout>\n      <a-layout-header>\n      </a-layout-header>\n      <a-layout>\n        <a-layout-sider>\n          <a-menu mode="inline" theme="dark">\n            <template v-for="m1 of servermenus">\n              <a-sub-menu v-if="m1.children" :key="m1.id" :title="m1.title">\n                <template #icon><a-icon :icon="m1.icon"></a-icon></template>\n                <a-menu-item v-for="m2 of m1.children" :key="m2.id">\n                  <template #icon><a-icon :icon="m2.icon"></a-icon></template>\n                  <router-link v-if="m2.routepath" :to="m2.routepath">{{m2.title}}</router-link>\n                  <span v-else>{{m2.title}}</span>\n                </a-menu-item>\n              </a-sub-menu>\n              <a-menu-item v-else :key="m1.id">\n                <template #icon><a-icon :icon="m1.icon"></a-icon></template>\n                <router-link v-if="m1.routepath" :to="m1.routepath">{{m1.title}}</router-link>\n                <span v-else>{{m1.title}}</span>\n              </a-menu-item>\n            </template>            \n          </a-menu>\n        </a-layout-sider>\n        <a-layout-content>\n          <router-view></router-view>\n        </a-layout-content>\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n<script setup lang="ts">\nimport aicon from \'../components/aicon3\' // jsx icon 组件\nimport { servermenus } from \'../router/a6router\'\n<\/script>\n<style scoped>\n.a6main {\n  height: 100%;\n  background-color: rgb(220, 225, 255);\n  box-sizing: border-box;\n}\n.ant-layout-header {\n  height: 50px;\n  background-color:darkseagreen;\n}\n\n.ant-layout-sider {\n  background-color:lightsalmon;\n}\n\n.ant-layout-content {\n  background-color: aliceblue;\n}\n\n.ant-layout-footer {\n  background-color:darkslateblue;\n  height: 30px;\n}\n\n.ant-layout {\n  height: 100%;\n}\n\n.ant-layout-has-sider {\n  height: calc(100% - 50px);\n}\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n# token 使用\n\n 1. 获取用户信息，例如服务器端可以把用户名、该用户的路由、菜单信息都统一从 token 返回\n 2. 前端路由跳转依据，例如跳转前检查 token，如果不存在，表示未登录，就避免跳转至某些路由\n 3. 后端 api 访问依据，例如每次发请求携带 token，后端需要身份校验的 api 需要用到\n\n\n# 3) pinia\n\n需求：在组件 p1 里更新了数据，主页组件也同步更新显示\n\n\n\n * storage 虽然可以实现多个组件的数据共享，但是需要【主动访问】才能获取更新后的数据\n * 本例中由于没有涉及主页组件的 mounted 操作，因此并不会【主动】获取 storage 的数据\n\n# 安装\n\nnpm install pinia\n\n\n1\n\n\n在 main.ts 中引入\n\nimport { createpinia } from \'pinia\'\n\n// ...\ncreateapp(a6).use(antdv).use(router).use(createpinia()).mount(\'#app\')\n\n\n1\n2\n3\n4\n\n\n# 定义store\n\n再新建 store 目录来管理共享数据，下面是 /src/store/userinfo.ts\n\nimport axios from \'../api/request\'\nimport { definestore } from "pinia"\nimport { userinfodto } from \'../model/model8080\'\n\nexport const useuserinfo = definestore(\'userinfo\', {\n  state: () => {\n    return { username: \'\', name: \'\', sex: \'\' }\n  },\n  actions: {\n    async get(username: string) {\n      const resp = await axios.get(`/api/info/${username}`)\n      object.assign(this, resp.data.data)\n    },\n    async update(dto: userinfodto) {\n      await axios.post(\'/api/info\', dto)\n      object.assign(this, dto)\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n * 定义了 useuserinfo 函数，用来获取共享数据，它可能用于多个组件\n   \n   * 命名习惯上，函数变量以 use 打头\n\n * state 定义数据格式\n\n * actions 定义操作数据的方法\n   \n   * get 方法用来获取用户信息\n   \n   * update 方法用来修改用户信息\n\n * 由于 userequest 必须放在 setup 函数内，这里简化起见，直接使用了 axios\n\n获取用户信息\n\n<template>\n  <div class="a6main">\n    <a-layout>\n      <a-layout-header>\n        <span>{{serverusername}} 【{{userinfo.name}} - {{userinfo.sex}}】</span>\n      </a-layout-header>\n      <a-layout>\n        \x3c!-- ... --\x3e\n      </a-layout>\n    </a-layout>\n  </div>\n</template>\n<script setup lang="ts">\nimport { onmounted } from \'vue\';\nimport aicon from \'../components/aicon3\' // jsx icon 组件\nimport { servermenus, serverusername } from \'../router/a6router\'\nimport { useuserinfo } from \'../store/userinfo\'\nconst userinfo = useuserinfo()\n\nonmounted(()=>{\n  userinfo.get(serverusername.value)\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n修改用户信息\n\n<template>\n  <div class="a6p1">\n    <h3>修改用户信息</h3>\n    <hr>\n    <a-form>\n      <a-form-item label="用户名">\n        <a-input readonly v-model:value="dto.username"></a-input>\n      </a-form-item>\n      <a-form-item label="姓名" v-bind="validateinfos.name">\n        <a-input v-model:value="dto.name"></a-input>\n      </a-form-item>\n      <a-form-item label="性别">\n        <a-radio-group v-model:value="dto.sex">\n          <a-radio-button value="男">男</a-radio-button>\n          <a-radio-button value="女">女</a-radio-button>\n        </a-radio-group>\n      </a-form-item>\n    </a-form>\n    <a-button type="primary" @click="onclick">确定</a-button>\n  </div>\n</template>\n<script setup lang="ts">\nimport { form } from \'ant-design-vue\'\nimport { onmounted, ref } from \'vue\'\nimport { userinfodto } from \'../model/model8080\'\nimport { useuserinfo } from \'../store/userinfo\';\nconst dto = ref<userinfodto>({ username: \'\', name: \'\', sex: \'\' })\nconst userinfo = useuserinfo()\nonmounted(()=>{\n  object.assign(dto.value, userinfo)\n})\nconst rules = ref({\n  name: [\n    {required: true, message:\'姓名必填\'}\n  ]\n})\nconst { validateinfos, validate } = form.useform(dto, rules)\nasync function onclick() {\n  try {\n    await validate()\n    await userinfo.update(dto.value)\n  } catch (e) {\n    console.error(e)\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 不能直接把 userinfo 绑定到表单，需要 dto 中转一下\n * userinfo.update 和 useinfo.get 返回的都是 promise 对象，可以配合 await 一起用\n\n\n# 后记\n\nvite + vue3 + vue-router + ts 还没有太多成熟的项目范例，可以参考 github - sendya/preview-pro: use pro-layout in vitejs. preview https://sendya.github.io/preview-pro/index.html，它提供了基本的布局和样例代码',charsets:{cjk:!0}},{title:"虎牙C++技术面经",frontmatter:{title:"虎牙C++技术面经",date:"2023-12-05T16:23:56.000Z",permalink:"/pages/d69946/"},regularPath:"/15.%E9%9D%A2%E7%BB%8F/01.%E8%99%8E%E7%89%99C++%E6%8A%80%E6%9C%AF%E9%9D%A2%E7%BB%8F.html",relativePath:"15.面经/01.虎牙C++技术面经.md",key:"v-cc44b1e0",path:"/pages/d69946/",lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"4 min read",minutes:3.38,time:202799.99999999997,words:676},headersStr:null,content:'# 虎牙C++技术面经\n\n\n# 1、虚函数底层\n\n在C++中，虚函数的实现涉及到虚函数表（Virtual Table）的概念。每个含有虚函数的类都会有一个对应的虚函数表，其中存储着指向各个虚函数的地址。当一个对象被创建时，编译器会将该对象的虚函数表地址保存在对象的内存布局中。\n\n通过使用指针或引用来访问对象时，可以根据对象所属类型找到相应的虚函数表，并通过虚函数表中存储的地址调用正确的虚函数。\n\n具体来说，在底层实现上，编译器通常为每个类生成一个隐藏的成员变量——指向虚函数表的指针（即vptr）。当调用一个基类指针或引用上的虚成员函数时，实际执行过程是首先根据 vptr 找到相应的虚函数表，然后通过偏移量找到正确位置上存储着目标成员函数地址，并进行调用。\n\n这种方式使得在派生类中重写（override）基类中定义的虚函数成为可能，派生类可以通过修改自己对应的虚函数表中相应项来改变默认行为。这也是 C++ 多态性（polymorphism）特性实现之一。\n\n细节补充：\n\n 1. 虚函数表的位置： 虚函数表通常位于类的静态存储区域。每个类的实例都包含一个指向其虚函数表的指针。\n 2. 纯虚函数： 如果一个类包含至少一个纯虚函数（即带有 = 0 的虚函数），那么该类将变为抽象类，无法被实例化。抽象类的虚函数表中包含指向纯虚函数的指针。\n 3. 虚析构函数： 如果基类的析构函数是虚的，那么它可以确保在通过基类指针删除指向派生类对象的时候调用正确的析构函数。\n 4. 多重继承： 对于多继承，每个基类都有自己的虚函数表，派生类会包含指向这些表的指针。在多重继承的情况下，可能会有虚拟继承的概念，以避免产生二义性。\n 5. vptr 和 vtable 的命名： 虚指针（vptr）和虚函数表（vtable）的具体命名可能会有所不同，取决于编译器和平台。\n 6. 动态类型识别： 运行时类型信息（RTTI）也与虚函数密切相关，可以通过 typeid 运算符来获得对象的实际类型。\n\n#include <iostream>\n#include <typeinfo>\nclass Base {\npublic:\n    virtual void foo() {\n        std::cout << "Base::foo()" << std::endl;\n    }\n\n    virtual ~Base() = default; // 虚析构函数\n};\nclass Derived : public Base {\npublic:\n    void foo() override {\n        std::cout << "Derived::foo()" << std::endl;\n    }\n};\nint main() {\n    Base* basePtr = new Derived; \n    // 运行时类型识别\n    if (typeid(*basePtr) == typeid(Derived)) {\n        std::cout << "basePtr指向Derived类对象" << std::endl;\n    }\n    // 删除对象时会调用正确的析构函数\n    delete basePtr;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 2、Vector 动态扩容底层\n\n在 C++ 中，std::vector 是一个动态数组容器，它会根据需要自动扩展内部的存储空间。当元素数量超过当前容量时，vector 会重新分配一块更大的内存，并将现有元素拷贝到新的内存区域中。\n\n具体实现上，vector 通常使用动态分配的连续内存来存储元素。它在底层使用了指针和动态内存分配函数（如malloc()或new[]）来管理内存。\n\n当需要扩展容量时，vector 会创建一个更大的缓冲区，并将原有数据拷贝到新缓冲区中。然后释放旧缓冲区所占用的内存空间。\n\n这种动态扩容的机制使得 vector 可以高效地处理不确定大小的数据集合，并且支持随机访问、快速插入和删除操作。\n\n细节补充：\n\n 1. 内存分配策略：\n    * 预留容量： vector 通常会预留一些额外的容量，以避免每次插入操作都触发动态扩容。这个额外的容量可以通过 capacity() 函数查询。预留容量的目的是减少频繁扩容的次数，提高性能。\n 2. 扩容策略：\n    * 翻倍扩容： 为了均摊插入操作的代价，vector 通常采用翻倍扩容的策略。也就是说，当容量不足时，它会创建一个原容量两倍大小的新缓冲区，并将元素从旧缓冲区拷贝到新缓冲区，然后释放旧缓冲区。这个策略确保了插入操作的平摊复杂度是 O(1)。\n    * 增量步长： 有些实现可能选择采用增加一个固定步长的方式进行扩容，而不是翻倍。这可以减小内存的浪费，但可能会导致插入操作的均摊代价略高。\n 3. 移动语义：\n    * C++11 引入的优化： C++11 引入了移动语义，使得在动态扩容时可以对元素进行移动而非拷贝。这在对象较大且开销较高的情况下可以提高性能。\n 4. 内存碎片：\n    * 碎片问题： 尽管 vector 的动态扩容机制带来了灵活性，但在频繁插入和删除操作时可能导致内存碎片。这可能影响内存的利用率，特别是对于大量小对象的情况。\n 5. swap 惯用法：\n    * 释放不需要的内存： 在预知要插入大量元素之前，可以使用 vector<T>().swap(v) 的惯用法来释放不需要的内存。这个操作会构造一个临时 vector 并与原 vector 进行交换，最终原 vector 会获得一个较小的容量。这在需要最小化内存占用的情况下是一种常见的做法。\n\n\n# 3、两个 vector 一个放普通数据类型一个放指针，扩容有什么区别\n\n当一个 vector 存放普通数据类型（如int、float等）而另一个 vector 存放指针时，在扩容过程中会有一些区别。\n\n对于存放普通数据类型的 vector，扩容时会重新分配更大的连续内存空间，并将原有数据拷贝到新的内存区域中。这是因为普通数据类型是值语义，直接复制即可。\n\n而对于存放指针的 vector，扩容时仅会复制指针本身，并不会复制指针所指向的对象。这是因为指针只是保存了对象地址，而不拥有对象本身。因此，在扩容过程中，原有指针的值被简单地复制到新内存区域中，而并没有复制指针所指向的实际对象。\n\n需要注意的是，在存在多个 vector 同时持有同一个对象或者多个对象之间存在依赖关系（比如共享同一块动态分配内存）时，对其中一个 vector 进行扩容可能导致其他 vector 中的指针失效或引起潜在错误。在这种情况下，需要谨慎处理和管理指针以避免问题发生。\n\n细节补充：\n\n 1. 指针不负责内存管理： 存放指针的 vector 本身并不负责指针所指向的内存的生命周期管理。这意味着在扩容的过程中，指针的值会被简单地复制，但指针所指向的实际对象并不会被复制。如果指针所指向的内存是动态分配的，需要确保在不再需要的时候正确释放内存，以防止内存泄漏。\n\n 2. 潜在的野指针问题： 如果在扩容后没有正确处理指针的所有权和生命周期，可能会导致悬空指针或野指针的问题。当一个 vector 扩容时，其元素的指针值被复制到新的内存区域，而老的内存区域被释放。如果其他地方还在使用老的内存区域，就会出现悬空指针问题。\n\n 3. 共享同一块内存： 如果多个 vector 共享同一块内存，那么在扩容时需要确保所有相关的 vector 都被正确处理。否则，一个 vector 的扩容可能会导致其他 vector 中的指针失效或指向无效内存。\n\n 4. 深拷贝和浅拷贝： 如果指针所指向的对象需要深度拷贝，那么在扩容时需要自行实现深拷贝操作。否则，多个 vector 可能会指向相同的对象，从而导致对一个对象的修改影响其他对象。\n\n总体而言，在存放指针的 vector 中进行扩容需要特别小心，确保正确地管理指针和与指针相关的内存。使用智能指针（如std::shared_ptr或std::unique_ptr）可以帮助减少一些潜在的问题，因为它们具有自动内存管理的特性。\n\n\n# 4、进程通信，共享内存如何实现进程安全\n\n在使用共享内存进行进程间通信时，确保进程安全是非常重要的。以下是一些常见的方法来实现进程安全：\n\n 1.  互斥锁（Mutex）： 使用互斥锁可以确保同一时间只有一个进程可以访问共享内存区域。在读写共享内存之前，进程需要先获得互斥锁，完成操作后释放锁。这样可以防止多个进程同时修改数据导致冲突。\n 2.  信号量（Semaphore）： 通过信号量来控制对共享内存的访问。使用计数型的信号量可以限制对资源的并发访问数量。当一个进程需要访问共享内存时，它必须首先检查信号量计数值，如果大于0，则允许访问，并将计数减1；如果为0，则表示当前没有可用资源，进程需要等待其他进程释放资源。\n 3.  文件锁（File Locking）： 利用操作系统提供的文件锁机制，在访问共享内存之前获取一个特定文件上的独占锁或共享锁。只有获得了文件锁的进程才能执行相应操作，其他进程则需要等待。\n 4.  读写锁（Read-Write Lock）： 当多个进程需要同时读取共享内存而不涉及修改时，可以使用读写锁进行优化。读写锁允许多个进程同时读取，但只有一个进程能够进行写操作。这样可以提高读操作的并发性能。\n 5.  原子操作（Atomic Operation）： 某些特定情况下，共享内存中的数据可以通过原子操作进行修改。原子操作是不可被中断的单个指令，保证了在多线程或多进程环境中的一致性和完整性。\n 6.  适当的数据结构设计： 在共享内存中使用适当的数据结构设计可以降低竞态条件的发生。例如，使用原子操作的计数器而不是共享的计数器，可以减少竞态条件的可能性。\n 7.  事务性操作： 将对共享内存的一系列操作组织成事务，要么全部成功执行，要么全部回滚。这通常需要使用类似数据库事务的机制，确保在一系列操作中任何一步出错都能够回滚到一致的状态\n 8.  同步工具： 利用同步工具如条件变量，确保一个进程在进入关键代码段之前等待某个条件的发生，从而避免竞态条件。\n 9.  锁层次： 如果多个共享资源需要访问，考虑使用锁层次结构，按照顺序获取锁，释放锁的顺序相反。这样可以降低死锁的概率。\n 10. 仔细的错误处理： 需要在共享内存的读写过程中处理可能发生的错误，以防止错误的状态导致不一致性。\n 11. 写时复制（Copy-on-Write）： 对于大块数据的写操作，可以考虑使用写时复制策略，即在写操作时先复制一份，再修改。这样可以减少写操作的冲突。\n\n\n# 5、malloc和 free如何知道释放内存具体大小\n\n在使用 malloc 动态分配内存时，系统会在分配的内存块之前记录其大小。这样，当你调用 free 释放内存时，系统可以根据这个大小信息来确保正确地释放相应的内存。\n\n具体而言，在大部分情况下，malloc 会在分配的内存块之前留出一定大小的空间用于保存大小信息。这个大小信息通常是以字节为单位，并且依赖于系统和编译器的实现。\n\n对于 free 函数，它能够根据传入指针所指向的内存地址找到相关的大小信息，并将相应的内存块归还给系统。\n\n需要注意的是，在使用动态分配函数时（如 malloc、calloc、realloc），我们不能修改返回指针所指向的数据区域之前或之后额外添加任何数据。如果这样做可能会导致未定义行为。\n\n细节补充：\n\n 1. 头部信息：\n    \n    * 通常，malloc 分配的内存块前面会有一个头部信息，用于存储分配的大小。这个头部信息的大小和具体内容取决于系统和编译器的实现。\n    * 这个头部信息通常包含了分配的内存块的大小，以字节为单位。malloc 返回的指针指向的是用户可用的内存块的起始地址，而不是头部信息的地址。\n\n 2. 对齐要求：\n    \n    * 有些系统和编译器对内存的对齐有特殊要求，因此分配的内存块的实际大小可能会比用户请求的大小大一些。这是为了满足平台的对齐需求。\n\n 3. 内部碎片：\n    \n    * malloc 会根据系统的内存分配策略（如首次适应、最佳适应等）分配一块足够大的内存，这可能导致一些内部碎片，即实际分配的内存块大小可能比用户请求的稍大。\n\n 4. 多线程安全：\n    \n    * 在多线程环境下，一些实现可能需要额外的空间来存储线程相关的信息，以确保 malloc 和 free 的多线程安全性。\n\n\n# 6、线程池\n\n线程池是一种用于管理和复用多个线程的机制，它通过维护一定数量的线程，并将任务分配给这些线程来提高应用程序的性能和效率。以下是线程池的基本原理和实现过程：\n\n 1. 创建线程池：首先需要创建一个线程池对象，其中包含固定数量的工作线程（也称为工作者线程）。\n 2. 接收任务：当有新任务需要执行时，可以将任务提交给线程池。任务可以以函数、方法或其他可执行单位的形式表示。\n 3. 任务队列：线程池维护一个任务队列，用于存储待执行的任务。当有新任务提交时，将其加入到队列中。\n 4. 工作者线程：在初始化阶段，所有工作者线程都处于空闲状态，等待从任务队列中获取可执行的任务。\n 5. 任务调度：当有空闲的工作者线程时，它会从任务队列中取出一个待执行的任务，并开始执行该任务。\n 6. 处理结果：在任务完成后，可以选择返回结果或通知相关方。\n 7. 线程复用：一旦某个工作者线程完成了当前分配的任务，它会再次进入空闲状态并准备接受下一个任务。这样就避免了频繁创建和销毁线程带来的开销。\n 8. 线程池管理：线程池还可以提供一些管理功能，例如动态调整线程数量、设置最大线程数、超时处理等。\n\n使用线程池的好处是避免了反复创建和销毁线程的开销，提高了任务执行的效率。此外，它还能够限制并发线程数量，避免资源过度占用，并提供更好的任务调度和管理机制。\n\n\n# 7、基类析构函数为什么是虚函数\n\n基类析构函数为虚函数的主要目的是实现多态性的正确销毁。\n\n当基类指针指向派生类对象时，如果基类析构函数不是虚函数，则在使用 delete 操作符释放这个对象时，只会调用基类的析构函数而不会调用派生类的析构函数。这就导致派生类中可能存在资源没有正确释放，造成内存泄漏或其他问题。\n\n通过将基类析构函数声明为虚函数，在使用 delete 操作符释放一个指向派生类对象的基类指针时，会先调用派生类的析构函数，再调用基类的析构函数。这样可以确保每个继承层次上的析构过程都得到正确执行，从而避免了潜在的资源泄漏和错误。\n\n\n# 8、堆区和栈区的区别\n\n堆区和栈区是计算机内存中两个不同的存储区域，主要用于管理变量和对象的内存分配。\n\n栈区（Stack）：\n\n * 栈区是由编译器自动管理的，具有自动分配和释放内存的特性。\n * 存放函数调用时的局部变量、函数参数等。\n * 栈内存由系统自动分配和回收，速度较快。\n * 存储空间有限，一般较小。\n\n堆区（Heap）：\n\n * 堆区是由程序员手动管理的，需要显式地申请和释放内存。\n * 用于存储程序运行时动态分配的对象或大块数据。\n * 堆内存分配通过 malloc、new 等操作实现，释放通过 free、delete 等操作实现。\n * 堆内存空间较大，可以灵活地进行动态分配。\n\n细节补充：\n\n 1. 生命周期：\n    \n    * 栈区中的变量生命周期由其作用域决定，函数执行结束时，栈上的局部变量会自动被销毁。\n    * 堆区中的对象生命周期由程序员控制，需要手动分配和释放，没有明确的作用域概念，需要注意防止内存泄漏。\n\n 2. 大小限制：\n    \n    * 栈区的大小是有限的，通常较小。栈空间是有限的，通常几 MB 到几十 MB ，具体取决于系统和编译器。\n    * 堆区的大小较大，理论上受制于计算机的虚拟内存限制，可以动态地分配和释放较大的内存块。\n\n 3. 碎片问题：\n    \n    * 栈区由于是连续分配的，可能会发生碎片问题，即频繁的压栈和出栈可能导致栈内存出现零散的空间，不能被充分利用。\n    * 堆区由于是动态分配的，可能会有内存碎片问题，但通过各种内存管理策略（如内存池）可以缓解这一问题。\n\n 4. 访问速度：\n    \n    * 栈区的存取速度较快，因为它是线性的、有序的，变量的创建和销毁只涉及移动栈指针。\n    * 堆区的存取速度相对较慢，因为需要动态分配和释放，而且可能存在内存碎片问题。\n\n 5. 使用场景：\n    \n    * 栈区适合存放局部变量、函数调用等，适用于生命周期较短、较小的数据。\n    * 堆区适合存放动态分配的大量数据，如动态数组、对象等，适用于需要灵活管理内存的情况。\n\n总体而言，栈和堆的选择取决于数据的生命周期、大小以及对内存管理的要求。\n\n\n# 9、宏定义放在哪里\n\n 1. 可读性： 将宏定义放在开头可以让其他人更容易理解代码中使用的宏，提高代码的可读性。\n 2. 作用域： 如果宏定义放在源文件或头文件的顶部，则该宏定义对整个源文件或包含了该头文件的所有源文件都可见，确保了正确地应用于需要的范围内。\n 3. 预处理效率： 将宏定义集中放置，预处理器可以更快速地进行替换和展开，提高预处理效率。\n\n然而，在特定情况下，也可以将宏定义局部化，只在特定作用域内起作用。例如，在某个函数内部使用一个简单的宏定义来提高代码可读性或减少重复输入。\n\n细节补充：\n\n 1. 括号的使用： 在宏定义中，对于参数的使用要特别小心，确保用括号括起来，以避免由于运算符优先级导致的问题。例如，MAX(a, b) 中的括号是必要的，因为在宏中可能包含表达式。\n    \n    #define MAX(a, b) ((a) > (b) ? (a) : (b))\n    \n    \n    1\n    \n\n 2. 副作用： 宏中的参数可能会被多次求值，因此在传递有副作用的表达式时要小心。\n    \n    #define SQUARE(x) ((x) * (x))\n    \n    int a = 5;\n    int result = SQUARE(a++);  // 此时 a 被修改两次\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 名称空间： 宏定义没有名称空间的概念，因此可能会发生命名冲突。为了减少冲突的可能性，可以使用较长或者具有特殊前缀的名字。\n    \n    #define MY_PROJECT_MAX(a, b) ((a) > (b) ? (a) : (b))\n    \n    \n    1\n    \n\n 4. 内联函数： 在 C++ 中，宏定义可以被内联函数替代，内联函数更安全，而且通常更易读。\n    \n    // 宏定义\n    #define SQUARE_MACRO(x) ((x) * (x))\n    \n    // 内联函数\n    inline int square_inline(int x) {\n        return x * x;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 5. 条件编译： 宏定义常用于条件编译，但要注意使用 #ifdef、#ifndef、#else、#endif 来确保只在需要时进行编译。\n    \n    #ifdef DEBUG\n    #define LOG(msg) std::cout << msg << std::endl;\n    #else\n    #define LOG(msg)\n    #endif\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n宏定义在一些情况下可以提高代码的灵活性和可读性，但过度使用可能会导致代码的可维护性降低。在现代 C++ 中，许多情况下都能使用 const、constexpr、内联函数或模板来替代宏定义。\n\n\n# 10、qt 信号链接的方式\n\n在 Qt 中，信号与槽是一种常用的通信机制。以下是几种常见的连接方式：\n\n 1. 使用 QObject::connect() 函数：这是最常见的连接方式。可以使用该函数将一个信号与一个槽函数进行连接。示例代码如下：\n\n   QObject::connect(senderObject, SIGNAL(signalName()), receiverObject, SLOT(slotName()));\n\n\n1\n\n 2. 使用 Lambda 表达式：如果你使用 C++11 或更高版本，可以使用 Lambda 表达式来连接信号和槽。示例代码如下：\n\n   QObject::connect(senderObject, &SenderClass::signalName, receiverObject, [](parameters) {\n       // 槽函数实现\n   });\n\n\n1\n2\n3\n\n 3. 使用 Qt5 新语法：从 Qt5 开始引入了新的连接语法，它使用了更安全和类型检查的方法来连接信号和槽。示例代码如下：\n\n   QObject::connect(senderObject, &SenderClass::signalName, receiverObject, &ReceiverClass::slotName);\n\n\n1\n\n\n无论选择哪种方式，都需要确保发送者对象、接收者对象和信号/槽函数正确地定义和声明，并且满足相应的访问限制要求。\n\n还有其他一些高级特性可用于信号与槽的连接，例如使用 Qt 的元对象系统查询、使用多个参数等。具体使用方式可以参考 Qt 文档以及相关教程和示例。\n\n\n# 11、智能指针三种底层实现和应用场景\n\n智能指针是一种 C++ 中的智能内存管理工具，用于自动化地管理动态分配的内存资源，防止内存泄漏和悬空指针等问题。以下是三种常见的智能指针底层实现和它们的应用场景：\n\n 1. shared_ptr：shared_ptr使用引用计数的方式来管理资源，即通过记录有多少个智能指针共享同一个资源，并在没有任何引用时释放该资源。这种底层实现适用于多个智能指针需要共享同一个资源的情况，例如在多线程环境下共享数据、循环引用等。\n 2. unique_ptr：unique_ptr使用独占所有权的方式来管理资源，即每个资源只能由一个unique_ptr拥有，并且不能进行复制或拷贝操作。这种底层实现适用于需要独占某个资源且不需要共享所有权的情况，例如管理原始数组、显式拥有对象等。\n 3. weak_ptr：weak_ptr是一种辅助性智能指针，它可以与shared_ptr配合使用。与shared_ptr相比，weak_ptr不增加引用计数，也不拥有所指向的资源。其主要作用是解决shared_ptr可能导致的循环引用问题，在需要观察但不拥有某个对象时使用。\n\n应用场景举例：\n\n * shared_ptr：在多个对象之间共享同一资源，如共享数据结构、共享缓存等。\n * unique_ptr：管理独占性资源，如动态分配的内存块、原始指针等。\n * weak_ptr：解决shared_ptr循环引用问题，如观察者模式、缓存回收等。\n\n需要根据具体的需求和设计来选择适合的智能指针类型及其底层实现方式。\n\n\n# 12、预防内存泄漏方式\n\n 1. 使用智能指针：使用 C++ 中的智能指针，如 shared_ptr 、 unique_ptr 等，可以自动管理动态分配的内存资源，避免手动释放忘记或错误释放导致的内存泄漏。\n 2. 遵循 RAII（资源获取即初始化）原则：在对象构造时申请资源，在析构时释放资源。通过使用栈上对象或成员对象来管理资源生命周期，确保在不再需要时及时释放资源。\n 3. 避免无效指针赋值：在将指针变量赋值为 nullptr 之前，应始终检查其是否已经被删除或释放。同时，避免野指针和悬空指针的出现。\n 4. 清理不再使用的对象：定期检查并清理不再使用的对象和数据结构，确保它们被正确地删除或释放。\n 5. 谨慎使用动态内存分配：尽量减少对堆内存的直接动态分配，并且在必要时使用合适大小和作用域的内存块进行动态分配，以避免过多频繁地申请和销毁内存。\n 6. 使用工具进行内存泄漏检测：可以借助一些工具来进行静态代码分析或运行时检测，以帮助发现潜在的内存泄漏问题，如 Valgrind 、 LeakSanitizer 等。\n\n\n# 13、调试工具用什么\n\n 1. GDB：GDB 是一个功能强大的命令行调试器，适用于 C、C++ 等语言。它允许你在程序运行时进行断点设置、变量查看、堆栈跟踪等操作。\n 2. Visual Studio Debugger：对于使用Visual Studio开发的项目，Visual Studio提供了内置的集成调试器，可以方便地进行单步执行、变量查看、条件断点等操作。\n 3. Xcode Debugger： Xcode 是苹果公司提供的集成开发环境，在 Mac 上进行 iOS 和 macOS 开发时常用。Xcode 提供了强大的调试功能，包括代码断点、变量监视、内存查看等。\n 4. Eclipse Debugger： Eclipse 是一个流行的Java开发环境，并且支持多种编程语言。Eclipse提供了内置的调试功能，适用于Java和其他语言。\n 5. Valgrind： Valgrind 是一款用于内存错误检测和性能分析的工具套件。它可以检测到内存泄漏、不正确的内存访问以及其他潜在问题。\n 6. Chrome DevTools：针对 Web 开发，在 Chrome 浏览器中使用 DevTools 可以进行 JavaScript 调试和性能分析，包括断点设置、网络请求监控、内存分析等功能。\n\n\n# 14、互斥锁和条件变量的使用\n\n互斥锁（Mutex）和条件变量（Condition Variable）是多线程编程中常用的同步机制。它们通常一起使用来实现线程间的协调与同步。\n\n互斥锁主要用于保护共享资源，确保在任意时刻只有一个线程可以访问该资源。以下是互斥锁的基本使用方式：\n\n 1. 初始化互斥锁：在使用互斥锁之前，需要先进行初始化。\n 2. 加锁：当一个线程需要访问共享资源时，它会尝试获取互斥锁。如果互斥锁已经被其他线程持有，则该线程将进入阻塞状态，直到获得锁为止。\n 3. 访问共享资源：一旦某个线程成功获得了互斥锁，它就可以安全地访问共享资源了。\n 4. 解锁：当某个线程完成对共享资源的操作后，应该及时释放互斥锁，以便其他等待获取该资源的线程可以继续执行。\n\n条件变量用于在线程之间发送信号和等待信号。以下是条件变量的基本使用方式：\n\n 1. 初始化条件变量：在使用条件变量之前，需要先进行初始化。\n 2. 等待信号：当某个线程需要等待某个条件满足时，在加锁的情况下，它会调用条件变量的等待函数进行等待。此时，线程会释放互斥锁，并进入阻塞状态。\n 3. 发送信号：当某个条件满足时，可以通过条件变量的发送信号函数通知正在等待的线程。该线程将从阻塞状态中被唤醒，并重新获取互斥锁以继续执行。\n\n需要注意的是，条件变量和互斥锁一起使用时，通常先对互斥锁加锁，然后再操作条件变量。',normalizedContent:'# 虎牙c++技术面经\n\n\n# 1、虚函数底层\n\n在c++中，虚函数的实现涉及到虚函数表（virtual table）的概念。每个含有虚函数的类都会有一个对应的虚函数表，其中存储着指向各个虚函数的地址。当一个对象被创建时，编译器会将该对象的虚函数表地址保存在对象的内存布局中。\n\n通过使用指针或引用来访问对象时，可以根据对象所属类型找到相应的虚函数表，并通过虚函数表中存储的地址调用正确的虚函数。\n\n具体来说，在底层实现上，编译器通常为每个类生成一个隐藏的成员变量——指向虚函数表的指针（即vptr）。当调用一个基类指针或引用上的虚成员函数时，实际执行过程是首先根据 vptr 找到相应的虚函数表，然后通过偏移量找到正确位置上存储着目标成员函数地址，并进行调用。\n\n这种方式使得在派生类中重写（override）基类中定义的虚函数成为可能，派生类可以通过修改自己对应的虚函数表中相应项来改变默认行为。这也是 c++ 多态性（polymorphism）特性实现之一。\n\n细节补充：\n\n 1. 虚函数表的位置： 虚函数表通常位于类的静态存储区域。每个类的实例都包含一个指向其虚函数表的指针。\n 2. 纯虚函数： 如果一个类包含至少一个纯虚函数（即带有 = 0 的虚函数），那么该类将变为抽象类，无法被实例化。抽象类的虚函数表中包含指向纯虚函数的指针。\n 3. 虚析构函数： 如果基类的析构函数是虚的，那么它可以确保在通过基类指针删除指向派生类对象的时候调用正确的析构函数。\n 4. 多重继承： 对于多继承，每个基类都有自己的虚函数表，派生类会包含指向这些表的指针。在多重继承的情况下，可能会有虚拟继承的概念，以避免产生二义性。\n 5. vptr 和 vtable 的命名： 虚指针（vptr）和虚函数表（vtable）的具体命名可能会有所不同，取决于编译器和平台。\n 6. 动态类型识别： 运行时类型信息（rtti）也与虚函数密切相关，可以通过 typeid 运算符来获得对象的实际类型。\n\n#include <iostream>\n#include <typeinfo>\nclass base {\npublic:\n    virtual void foo() {\n        std::cout << "base::foo()" << std::endl;\n    }\n\n    virtual ~base() = default; // 虚析构函数\n};\nclass derived : public base {\npublic:\n    void foo() override {\n        std::cout << "derived::foo()" << std::endl;\n    }\n};\nint main() {\n    base* baseptr = new derived; \n    // 运行时类型识别\n    if (typeid(*baseptr) == typeid(derived)) {\n        std::cout << "baseptr指向derived类对象" << std::endl;\n    }\n    // 删除对象时会调用正确的析构函数\n    delete baseptr;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 2、vector 动态扩容底层\n\n在 c++ 中，std::vector 是一个动态数组容器，它会根据需要自动扩展内部的存储空间。当元素数量超过当前容量时，vector 会重新分配一块更大的内存，并将现有元素拷贝到新的内存区域中。\n\n具体实现上，vector 通常使用动态分配的连续内存来存储元素。它在底层使用了指针和动态内存分配函数（如malloc()或new[]）来管理内存。\n\n当需要扩展容量时，vector 会创建一个更大的缓冲区，并将原有数据拷贝到新缓冲区中。然后释放旧缓冲区所占用的内存空间。\n\n这种动态扩容的机制使得 vector 可以高效地处理不确定大小的数据集合，并且支持随机访问、快速插入和删除操作。\n\n细节补充：\n\n 1. 内存分配策略：\n    * 预留容量： vector 通常会预留一些额外的容量，以避免每次插入操作都触发动态扩容。这个额外的容量可以通过 capacity() 函数查询。预留容量的目的是减少频繁扩容的次数，提高性能。\n 2. 扩容策略：\n    * 翻倍扩容： 为了均摊插入操作的代价，vector 通常采用翻倍扩容的策略。也就是说，当容量不足时，它会创建一个原容量两倍大小的新缓冲区，并将元素从旧缓冲区拷贝到新缓冲区，然后释放旧缓冲区。这个策略确保了插入操作的平摊复杂度是 o(1)。\n    * 增量步长： 有些实现可能选择采用增加一个固定步长的方式进行扩容，而不是翻倍。这可以减小内存的浪费，但可能会导致插入操作的均摊代价略高。\n 3. 移动语义：\n    * c++11 引入的优化： c++11 引入了移动语义，使得在动态扩容时可以对元素进行移动而非拷贝。这在对象较大且开销较高的情况下可以提高性能。\n 4. 内存碎片：\n    * 碎片问题： 尽管 vector 的动态扩容机制带来了灵活性，但在频繁插入和删除操作时可能导致内存碎片。这可能影响内存的利用率，特别是对于大量小对象的情况。\n 5. swap 惯用法：\n    * 释放不需要的内存： 在预知要插入大量元素之前，可以使用 vector<t>().swap(v) 的惯用法来释放不需要的内存。这个操作会构造一个临时 vector 并与原 vector 进行交换，最终原 vector 会获得一个较小的容量。这在需要最小化内存占用的情况下是一种常见的做法。\n\n\n# 3、两个 vector 一个放普通数据类型一个放指针，扩容有什么区别\n\n当一个 vector 存放普通数据类型（如int、float等）而另一个 vector 存放指针时，在扩容过程中会有一些区别。\n\n对于存放普通数据类型的 vector，扩容时会重新分配更大的连续内存空间，并将原有数据拷贝到新的内存区域中。这是因为普通数据类型是值语义，直接复制即可。\n\n而对于存放指针的 vector，扩容时仅会复制指针本身，并不会复制指针所指向的对象。这是因为指针只是保存了对象地址，而不拥有对象本身。因此，在扩容过程中，原有指针的值被简单地复制到新内存区域中，而并没有复制指针所指向的实际对象。\n\n需要注意的是，在存在多个 vector 同时持有同一个对象或者多个对象之间存在依赖关系（比如共享同一块动态分配内存）时，对其中一个 vector 进行扩容可能导致其他 vector 中的指针失效或引起潜在错误。在这种情况下，需要谨慎处理和管理指针以避免问题发生。\n\n细节补充：\n\n 1. 指针不负责内存管理： 存放指针的 vector 本身并不负责指针所指向的内存的生命周期管理。这意味着在扩容的过程中，指针的值会被简单地复制，但指针所指向的实际对象并不会被复制。如果指针所指向的内存是动态分配的，需要确保在不再需要的时候正确释放内存，以防止内存泄漏。\n\n 2. 潜在的野指针问题： 如果在扩容后没有正确处理指针的所有权和生命周期，可能会导致悬空指针或野指针的问题。当一个 vector 扩容时，其元素的指针值被复制到新的内存区域，而老的内存区域被释放。如果其他地方还在使用老的内存区域，就会出现悬空指针问题。\n\n 3. 共享同一块内存： 如果多个 vector 共享同一块内存，那么在扩容时需要确保所有相关的 vector 都被正确处理。否则，一个 vector 的扩容可能会导致其他 vector 中的指针失效或指向无效内存。\n\n 4. 深拷贝和浅拷贝： 如果指针所指向的对象需要深度拷贝，那么在扩容时需要自行实现深拷贝操作。否则，多个 vector 可能会指向相同的对象，从而导致对一个对象的修改影响其他对象。\n\n总体而言，在存放指针的 vector 中进行扩容需要特别小心，确保正确地管理指针和与指针相关的内存。使用智能指针（如std::shared_ptr或std::unique_ptr）可以帮助减少一些潜在的问题，因为它们具有自动内存管理的特性。\n\n\n# 4、进程通信，共享内存如何实现进程安全\n\n在使用共享内存进行进程间通信时，确保进程安全是非常重要的。以下是一些常见的方法来实现进程安全：\n\n 1.  互斥锁（mutex）： 使用互斥锁可以确保同一时间只有一个进程可以访问共享内存区域。在读写共享内存之前，进程需要先获得互斥锁，完成操作后释放锁。这样可以防止多个进程同时修改数据导致冲突。\n 2.  信号量（semaphore）： 通过信号量来控制对共享内存的访问。使用计数型的信号量可以限制对资源的并发访问数量。当一个进程需要访问共享内存时，它必须首先检查信号量计数值，如果大于0，则允许访问，并将计数减1；如果为0，则表示当前没有可用资源，进程需要等待其他进程释放资源。\n 3.  文件锁（file locking）： 利用操作系统提供的文件锁机制，在访问共享内存之前获取一个特定文件上的独占锁或共享锁。只有获得了文件锁的进程才能执行相应操作，其他进程则需要等待。\n 4.  读写锁（read-write lock）： 当多个进程需要同时读取共享内存而不涉及修改时，可以使用读写锁进行优化。读写锁允许多个进程同时读取，但只有一个进程能够进行写操作。这样可以提高读操作的并发性能。\n 5.  原子操作（atomic operation）： 某些特定情况下，共享内存中的数据可以通过原子操作进行修改。原子操作是不可被中断的单个指令，保证了在多线程或多进程环境中的一致性和完整性。\n 6.  适当的数据结构设计： 在共享内存中使用适当的数据结构设计可以降低竞态条件的发生。例如，使用原子操作的计数器而不是共享的计数器，可以减少竞态条件的可能性。\n 7.  事务性操作： 将对共享内存的一系列操作组织成事务，要么全部成功执行，要么全部回滚。这通常需要使用类似数据库事务的机制，确保在一系列操作中任何一步出错都能够回滚到一致的状态\n 8.  同步工具： 利用同步工具如条件变量，确保一个进程在进入关键代码段之前等待某个条件的发生，从而避免竞态条件。\n 9.  锁层次： 如果多个共享资源需要访问，考虑使用锁层次结构，按照顺序获取锁，释放锁的顺序相反。这样可以降低死锁的概率。\n 10. 仔细的错误处理： 需要在共享内存的读写过程中处理可能发生的错误，以防止错误的状态导致不一致性。\n 11. 写时复制（copy-on-write）： 对于大块数据的写操作，可以考虑使用写时复制策略，即在写操作时先复制一份，再修改。这样可以减少写操作的冲突。\n\n\n# 5、malloc和 free如何知道释放内存具体大小\n\n在使用 malloc 动态分配内存时，系统会在分配的内存块之前记录其大小。这样，当你调用 free 释放内存时，系统可以根据这个大小信息来确保正确地释放相应的内存。\n\n具体而言，在大部分情况下，malloc 会在分配的内存块之前留出一定大小的空间用于保存大小信息。这个大小信息通常是以字节为单位，并且依赖于系统和编译器的实现。\n\n对于 free 函数，它能够根据传入指针所指向的内存地址找到相关的大小信息，并将相应的内存块归还给系统。\n\n需要注意的是，在使用动态分配函数时（如 malloc、calloc、realloc），我们不能修改返回指针所指向的数据区域之前或之后额外添加任何数据。如果这样做可能会导致未定义行为。\n\n细节补充：\n\n 1. 头部信息：\n    \n    * 通常，malloc 分配的内存块前面会有一个头部信息，用于存储分配的大小。这个头部信息的大小和具体内容取决于系统和编译器的实现。\n    * 这个头部信息通常包含了分配的内存块的大小，以字节为单位。malloc 返回的指针指向的是用户可用的内存块的起始地址，而不是头部信息的地址。\n\n 2. 对齐要求：\n    \n    * 有些系统和编译器对内存的对齐有特殊要求，因此分配的内存块的实际大小可能会比用户请求的大小大一些。这是为了满足平台的对齐需求。\n\n 3. 内部碎片：\n    \n    * malloc 会根据系统的内存分配策略（如首次适应、最佳适应等）分配一块足够大的内存，这可能导致一些内部碎片，即实际分配的内存块大小可能比用户请求的稍大。\n\n 4. 多线程安全：\n    \n    * 在多线程环境下，一些实现可能需要额外的空间来存储线程相关的信息，以确保 malloc 和 free 的多线程安全性。\n\n\n# 6、线程池\n\n线程池是一种用于管理和复用多个线程的机制，它通过维护一定数量的线程，并将任务分配给这些线程来提高应用程序的性能和效率。以下是线程池的基本原理和实现过程：\n\n 1. 创建线程池：首先需要创建一个线程池对象，其中包含固定数量的工作线程（也称为工作者线程）。\n 2. 接收任务：当有新任务需要执行时，可以将任务提交给线程池。任务可以以函数、方法或其他可执行单位的形式表示。\n 3. 任务队列：线程池维护一个任务队列，用于存储待执行的任务。当有新任务提交时，将其加入到队列中。\n 4. 工作者线程：在初始化阶段，所有工作者线程都处于空闲状态，等待从任务队列中获取可执行的任务。\n 5. 任务调度：当有空闲的工作者线程时，它会从任务队列中取出一个待执行的任务，并开始执行该任务。\n 6. 处理结果：在任务完成后，可以选择返回结果或通知相关方。\n 7. 线程复用：一旦某个工作者线程完成了当前分配的任务，它会再次进入空闲状态并准备接受下一个任务。这样就避免了频繁创建和销毁线程带来的开销。\n 8. 线程池管理：线程池还可以提供一些管理功能，例如动态调整线程数量、设置最大线程数、超时处理等。\n\n使用线程池的好处是避免了反复创建和销毁线程的开销，提高了任务执行的效率。此外，它还能够限制并发线程数量，避免资源过度占用，并提供更好的任务调度和管理机制。\n\n\n# 7、基类析构函数为什么是虚函数\n\n基类析构函数为虚函数的主要目的是实现多态性的正确销毁。\n\n当基类指针指向派生类对象时，如果基类析构函数不是虚函数，则在使用 delete 操作符释放这个对象时，只会调用基类的析构函数而不会调用派生类的析构函数。这就导致派生类中可能存在资源没有正确释放，造成内存泄漏或其他问题。\n\n通过将基类析构函数声明为虚函数，在使用 delete 操作符释放一个指向派生类对象的基类指针时，会先调用派生类的析构函数，再调用基类的析构函数。这样可以确保每个继承层次上的析构过程都得到正确执行，从而避免了潜在的资源泄漏和错误。\n\n\n# 8、堆区和栈区的区别\n\n堆区和栈区是计算机内存中两个不同的存储区域，主要用于管理变量和对象的内存分配。\n\n栈区（stack）：\n\n * 栈区是由编译器自动管理的，具有自动分配和释放内存的特性。\n * 存放函数调用时的局部变量、函数参数等。\n * 栈内存由系统自动分配和回收，速度较快。\n * 存储空间有限，一般较小。\n\n堆区（heap）：\n\n * 堆区是由程序员手动管理的，需要显式地申请和释放内存。\n * 用于存储程序运行时动态分配的对象或大块数据。\n * 堆内存分配通过 malloc、new 等操作实现，释放通过 free、delete 等操作实现。\n * 堆内存空间较大，可以灵活地进行动态分配。\n\n细节补充：\n\n 1. 生命周期：\n    \n    * 栈区中的变量生命周期由其作用域决定，函数执行结束时，栈上的局部变量会自动被销毁。\n    * 堆区中的对象生命周期由程序员控制，需要手动分配和释放，没有明确的作用域概念，需要注意防止内存泄漏。\n\n 2. 大小限制：\n    \n    * 栈区的大小是有限的，通常较小。栈空间是有限的，通常几 mb 到几十 mb ，具体取决于系统和编译器。\n    * 堆区的大小较大，理论上受制于计算机的虚拟内存限制，可以动态地分配和释放较大的内存块。\n\n 3. 碎片问题：\n    \n    * 栈区由于是连续分配的，可能会发生碎片问题，即频繁的压栈和出栈可能导致栈内存出现零散的空间，不能被充分利用。\n    * 堆区由于是动态分配的，可能会有内存碎片问题，但通过各种内存管理策略（如内存池）可以缓解这一问题。\n\n 4. 访问速度：\n    \n    * 栈区的存取速度较快，因为它是线性的、有序的，变量的创建和销毁只涉及移动栈指针。\n    * 堆区的存取速度相对较慢，因为需要动态分配和释放，而且可能存在内存碎片问题。\n\n 5. 使用场景：\n    \n    * 栈区适合存放局部变量、函数调用等，适用于生命周期较短、较小的数据。\n    * 堆区适合存放动态分配的大量数据，如动态数组、对象等，适用于需要灵活管理内存的情况。\n\n总体而言，栈和堆的选择取决于数据的生命周期、大小以及对内存管理的要求。\n\n\n# 9、宏定义放在哪里\n\n 1. 可读性： 将宏定义放在开头可以让其他人更容易理解代码中使用的宏，提高代码的可读性。\n 2. 作用域： 如果宏定义放在源文件或头文件的顶部，则该宏定义对整个源文件或包含了该头文件的所有源文件都可见，确保了正确地应用于需要的范围内。\n 3. 预处理效率： 将宏定义集中放置，预处理器可以更快速地进行替换和展开，提高预处理效率。\n\n然而，在特定情况下，也可以将宏定义局部化，只在特定作用域内起作用。例如，在某个函数内部使用一个简单的宏定义来提高代码可读性或减少重复输入。\n\n细节补充：\n\n 1. 括号的使用： 在宏定义中，对于参数的使用要特别小心，确保用括号括起来，以避免由于运算符优先级导致的问题。例如，max(a, b) 中的括号是必要的，因为在宏中可能包含表达式。\n    \n    #define max(a, b) ((a) > (b) ? (a) : (b))\n    \n    \n    1\n    \n\n 2. 副作用： 宏中的参数可能会被多次求值，因此在传递有副作用的表达式时要小心。\n    \n    #define square(x) ((x) * (x))\n    \n    int a = 5;\n    int result = square(a++);  // 此时 a 被修改两次\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 名称空间： 宏定义没有名称空间的概念，因此可能会发生命名冲突。为了减少冲突的可能性，可以使用较长或者具有特殊前缀的名字。\n    \n    #define my_project_max(a, b) ((a) > (b) ? (a) : (b))\n    \n    \n    1\n    \n\n 4. 内联函数： 在 c++ 中，宏定义可以被内联函数替代，内联函数更安全，而且通常更易读。\n    \n    // 宏定义\n    #define square_macro(x) ((x) * (x))\n    \n    // 内联函数\n    inline int square_inline(int x) {\n        return x * x;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 5. 条件编译： 宏定义常用于条件编译，但要注意使用 #ifdef、#ifndef、#else、#endif 来确保只在需要时进行编译。\n    \n    #ifdef debug\n    #define log(msg) std::cout << msg << std::endl;\n    #else\n    #define log(msg)\n    #endif\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n宏定义在一些情况下可以提高代码的灵活性和可读性，但过度使用可能会导致代码的可维护性降低。在现代 c++ 中，许多情况下都能使用 const、constexpr、内联函数或模板来替代宏定义。\n\n\n# 10、qt 信号链接的方式\n\n在 qt 中，信号与槽是一种常用的通信机制。以下是几种常见的连接方式：\n\n 1. 使用 qobject::connect() 函数：这是最常见的连接方式。可以使用该函数将一个信号与一个槽函数进行连接。示例代码如下：\n\n   qobject::connect(senderobject, signal(signalname()), receiverobject, slot(slotname()));\n\n\n1\n\n 2. 使用 lambda 表达式：如果你使用 c++11 或更高版本，可以使用 lambda 表达式来连接信号和槽。示例代码如下：\n\n   qobject::connect(senderobject, &senderclass::signalname, receiverobject, [](parameters) {\n       // 槽函数实现\n   });\n\n\n1\n2\n3\n\n 3. 使用 qt5 新语法：从 qt5 开始引入了新的连接语法，它使用了更安全和类型检查的方法来连接信号和槽。示例代码如下：\n\n   qobject::connect(senderobject, &senderclass::signalname, receiverobject, &receiverclass::slotname);\n\n\n1\n\n\n无论选择哪种方式，都需要确保发送者对象、接收者对象和信号/槽函数正确地定义和声明，并且满足相应的访问限制要求。\n\n还有其他一些高级特性可用于信号与槽的连接，例如使用 qt 的元对象系统查询、使用多个参数等。具体使用方式可以参考 qt 文档以及相关教程和示例。\n\n\n# 11、智能指针三种底层实现和应用场景\n\n智能指针是一种 c++ 中的智能内存管理工具，用于自动化地管理动态分配的内存资源，防止内存泄漏和悬空指针等问题。以下是三种常见的智能指针底层实现和它们的应用场景：\n\n 1. shared_ptr：shared_ptr使用引用计数的方式来管理资源，即通过记录有多少个智能指针共享同一个资源，并在没有任何引用时释放该资源。这种底层实现适用于多个智能指针需要共享同一个资源的情况，例如在多线程环境下共享数据、循环引用等。\n 2. unique_ptr：unique_ptr使用独占所有权的方式来管理资源，即每个资源只能由一个unique_ptr拥有，并且不能进行复制或拷贝操作。这种底层实现适用于需要独占某个资源且不需要共享所有权的情况，例如管理原始数组、显式拥有对象等。\n 3. weak_ptr：weak_ptr是一种辅助性智能指针，它可以与shared_ptr配合使用。与shared_ptr相比，weak_ptr不增加引用计数，也不拥有所指向的资源。其主要作用是解决shared_ptr可能导致的循环引用问题，在需要观察但不拥有某个对象时使用。\n\n应用场景举例：\n\n * shared_ptr：在多个对象之间共享同一资源，如共享数据结构、共享缓存等。\n * unique_ptr：管理独占性资源，如动态分配的内存块、原始指针等。\n * weak_ptr：解决shared_ptr循环引用问题，如观察者模式、缓存回收等。\n\n需要根据具体的需求和设计来选择适合的智能指针类型及其底层实现方式。\n\n\n# 12、预防内存泄漏方式\n\n 1. 使用智能指针：使用 c++ 中的智能指针，如 shared_ptr 、 unique_ptr 等，可以自动管理动态分配的内存资源，避免手动释放忘记或错误释放导致的内存泄漏。\n 2. 遵循 raii（资源获取即初始化）原则：在对象构造时申请资源，在析构时释放资源。通过使用栈上对象或成员对象来管理资源生命周期，确保在不再需要时及时释放资源。\n 3. 避免无效指针赋值：在将指针变量赋值为 nullptr 之前，应始终检查其是否已经被删除或释放。同时，避免野指针和悬空指针的出现。\n 4. 清理不再使用的对象：定期检查并清理不再使用的对象和数据结构，确保它们被正确地删除或释放。\n 5. 谨慎使用动态内存分配：尽量减少对堆内存的直接动态分配，并且在必要时使用合适大小和作用域的内存块进行动态分配，以避免过多频繁地申请和销毁内存。\n 6. 使用工具进行内存泄漏检测：可以借助一些工具来进行静态代码分析或运行时检测，以帮助发现潜在的内存泄漏问题，如 valgrind 、 leaksanitizer 等。\n\n\n# 13、调试工具用什么\n\n 1. gdb：gdb 是一个功能强大的命令行调试器，适用于 c、c++ 等语言。它允许你在程序运行时进行断点设置、变量查看、堆栈跟踪等操作。\n 2. visual studio debugger：对于使用visual studio开发的项目，visual studio提供了内置的集成调试器，可以方便地进行单步执行、变量查看、条件断点等操作。\n 3. xcode debugger： xcode 是苹果公司提供的集成开发环境，在 mac 上进行 ios 和 macos 开发时常用。xcode 提供了强大的调试功能，包括代码断点、变量监视、内存查看等。\n 4. eclipse debugger： eclipse 是一个流行的java开发环境，并且支持多种编程语言。eclipse提供了内置的调试功能，适用于java和其他语言。\n 5. valgrind： valgrind 是一款用于内存错误检测和性能分析的工具套件。它可以检测到内存泄漏、不正确的内存访问以及其他潜在问题。\n 6. chrome devtools：针对 web 开发，在 chrome 浏览器中使用 devtools 可以进行 javascript 调试和性能分析，包括断点设置、网络请求监控、内存分析等功能。\n\n\n# 14、互斥锁和条件变量的使用\n\n互斥锁（mutex）和条件变量（condition variable）是多线程编程中常用的同步机制。它们通常一起使用来实现线程间的协调与同步。\n\n互斥锁主要用于保护共享资源，确保在任意时刻只有一个线程可以访问该资源。以下是互斥锁的基本使用方式：\n\n 1. 初始化互斥锁：在使用互斥锁之前，需要先进行初始化。\n 2. 加锁：当一个线程需要访问共享资源时，它会尝试获取互斥锁。如果互斥锁已经被其他线程持有，则该线程将进入阻塞状态，直到获得锁为止。\n 3. 访问共享资源：一旦某个线程成功获得了互斥锁，它就可以安全地访问共享资源了。\n 4. 解锁：当某个线程完成对共享资源的操作后，应该及时释放互斥锁，以便其他等待获取该资源的线程可以继续执行。\n\n条件变量用于在线程之间发送信号和等待信号。以下是条件变量的基本使用方式：\n\n 1. 初始化条件变量：在使用条件变量之前，需要先进行初始化。\n 2. 等待信号：当某个线程需要等待某个条件满足时，在加锁的情况下，它会调用条件变量的等待函数进行等待。此时，线程会释放互斥锁，并进入阻塞状态。\n 3. 发送信号：当某个条件满足时，可以通过条件变量的发送信号函数通知正在等待的线程。该线程将从阻塞状态中被唤醒，并重新获取互斥锁以继续执行。\n\n需要注意的是，条件变量和互斥锁一起使用时，通常先对互斥锁加锁，然后再操作条件变量。',charsets:{cjk:!0}},{title:"金山一面复习",frontmatter:{title:"金山一面复习",date:"2023-12-05T16:24:22.000Z",permalink:"/pages/29251d/"},regularPath:"/15.%E9%9D%A2%E7%BB%8F/02.%E9%87%91%E5%B1%B1%E4%B8%80%E9%9D%A2%E5%A4%8D%E4%B9%A0.html",relativePath:"15.面经/02.金山一面复习.md",key:"v-3616f8cb",path:"/pages/29251d/",headers:[{level:2,title:"1、静态变量生命周期和普通变量比较？",slug:"_1、静态变量生命周期和普通变量比较",normalizedTitle:"1、静态变量生命周期和普通变量比较？",charIndex:29},{level:2,title:"2、什么时候创建虚函数表？",slug:"_2、什么时候创建虚函数表",normalizedTitle:"2、什么时候创建虚函数表？",charIndex:556},{level:3,title:"虚函数的定义：",slug:"虚函数的定义",normalizedTitle:"虚函数的定义：",charIndex:574},{level:3,title:"派生类中的重写：",slug:"派生类中的重写",normalizedTitle:"派生类中的重写：",charIndex:722},{level:3,title:"虚函数表的创建：",slug:"虚函数表的创建",normalizedTitle:"虚函数表的创建：",charIndex:930},{level:3,title:"虚函数表的指针：",slug:"虚函数表的指针",normalizedTitle:"虚函数表的指针：",charIndex:1035},{level:3,title:"运行时动态绑定：",slug:"运行时动态绑定",normalizedTitle:"运行时动态绑定：",charIndex:1121},{level:2,title:"3、虚函数指针会不会变，什么时候初始化，在析构里会不会变，析构函数能访问虚函数吗？",slug:"_3、虚函数指针会不会变-什么时候初始化-在析构里会不会变-析构函数能访问虚函数吗",normalizedTitle:"3、虚函数指针会不会变，什么时候初始化，在析构里会不会变，析构函数能访问虚函数吗？",charIndex:1294},{level:3,title:"初始化时创建：",slug:"初始化时创建",normalizedTitle:"初始化时创建：",charIndex:1340},{level:3,title:"不会在析构函数中改变：",slug:"不会在析构函数中改变",normalizedTitle:"不会在析构函数中改变：",charIndex:1428},{level:3,title:"虚函数的调用：",slug:"虚函数的调用",normalizedTitle:"虚函数的调用：",charIndex:1523},{level:3,title:"注意虚函数表指针变化的情况：",slug:"注意虚函数表指针变化的情况",normalizedTitle:"注意虚函数表指针变化的情况：",charIndex:1661},{level:2,title:"4、静态函数可以访问非静态成员变量吗为什么？",slug:"_4、静态函数可以访问非静态成员变量吗为什么",normalizedTitle:"4、静态函数可以访问非静态成员变量吗为什么？",charIndex:1783},{level:2,title:"5、编译实现重载？",slug:"_5、编译实现重载",normalizedTitle:"5、编译实现重载？",charIndex:2488},{level:2,title:"6、静态变量新特性保证原子性？",slug:"_6、静态变量新特性保证原子性",normalizedTitle:"6、静态变量新特性保证原子性？",charIndex:3239},{level:3,title:"1、初始化保护：",slug:"_1、初始化保护",normalizedTitle:"1、初始化保护：",charIndex:3259},{level:3,title:"2、内存模型：",slug:"_2、内存模型",normalizedTitle:"2、内存模型：",charIndex:3662},{level:2,title:"7、静态局部变量的使用？",slug:"_7、静态局部变量的使用",normalizedTitle:"7、静态局部变量的使用？",charIndex:4526},{level:3,title:"初始化保护：",slug:"初始化保护",normalizedTitle:"初始化保护：",charIndex:3261},{level:3,title:"作用域：",slug:"作用域",normalizedTitle:"作用域：",charIndex:220},{level:3,title:"内存分配：",slug:"内存分配",normalizedTitle:"内存分配：",charIndex:4917},{level:3,title:"线程安全性：",slug:"线程安全性",normalizedTitle:"线程安全性：",charIndex:4985},{level:3,title:"初始值：",slug:"初始值",normalizedTitle:"初始值：",charIndex:5051},{level:3,title:"保持状态：",slug:"保持状态",normalizedTitle:"保持状态：",charIndex:5121},{level:2,title:"8、四种cast用在什么时候，dynamic什么时候用，不这么用返回值是什么？",slug:"_8、四种cast用在什么时候-dynamic什么时候用-不这么用返回值是什么",normalizedTitle:"8、四种cast用在什么时候，dynamic什么时候用，不这么用返回值是什么？",charIndex:5502},{level:3,title:"static_cast",slug:"static-cast",normalizedTitle:"static_cast",charIndex:5546},{level:3,title:"dynamic_cast",slug:"dynamic-cast",normalizedTitle:"dynamic_cast",charIndex:5721},{level:3,title:"const_cast",slug:"const-cast",normalizedTitle:"const_cast",charIndex:6129},{level:3,title:"reinterpret_cast",slug:"reinterpret-cast",normalizedTitle:"reinterpret_cast",charIndex:6320},{level:2,title:"9、Vector数组迭代器失效时机，如何使用迭代器删除vector，erase返回值？",slug:"_9、vector数组迭代器失效时机-如何使用迭代器删除vector-erase返回值",normalizedTitle:"9、vector数组迭代器失效时机，如何使用迭代器删除vector，erase返回值？",charIndex:6602},{level:2,title:"10、Map数据结构，struct插入map需要注意什么",slug:"_10、map数据结构-struct插入map需要注意什么",normalizedTitle:"10、map数据结构，struct插入map需要注意什么",charIndex:7958},{level:2,title:"11、进程间通信？",slug:"_11、进程间通信",normalizedTitle:"11、进程间通信？",charIndex:9005},{level:2,title:"12、如何实现多次运行一个程序只有一个后台进程？",slug:"_12、如何实现多次运行一个程序只有一个后台进程",normalizedTitle:"12、如何实现多次运行一个程序只有一个后台进程？",charIndex:10154},{level:2,title:"13、Tcp三次握手为什么不是2次或者4次？",slug:"_13、tcp三次握手为什么不是2次或者4次",normalizedTitle:"13、tcp三次握手为什么不是2次或者4次？",charIndex:11421},{level:2,title:"14、二叉树最大深度？",slug:"_14、二叉树最大深度",normalizedTitle:"14、二叉树最大深度？",charIndex:12132},{level:3,title:"思路：双栈法",slug:"思路-双栈法",normalizedTitle:"思路：双栈法",charIndex:12208},{level:3,title:"思路：递归",slug:"思路-递归",normalizedTitle:"思路：递归",charIndex:13914},{level:2,title:"15、反转链表？",slug:"_15、反转链表",normalizedTitle:"15、反转链表？",charIndex:15001}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"6 min read",minutes:5.725,time:343500,words:1145},headersStr:"1、静态变量生命周期和普通变量比较？ 2、什么时候创建虚函数表？ 虚函数的定义： 派生类中的重写： 虚函数表的创建： 虚函数表的指针： 运行时动态绑定： 3、虚函数指针会不会变，什么时候初始化，在析构里会不会变，析构函数能访问虚函数吗？ 初始化时创建： 不会在析构函数中改变： 虚函数的调用： 注意虚函数表指针变化的情况： 4、静态函数可以访问非静态成员变量吗为什么？ 5、编译实现重载？ 6、静态变量新特性保证原子性？ 1、初始化保护： 2、内存模型： 7、静态局部变量的使用？ 初始化保护： 作用域： 内存分配： 线程安全性： 初始值： 保持状态： 8、四种cast用在什么时候，dynamic什么时候用，不这么用返回值是什么？ static_cast dynamic_cast const_cast reinterpret_cast 9、Vector数组迭代器失效时机，如何使用迭代器删除vector，erase返回值？ 10、Map数据结构，struct插入map需要注意什么 11、进程间通信？ 12、如何实现多次运行一个程序只有一个后台进程？ 13、Tcp三次握手为什么不是2次或者4次？ 14、二叉树最大深度？ 思路：双栈法 思路：递归 15、反转链表？",content:'# 金山一面复习\n\n> 时间：2023.11.7\n\n\n# 1、静态变量生命周期和普通变量比较？\n\n 1. 生命周期：\n    1. 普通变量（自动变量）：自动变量的生命周期与其所在的代码块（作用域）相关。它们在离开其定义的作用域时被销毁，通常是栈上分配的。\n    2. 静态变量（静态存储期变量）：静态变量的生命周期在整个程序运行期间，它们在程序启动时分配内存，在程序结束时才会被释放。静态变量可以存储在全局存储区或静态存储区。\n 2. 作用域：\n    1. 普通变量：普通变量的作用域通常仅限于定义它们的代码块，它们不能被其他代码块访问。\n    2. 静态变量：静态变量可以具有更广泛的作用域，例如，如果它们在全局范围内声明，它们可以被整个程序访问。\n 3. 初始化：\n    1. 普通变量：普通变量在声明时不会自动初始化，除非显式赋初值。\n    2. 静态变量：静态变量在定义时如果不显式初始化，会自动初始化为零（对于基本数据类型）或空（对于类对象）。\n 4. 存储位置：\n    1. 普通变量：普通变量通常分配在栈上，每次函数调用时都会创建新的实例。\n    2. 静态变量：静态变量可以存储在全局存储区或静态存储区。全局变量在程序启动时初始化，它们的值在程序的整个生命周期内都可用。\n\n\n# 2、什么时候创建虚函数表？\n\n\n# 虚函数的定义：\n\n虚函数是通过在基类中声明的。虚函数的定义包括返回类型、函数名和参数列表。\n\nclass Base {\n    public:\n    virtual void foo() { /* Base class implementation */}\n};\n\n\n1\n2\n3\n4\n\n\n\n# 派生类中的重写：\n\n派生类可以重写虚函数，这意味着它可以提供自己的实现版本。在派生类中重新定义虚函数时，需要使用 virtual 关键字来保持虚函数性质。\n\nclass Derived : public Base {\n    public:\n    virtual void foo() override {/* Derived class implementation */}\n};\n\n\n1\n2\n3\n4\n\n\n\n# 虚函数表的创建：\n\n虚函数表在编译时由C++编译器自动生成。对于每个具有虚函数的类，编译器会生成一个虚函数表，其中包含了该类的虚函数指针。这个虚函数表通常位于类的内部，它是静态的，一旦创建就不会更改。\n\n\n# 虚函数表的指针：\n\n对于每个包含虚函数的类，编译器会在类的内部添加一个指向虚函数表的指针，通常位于对象的内存布局的最前面。这个指针被称为虚函数表指针（vptr）。\n\n\n# 运行时动态绑定：\n\n当你通过基类指针或引用调用虚函数时，实际执行的是派生类中的版本（如果派生类重新定义了虚函数）。这是因为虚函数表指针（vptr）指向了正确的虚函数表，允许在运行时根据对象的类型进行动态绑定。\n\nBase *ptr = new Derived;\nptr->foo();//调用Derived类中的foo()\n\n\n1\n2\n\n\n\n# 3、虚函数指针会不会变，什么时候初始化，在析构里会不会变，析构函数能访问虚函数吗？\n\n\n# 初始化时创建：\n\n虚函数表指针在对象创建时就被初始化。当你创建一个类的实例（对象）时，其中包括一个指向该类虚函数表的虚函数表指针。这个指针是在对象构造过程中初始化的。\n\n\n# 不会在析构函数中改变：\n\n虚函数表指针通常在对象的整个生命周期内保持不变。这意味着即使在对象的析构函数中，虚函数表指针也不会改变。析构函数是用于对象销毁的，不负责改变虚函数表指针。\n\n\n# 虚函数的调用：\n\n虚函数表指针的主要作用是支持运行时多态性。通过这个指针，程序可以在运行时查找并调用正确的虚函数版本。在析构函数中，你可以调用虚函数，但需要注意的是析构函数本身不会改变虚函数表指针。在析构函数中调用虚函数时，通常执行的是对象的类型，而不是基类的类型。\n\n\n# 注意虚函数表指针变化的情况：\n\n在一些特殊情况下，虚函数表指针可能会变化。例如，当一个对象通过复制构造函数复制时，复制的对象将有自己的虚函数表指针。这通常发生在基类和派生类之间的复制。另外，如果你使用虚继承，虚函数表指针也可能会更改。\n\n\n# 4、静态函数可以访问非静态成员变量吗为什么？\n\n静态成员函数（静态方法）可以访问非静态成员变量。\n\n 1. 静态函数（静态成员函数）：静态函数是与类关联，而不是与类的实例（对象）关联的函数。这意味着它不依赖于特定的对象，可以通过类名直接调用。静态函数通常用于执行与类本身相关的操作，而不涉及特定对象的状态。\n 2. 非静态成员变量：非静态成员变量是与类的实例（对象）关联的变量。每个类的对象都有其自己的一组非静态成员变量，它们可以存储对象特定的状态信息。\n\n现在来看静态函数访问非静态成员变量的情况：\n\n * 可以访问静态成员变量：静态函数可以自由地访问同一类的静态成员变量，因为这些成员变量与类相关，而不是与对象相关。在静态函数中，你可以使用类名或this指针（在类的范围内）来访问静态成员变量。\n * 不能直接访问非静态成员变量：静态函数不能直接访问特定对象的非静态成员变量。这是因为静态函数没有"this"指针，它不知道它应该关联到哪个对象的非静态成员变量。\n * 需要对象实例：如果静态函数需要访问特定对象的非静态成员变量，它必须通过传递对象实例作为参数或在函数内部创建对象实例，然后使用该对象实例来访问非静态成员变量。\n\n示例：\n\nclass MyClass {\n    public:\n    int nonStaticVar;//非静态成员变量\n    static void StaticFunction(MyClass& obj) {\n        obj.nonStaticVar = 42;//通过对象实例访问非静态成员变量\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5、编译实现重载？\n\n**函数重载（Function Overloading）是一种允许你定义多个同名函数，但它们具有不同的参数列表的机制。**编译器会根据不同的参数列表来决定调用哪个重载函数。函数重载使你能够使用相同的函数名来处理不同类型的数据或不同数量的参数，从而提高了代码的可读性和复用性。\n\n 1. 函数名称相同：在函数重载中，你可以定义多个具有相同名称的函数，但它们的参数列表不同。\n 2. 参数列表不同：参数列表包括参数的数量、参数的类型、参数的顺序等。至少需要有一个方面在参数列表中不同，否则编译器将无法区分这些函数。\n 3. 返回类型不同：重载函数的返回类型可以不同，但它通常不是编译器用于函数重载决策的关键因素。编译器主要关注参数列表。\n 4. 与函数调用相关：编译器会根据函数调用时提供的参数来决定调用哪个重载函数。\n\n#include <iostream>\nvoid print(int value) {\n\tstd::cout << "Printing integer: " << value << std::endl;\n}\nvoid print(double value) {\n\tstd::cout << "Printing double: " << value << std::endl;\n}\n\nint main() {\n    int intVar = 42;\n    double doubleVar = 3.14159;\n    print(intVar);\t //调用第一个重载函数\n    print(doubleVar);//调用第二个重载函数\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 6、静态变量新特性保证原子性？\n\n\n# 1、初始化保护：\n\nC++11规定了静态局部变量的初始化必须是线程安全的。这意味着在多线程环境中，多个线程第一次进入函数并尝试初始化同一个静态局部变量时，只有一个线程会执行初始化，其他线程会等待。这种机制确保了静态局部变量的初始化是线程安全的。\n\n#include <iostream>\n#include <thread>\nvoid foo(){\n    static int x = 0;//C++11以后的标准保证x的初始化是线程安全的\n    std::cout << x++ << std::endl;\n}\nint main(){\n    std::thread t1(foo);\n    std::thread t2(foo);\n    t1.join();\n    t2.join();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2、内存模型：\n\nC++11引入了内存模型，定义了多线程程序中的内存访问行为。这使得对静态局部变量的访问在多线程环境下更加可控。\n\nC++11引入的内存模型定义了一些术语，如"原子操作"、"memory order"等，允许程序员更精确地控制多线程环境中的内存访问。可以使用std::atomic类型来声明原子变量，确保它们的操作是线程安全的。\n\n#include <iostream>\n#include <thread>\n#include <atomic>\nstd::atomic<int> x(0);//使用std::atomic声明原子变量\nvoid foo() {\n    x.fetch_add(1,std::memory_order_relaxed);//使用原子操作\n}\nint main() {\n\tstd::thread t1(foo);\n    std::thread t2(foo);\n    t1.join();\n    t2.join();\n    std::cout << x.load(std::memory_order_relaxed) << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 在这个例子中，x是一个原子整数，可以被多个线程同时访问而不引发竞态条件或数据竞争。\n * foo函数通过x.fetch_add(1, std::memory_order_relaxed)来增加x的值，这个操作是原子的，不会被中断，因此多个线程可以同时执行它。\n * 主线程使用x.load(std::memory_order_relaxed)来加载x的值，并输出它。这个例子中使用的是std::memory_order_relaxed，它是一种内存顺序（memory order）选项，表示对x的操作可以是松散的，没有特定的内存顺序要求。这意味着编译器和硬件可以以不同的顺序执行操作，只要最终结果是正确的。\n\n\n# 7、静态局部变量的使用？\n\n静态局部变量是在函数内部定义的局部变量，但它与普通局部变量不同，它的生命周期在整个程序运行期间保持不变。这意味着它只会被初始化一次，并且在后续的函数调用中保持其值，直到程序终止。静态局部变量通常用关键字 static 来声明。\n\n\n# 初始化保护：\n\n静态局部变量的初始化仅在第一次进入包含它的函数时执行，后续的函数调用将跳过初始化过程。这使得静态局部变量适合用于一些需要在多次函数调用中保持状态的情况。\n\nint myFunction() {\n    static int count = 0;//静态局部变量，只在第一次调用时初始化\n    count++;\n    return count;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 作用域：\n\n静态局部变量的作用域限于包含它的函数。这意味着它只能在该函数内部访问，不能被其他函数直接访问。\n\n\n# 内存分配：\n\n静态局部变量通常存储在程序的全局数据区中，而不是堆栈中。因此，它们在程序启动时分配内存，并在程序终止时释放内存。\n\n\n# 线程安全性：\n\n静态局部变量的初始化是线程安全的。C++11以后的标准规定了这一点，确保只有一个线程在初始化时访问该变量。\n\n\n# 初始值：\n\n如果不明确初始化静态局部变量，它们将被自动初始化为零值（对于内置类型，如整数）或者空值（对于类类型，如指针或字符串）。\n\n\n# 保持状态：\n\n静态局部变量通常用于需要在多次函数调用之间保持状态的情况，如计数器、状态标志或缓存。\n\n#include <iostream>\nint myFunction(){\n    static int count = 0;//静态局部变量，旨在i第一次调用时初始化\n    count++;\n    return count;\n}\nint main(){\n    std::count << myFunction() << std::endl;//输出1\n    std::count << myFunction() << std::endl;//输出2\n    std::count << myFunction() << std::endl;//输出3\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 8、四种cast用在什么时候，dynamic什么时候用，不这么用返回值是什么？\n\n\n# static_cast\n\n * 用途：主要用于基本类型之间的转换，如将整数转换为浮点数，或者将指针或引用从一个类型转换为另一个相关类型。\n * 安全性：在编译时执行，较为安全。不进行运行时类型检查。\n\n示例：\n\nint i = 42;\ndouble d = static_cast<double>(i);//整数到浮点数的转换\n\n\n1\n2\n\n\n\n# dynamic_cast\n\n * 用途：用于在继承关系中进行安全的向下转型（向子类转换）。通常与多态一起使用，可在运行时检查对象的类型。\n\n * 安全性：在运行时执行，较为安全。如果无法进行安全的向下转型，返回空指针（对于指针）或引发std::bad_cast异常（对于引用）。\n\n示例：\n\nclass Base{\n    virtual void foo(){}\n};\nclass Derived : public Base {\n    void bar(){}\n};\nBase* basePtr = new Derived;\nDerived derivedPtr = dynamic_cast<Derived*>(basePtr);\nif(derivedPtr){\n    //安全的向下转型\n    derivedPtr->bar();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# const_cast\n\n * 用途：用于添加或去除const限定符。主要用于让常量变量变为非常量，或非常量变为常量。\n * 安全性：在编译时执行，较为安全。但要注意，滥用const_cast可能导致未定义行为。\n\n示例：\n\nconst int i = 42;\nint* nonConstPtr = const_cast<int*>(&i);//去除常量限定符\n\n\n1\n2\n\n\n\n# reinterpret_cast\n\n * 用途：进行低级别的类型转换，通常用于指针和整数之间的转换。不执行类型检查，可能导致未定义行为。\n * 安全性：不进行类型检查，非常危险，应慎用。\n\n示例：\n\nint i = 42;\nvoid* ptr = reinterpret_cast<void*>(&i);//指针到无关类型的转换\n\n\n1\n2\n\n\n注意事项：\n\n * dynamic_cast主要用于多态场景，只适用于具有虚函数的类，用于安全的向下转型。\n\n * 滥用强制类型转换可能导致程序错误，建议遵循类型安全和良好的设计原则，尽量减少类型转换的需求。\n\n\n# 9、Vector数组迭代器失效时机，如何使用迭代器删除vector，erase返回值？\n\n在C++中，std::vector的迭代器失效时机主要涉及到插入和删除操作。迭代器失效是指迭代器不再指向有效的元素或容器末尾，因此应该谨慎操作迭代器。\n\n 1. 插入元素：如果在std::vector中间插入元素，所有在插入点之后的迭代器都会失效，因为插入操作会导致元素的移动，改变容器的内存布局。\n 2. 删除元素：删除元素时，被删除元素之后的迭代器都会失效。如果使用erase函数删除元素，它会返回指向删除元素之后元素的迭代器。\n 3. 重新分配内存：当std::vector需要重新分配内存以容纳更多元素时，所有迭代器都会失效，因为元素的内存位置已经发生了变化。\n\n示例：如何使用erase来删除std::vector中的元素以及erase的返回值\n\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> numbers = {1,2,3,4,5};\n    //使用迭代器删除元素\n    std::vector<int>::iterator it = numbers.begin()+2;//指向元素3\n    it = numbers.erase(it);//删除元素3，it指向元素4\n    std::cout << "Element at iterator after erasing: " << *it << std::endl;\n    //使用返回值删除元素\n    it = numbers.begin() + 2;//指向元素4\n    std::vector<int>::iterator next_it = numbers.erase(it);//删除元素4，next_it指向元素5\n    std::cout << "Element at iterator after erasing: " << *next_it << std::endl;\n\n    for(int num : numbers){\n        std::cout << num << " ";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n为了避免迭代器失效，可以采取以下方法：\n\n 1. 使用索引而不是迭代器：如果可能的话，可以使用索引来访问std::vector的元素，因为索引不会受到插入和删除操作的影响。\n 2. 使用迭代器的稳定操作：C++11引入了一些迭代器操作，如std::vector::emplace，std::vector::emplace_back和std::vector::push_back的重载版本，它们可以用来插入元素而不使迭代器失效。\n\n如果需要在std::vector中删除元素，并且要在操作后获得指向下一个元素的有效迭代器，可以使用std::vector::erase函数。这个函数返回指向被删除元素之后元素的迭代器。\n\n\n# 10、Map数据结构，struct插入map需要注意什么\n\n在C++中，std::map是一个关联容器，用于存储键值对（key-value pairs），并按键的顺序进行排序。\n\n你要往std::map中插入struct对象时，需要注意以下几点：\n\n 1. 定义比较函数或比较运算符：std::map根据键来排序，因此需要确保你的struct类型有定义适当的比较函数或比较运算符（<），以便std::map可以根据键的值进行排序。\n 2. 保证键是唯一的：std::map要求键是唯一的，如果你插入的struct对象具有相同的键，后一个会覆盖前一个。\n 3. 插入操作：使用std::map的insert函数或[]运算符来插入struct对象。\n\n下面是一个示例，展示如何将自定义struct对象插入std::map：\n\n#include <iostream>\n#include <map>\nusing namespace std;\n//自定义结构体\nstruct Person{\n    string name;\n    int age;\n    //自定义比较函数，根据名称比较\n    bool operator<(const Person& other)const{\n        return name < other.name;\n    }\n};\nint main(){\n    map<Person,string>personMap;\n    //插入数据\n    Person person1 = {"Alice",25};\n    Person person2 = {"Bob",30};\n    personMap[person1] = "Entry 1";\n    personMap[person2] = "Entry 2";\n    \n    //遍历输出\n    for(const auto& entry : personMap){\n        cout << "Name: " << entry.first.name << ", Age: " << entry.first.age << ", Data: " << entry.second << endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 11、进程间通信？\n\n 1. 管道（Pipes）：\n    \n    1. 管道是一种单向通信机制，通常用于父子进程之间或者兄弟进程之间。\n    2. 在Unix/Linux中，可以使用pipe系统调用来创建管道。\n\n 2. 命名管道（Named Pipes或FIFO）：\n    \n    1. 命名管道是一种命名的管道，允许不相关的进程进行通信。\n    2. 在Unix/Linux中，可以使用mkfifo函数来创建命名管道。\n\n 3. 消息队列（Message Queues）：\n    \n    1. 消息队列是一种可以在进程之间传递数据的通信方式。\n    2. 在Unix/Linux中，可以使用msgget、msgsnd和msgrcv函数来操作消息队列。\n\n 4. 共享内存（Shared Memory）：\n    \n    1. 共享内存允许多个进程共享同一块物理内存，以便高效地交换数据。\n    \n    2. 在Unix/Linux中，可以使用shmget、shmat和shmdt函数来操作共享内存。\n       \n       > shmget：用于创建一个新的共享内存段或获取一个现有共享内存段的标识符。\n       > \n       > shmat：用于将共享内存段连接到当前进程的地址空间，以便访问共享内存中的数据。\n       > \n       > shmdt：用于将共享内存段从当前进程的地址空间中分离，使其不再可访问。\n       > \n       > shmctl：用于控制和管理共享内存段，如删除共享内存段等。\n\n 5. 信号（Signals）：\n    \n    1. 信号是一种轻量级的IPC方式，用于通知进程发生了某种事件。\n    2. 信号通常用于处理异步事件，如进程终止或错误发生。\n\n 6. 套接字（Sockets）：\n    \n    1. 套接字允许进程在不同的主机上通过网络通信。\n    2. 常见的套接字包括TCP套接字和UDP套接字。\n\n 7. 文件锁（File Locking）：\n    \n    1. 文件锁允许进程通过文件系统进行协同工作，确保数据的一致性。\n    2. 文件锁通常用于避免多个进程同时写入相同的文件。\n\n 8. 信号量（Semaphores）：\n    \n    1. 信号量是一种用于同步进程之间操作的IPC方式，通常用于解决竞争条件问题。\n    2. 在Unix/Linux中，可以使用semget、semop等函数来操作信号量。\n\n 9. RPC（远程过程调用）：\n    \n    1. RPC允许进程在不同的机器上调用远程的函数，使得远程调用看起来像本地函数调用。\n\n\n# 12、如何实现多次运行一个程序只有一个后台进程？\n\n要确保一个程序只有一个后台进程在运行，可以使用锁文件（Lock File）的方式来实现。锁文件是一个特殊的文件，用于表示某个进程是否已经在运行。\n\n举个例子：\n\n 1. 创建一个锁文件：在程序启动时，检查是否存在一个特定的锁文件。如果锁文件不存在，程序可以创建一个锁文件，并继续执行。如果锁文件已经存在，说明另一个实例正在运行，程序应该退出。\n 2. 运行程序：程序在创建锁文件后，继续执行正常的任务。\n 3. 删除锁文件：当程序完成任务后，应该删除锁文件，以允许将来的实例运行。\n\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <thread>\n#include <chrono>\n\nbool isAnotherInstanceRunning(){\n    //尝试打开锁文件\n    std::ifstream lockFile("myapp.lock");\n    if(lockFile.is_open()){\n        //锁文件存在，另一个实例正在运行\n        lockFile.close();\n        return true;\n    }\n    //锁文件不存在，当前实例可以运行\n    std::ofstream newLockFile("myapp.lock");\n    return false;\n}\nvoid removeLockFile(){\n    std::remove("myapp.lock");\n}\nint main(){\n    if(isAnotherInstanceRunning()){\n        std::cout << "Another instance is already running. Exiting." << std::endl;\n        return 1;\n    }\n    // 正常的应用逻辑\n    std::cout << "Running the application..." << std::endl;\n    // 模拟应用程序的工作\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n    // 删除锁文件，允许其他实例运行\n    removeLockFile();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n程序首先检查是否存在名为myapp.lock的锁文件。如果锁文件存在，程序会发出警告并退出。如果锁文件不存在，程序创建锁文件并执行其正常任务。在任务完成后，程序会删除锁文件，以允许将来的实例运行。\n\n\n# 13、Tcp三次握手为什么不是2次或者4次？\n\nTCP（传输控制协议）使用三次握手建立连接的原因是为了确保可靠性和防止旧的连接请求被误认为是新的连接请求。\n\n这三次握手的目的是：\n\n 1. 同步双方的序列号（Sequence Number）：在TCP连接建立期间，双方需要交换初始的序列号，以确保数据包按正确的顺序传递。三次握手允许双方同步他们的初始序列号。\n 2. 确保可靠连接：第三次握手是客户端向服务器发送一个确认，表示服务器已经知道客户端的初始序列号，这样确保了双方都知道对方已经准备好建立连接。\n 3. 防止旧连接的重新连接：假设连接的第三次握手被延迟，客户端可能认为连接失败并尝试重新连接。如果连接只采用两次握手，这个延迟的第三次握手可能被错误地解释为新连接的请求，从而导致连接混乱。\n\n下面是三次握手的详细步骤：\n\n 1. 客户端向服务器发送连接请求：客户端发送一个TCP数据包，其中包含SYN标志位，表示客户端希望建立连接。同时，客户端会选择一个随机的初始序列号。\n 2. 服务器接受连接请求并回应：服务器接受客户端的连接请求，并发送回一个TCP数据包，其中包含SYN和ACK标志位。服务器也会选择一个随机的初始序列号。\n 3. 客户端确认连接：客户端接受服务器的回应，发送一个带有ACK标志位的数据包，表示连接已建立。此时，客户端和服务器都知道了彼此的初始序列号，连接已经准备好使用。\n\n四次握手不是必需的，因为第四次握手在连接建立后通常没有必要。连接的终止通常需要四次挥手，因为双方都需要确认数据传输已经完成，然后才能安全地关闭连接。但在连接建立过程中，三次握手足以确保连接的可靠性和唯一性。\n\n\n# 14、二叉树最大深度？\n\n给定一个二叉树 root ，返回其最大深度。\n\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n\n\n# 思路：双栈法\n\n使用两个栈，一个用于存储节点，另一个用于存储节点的深度。我们从根节点开始，逐层遍历树的节点，同时记录每个节点的深度。最终，返回最大深度作为结果。这种方法避免了递归，减小了函数调用栈的开销。\n\n#include <iostream>\n#include <stack>\n//定义二叉树节点\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x):val(x),left(nullptr),right(nullptr){}\n};\nclass Solution{\n    public:\n    int maxDepth(TreeNode *root){\n        if(root == nullptr) {\n            return 0;//如果根节点为空，返回深度0\n        } \n        //使用DFS进行深度搜索\n        std::stack<TreeNode*> nodes;\n        std::stack<int> depths;\n        int max = 0;\n        nodes.push(root);\n        depths.push(1);//根节点的深度为1\n        while(!nodes.empty()){\n            TreeNode* node = nodes.top();\n            nodes.pop();\n            int depth = depths.top();\n            depths.pop();\n            max = std::max(max,depth);//更新最大深度\n            //遍历左子树\n            if(node->left){\n                nodes.push(node->left);\n                depths.push(depth+1);//左子树深度加1\n            }\n            //遍历右子树\n            if(node->right){\n                nodes.push(node->right);\n                depths.push(depth+1);//右子树深度加1\n            }\n        }\n        return max;//返回最大深度\n    }\n};\n\nint main(){\n    //创建一个二叉树\n    TreeNode* root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n    root->left->left = new TreeNode(4);\n    root->left->right = new TreeNode(5);\n\n    //创建Solution对象\n    Solution solution;\n    //计算二叉树的最大深度\n    int depth = solution.maxDepth(root);\n    std::cout << "二叉树的最大深度为：" << depth << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 思路：递归\n\n 1. 如果二叉树为空（即根节点为空），则深度为0。\n 2. 否则，分别计算左子树和右子树的最大深度。\n 3. 最大深度为左子树的最大深度和右子树的最大深度的较大值加1。\n 4. 递归地应用这个规则，直到到达叶子节点。\n\n这个算法通过递归遍历整棵树，每次调用递归函数时，都将问题缩小到子树上，最终得出树的最大深度。这是一种自顶向下的方法，它从根节点开始，逐层深入树的结构。\n\n#include <iostream>\n// 二叉树的节点定义\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x):val(x),left(nullptr),right(nullptr){}\n};\n\nint maxDepth(TreeNode* root) {\n    // 如果树为空，深度为0\n    if (root == nullptr) {\n        return 0;\n    }\n    // 递归计算左子树和右子树的深度\n    int leftDepth = maxDepth(root->left);\n    int rightDepth = maxDepth(root->right);\n    // 返回左子树和右子树深度的较大值加1\n    return std::max(leftDepth, rightDepth) + 1;\n}\n\nint main() {\n    // 创建一个示例二叉树\n    TreeNode* root    = new TreeNode(1);\n    root->left \t\t  = new TreeNode(2);\n    root->right \t  = new TreeNode(3);\n    root->left->left  = new TreeNode(4);\n    root->left->right = new TreeNode(5);\n    // 计算最大深度\n    int depth = maxDepth(root);\n    std::cout << "二叉树的最大深度为: " << depth << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 15、反转链表？\n\n思路：\n\n 1. 创建两个指针，prev（前一个节点）和current（当前节点），并初始化为nullptr和链表的头节点，即head。\n 2. 使用一个while循环来迭代整个链表，循环条件是current不为nullptr。在每一次迭代中：\n    1. 保存current的下一个节点为next，以免在反转指针后丢失对后续节点的引用。\n    2. 将current的next指针指向prev，从而反转当前节点。\n    3. 更新prev为current，将current前进到下一个节点，即next。\n 3. 当循环结束时，prev将指向反转后链表的头节点，而current将为nullptr。\n 4. 返回prev，作为新链表的头节点。\n\n#include <iostream>\n//定义链表节点结构\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x):val(x),next(nullptr){}\n};\nclass Solution{\npublic:\n    ListNode* reverseList(ListNode* head){\n        ListNode* prev = nullptr;//前一个节点初始化为nullptr\n        ListNode* current = head;//当前节点从链表头开始\n        while(current){\n            ListNode* next = current->next;//保存下一个节点\n            current->next = prev;//当前节点指向前一个节点完成反转\n            prev = current;//更新前一个节点位当前节点\n            current = next;//当前节点指向下一个节点，继续迭代\n        }\n        return prev;//prev最终指向新链表的头节点\n    }\n};\nint main(){\n    //创建一个链表：1-》2-》3-》4-》5\n    ListNode* head = new ListNode(1);\n    head->next = new ListNode(2);\n    head->next->next = new ListNode(3);\n    head->next->next->next = new ListNode(4);\n    head->next->next->next->next = new ListNode(5);\n    \n    //创建Solution对象\n    Solution solution;\n    //反转链表\n    ListNode* reversedHead = solution.reverseList(head);\n    //打印反转后的链表\n    ListNode* current = reversedHead;\n    while(current){\n        std::cout << current->val << " -> ";\n        current = current->next;\n    }\n    std::cout << "nullptr" << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n参考文章\n\nhttps://mp.weixin.qq.com/s/6B5wKMy2vBW9RfomiEFeqQ',normalizedContent:'# 金山一面复习\n\n> 时间：2023.11.7\n\n\n# 1、静态变量生命周期和普通变量比较？\n\n 1. 生命周期：\n    1. 普通变量（自动变量）：自动变量的生命周期与其所在的代码块（作用域）相关。它们在离开其定义的作用域时被销毁，通常是栈上分配的。\n    2. 静态变量（静态存储期变量）：静态变量的生命周期在整个程序运行期间，它们在程序启动时分配内存，在程序结束时才会被释放。静态变量可以存储在全局存储区或静态存储区。\n 2. 作用域：\n    1. 普通变量：普通变量的作用域通常仅限于定义它们的代码块，它们不能被其他代码块访问。\n    2. 静态变量：静态变量可以具有更广泛的作用域，例如，如果它们在全局范围内声明，它们可以被整个程序访问。\n 3. 初始化：\n    1. 普通变量：普通变量在声明时不会自动初始化，除非显式赋初值。\n    2. 静态变量：静态变量在定义时如果不显式初始化，会自动初始化为零（对于基本数据类型）或空（对于类对象）。\n 4. 存储位置：\n    1. 普通变量：普通变量通常分配在栈上，每次函数调用时都会创建新的实例。\n    2. 静态变量：静态变量可以存储在全局存储区或静态存储区。全局变量在程序启动时初始化，它们的值在程序的整个生命周期内都可用。\n\n\n# 2、什么时候创建虚函数表？\n\n\n# 虚函数的定义：\n\n虚函数是通过在基类中声明的。虚函数的定义包括返回类型、函数名和参数列表。\n\nclass base {\n    public:\n    virtual void foo() { /* base class implementation */}\n};\n\n\n1\n2\n3\n4\n\n\n\n# 派生类中的重写：\n\n派生类可以重写虚函数，这意味着它可以提供自己的实现版本。在派生类中重新定义虚函数时，需要使用 virtual 关键字来保持虚函数性质。\n\nclass derived : public base {\n    public:\n    virtual void foo() override {/* derived class implementation */}\n};\n\n\n1\n2\n3\n4\n\n\n\n# 虚函数表的创建：\n\n虚函数表在编译时由c++编译器自动生成。对于每个具有虚函数的类，编译器会生成一个虚函数表，其中包含了该类的虚函数指针。这个虚函数表通常位于类的内部，它是静态的，一旦创建就不会更改。\n\n\n# 虚函数表的指针：\n\n对于每个包含虚函数的类，编译器会在类的内部添加一个指向虚函数表的指针，通常位于对象的内存布局的最前面。这个指针被称为虚函数表指针（vptr）。\n\n\n# 运行时动态绑定：\n\n当你通过基类指针或引用调用虚函数时，实际执行的是派生类中的版本（如果派生类重新定义了虚函数）。这是因为虚函数表指针（vptr）指向了正确的虚函数表，允许在运行时根据对象的类型进行动态绑定。\n\nbase *ptr = new derived;\nptr->foo();//调用derived类中的foo()\n\n\n1\n2\n\n\n\n# 3、虚函数指针会不会变，什么时候初始化，在析构里会不会变，析构函数能访问虚函数吗？\n\n\n# 初始化时创建：\n\n虚函数表指针在对象创建时就被初始化。当你创建一个类的实例（对象）时，其中包括一个指向该类虚函数表的虚函数表指针。这个指针是在对象构造过程中初始化的。\n\n\n# 不会在析构函数中改变：\n\n虚函数表指针通常在对象的整个生命周期内保持不变。这意味着即使在对象的析构函数中，虚函数表指针也不会改变。析构函数是用于对象销毁的，不负责改变虚函数表指针。\n\n\n# 虚函数的调用：\n\n虚函数表指针的主要作用是支持运行时多态性。通过这个指针，程序可以在运行时查找并调用正确的虚函数版本。在析构函数中，你可以调用虚函数，但需要注意的是析构函数本身不会改变虚函数表指针。在析构函数中调用虚函数时，通常执行的是对象的类型，而不是基类的类型。\n\n\n# 注意虚函数表指针变化的情况：\n\n在一些特殊情况下，虚函数表指针可能会变化。例如，当一个对象通过复制构造函数复制时，复制的对象将有自己的虚函数表指针。这通常发生在基类和派生类之间的复制。另外，如果你使用虚继承，虚函数表指针也可能会更改。\n\n\n# 4、静态函数可以访问非静态成员变量吗为什么？\n\n静态成员函数（静态方法）可以访问非静态成员变量。\n\n 1. 静态函数（静态成员函数）：静态函数是与类关联，而不是与类的实例（对象）关联的函数。这意味着它不依赖于特定的对象，可以通过类名直接调用。静态函数通常用于执行与类本身相关的操作，而不涉及特定对象的状态。\n 2. 非静态成员变量：非静态成员变量是与类的实例（对象）关联的变量。每个类的对象都有其自己的一组非静态成员变量，它们可以存储对象特定的状态信息。\n\n现在来看静态函数访问非静态成员变量的情况：\n\n * 可以访问静态成员变量：静态函数可以自由地访问同一类的静态成员变量，因为这些成员变量与类相关，而不是与对象相关。在静态函数中，你可以使用类名或this指针（在类的范围内）来访问静态成员变量。\n * 不能直接访问非静态成员变量：静态函数不能直接访问特定对象的非静态成员变量。这是因为静态函数没有"this"指针，它不知道它应该关联到哪个对象的非静态成员变量。\n * 需要对象实例：如果静态函数需要访问特定对象的非静态成员变量，它必须通过传递对象实例作为参数或在函数内部创建对象实例，然后使用该对象实例来访问非静态成员变量。\n\n示例：\n\nclass myclass {\n    public:\n    int nonstaticvar;//非静态成员变量\n    static void staticfunction(myclass& obj) {\n        obj.nonstaticvar = 42;//通过对象实例访问非静态成员变量\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5、编译实现重载？\n\n**函数重载（function overloading）是一种允许你定义多个同名函数，但它们具有不同的参数列表的机制。**编译器会根据不同的参数列表来决定调用哪个重载函数。函数重载使你能够使用相同的函数名来处理不同类型的数据或不同数量的参数，从而提高了代码的可读性和复用性。\n\n 1. 函数名称相同：在函数重载中，你可以定义多个具有相同名称的函数，但它们的参数列表不同。\n 2. 参数列表不同：参数列表包括参数的数量、参数的类型、参数的顺序等。至少需要有一个方面在参数列表中不同，否则编译器将无法区分这些函数。\n 3. 返回类型不同：重载函数的返回类型可以不同，但它通常不是编译器用于函数重载决策的关键因素。编译器主要关注参数列表。\n 4. 与函数调用相关：编译器会根据函数调用时提供的参数来决定调用哪个重载函数。\n\n#include <iostream>\nvoid print(int value) {\n\tstd::cout << "printing integer: " << value << std::endl;\n}\nvoid print(double value) {\n\tstd::cout << "printing double: " << value << std::endl;\n}\n\nint main() {\n    int intvar = 42;\n    double doublevar = 3.14159;\n    print(intvar);\t //调用第一个重载函数\n    print(doublevar);//调用第二个重载函数\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 6、静态变量新特性保证原子性？\n\n\n# 1、初始化保护：\n\nc++11规定了静态局部变量的初始化必须是线程安全的。这意味着在多线程环境中，多个线程第一次进入函数并尝试初始化同一个静态局部变量时，只有一个线程会执行初始化，其他线程会等待。这种机制确保了静态局部变量的初始化是线程安全的。\n\n#include <iostream>\n#include <thread>\nvoid foo(){\n    static int x = 0;//c++11以后的标准保证x的初始化是线程安全的\n    std::cout << x++ << std::endl;\n}\nint main(){\n    std::thread t1(foo);\n    std::thread t2(foo);\n    t1.join();\n    t2.join();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2、内存模型：\n\nc++11引入了内存模型，定义了多线程程序中的内存访问行为。这使得对静态局部变量的访问在多线程环境下更加可控。\n\nc++11引入的内存模型定义了一些术语，如"原子操作"、"memory order"等，允许程序员更精确地控制多线程环境中的内存访问。可以使用std::atomic类型来声明原子变量，确保它们的操作是线程安全的。\n\n#include <iostream>\n#include <thread>\n#include <atomic>\nstd::atomic<int> x(0);//使用std::atomic声明原子变量\nvoid foo() {\n    x.fetch_add(1,std::memory_order_relaxed);//使用原子操作\n}\nint main() {\n\tstd::thread t1(foo);\n    std::thread t2(foo);\n    t1.join();\n    t2.join();\n    std::cout << x.load(std::memory_order_relaxed) << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 在这个例子中，x是一个原子整数，可以被多个线程同时访问而不引发竞态条件或数据竞争。\n * foo函数通过x.fetch_add(1, std::memory_order_relaxed)来增加x的值，这个操作是原子的，不会被中断，因此多个线程可以同时执行它。\n * 主线程使用x.load(std::memory_order_relaxed)来加载x的值，并输出它。这个例子中使用的是std::memory_order_relaxed，它是一种内存顺序（memory order）选项，表示对x的操作可以是松散的，没有特定的内存顺序要求。这意味着编译器和硬件可以以不同的顺序执行操作，只要最终结果是正确的。\n\n\n# 7、静态局部变量的使用？\n\n静态局部变量是在函数内部定义的局部变量，但它与普通局部变量不同，它的生命周期在整个程序运行期间保持不变。这意味着它只会被初始化一次，并且在后续的函数调用中保持其值，直到程序终止。静态局部变量通常用关键字 static 来声明。\n\n\n# 初始化保护：\n\n静态局部变量的初始化仅在第一次进入包含它的函数时执行，后续的函数调用将跳过初始化过程。这使得静态局部变量适合用于一些需要在多次函数调用中保持状态的情况。\n\nint myfunction() {\n    static int count = 0;//静态局部变量，只在第一次调用时初始化\n    count++;\n    return count;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 作用域：\n\n静态局部变量的作用域限于包含它的函数。这意味着它只能在该函数内部访问，不能被其他函数直接访问。\n\n\n# 内存分配：\n\n静态局部变量通常存储在程序的全局数据区中，而不是堆栈中。因此，它们在程序启动时分配内存，并在程序终止时释放内存。\n\n\n# 线程安全性：\n\n静态局部变量的初始化是线程安全的。c++11以后的标准规定了这一点，确保只有一个线程在初始化时访问该变量。\n\n\n# 初始值：\n\n如果不明确初始化静态局部变量，它们将被自动初始化为零值（对于内置类型，如整数）或者空值（对于类类型，如指针或字符串）。\n\n\n# 保持状态：\n\n静态局部变量通常用于需要在多次函数调用之间保持状态的情况，如计数器、状态标志或缓存。\n\n#include <iostream>\nint myfunction(){\n    static int count = 0;//静态局部变量，旨在i第一次调用时初始化\n    count++;\n    return count;\n}\nint main(){\n    std::count << myfunction() << std::endl;//输出1\n    std::count << myfunction() << std::endl;//输出2\n    std::count << myfunction() << std::endl;//输出3\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 8、四种cast用在什么时候，dynamic什么时候用，不这么用返回值是什么？\n\n\n# static_cast\n\n * 用途：主要用于基本类型之间的转换，如将整数转换为浮点数，或者将指针或引用从一个类型转换为另一个相关类型。\n * 安全性：在编译时执行，较为安全。不进行运行时类型检查。\n\n示例：\n\nint i = 42;\ndouble d = static_cast<double>(i);//整数到浮点数的转换\n\n\n1\n2\n\n\n\n# dynamic_cast\n\n * 用途：用于在继承关系中进行安全的向下转型（向子类转换）。通常与多态一起使用，可在运行时检查对象的类型。\n\n * 安全性：在运行时执行，较为安全。如果无法进行安全的向下转型，返回空指针（对于指针）或引发std::bad_cast异常（对于引用）。\n\n示例：\n\nclass base{\n    virtual void foo(){}\n};\nclass derived : public base {\n    void bar(){}\n};\nbase* baseptr = new derived;\nderived derivedptr = dynamic_cast<derived*>(baseptr);\nif(derivedptr){\n    //安全的向下转型\n    derivedptr->bar();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# const_cast\n\n * 用途：用于添加或去除const限定符。主要用于让常量变量变为非常量，或非常量变为常量。\n * 安全性：在编译时执行，较为安全。但要注意，滥用const_cast可能导致未定义行为。\n\n示例：\n\nconst int i = 42;\nint* nonconstptr = const_cast<int*>(&i);//去除常量限定符\n\n\n1\n2\n\n\n\n# reinterpret_cast\n\n * 用途：进行低级别的类型转换，通常用于指针和整数之间的转换。不执行类型检查，可能导致未定义行为。\n * 安全性：不进行类型检查，非常危险，应慎用。\n\n示例：\n\nint i = 42;\nvoid* ptr = reinterpret_cast<void*>(&i);//指针到无关类型的转换\n\n\n1\n2\n\n\n注意事项：\n\n * dynamic_cast主要用于多态场景，只适用于具有虚函数的类，用于安全的向下转型。\n\n * 滥用强制类型转换可能导致程序错误，建议遵循类型安全和良好的设计原则，尽量减少类型转换的需求。\n\n\n# 9、vector数组迭代器失效时机，如何使用迭代器删除vector，erase返回值？\n\n在c++中，std::vector的迭代器失效时机主要涉及到插入和删除操作。迭代器失效是指迭代器不再指向有效的元素或容器末尾，因此应该谨慎操作迭代器。\n\n 1. 插入元素：如果在std::vector中间插入元素，所有在插入点之后的迭代器都会失效，因为插入操作会导致元素的移动，改变容器的内存布局。\n 2. 删除元素：删除元素时，被删除元素之后的迭代器都会失效。如果使用erase函数删除元素，它会返回指向删除元素之后元素的迭代器。\n 3. 重新分配内存：当std::vector需要重新分配内存以容纳更多元素时，所有迭代器都会失效，因为元素的内存位置已经发生了变化。\n\n示例：如何使用erase来删除std::vector中的元素以及erase的返回值\n\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> numbers = {1,2,3,4,5};\n    //使用迭代器删除元素\n    std::vector<int>::iterator it = numbers.begin()+2;//指向元素3\n    it = numbers.erase(it);//删除元素3，it指向元素4\n    std::cout << "element at iterator after erasing: " << *it << std::endl;\n    //使用返回值删除元素\n    it = numbers.begin() + 2;//指向元素4\n    std::vector<int>::iterator next_it = numbers.erase(it);//删除元素4，next_it指向元素5\n    std::cout << "element at iterator after erasing: " << *next_it << std::endl;\n\n    for(int num : numbers){\n        std::cout << num << " ";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n为了避免迭代器失效，可以采取以下方法：\n\n 1. 使用索引而不是迭代器：如果可能的话，可以使用索引来访问std::vector的元素，因为索引不会受到插入和删除操作的影响。\n 2. 使用迭代器的稳定操作：c++11引入了一些迭代器操作，如std::vector::emplace，std::vector::emplace_back和std::vector::push_back的重载版本，它们可以用来插入元素而不使迭代器失效。\n\n如果需要在std::vector中删除元素，并且要在操作后获得指向下一个元素的有效迭代器，可以使用std::vector::erase函数。这个函数返回指向被删除元素之后元素的迭代器。\n\n\n# 10、map数据结构，struct插入map需要注意什么\n\n在c++中，std::map是一个关联容器，用于存储键值对（key-value pairs），并按键的顺序进行排序。\n\n你要往std::map中插入struct对象时，需要注意以下几点：\n\n 1. 定义比较函数或比较运算符：std::map根据键来排序，因此需要确保你的struct类型有定义适当的比较函数或比较运算符（<），以便std::map可以根据键的值进行排序。\n 2. 保证键是唯一的：std::map要求键是唯一的，如果你插入的struct对象具有相同的键，后一个会覆盖前一个。\n 3. 插入操作：使用std::map的insert函数或[]运算符来插入struct对象。\n\n下面是一个示例，展示如何将自定义struct对象插入std::map：\n\n#include <iostream>\n#include <map>\nusing namespace std;\n//自定义结构体\nstruct person{\n    string name;\n    int age;\n    //自定义比较函数，根据名称比较\n    bool operator<(const person& other)const{\n        return name < other.name;\n    }\n};\nint main(){\n    map<person,string>personmap;\n    //插入数据\n    person person1 = {"alice",25};\n    person person2 = {"bob",30};\n    personmap[person1] = "entry 1";\n    personmap[person2] = "entry 2";\n    \n    //遍历输出\n    for(const auto& entry : personmap){\n        cout << "name: " << entry.first.name << ", age: " << entry.first.age << ", data: " << entry.second << endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 11、进程间通信？\n\n 1. 管道（pipes）：\n    \n    1. 管道是一种单向通信机制，通常用于父子进程之间或者兄弟进程之间。\n    2. 在unix/linux中，可以使用pipe系统调用来创建管道。\n\n 2. 命名管道（named pipes或fifo）：\n    \n    1. 命名管道是一种命名的管道，允许不相关的进程进行通信。\n    2. 在unix/linux中，可以使用mkfifo函数来创建命名管道。\n\n 3. 消息队列（message queues）：\n    \n    1. 消息队列是一种可以在进程之间传递数据的通信方式。\n    2. 在unix/linux中，可以使用msgget、msgsnd和msgrcv函数来操作消息队列。\n\n 4. 共享内存（shared memory）：\n    \n    1. 共享内存允许多个进程共享同一块物理内存，以便高效地交换数据。\n    \n    2. 在unix/linux中，可以使用shmget、shmat和shmdt函数来操作共享内存。\n       \n       > shmget：用于创建一个新的共享内存段或获取一个现有共享内存段的标识符。\n       > \n       > shmat：用于将共享内存段连接到当前进程的地址空间，以便访问共享内存中的数据。\n       > \n       > shmdt：用于将共享内存段从当前进程的地址空间中分离，使其不再可访问。\n       > \n       > shmctl：用于控制和管理共享内存段，如删除共享内存段等。\n\n 5. 信号（signals）：\n    \n    1. 信号是一种轻量级的ipc方式，用于通知进程发生了某种事件。\n    2. 信号通常用于处理异步事件，如进程终止或错误发生。\n\n 6. 套接字（sockets）：\n    \n    1. 套接字允许进程在不同的主机上通过网络通信。\n    2. 常见的套接字包括tcp套接字和udp套接字。\n\n 7. 文件锁（file locking）：\n    \n    1. 文件锁允许进程通过文件系统进行协同工作，确保数据的一致性。\n    2. 文件锁通常用于避免多个进程同时写入相同的文件。\n\n 8. 信号量（semaphores）：\n    \n    1. 信号量是一种用于同步进程之间操作的ipc方式，通常用于解决竞争条件问题。\n    2. 在unix/linux中，可以使用semget、semop等函数来操作信号量。\n\n 9. rpc（远程过程调用）：\n    \n    1. rpc允许进程在不同的机器上调用远程的函数，使得远程调用看起来像本地函数调用。\n\n\n# 12、如何实现多次运行一个程序只有一个后台进程？\n\n要确保一个程序只有一个后台进程在运行，可以使用锁文件（lock file）的方式来实现。锁文件是一个特殊的文件，用于表示某个进程是否已经在运行。\n\n举个例子：\n\n 1. 创建一个锁文件：在程序启动时，检查是否存在一个特定的锁文件。如果锁文件不存在，程序可以创建一个锁文件，并继续执行。如果锁文件已经存在，说明另一个实例正在运行，程序应该退出。\n 2. 运行程序：程序在创建锁文件后，继续执行正常的任务。\n 3. 删除锁文件：当程序完成任务后，应该删除锁文件，以允许将来的实例运行。\n\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <thread>\n#include <chrono>\n\nbool isanotherinstancerunning(){\n    //尝试打开锁文件\n    std::ifstream lockfile("myapp.lock");\n    if(lockfile.is_open()){\n        //锁文件存在，另一个实例正在运行\n        lockfile.close();\n        return true;\n    }\n    //锁文件不存在，当前实例可以运行\n    std::ofstream newlockfile("myapp.lock");\n    return false;\n}\nvoid removelockfile(){\n    std::remove("myapp.lock");\n}\nint main(){\n    if(isanotherinstancerunning()){\n        std::cout << "another instance is already running. exiting." << std::endl;\n        return 1;\n    }\n    // 正常的应用逻辑\n    std::cout << "running the application..." << std::endl;\n    // 模拟应用程序的工作\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n    // 删除锁文件，允许其他实例运行\n    removelockfile();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n程序首先检查是否存在名为myapp.lock的锁文件。如果锁文件存在，程序会发出警告并退出。如果锁文件不存在，程序创建锁文件并执行其正常任务。在任务完成后，程序会删除锁文件，以允许将来的实例运行。\n\n\n# 13、tcp三次握手为什么不是2次或者4次？\n\ntcp（传输控制协议）使用三次握手建立连接的原因是为了确保可靠性和防止旧的连接请求被误认为是新的连接请求。\n\n这三次握手的目的是：\n\n 1. 同步双方的序列号（sequence number）：在tcp连接建立期间，双方需要交换初始的序列号，以确保数据包按正确的顺序传递。三次握手允许双方同步他们的初始序列号。\n 2. 确保可靠连接：第三次握手是客户端向服务器发送一个确认，表示服务器已经知道客户端的初始序列号，这样确保了双方都知道对方已经准备好建立连接。\n 3. 防止旧连接的重新连接：假设连接的第三次握手被延迟，客户端可能认为连接失败并尝试重新连接。如果连接只采用两次握手，这个延迟的第三次握手可能被错误地解释为新连接的请求，从而导致连接混乱。\n\n下面是三次握手的详细步骤：\n\n 1. 客户端向服务器发送连接请求：客户端发送一个tcp数据包，其中包含syn标志位，表示客户端希望建立连接。同时，客户端会选择一个随机的初始序列号。\n 2. 服务器接受连接请求并回应：服务器接受客户端的连接请求，并发送回一个tcp数据包，其中包含syn和ack标志位。服务器也会选择一个随机的初始序列号。\n 3. 客户端确认连接：客户端接受服务器的回应，发送一个带有ack标志位的数据包，表示连接已建立。此时，客户端和服务器都知道了彼此的初始序列号，连接已经准备好使用。\n\n四次握手不是必需的，因为第四次握手在连接建立后通常没有必要。连接的终止通常需要四次挥手，因为双方都需要确认数据传输已经完成，然后才能安全地关闭连接。但在连接建立过程中，三次握手足以确保连接的可靠性和唯一性。\n\n\n# 14、二叉树最大深度？\n\n给定一个二叉树 root ，返回其最大深度。\n\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n\n\n# 思路：双栈法\n\n使用两个栈，一个用于存储节点，另一个用于存储节点的深度。我们从根节点开始，逐层遍历树的节点，同时记录每个节点的深度。最终，返回最大深度作为结果。这种方法避免了递归，减小了函数调用栈的开销。\n\n#include <iostream>\n#include <stack>\n//定义二叉树节点\nstruct treenode {\n    int val;\n    treenode *left;\n    treenode *right;\n    treenode(int x):val(x),left(nullptr),right(nullptr){}\n};\nclass solution{\n    public:\n    int maxdepth(treenode *root){\n        if(root == nullptr) {\n            return 0;//如果根节点为空，返回深度0\n        } \n        //使用dfs进行深度搜索\n        std::stack<treenode*> nodes;\n        std::stack<int> depths;\n        int max = 0;\n        nodes.push(root);\n        depths.push(1);//根节点的深度为1\n        while(!nodes.empty()){\n            treenode* node = nodes.top();\n            nodes.pop();\n            int depth = depths.top();\n            depths.pop();\n            max = std::max(max,depth);//更新最大深度\n            //遍历左子树\n            if(node->left){\n                nodes.push(node->left);\n                depths.push(depth+1);//左子树深度加1\n            }\n            //遍历右子树\n            if(node->right){\n                nodes.push(node->right);\n                depths.push(depth+1);//右子树深度加1\n            }\n        }\n        return max;//返回最大深度\n    }\n};\n\nint main(){\n    //创建一个二叉树\n    treenode* root = new treenode(1);\n    root->left = new treenode(2);\n    root->right = new treenode(3);\n    root->left->left = new treenode(4);\n    root->left->right = new treenode(5);\n\n    //创建solution对象\n    solution solution;\n    //计算二叉树的最大深度\n    int depth = solution.maxdepth(root);\n    std::cout << "二叉树的最大深度为：" << depth << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 思路：递归\n\n 1. 如果二叉树为空（即根节点为空），则深度为0。\n 2. 否则，分别计算左子树和右子树的最大深度。\n 3. 最大深度为左子树的最大深度和右子树的最大深度的较大值加1。\n 4. 递归地应用这个规则，直到到达叶子节点。\n\n这个算法通过递归遍历整棵树，每次调用递归函数时，都将问题缩小到子树上，最终得出树的最大深度。这是一种自顶向下的方法，它从根节点开始，逐层深入树的结构。\n\n#include <iostream>\n// 二叉树的节点定义\nstruct treenode {\n    int val;\n    treenode* left;\n    treenode* right;\n    treenode(int x):val(x),left(nullptr),right(nullptr){}\n};\n\nint maxdepth(treenode* root) {\n    // 如果树为空，深度为0\n    if (root == nullptr) {\n        return 0;\n    }\n    // 递归计算左子树和右子树的深度\n    int leftdepth = maxdepth(root->left);\n    int rightdepth = maxdepth(root->right);\n    // 返回左子树和右子树深度的较大值加1\n    return std::max(leftdepth, rightdepth) + 1;\n}\n\nint main() {\n    // 创建一个示例二叉树\n    treenode* root    = new treenode(1);\n    root->left \t\t  = new treenode(2);\n    root->right \t  = new treenode(3);\n    root->left->left  = new treenode(4);\n    root->left->right = new treenode(5);\n    // 计算最大深度\n    int depth = maxdepth(root);\n    std::cout << "二叉树的最大深度为: " << depth << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 15、反转链表？\n\n思路：\n\n 1. 创建两个指针，prev（前一个节点）和current（当前节点），并初始化为nullptr和链表的头节点，即head。\n 2. 使用一个while循环来迭代整个链表，循环条件是current不为nullptr。在每一次迭代中：\n    1. 保存current的下一个节点为next，以免在反转指针后丢失对后续节点的引用。\n    2. 将current的next指针指向prev，从而反转当前节点。\n    3. 更新prev为current，将current前进到下一个节点，即next。\n 3. 当循环结束时，prev将指向反转后链表的头节点，而current将为nullptr。\n 4. 返回prev，作为新链表的头节点。\n\n#include <iostream>\n//定义链表节点结构\nstruct listnode {\n    int val;\n    listnode* next;\n    listnode(int x):val(x),next(nullptr){}\n};\nclass solution{\npublic:\n    listnode* reverselist(listnode* head){\n        listnode* prev = nullptr;//前一个节点初始化为nullptr\n        listnode* current = head;//当前节点从链表头开始\n        while(current){\n            listnode* next = current->next;//保存下一个节点\n            current->next = prev;//当前节点指向前一个节点完成反转\n            prev = current;//更新前一个节点位当前节点\n            current = next;//当前节点指向下一个节点，继续迭代\n        }\n        return prev;//prev最终指向新链表的头节点\n    }\n};\nint main(){\n    //创建一个链表：1-》2-》3-》4-》5\n    listnode* head = new listnode(1);\n    head->next = new listnode(2);\n    head->next->next = new listnode(3);\n    head->next->next->next = new listnode(4);\n    head->next->next->next->next = new listnode(5);\n    \n    //创建solution对象\n    solution solution;\n    //反转链表\n    listnode* reversedhead = solution.reverselist(head);\n    //打印反转后的链表\n    listnode* current = reversedhead;\n    while(current){\n        std::cout << current->val << " -> ";\n        current = current->next;\n    }\n    std::cout << "nullptr" << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n参考文章\n\nhttps://mp.weixin.qq.com/s/6b5wkmy2vbw9rfomiefeqq',charsets:{cjk:!0}},{title:"博客搭建",frontmatter:{title:"博客搭建",date:"2023-05-11T10:14:53.000Z",permalink:"/pages/fa256e/"},regularPath:"/20.%E7%A2%8E%E7%89%87%E6%96%87%E7%AB%A0/01.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html",relativePath:"20.碎片文章/01.博客搭建.md",key:"v-265da4ce",path:"/pages/fa256e/",headers:[{level:2,title:"一、主题介绍",slug:"一、主题介绍",normalizedTitle:"一、主题介绍",charIndex:11},{level:2,title:"二、模板套用",slug:"二、模板套用",normalizedTitle:"二、模板套用",charIndex:87},{level:2,title:"三、目录结构介绍",slug:"三、目录结构介绍",normalizedTitle:"三、目录结构介绍",charIndex:216},{level:2,title:"四、目录结构示例",slug:"四、目录结构示例",normalizedTitle:"四、目录结构示例",charIndex:887},{level:2,title:"五、部署到 github Pages",slug:"五、部署到-github-pages",normalizedTitle:"五、部署到 github pages",charIndex:1868},{level:3,title:"主要步骤",slug:"主要步骤",normalizedTitle:"主要步骤",charIndex:1891},{level:3,title:"要注意的点",slug:"要注意的点",normalizedTitle:"要注意的点",charIndex:2232},{level:3,title:"问题小结",slug:"问题小结",normalizedTitle:"问题小结",charIndex:2538},{level:2,title:"六、部署命令脚本",slug:"六、部署命令脚本",normalizedTitle:"六、部署命令脚本",charIndex:2883},{level:3,title:"运行方法：",slug:"运行方法",normalizedTitle:"运行方法：",charIndex:3738},{level:2,title:"七、场景小结",slug:"七、场景小结",normalizedTitle:"七、场景小结",charIndex:3804},{level:3,title:"1、嵌入图片",slug:"_1、嵌入图片",normalizedTitle:"1、嵌入图片",charIndex:3815},{level:3,title:"2、md 文档规范",slug:"_2、md-文档规范",normalizedTitle:"2、md 文档规范",charIndex:3995},{level:3,title:"3、插件资源",slug:"_3、插件资源",normalizedTitle:"3、插件资源",charIndex:4142},{level:3,title:"4、网站上的小 logo 设置",slug:"_4、网站上的小-logo-设置",normalizedTitle:"4、网站上的小 logo 设置",charIndex:4161},{level:3,title:"5、图床搭建",slug:"_5、图床搭建",normalizedTitle:"5、图床搭建",charIndex:4316}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"3 min read",minutes:2.45,time:147e3,words:490},headersStr:"一、主题介绍 二、模板套用 三、目录结构介绍 四、目录结构示例 五、部署到 github Pages 主要步骤 要注意的点 问题小结 六、部署命令脚本 运行方法： 七、场景小结 1、嵌入图片 2、md 文档规范 3、插件资源 4、网站上的小 logo 设置 5、图床搭建",content:"# 搭建流程\n\n\n# 一、主题介绍\n\n本博客使用的主题为：vuepress-theme-vdoing，相关介绍和使用方法可以参考该主题的官方文档\n\n官方文档快速上手\n\n\n# 二、模板套用\n\n为了减少搭建博客的成本，用的是海贼哥封装好了的快速搭建模板。\n\nGithub访问地址如下：https://github.com/wuchubuzai2018/vuepress-blog-template\n\n详细用法可以看：海贼哥博客\n\n\n# 三、目录结构介绍\n\n .\n├── .github   (可选，GitHub 相关文件)\n│   ├── workflows\n│   │   ├── baiduPush.yml (可选，百度定时自动推送)\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── vdoing (可选，本地的vdoing主题)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editFrontmatter.js (可选，批量操作front matter工具)\n├── baiduPush.sh (可选，百度推送命令脚本)\n├── deploy.sh (可选，部署命令脚本)\n│\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 四、目录结构示例\n\nconfig.js：示例\n\n.\n├── docs\n│   │  (不参与数据生成)\n│   ├── .vuepress\n│   ├── @pages\n│   ├── _posts\n│   ├── index.md（主页）\n│   │\n│   │ (以下部分参与数据生成)\n│   ├── 《JavaScript教程》专栏 (一级目录)\n│   │   ├── 01.章节1 (二级目录)\n│   │   |   ├── 01.js1.md (三级目录-文件)\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.章节2 (二级目录)\n│   │   |   ├── 01.jsa.md\n│   │   |   ├── 02.小节 (三级目录)\n│   │   |   |   └── 01.jsxx.md (四级目录-文件)\n│   ├── 01.前端\n│   │   ├── 01.JavaScript\n│   │   |   ├── 01.js1.md\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.vue\n│   │   |   ├── 01.vue1.md\n│   │   |   └── 02.vue2.md\n│   ├── 02.其他\n│   │   ├── 01.学习\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 02.学习笔记\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 03.文件x.md\n│   │   └── 04.文件xx.md\n│   └── 03.关于我\n│   │   └── 01.关于我.md\n.   .\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n特别注意：数字顺序。详细看官方文档。\n\n\n# 五、部署到 github Pages\n\n\n# 主要步骤\n\n 1. 在 github 上新建一个自己的项目，作为远程仓库\n 2. 把生成的 dist 项目上传到远程仓库中\n 3. 上传成功之后，在远程仓库的页面上点击 seeting，然后左边侧边栏找到 Pages 选项点击，找到部署成功的网址\n\n详细流程可以看（可以先浏览以下两点内容再看教程）：\n\n视频：https://www.bilibili.com/video/BV17t41177cr?p=4&vd_source=d130139a92227a66fb558961b98507cb\n\n配套文档：https://www.it235.com/guide/notes/vuepress.html#%E5%8F%91%E5%B8%83%E5%88%B0github-io\n\n\n# 要注意的点\n\n在自己的 github 上新建一个项目，建议大家都按照用户名.github.io的格式创建（可以自定义），我这里命名是cmty256.github.io（这里的用户名是指你 github 账户的用户名）\n\n\n\n好处：\n\n 1. 最后部署到的网址是：https://用户名.github.io，如果不是上面那种格式的命名的话，网址可能会不太好看：https://用户名.github.io/项目名\n\n 2. 在仓库文件推送成功后，Pages 中的站点自动开通，如果你的仓库名不是 用户名.github.io，则需要你手动选择分支后进行 Save\n    \n    具体是指下面这个区域：\n\n\n\n\n# 问题小结\n\n踩坑：第一次创建 github 项目可能会在连接远程仓库时报下面这个错：\n\ngit@github.com: Permission denied (publickey). fatal: Could not read from remote repository. \nPlease make sure you have the correct access rights and the rep\n\n\n1\n2\n\n\n解决方法：(110条消息) 解决git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Pleas_杭州小哥哥的博客-CSDN博客\n\n\n# 六、部署命令脚本\n\n项目第一个目录下创建 deploy.sh 文件\n\n文件内容：\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件 , yarn docs:build\nnpm run docs:build\nrm -rf ../blog/dist/*\n\n# 将build生成的dist目录拷贝至上一层目录中\ncp -rf docs/.vuepress/dist ../blog/\n\n# 进入生成的文件夹\ncd ../blog/dist\n\n# git初始化，每次初始化不影响推送\ngit init\ngit add -A\ngit commit -m 'deploy'\ngit branch -M main\n\n# 注意此处的格式是：git push -f git@github.com:USERNAME/USERNAME.github.io.git main\n# git push -f git@github.com:xiaose-code/xiaose-code.github.io.git main\ngit push -f https://github.com/xiaose-code/xiaose-code.github.io.git main\n\n# 上行代码中 git@github.com:cmty256/cmty256.github.io.git 这一段其实就是你的 github 项目远程地址，建议直接粘贴\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这里要注意的是路径问题，笔者是建了两个文件夹，上传只包含 dist 的文件夹：\n\n# 将build生成的dist目录拷贝至上一层目录中\ncp -rf docs/.vuepress/dist ../blog/\n\n# 进入生成的文件夹\ncd ../blog/dist\n\n\n1\n2\n3\n4\n5\n\n\n\n# 运行方法：\n\n右键，打开 Git Bash Here 窗口，执行 npm run deploy 或 yarn deploy\n\n\n# 七、场景小结\n\n\n# 1、嵌入图片\n\n例子：\n\n\n\n// 可以在当前目录下创建一个 images 文件夹，然后在MD文件中写入如下代码进行设置文件的记录：\n// 注意：文件夹的命名不能是中文，下面的 ./ 必须加，否则不会识别\n![image-20230401144756087](./imags/image-20230401144756087.png)\n\n\n1\n2\n3\n\n\n\n# 2、md 文档规范\n\nHashSet<String> -- 错误，格式识别不了，会导致运行之后页面没有内容显示\n`HashSet<String>` -- 正确，需转成代码块才能正常识别\n\n直接写 `{{ }}` -- 错误，也会识别不了；可以使用代码块的方式解决\n\n\n1\n2\n3\n4\n\n\n\n# 3、插件资源\n\n花里胡哨必备\n\n\n# 4、网站上的小 logo 设置\n\n.vuepress/config.js 中的头标签 head 中加入以下代码：\n\n['link', { rel: 'icon', href: '/img/book.png' }],\n\n\n1\n\n\n图片存放在 .vuepress/public/img 目录下，没有就新建\n\n\n# 5、图床搭建\n\nPicGo 下载地址：https://github.com/Molunerfinn/PicGo/releases\n\n官方文档：https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E5%8F%88%E6%8B%8D%E4%BA%91\n\n笔者个人比较喜欢：PicX",normalizedContent:"# 搭建流程\n\n\n# 一、主题介绍\n\n本博客使用的主题为：vuepress-theme-vdoing，相关介绍和使用方法可以参考该主题的官方文档\n\n官方文档快速上手\n\n\n# 二、模板套用\n\n为了减少搭建博客的成本，用的是海贼哥封装好了的快速搭建模板。\n\ngithub访问地址如下：https://github.com/wuchubuzai2018/vuepress-blog-template\n\n详细用法可以看：海贼哥博客\n\n\n# 三、目录结构介绍\n\n .\n├── .github   (可选，github 相关文件)\n│   ├── workflows\n│   │   ├── baidupush.yml (可选，百度定时自动推送)\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── vdoing (可选，本地的vdoing主题)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editfrontmatter.js (可选，批量操作front matter工具)\n├── baidupush.sh (可选，百度推送命令脚本)\n├── deploy.sh (可选，部署命令脚本)\n│\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 四、目录结构示例\n\nconfig.js：示例\n\n.\n├── docs\n│   │  (不参与数据生成)\n│   ├── .vuepress\n│   ├── @pages\n│   ├── _posts\n│   ├── index.md（主页）\n│   │\n│   │ (以下部分参与数据生成)\n│   ├── 《javascript教程》专栏 (一级目录)\n│   │   ├── 01.章节1 (二级目录)\n│   │   |   ├── 01.js1.md (三级目录-文件)\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.章节2 (二级目录)\n│   │   |   ├── 01.jsa.md\n│   │   |   ├── 02.小节 (三级目录)\n│   │   |   |   └── 01.jsxx.md (四级目录-文件)\n│   ├── 01.前端\n│   │   ├── 01.javascript\n│   │   |   ├── 01.js1.md\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.vue\n│   │   |   ├── 01.vue1.md\n│   │   |   └── 02.vue2.md\n│   ├── 02.其他\n│   │   ├── 01.学习\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 02.学习笔记\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 03.文件x.md\n│   │   └── 04.文件xx.md\n│   └── 03.关于我\n│   │   └── 01.关于我.md\n.   .\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n特别注意：数字顺序。详细看官方文档。\n\n\n# 五、部署到 github pages\n\n\n# 主要步骤\n\n 1. 在 github 上新建一个自己的项目，作为远程仓库\n 2. 把生成的 dist 项目上传到远程仓库中\n 3. 上传成功之后，在远程仓库的页面上点击 seeting，然后左边侧边栏找到 pages 选项点击，找到部署成功的网址\n\n详细流程可以看（可以先浏览以下两点内容再看教程）：\n\n视频：https://www.bilibili.com/video/bv17t41177cr?p=4&vd_source=d130139a92227a66fb558961b98507cb\n\n配套文档：https://www.it235.com/guide/notes/vuepress.html#%e5%8f%91%e5%b8%83%e5%88%b0github-io\n\n\n# 要注意的点\n\n在自己的 github 上新建一个项目，建议大家都按照用户名.github.io的格式创建（可以自定义），我这里命名是cmty256.github.io（这里的用户名是指你 github 账户的用户名）\n\n\n\n好处：\n\n 1. 最后部署到的网址是：https://用户名.github.io，如果不是上面那种格式的命名的话，网址可能会不太好看：https://用户名.github.io/项目名\n\n 2. 在仓库文件推送成功后，pages 中的站点自动开通，如果你的仓库名不是 用户名.github.io，则需要你手动选择分支后进行 save\n    \n    具体是指下面这个区域：\n\n\n\n\n# 问题小结\n\n踩坑：第一次创建 github 项目可能会在连接远程仓库时报下面这个错：\n\ngit@github.com: permission denied (publickey). fatal: could not read from remote repository. \nplease make sure you have the correct access rights and the rep\n\n\n1\n2\n\n\n解决方法：(110条消息) 解决git@github.com: permission denied (publickey). fatal: could not read from remote repository. pleas_杭州小哥哥的博客-csdn博客\n\n\n# 六、部署命令脚本\n\n项目第一个目录下创建 deploy.sh 文件\n\n文件内容：\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件 , yarn docs:build\nnpm run docs:build\nrm -rf ../blog/dist/*\n\n# 将build生成的dist目录拷贝至上一层目录中\ncp -rf docs/.vuepress/dist ../blog/\n\n# 进入生成的文件夹\ncd ../blog/dist\n\n# git初始化，每次初始化不影响推送\ngit init\ngit add -a\ngit commit -m 'deploy'\ngit branch -m main\n\n# 注意此处的格式是：git push -f git@github.com:username/username.github.io.git main\n# git push -f git@github.com:xiaose-code/xiaose-code.github.io.git main\ngit push -f https://github.com/xiaose-code/xiaose-code.github.io.git main\n\n# 上行代码中 git@github.com:cmty256/cmty256.github.io.git 这一段其实就是你的 github 项目远程地址，建议直接粘贴\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这里要注意的是路径问题，笔者是建了两个文件夹，上传只包含 dist 的文件夹：\n\n# 将build生成的dist目录拷贝至上一层目录中\ncp -rf docs/.vuepress/dist ../blog/\n\n# 进入生成的文件夹\ncd ../blog/dist\n\n\n1\n2\n3\n4\n5\n\n\n\n# 运行方法：\n\n右键，打开 git bash here 窗口，执行 npm run deploy 或 yarn deploy\n\n\n# 七、场景小结\n\n\n# 1、嵌入图片\n\n例子：\n\n\n\n// 可以在当前目录下创建一个 images 文件夹，然后在md文件中写入如下代码进行设置文件的记录：\n// 注意：文件夹的命名不能是中文，下面的 ./ 必须加，否则不会识别\n![image-20230401144756087](./imags/image-20230401144756087.png)\n\n\n1\n2\n3\n\n\n\n# 2、md 文档规范\n\nhashset<string> -- 错误，格式识别不了，会导致运行之后页面没有内容显示\n`hashset<string>` -- 正确，需转成代码块才能正常识别\n\n直接写 `{{ }}` -- 错误，也会识别不了；可以使用代码块的方式解决\n\n\n1\n2\n3\n4\n\n\n\n# 3、插件资源\n\n花里胡哨必备\n\n\n# 4、网站上的小 logo 设置\n\n.vuepress/config.js 中的头标签 head 中加入以下代码：\n\n['link', { rel: 'icon', href: '/img/book.png' }],\n\n\n1\n\n\n图片存放在 .vuepress/public/img 目录下，没有就新建\n\n\n# 5、图床搭建\n\npicgo 下载地址：https://github.com/molunerfinn/picgo/releases\n\n官方文档：https://picgo.github.io/picgo-doc/zh/guide/config.html#%e5%8f%88%e6%8b%8d%e4%ba%91\n\n笔者个人比较喜欢：picx",charsets:{cjk:!0}},{title:"网站收藏箱",frontmatter:{title:"网站收藏箱",date:"2023-06-16T16:05:20.000Z",permalink:"/pages/335531/"},regularPath:"/20.%E7%A2%8E%E7%89%87%E6%96%87%E7%AB%A0/02.%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F%E7%AE%B1.html",relativePath:"20.碎片文章/02.网站收藏箱.md",key:"v-34e1c1e0",path:"/pages/335531/",headers:[{level:2,title:"学习博客",slug:"学习博客",normalizedTitle:"学习博客",charIndex:12},{level:2,title:"前端",slug:"前端",normalizedTitle:"前端",charIndex:344},{level:2,title:"后端",slug:"后端",normalizedTitle:"后端",charIndex:532},{level:2,title:"工具网站",slug:"工具网站",normalizedTitle:"工具网站",charIndex:827},{level:2,title:"资源搜索",slug:"资源搜索",normalizedTitle:"资源搜索",charIndex:1100},{level:2,title:"GPT",slug:"gpt",normalizedTitle:"gpt",charIndex:1282},{level:2,title:"开源项目",slug:"开源项目",normalizedTitle:"开源项目",charIndex:1367},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1542}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.635,time:38100,words:127},headersStr:"学习博客 前端 后端 工具网站 资源搜索 GPT 开源项目 其他",content:"# 网站收藏箱\n\n\n# 学习博客\n\nJavaGuide：https://javaguide.cn/home.html\n\n小林coding：https://xiaolincoding.com\n\nShark Chili：Shark Chili\n\n帅地：https://blog.csdn.net/m0_37907797/article/details/104029002\n\n代码随想录：代码随想录 (programmercarl.com)\n\nNotes【看源码】：https://wardseptember.gitee.io/mynotes/#/README\n\nrocketmq 笔记：http://vue.xiyankt.com/#/rocketmq/index\n\n面渣：面渣逆袭\n\n\n# 前端\n\nant-design-vue：Ant Design Vue (antdv.com)\n\naxios：起步 | Axios 中文文档 | Axios 中文网 (axios-http.cn)\n\nant-design-pro：开始使用 - Ant Design Pro\n\nProComponents：组件总览 - ProComponents (ant.design)\n\n\n# 后端\n\nMybatis-Plus 官网：MyBatis-Plus (baomidou.com)\n\nSpring 中文文档：https://springdoc.cn/\n\n源码阅读网：https://www.coderead.cn/home/index.html#project\n\nmaven 仓库：Maven Repository: Search/Browse/Explore (mvnrepository.com)\n\nJsoup Java HTML Parser（解析器）：https://jsoup.org/\n\nDockerHub：https://hub.docker.com/\n\n\n# 工具网站\n\nPDF 转 md 文件：PDF to Markdown (morethan.io)\n\n免费的 API 接口文档：Swagger UI (apiopen.top)\n\n在线工具：在线单位换算 (lddgo.net)\n\n程序员之家：程序员工具-CXY965\n\n图片清晰：https://bigjpg.com/\n\n奇趣收藏家：https://fuun.fun/\n\n图表绘制：draw.io (drawio.com)\n\nprocesson：ProcessOn思维导图流程图-在线画思维导图流程图_在线作图实时协作\n\n飞书妙记：飞书妙记\n\n\n# 资源搜索\n\n奇妙搜索：https://www.magicalsearch.top/main\n\n混合盘：https://hunhepan.com/\n\n淘链客：https://www.taolinks.cc/s/\n\n熊猫搜索：https://xmsoushu.com/#/\n\n我爱电子书：https://www.52doc.com/download/3214\n\n\n# GPT\n\nAI EDU：FORCHANGE AI EDU (leyoyu.cn)\n\n鱼聪明：鱼聪明AI - 做您强大的AI助手 (yucongming.com)\n\n\n# 开源项目\n\nRuoYi-Vue\n\n官方文档：后台手册 | RuoYi\n\n项目地址：若依管理系统 (ruoyi.vip)\n\nrenren-security\n\n官网：人人开源 (renren.io)\n\nrenren-fast\n\n项目地址：renren-fast\n\n阿里巴巴开发手册\n\nhttps://github.com/alibaba/p3c\n\n\n# 其他\n\n断墨寻径：学习误区自查课程介绍 - 断墨寻径 - 渐构 Modevol\n\n学习方法：学习观1-6（学习方法） - 学习观 - 渐构 Modevol",normalizedContent:"# 网站收藏箱\n\n\n# 学习博客\n\njavaguide：https://javaguide.cn/home.html\n\n小林coding：https://xiaolincoding.com\n\nshark chili：shark chili\n\n帅地：https://blog.csdn.net/m0_37907797/article/details/104029002\n\n代码随想录：代码随想录 (programmercarl.com)\n\nnotes【看源码】：https://wardseptember.gitee.io/mynotes/#/readme\n\nrocketmq 笔记：http://vue.xiyankt.com/#/rocketmq/index\n\n面渣：面渣逆袭\n\n\n# 前端\n\nant-design-vue：ant design vue (antdv.com)\n\naxios：起步 | axios 中文文档 | axios 中文网 (axios-http.cn)\n\nant-design-pro：开始使用 - ant design pro\n\nprocomponents：组件总览 - procomponents (ant.design)\n\n\n# 后端\n\nmybatis-plus 官网：mybatis-plus (baomidou.com)\n\nspring 中文文档：https://springdoc.cn/\n\n源码阅读网：https://www.coderead.cn/home/index.html#project\n\nmaven 仓库：maven repository: search/browse/explore (mvnrepository.com)\n\njsoup java html parser（解析器）：https://jsoup.org/\n\ndockerhub：https://hub.docker.com/\n\n\n# 工具网站\n\npdf 转 md 文件：pdf to markdown (morethan.io)\n\n免费的 api 接口文档：swagger ui (apiopen.top)\n\n在线工具：在线单位换算 (lddgo.net)\n\n程序员之家：程序员工具-cxy965\n\n图片清晰：https://bigjpg.com/\n\n奇趣收藏家：https://fuun.fun/\n\n图表绘制：draw.io (drawio.com)\n\nprocesson：processon思维导图流程图-在线画思维导图流程图_在线作图实时协作\n\n飞书妙记：飞书妙记\n\n\n# 资源搜索\n\n奇妙搜索：https://www.magicalsearch.top/main\n\n混合盘：https://hunhepan.com/\n\n淘链客：https://www.taolinks.cc/s/\n\n熊猫搜索：https://xmsoushu.com/#/\n\n我爱电子书：https://www.52doc.com/download/3214\n\n\n# gpt\n\nai edu：forchange ai edu (leyoyu.cn)\n\n鱼聪明：鱼聪明ai - 做您强大的ai助手 (yucongming.com)\n\n\n# 开源项目\n\nruoyi-vue\n\n官方文档：后台手册 | ruoyi\n\n项目地址：若依管理系统 (ruoyi.vip)\n\nrenren-security\n\n官网：人人开源 (renren.io)\n\nrenren-fast\n\n项目地址：renren-fast\n\n阿里巴巴开发手册\n\nhttps://github.com/alibaba/p3c\n\n\n# 其他\n\n断墨寻径：学习误区自查课程介绍 - 断墨寻径 - 渐构 modevol\n\n学习方法：学习观1-6（学习方法） - 学习观 - 渐构 modevol",charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,heroImage:"/img/2.png",heroText:"霜晨月",tagline:"欲买桂花同载酒，终不似，少年游。",bannerBg:"none",actionText:"开始阅读 →",actionLink:"/pages/c5bdd8/",features:[{title:"晁错论·苏轼",details:"古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。"},{title:"忆秦娥·娄山关·毛泽东",details:"西风烈，长空雁叫霜晨月。霜晨月，马蹄声碎，喇叭声咽。雄关漫道真如铁，而今迈步从头越。从头越，苍山如海，残阳如血。"},{title:"行路难·李白",details:"行路难！行路难！多歧路，今安在？长风破浪会有时，直挂云帆济沧海。"}],postList:"none",hideRightBar:!0},regularPath:"/",relativePath:"index.md",key:"v-0fc0ddc2",path:"/",lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"1 min read",minutes:.365,time:21900,words:73},headersStr:null,content:"# 🎖学习向导\n\n阿秀的学习笔记\n\n面试指南\n\n小林coding\n\n图解计算机基础\n\n帅地\n\n优质博客\n\nCodeTop\n\n热题速刷\n\n代码随想录\n\n系统的刷题\n\n霜晨月\n\n自己的CSDN博客\n\n- name: <b>阿秀的学习笔记</b>\n  desc: <b>面试指南</b>\n  link: https://interviewguide.cn/\n  bgColor: '#ffb3a7'\n  textColor: '#000000'\n- name: <b>小林coding</b>\n  desc: <b>图解计算机基础</b>\n  link: https://xiaolincoding.com/\n  bgColor: '#ed5736'\n  textColor: '#000000'\n- name: <b>帅地</b>\n  desc: <b>优质博客</b>\n  link: https://blog.csdn.net/m0_37907797/article/details/104029002\n  bgColor: '#ff4c00'\n  textColor: '#000000'\n- name: <b>CodeTop</b>\n  desc: <b>热题速刷</b>\n  link: https://codetop.cc/home\n  bgColor: '#ff7500'\n  textColor: '#000000'\n- name: <b>代码随想录</b>\n  desc: <b>系统的刷题</b>\n  link: https://www.programmercarl.com/\n  bgColor: '#0eb83a'\n  textColor: '#000000'\n- name: <b>霜晨月</b>\n  desc: <b>自己的CSDN博客</b>\n  link: https://blog.csdn.net/m0_53485135\n  bgColor: '#70f3ff'\n  textColor: '#000000'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",normalizedContent:"# 🎖学习向导\n\n阿秀的学习笔记\n\n面试指南\n\n小林coding\n\n图解计算机基础\n\n帅地\n\n优质博客\n\ncodetop\n\n热题速刷\n\n代码随想录\n\n系统的刷题\n\n霜晨月\n\n自己的csdn博客\n\n- name: <b>阿秀的学习笔记</b>\n  desc: <b>面试指南</b>\n  link: https://interviewguide.cn/\n  bgcolor: '#ffb3a7'\n  textcolor: '#000000'\n- name: <b>小林coding</b>\n  desc: <b>图解计算机基础</b>\n  link: https://xiaolincoding.com/\n  bgcolor: '#ed5736'\n  textcolor: '#000000'\n- name: <b>帅地</b>\n  desc: <b>优质博客</b>\n  link: https://blog.csdn.net/m0_37907797/article/details/104029002\n  bgcolor: '#ff4c00'\n  textcolor: '#000000'\n- name: <b>codetop</b>\n  desc: <b>热题速刷</b>\n  link: https://codetop.cc/home\n  bgcolor: '#ff7500'\n  textcolor: '#000000'\n- name: <b>代码随想录</b>\n  desc: <b>系统的刷题</b>\n  link: https://www.programmercarl.com/\n  bgcolor: '#0eb83a'\n  textcolor: '#000000'\n- name: <b>霜晨月</b>\n  desc: <b>自己的csdn博客</b>\n  link: https://blog.csdn.net/m0_53485135\n  bgcolor: '#70f3ff'\n  textcolor: '#000000'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n",charsets:{cjk:!0}},{title:"断墨寻径摘录",frontmatter:{title:"断墨寻径摘录",date:"2023-07-29T17:20:52.000Z",permalink:"/pages/94109b/"},regularPath:"/20.%E7%A2%8E%E7%89%87%E6%96%87%E7%AB%A0/03.%E6%96%AD%E5%A2%A8%E5%AF%BB%E5%BE%84%E6%91%98%E5%BD%95.html",relativePath:"20.碎片文章/03.断墨寻径摘录.md",key:"v-7db92364",path:"/pages/94109b/",headers:[{level:2,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:11},{level:3,title:"重现目标与泛化目标",slug:"重现目标与泛化目标",normalizedTitle:"重现目标与泛化目标",charIndex:18},{level:4,title:"信息与知识",slug:"信息与知识",normalizedTitle:"信息与知识",charIndex:31},{level:4,title:"记忆与学习",slug:"记忆与学习",normalizedTitle:"记忆与学习",charIndex:196},{level:4,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:634},{level:3,title:"指令学习与归纳学习",slug:"指令学习与归纳学习",normalizedTitle:"指令学习与归纳学习",charIndex:672},{level:4,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:634},{level:2,title:"成果",slug:"成果",normalizedTitle:"成果",charIndex:1139},{level:3,title:"归纳不足与以偏概全",slug:"归纳不足与以偏概全",normalizedTitle:"归纳不足与以偏概全",charIndex:1146},{level:4,title:"拟合",slug:"拟合",normalizedTitle:"拟合",charIndex:1159},{level:4,title:"欠拟合",slug:"欠拟合",normalizedTitle:"欠拟合",charIndex:1400},{level:4,title:"过拟合",slug:"过拟合",normalizedTitle:"过拟合",charIndex:1474},{level:4,title:"双例对比法",slug:"双例对比法",normalizedTitle:"双例对比法",charIndex:1579},{level:2,title:"可泛化性与有效范围",slug:"可泛化性与有效范围",normalizedTitle:"可泛化性与有效范围",charIndex:2002},{level:3,title:"知识可泛化性",slug:"知识可泛化性",normalizedTitle:"知识可泛化性",charIndex:2016},{level:3,title:"知识局部有效",slug:"知识局部有效",normalizedTitle:"知识局部有效",charIndex:2308},{level:2,title:"材料",slug:"材料",normalizedTitle:"材料",charIndex:551},{level:3,title:"有效实例与有效描述",slug:"有效实例与有效描述",normalizedTitle:"有效实例与有效描述",charIndex:2644},{level:4,title:"有效实例",slug:"有效实例",normalizedTitle:"有效实例",charIndex:2644},{level:4,title:"有效描述",slug:"有效描述",normalizedTitle:"有效描述",charIndex:2649},{level:3,title:"材料瓶颈与模型瓶颈",slug:"材料瓶颈与模型瓶颈",normalizedTitle:"材料瓶颈与模型瓶颈",charIndex:3150},{level:4,title:"现象",slug:"现象",normalizedTitle:"现象",charIndex:1438},{level:4,title:"材料的瓶颈",slug:"材料的瓶颈",normalizedTitle:"材料的瓶颈",charIndex:3256},{level:4,title:"模型的瓶颈",slug:"模型的瓶颈",normalizedTitle:"模型的瓶颈",charIndex:3671},{level:4,title:"总结",slug:"总结-3",normalizedTitle:"总结",charIndex:634},{level:2,title:"存储",slug:"存储",normalizedTitle:"存储",charIndex:4660},{level:3,title:"存储目标与存储过程",slug:"存储目标与存储过程",normalizedTitle:"存储目标与存储过程",charIndex:4667},{level:4,title:"存储位置",slug:"存储位置",normalizedTitle:"存储位置",charIndex:4680},{level:4,title:"存储过程",slug:"存储过程",normalizedTitle:"存储过程",charIndex:4672},{level:4,title:"总结",slug:"总结-4",normalizedTitle:"总结",charIndex:634},{level:3,title:"有效训练与精细加工",slug:"有效训练与精细加工",normalizedTitle:"有效训练与精细加工",charIndex:5425},{level:4,title:"实际执行",slug:"实际执行",normalizedTitle:"实际执行",charIndex:5589},{level:4,title:"答案反馈",slug:"答案反馈",normalizedTitle:"答案反馈",charIndex:5685},{level:4,title:"精细加工",slug:"精细加工",normalizedTitle:"精细加工",charIndex:5430},{level:4,title:"总结",slug:"总结-5",normalizedTitle:"总结",charIndex:634},{level:2,title:"验证",slug:"验证",normalizedTitle:"验证",charIndex:2375},{level:3,title:"新例预测与表述转换",slug:"新例预测与表述转换",normalizedTitle:"新例预测与表述转换",charIndex:6809},{level:4,title:"预测新例",slug:"预测新例",normalizedTitle:"预测新例",charIndex:6831},{level:4,title:"转换表述",slug:"转换表述",normalizedTitle:"转换表述",charIndex:6905},{level:4,title:"总结",slug:"总结-6",normalizedTitle:"总结",charIndex:634},{level:4,title:"以教促学",slug:"以教促学",normalizedTitle:"以教促学",charIndex:7145},{level:2,title:"汇总",slug:"汇总",normalizedTitle:"汇总",charIndex:7380},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:7871}],lastUpdated:"2023/12/15 11:24:12",lastUpdatedTimestamp:1702610652e3,readingTime:{text:"2 min read",minutes:1.54,time:92400,words:308},headersStr:"目标 重现目标与泛化目标 信息与知识 记忆与学习 总结 指令学习与归纳学习 总结 成果 归纳不足与以偏概全 拟合 欠拟合 过拟合 双例对比法 可泛化性与有效范围 知识可泛化性 知识局部有效 材料 有效实例与有效描述 有效实例 有效描述 材料瓶颈与模型瓶颈 现象 材料的瓶颈 模型的瓶颈 总结 存储 存储目标与存储过程 存储位置 存储过程 总结 有效训练与精细加工 实际执行 答案反馈 精细加工 总结 验证 新例预测与表述转换 预测新例 转换表述 总结 以教促学 汇总 参考",content:"# 断墨寻径\n\n\n# 目标\n\n\n# 重现目标与泛化目标\n\n# 信息与知识\n\n信息是相对具象的，因为它只描述一个情况\n\n而知识是同一类的所有情况，包括老师从未提及的新情况，就不得不用概括性词语来描述各种情况的共同特征，因此必然是抽象的。\n\n> 偶数是能够被 2 所整除的整数”这个知识所描述的并不是 2、4、6、8 这些具体的偶数，而是所有偶数的共同特征，包括我们从来都没有数过的偶数。\n\n# 记忆与学习\n\n掌握信息时，我们的目标是「重现旧信息」，用于达成这一目标的行为叫做记忆。（重现目标）\n\n而掌握知识时，我们的目标是「生成新信息」，「解决从未记忆过的新情况」，用于达成这一目标的行为叫做学习。（泛化目标）\n\n二者区别\n\n泛化才是我们为什么要学习的真正原因，如果可以提前见到所有情况，那么采取记忆就可以了。因此判断一个行为是学习还是记忆，就看该行为是否可以解决从未记忆过的新情况。\n\n * 假如这个有三个情况，若某一行为能让学生解决这三个情况之外的新情况，那这一行为就称为学习，\n * 若某一行为只能让学生重现这三个情况，那这一行为就称为记忆。\n\n机械记忆\n\n在学习范畴中，机械记忆是与有意义学习相对的概念，并不是指呆板的、不灵活的记忆，而是指“学习的目标错了”，也就是“把本应用来实现泛化目标的学习材料单纯地记忆了下来的行为”，“使学习材料失去了其应有的意义的行为”。\n\n> 就好比，本应用来看电影的电影票，却被用来折纸飞机了，让电影票失去了它原本的意义。\n\n# 总结\n\n信息对单，知识对群。\n\n重现信息是记忆，生成新信息是学习。\n\n\n# 指令学习与归纳学习\n\n> 学习的目的不是记忆已见过的旧情况（重现），而是解决从未见过的新情况（泛化），也就不能只针对具体情况，而是要在脑中建构一个规律，用规律来生成从未见过的新情况。\n\n看教程、参加课程的方式，也就是通过语言，对概念、规律、共性进行描述，从而建构规律的方式，也被称为指令学习。\n\n> 但实际上，可以提升泛化能力的学习方式有很多种，指令学习只不过是其中一种，而且还是人脑最不擅长的一种。\n\n通过观察多个实际案例，让大脑自动找到不同实例之间的共性，用共性来推测从未见过的情况该如何处理。这种方式，叫做归纳学习。\n\n比如遥控器学习：\n\n但可以回想我们是如何学会使用遥控器的。是看说明书吗？很少人会这么做吧。基本都是按一个按钮，看结果；再按另一个按钮，再看结果，通过反复尝试来搜集实例，随后大脑就可以利用这些实例来建构规律，从而预测新情况。\n\n实际上，多数情况下，归纳的过程并不是由我们的意识直接控制的，而是大脑在特定条件下自动执行的。\n\n# 总结\n\n指令就是纯靠背、听、看知识。归纳就是实践总结，大脑自动产生意识。\n\n\n# 成果\n\n\n# 归纳不足与以偏概全\n\n# 拟合\n\n建构可以满足所有旧情况的模型的过程，也可称为归纳\n\n经验拟合\n\n我们知道这个客观规律一定也可以满足所有已见过的旧情况。归纳学习正是利用这一点，去建构一个可以满足所有已见过的旧情况，并希望该规律恰好就是客观规律。建构可以满足所有旧情况的规律的过程也叫做拟合，这些旧情况也叫做经验。\n\n拟合与学习\n\n但是，拟合并不能和学习划等号，因为拟合只能保证记忆，并不能保证学习。拟合只是我们在达成泛化目标时所使用的一种手段，能拟合经验的规律未必能泛化新情况，而泛化才是学习的目标。\n\n# 欠拟合\n\n所拟合的模型无法满足旧情况的特性，又叫归纳不足\n\n其中一个不理想的现象是：所拟合出来的规律连旧情况都无法满足，这一现象叫做欠拟合。\n\n# 过拟合\n\n所拟合的模型可以满足旧情况，但却无法满足新情况的特性，又叫以偏概全\n\n另一个不理想现象是，拟合出来的规律可以满足所有旧情况，但却无法预测新情况，仅仅是个以偏概全的局部规律，这一现象叫做过拟合。\n\n# 双例对比法\n\n 1. 第一步，确定一个要学习的知识点。\n 2. 第二步，先试着理解课本上讲解，也就是用指令学习的方式，确定一个大概。\n 3. 第三步，再找出很多道该知识点的习题来做，也就是搜集该知识点的实例。\n\n> 注意别立刻看答案\n> \n> 注意，做每道题都要经过完整的思考，不能一没思路就立马看答案，这是为了让大脑明确问题是什么，以便于让大脑做好自动归纳的准备。\n\n 4. 到了第四步就是该方法的关键：当做完两道题后，停下来比较两道题中该知识点的共性和差异性，同时去再去理解课本上的知识点讲解，这一步就是总结了。\n\n> 注意自动感知\n> \n> 注意，在比较共性和差异性的时候，不必太过注重规律的寻找，因为大脑会自动完成这一工作，我们只需要确保提供给大脑充分长的感知时间和足够多情况就好。\n\n 5. 第五步，做新题，来测试自己的理解，以此调整自己的理解。\n\n 6. 随后，再重复第二到第五步，直到将自己的泛化能力提高到满意地程度为止。\n\n\n# 可泛化性与有效范围\n\n\n# 知识可泛化性\n\n知识具有超越已有经验普遍性的特点。\n\n先前所说，知识是用来解决同一类问题中所有情况，包括从未见过的新情况，因此知识必须具有可泛化性。\n\n知识付费课程的内容都具有可泛化性吗？\n\n知识付费课程的基本模式是：抛一个问题，讲一个故事，提一个规律，再起一个名字。\n\n其中的规律，由于就是根据所讲故事而归纳的，因此必然可以完美解释所讲的这个故事，观众听起当然觉得很有道理。然而，若所提规律只是用单个案例归纳得出的，那么很容易过拟合（也就是接收到的知识不完整），不具有可泛化性，也就自然不能解决听众在生活中所遇到的新问题。\n\n> 并非所有知识付费课程中的内容都是不可泛化的\n\n\n# 知识局部有效\n\n知识只能在特定的范围内获得有效预测。\n\n知识并不是永恒不变的真理。所有科学知识都是基于人类现有的观察，在特定条件下，经验证所得到的，因此也就只能确保在特定条件下泛化。\n\n换句话说，知识的可泛化范围并不是无限的，是在做验证之前就已经被限定过的，倘若超出了限定范围，就无法再确保该知识依旧有效。\n\n知识组成\n\n限制条件同样也是知识的一部分，我们在使用某知识的时候，必须在它所限定的条件下使用，否则就会出错。\n\n明确输入输出\n\n在学习任何一个知识时，都不能仅仅关注它的预测结果，还要明确它的前提条件。也就是要同时明确它的输入范围和输出范围。\n\n对于学习方法也是同理，任何学习方法也都有它的前提条件，若不满足条件，再高效的学习方法也会失效。\n\n\n# 材料\n\n\n# 有效实例与有效描述\n\n# 有效实例\n\n同时具有“前因”和“后果”的实例才是有效的实例性材料。\n\n在使用归纳学习方式时，必须要有实例作为建构知识的依据，而作为一个实例，不能只有起因而没有结果，不能只有提问没有回答。\n\n> 比如猜数字问题，倘若只告诉大家数字的位置，却不告诉位置所对应的数字，就无法归纳，单独的一个位置信息也不能称为一个实例。\n\n# 有效描述\n\n所有旧概念均被理解的描述才是对学习有效的描述性材料。\n\n比如 背论文 和 讲论文\n\n背论文是将论文作为描述性材料，以指令学习的方式来建构新知识。\n\n对于讲论文而言，这些描述性材料能够被用来学习的前提就是你已经掌握了描述中的所有旧概念，明白每个词的指代。\n\n这也是为什么，所有描述性学习材料无法让每个人都满意。倘若用了精准的专有名词来描述新知识，那么掌握了这些名词的人观看起来会非常高效，但对没掌握这些名词的人而言就是无效材料。但若将专有名词展开来解释，又必然会增加篇幅，让掌握了专有名词的人觉得啰嗦。\n\n> 现在，我们知道了，什么样的实例性材料和描述性材料才是有效的，然而，有时，我们获得的明明都是有效材料，为什么却没能再提升自己的泛化能力呢？\n\n\n# 材料瓶颈与模型瓶颈\n\n# 现象\n\n我们经常会发现，刚开始学习新事物时，会迅速提升，随后却进步缓慢，最终处在一个瓶颈，难以突破。像轮滑的学习、绘画的学习、设计的学习，对识别心电图的学习，甚至是对游戏的学习。\n\n# 材料的瓶颈\n\n由材料所引起的学习瓶颈。\n\n当我们对同一个任务的学习到达一定程度时，就会遇到很多重复材料，此时不论再怎么背诵或理解这些材料，都无法帮助我们进一步提升泛化能力了，也就是由材料所引起的瓶颈。\n\n打破材料瓶颈\n\n若想打破这种瓶颈，就不能单守着旧材料不断背诵，而是就要去搜寻新的学习材料。\n\n多教材学习：这也是为什么，有的同学用多本不同角度的教材去学习同一个知识时，理解会非常深刻。\n\n实例材料瓶颈\n\n在使用归纳学习材料来建构知识时，也需要用那些没有见过的新实例，来提升自己的泛化能力。\n\n * 这便是为什么，那些从事艺术创作的人，比如，UI设计，服装设计，需要看大量的新素材，来提升自己，这类知识是很难用指令学习来建构的。\n * 同时也解释了，为什么学校的老师会训诫学生，错题本一定要时时更新，把掌握了的旧题移除，但有的学生的错题本，从开始使用就在那里不断积累，从来没有移除过旧题，每次翻看时又都是从第一页开始看。\n\n# 模型的瓶颈\n\n由旧认识所引起的学习抵触。\n\n地穴寓言\n\n有一批囚徒自出生起就被锁链束缚在一个地穴中，不能回头，只能看着墙壁上的影子。久而久之，囚徒们建构了关于影子的各种知识，并认为这些影子就是世界的全部。某天，一个囚徒偶然打开了锁链，爬出了洞穴，看到了阳光下的真实世界，他这才意识到曾被自己称为“世界”的地方，只不过是个洞穴。随后，他回到了洞穴，想要告诉自己的同伴，外面的世界才是真实的，向他们解释什么是太阳，什么是树。但这一行为却激怒了同伴，认为他在胡言乱语，并计划将他杀死，以此来捍卫大家的“世界”。\n\n地穴寓言出自柏拉图的《理想国》，曾给人们很多启示，而我们也可以从中认识到在突破瓶颈时会遭遇的又一个问题。那就是：学习者的大脑中，已经存在一个既有“认识”了，虽然在理论上该认识不完美，但由于该认识能让该学习者预测他所处环境中的种种情况，大脑并不会觉得这个认识存在什么不足。那么此时，该学习者的大脑就会拒绝任何新材料。(拒绝接收新材料，新知识)\n\n那么该如何处理这个问题呢？\n\n其实答案同时也出现在了寓言中，因为地穴中已经有一个突破了旧认识的人，那就是爬出洞穴的人。这个人和其他人的区别是什么呢？爬出洞穴的人，最初所用的是【实例性材料】，而洞穴内的人所用的是【描述性材料】。通常来说，大脑对实例性材料是不抵触的。\n\n突破模型瓶颈\n\n在学习时，不能单单只喊“我们应该克服旧认识”的口号，还要依从大脑的特性来实现这一目标。\n\n那就是先不要用描述性材料对规律本身进行矫正，而是先至少用一个实例性材料，让大脑意识到自己的“认识”对于预测哪些新情况依旧是不足的 ，以打破对新材料的戒备和屏蔽。\n\n苏格拉底提问\n\n在辩论中，就经常使用这种技巧。即不跟对方争论，而是直接抛出一个新情况，让对方用现有的认识来预测结果再展示给对方他的预测结果不符合实际情况。\n\n# 总结\n\n 1. 一个是由材料所带来的瓶颈，解决这种瓶颈的办法就是去搜集新材料。一些应试生容易犯的误区是不断去背诵已掌握的旧材料。\n 2. 另一个是由脑中的旧认识对新材料的抗拒所带来的瓶颈，解决这种瓶颈的方法是，先至少用一个实例性材料来让大脑意识到自己已有的认识是不足的，然后再继续学习。比如，一个 UI 设计师，若在任何时候都抱着“自己的认识是高级的，欣赏不了的人就是不懂”的想法，那他的大脑自然是不会接受新材料的。\n\n\n# 存储\n\n\n# 存储目标与存储过程\n\n# 存储位置\n\n人脑知识存储在神经网络的结构中。\n\n规律的实现\n\n为了实现泛化，需要建构一个规律，一种映射，来生成从未见过的新情况。而这种规律，正是由大量神经细胞所形成的网络来实现的，网络中的神经细胞们会通过电信号的频率来交流，通过层层计算，最终告诉我们的身体该怎么做，而电信号的频率又受神经细胞之间的突触结构所控制，倘若结构不合适，就无法生成正确的电信号来控制身体。\n\n频率的调整\n\n在细胞层面来看，学习就变成了让神经细胞之间形成合适结构的过程。\n\n# 存储过程\n\n人脑知识在睡眠中自动构建。\n\n调整的手段\n\n我们只需要通过有效的训练，让大脑接收到合适的材料，大脑便可以把这些材料作为依据，调整出合适的结构。\n\n调整的时间\n\n大脑大规模调整结构的时间段，正是在睡眠期间。倘若一个人学习了一整天后却不睡觉，那他的大脑就没有获得足够的调整时间，自然就无法形成长期的记忆和知识。\n\n策略\n\n需要掌握好学习和睡眠这两个因素的平衡。\n\n * 光学习，不睡眠，那么大脑就没时间调整结构，无法存储知识；\n * 若光睡觉，不学习，那大脑也没有依据来调整结构。\n\n调整的试错\n\n大脑也并不能确保每次的调整都是正确的，对于复杂的知识，大脑经常会调整出以偏概全的规律，也就需要慢慢调整回更加普遍的规律。\n\n换句话说，神经细胞们也是需要试错的，这意味着很多任务的学习无法一蹴而就，而是一个多次迭代的过程。需要反复用不同的学习材料来训练大脑。\n\n多科目学习\n\n大脑的学习需要时间和调整过程，同样意味着，在校学生其实没必要一天只啃一个学科，每个科目都学习两三个知识点，同时学习多个科目，可能会产生事半功倍的效果。\n\n# 总结\n\n只要通过有效的训练给大脑提供合适的材料，并保障足够的睡眠，大脑便可以自己形成规律。\n\n\n# 有效训练与精细加工\n\n> 上期我们说过，在细胞层面上来看，学习就相当于让特定的神经细胞群形成适合所学任务的正确结构。\n> \n> 那么在学习时，我们自然是想让与所学任务相关的所有神经细胞都先受到刺激，做好更新的准备，随后再让大脑去更新这些神经细胞的结构。\n\n可要如何实现这个目标呢？我们仍然只能通过间接的手段来达成该目标。\n\n# 实际执行\n\n研究表明，想象和观察也能刺激到部分相关神经细胞。但要想全面高效地刺激相关神经细胞的最好办法，其实就是：自己实际去执行一遍这个任务，并得到一个自己的答案。（也就是实践见真知）\n\n# 答案反馈\n\n学习的材料必须要有反馈，才能提供改进方向。\n\n反馈答案\n\n实际执行一遍只是让相关神经细胞做好更新的准备，关键还是最后的更新，而让大脑知道该如何更新的前提条件，就是要有对应的答案，或对应的评分，反馈给大脑。\n\n有效训练\n\n所以，想要让大脑高效地学习，最好的方式就是经历“实际执行与反馈答案”两个过程。倘若我们用有效的学习材料，经历了这两个过程，就可以称其为一次有效训练，而大量的有效训练才是我们进步的关键。\n\n# 精细加工\n\n建立新学的知识与旧知识之间关联。\n\n对于实例性材料，我们很容易做到“实际执行与反馈答案”这两步，那么对于指令性材料，我们该怎么做呢？\n\n答案是相同的，仍然是“实际执行与反馈答案”两个过程。\n\n在第一期就讲过，指令性材料是对规律的直接描述，是用来“打底稿”的，防止大脑自动归纳出了以偏概全的规律，其最终目的仍是要预测新情况，实现泛化。\n\n尽管是对规律的直接描述，但指令性材料对大脑神经结构的直接调整能力远不如实例性材料，很容易就会被大脑所遗忘，尤其是在学习者不能理解指令材料的意义时，遗忘速度会非常迅速。\n\n所以，即便使用的是指令性材料，也需要自己扩充实例性材料，自己举例，并试图回答。最好能用该知识去解释自己周围的现象。\n\n强化指令学习\n\n为了抑制人脑对指令性材料的快速遗忘，我们还有一个办法，那就是：建立新学的知识与旧知识之间关联。当两个知识产生他洽与印证时，大脑会留下深刻印象。\n\n数学家华罗庚所分享的学习方法 -- 先把书读厚，再把书读薄\n\n读薄 并不是一种行为，而是一种状态，意思是说，当自己利用其他材料充分地理解了知识点后，大脑就可以推测出其他材料了，此时，书就相当于变薄了，并不是让大家通过删除内容把书变薄。\n\n# 总结\n\n这一期讲了只有经历了实际执行和反馈答案两个过程才算是一个有效的训练，并讲了如何通过精细加工让指令性材料也能达到有效训练的效果。\n\n\n# 验证\n\n学习的最后一步，验证。\n\n验证巩固作用\n\n验证的是前人脑中所建构的知识，而我们的目标是在自己的脑中建构出相同的知识，并且是通过有效训练间接地让大脑自动调整神经结构，来实现这一目标，问题在于大脑并不知道所调整的结构是否已经可以泛化，不知道什么时候该停止调整，更不知道是否应该将已调整的结构视为以偏概全的、过拟合的规律而直接遗忘掉（长期记忆的遗忘）。\n\n所以需要我们提供给大脑一个反馈信号，告诉它，现在建构出的规律是可以泛化的，不需要再调整了，也千万别遗忘了。而这个反馈信号，就是通过验证来间接提供给大脑的。\n\n验证校验作用\n\n验证最重要的功能，还是确保我们所建构的知识是正确的，我们不希望自己建构了错误的知识后，还永远不忘。\n\n\n# 新例预测与表述转换\n\n要如何验证呢？\n\n# 预测新例\n\n用所建构的知识去解决新问题。倘若无法解决新问题，就说明所建构知识的泛化能力还不足够。这是泛化能力原本的定义。（验证的是实例材料）\n\n# 转换表述\n\n通过能否用自己的话来表述相同的意思，来排除自己并不是只记住了表述而未理解。\n\n表述转换\n\n倘若某人真的用指令性材料建构了知识，而不是单单机械记住了这个材料本身，那他一定也可以用另一种描述表达出于与该指令性材料类似的意思。也就是老师常说的“学习要用自己的话来表述”。\n\n# 总结\n\n有两种最基本的验证方式：\n\n 1. 运用自己构建的知识来预测新情况的结果，并与实际情况相对照。 -- 看是否能解决新问题\n 2. 转换表述 -- 要学会用自己的话来描述指令性材料。\n\n# 以教促学\n\n预测新例和转换表述的结合应用。\n\n教人之所以可以巩固自己学习，其关键就在于，教学过程既可以检验学习者所建构知识的正确性，又给大脑提供了一个反馈信号，让大脑知道所建构的知识已经可以泛化，不必遗忘，从而巩固了知识的存储。\n\n复习方式\n\n复习和巩固知识的一种方法。不是单单拿自己勾画的那些重点句反复看，反复背诵，而是做几道新题，问自己几个新情况，或者用另一句话来表达相同的意思，正确解答之后，就可以巩固所建构的知识不被大脑所轻易遗忘。 -- 做题保持手感\n\n\n# 汇总\n\n学习的五个层面：目标、成果、材料、存储、验证。\n\n这五个层面囊括了学习的基本流程，当自己的学习出现任何问题时，都可以从这五个层面进行排查。\n\n 1. 目标层面决定了我们努力的方向和可以获得的成果；\n 2. 材料层面则是我们达成目标的代价和条件；\n 3. 存储层面又决定了我们以什么样的方式利用材料在脑中建构知识；\n 4. 成果层面或者说对象层面则让我们知晓要建构的知识有什么特点，建构时会遇到什么障碍，以及使用时又有哪些局限。\n 5. 验证层面则用来确保所获得的成果和我们的目标成果是相同的，并对大脑的存储做进一步的巩固。\n\n1.1 明确目标\n\n当有了一个需要掌握的内容时，先看这是一个需要重现的内容，还是一个需要泛化的内容，以此来决定是要采用学习方法，还是记忆方法。\n\n1.2 误区排查\n\n在 方式、材料、瓶颈突破、存储、训练、成果、应用、验证 等 8 个方面上排查是否有问题。\n\n课程名中的“断墨”正取自“断墨残楮”的前两个字，意为“残缺不全的典籍”，而断墨寻径这四个字正是在概括，学习中，我们究竟在做什么，即，在残缺不全，充满未知的条件下，寻找出通用的模式。\n\n\n# 参考\n\n断墨寻径：https://www.modevol.com/episode/ckx8eb99w000501l2ewyt2kto",normalizedContent:"# 断墨寻径\n\n\n# 目标\n\n\n# 重现目标与泛化目标\n\n# 信息与知识\n\n信息是相对具象的，因为它只描述一个情况\n\n而知识是同一类的所有情况，包括老师从未提及的新情况，就不得不用概括性词语来描述各种情况的共同特征，因此必然是抽象的。\n\n> 偶数是能够被 2 所整除的整数”这个知识所描述的并不是 2、4、6、8 这些具体的偶数，而是所有偶数的共同特征，包括我们从来都没有数过的偶数。\n\n# 记忆与学习\n\n掌握信息时，我们的目标是「重现旧信息」，用于达成这一目标的行为叫做记忆。（重现目标）\n\n而掌握知识时，我们的目标是「生成新信息」，「解决从未记忆过的新情况」，用于达成这一目标的行为叫做学习。（泛化目标）\n\n二者区别\n\n泛化才是我们为什么要学习的真正原因，如果可以提前见到所有情况，那么采取记忆就可以了。因此判断一个行为是学习还是记忆，就看该行为是否可以解决从未记忆过的新情况。\n\n * 假如这个有三个情况，若某一行为能让学生解决这三个情况之外的新情况，那这一行为就称为学习，\n * 若某一行为只能让学生重现这三个情况，那这一行为就称为记忆。\n\n机械记忆\n\n在学习范畴中，机械记忆是与有意义学习相对的概念，并不是指呆板的、不灵活的记忆，而是指“学习的目标错了”，也就是“把本应用来实现泛化目标的学习材料单纯地记忆了下来的行为”，“使学习材料失去了其应有的意义的行为”。\n\n> 就好比，本应用来看电影的电影票，却被用来折纸飞机了，让电影票失去了它原本的意义。\n\n# 总结\n\n信息对单，知识对群。\n\n重现信息是记忆，生成新信息是学习。\n\n\n# 指令学习与归纳学习\n\n> 学习的目的不是记忆已见过的旧情况（重现），而是解决从未见过的新情况（泛化），也就不能只针对具体情况，而是要在脑中建构一个规律，用规律来生成从未见过的新情况。\n\n看教程、参加课程的方式，也就是通过语言，对概念、规律、共性进行描述，从而建构规律的方式，也被称为指令学习。\n\n> 但实际上，可以提升泛化能力的学习方式有很多种，指令学习只不过是其中一种，而且还是人脑最不擅长的一种。\n\n通过观察多个实际案例，让大脑自动找到不同实例之间的共性，用共性来推测从未见过的情况该如何处理。这种方式，叫做归纳学习。\n\n比如遥控器学习：\n\n但可以回想我们是如何学会使用遥控器的。是看说明书吗？很少人会这么做吧。基本都是按一个按钮，看结果；再按另一个按钮，再看结果，通过反复尝试来搜集实例，随后大脑就可以利用这些实例来建构规律，从而预测新情况。\n\n实际上，多数情况下，归纳的过程并不是由我们的意识直接控制的，而是大脑在特定条件下自动执行的。\n\n# 总结\n\n指令就是纯靠背、听、看知识。归纳就是实践总结，大脑自动产生意识。\n\n\n# 成果\n\n\n# 归纳不足与以偏概全\n\n# 拟合\n\n建构可以满足所有旧情况的模型的过程，也可称为归纳\n\n经验拟合\n\n我们知道这个客观规律一定也可以满足所有已见过的旧情况。归纳学习正是利用这一点，去建构一个可以满足所有已见过的旧情况，并希望该规律恰好就是客观规律。建构可以满足所有旧情况的规律的过程也叫做拟合，这些旧情况也叫做经验。\n\n拟合与学习\n\n但是，拟合并不能和学习划等号，因为拟合只能保证记忆，并不能保证学习。拟合只是我们在达成泛化目标时所使用的一种手段，能拟合经验的规律未必能泛化新情况，而泛化才是学习的目标。\n\n# 欠拟合\n\n所拟合的模型无法满足旧情况的特性，又叫归纳不足\n\n其中一个不理想的现象是：所拟合出来的规律连旧情况都无法满足，这一现象叫做欠拟合。\n\n# 过拟合\n\n所拟合的模型可以满足旧情况，但却无法满足新情况的特性，又叫以偏概全\n\n另一个不理想现象是，拟合出来的规律可以满足所有旧情况，但却无法预测新情况，仅仅是个以偏概全的局部规律，这一现象叫做过拟合。\n\n# 双例对比法\n\n 1. 第一步，确定一个要学习的知识点。\n 2. 第二步，先试着理解课本上讲解，也就是用指令学习的方式，确定一个大概。\n 3. 第三步，再找出很多道该知识点的习题来做，也就是搜集该知识点的实例。\n\n> 注意别立刻看答案\n> \n> 注意，做每道题都要经过完整的思考，不能一没思路就立马看答案，这是为了让大脑明确问题是什么，以便于让大脑做好自动归纳的准备。\n\n 4. 到了第四步就是该方法的关键：当做完两道题后，停下来比较两道题中该知识点的共性和差异性，同时去再去理解课本上的知识点讲解，这一步就是总结了。\n\n> 注意自动感知\n> \n> 注意，在比较共性和差异性的时候，不必太过注重规律的寻找，因为大脑会自动完成这一工作，我们只需要确保提供给大脑充分长的感知时间和足够多情况就好。\n\n 5. 第五步，做新题，来测试自己的理解，以此调整自己的理解。\n\n 6. 随后，再重复第二到第五步，直到将自己的泛化能力提高到满意地程度为止。\n\n\n# 可泛化性与有效范围\n\n\n# 知识可泛化性\n\n知识具有超越已有经验普遍性的特点。\n\n先前所说，知识是用来解决同一类问题中所有情况，包括从未见过的新情况，因此知识必须具有可泛化性。\n\n知识付费课程的内容都具有可泛化性吗？\n\n知识付费课程的基本模式是：抛一个问题，讲一个故事，提一个规律，再起一个名字。\n\n其中的规律，由于就是根据所讲故事而归纳的，因此必然可以完美解释所讲的这个故事，观众听起当然觉得很有道理。然而，若所提规律只是用单个案例归纳得出的，那么很容易过拟合（也就是接收到的知识不完整），不具有可泛化性，也就自然不能解决听众在生活中所遇到的新问题。\n\n> 并非所有知识付费课程中的内容都是不可泛化的\n\n\n# 知识局部有效\n\n知识只能在特定的范围内获得有效预测。\n\n知识并不是永恒不变的真理。所有科学知识都是基于人类现有的观察，在特定条件下，经验证所得到的，因此也就只能确保在特定条件下泛化。\n\n换句话说，知识的可泛化范围并不是无限的，是在做验证之前就已经被限定过的，倘若超出了限定范围，就无法再确保该知识依旧有效。\n\n知识组成\n\n限制条件同样也是知识的一部分，我们在使用某知识的时候，必须在它所限定的条件下使用，否则就会出错。\n\n明确输入输出\n\n在学习任何一个知识时，都不能仅仅关注它的预测结果，还要明确它的前提条件。也就是要同时明确它的输入范围和输出范围。\n\n对于学习方法也是同理，任何学习方法也都有它的前提条件，若不满足条件，再高效的学习方法也会失效。\n\n\n# 材料\n\n\n# 有效实例与有效描述\n\n# 有效实例\n\n同时具有“前因”和“后果”的实例才是有效的实例性材料。\n\n在使用归纳学习方式时，必须要有实例作为建构知识的依据，而作为一个实例，不能只有起因而没有结果，不能只有提问没有回答。\n\n> 比如猜数字问题，倘若只告诉大家数字的位置，却不告诉位置所对应的数字，就无法归纳，单独的一个位置信息也不能称为一个实例。\n\n# 有效描述\n\n所有旧概念均被理解的描述才是对学习有效的描述性材料。\n\n比如 背论文 和 讲论文\n\n背论文是将论文作为描述性材料，以指令学习的方式来建构新知识。\n\n对于讲论文而言，这些描述性材料能够被用来学习的前提就是你已经掌握了描述中的所有旧概念，明白每个词的指代。\n\n这也是为什么，所有描述性学习材料无法让每个人都满意。倘若用了精准的专有名词来描述新知识，那么掌握了这些名词的人观看起来会非常高效，但对没掌握这些名词的人而言就是无效材料。但若将专有名词展开来解释，又必然会增加篇幅，让掌握了专有名词的人觉得啰嗦。\n\n> 现在，我们知道了，什么样的实例性材料和描述性材料才是有效的，然而，有时，我们获得的明明都是有效材料，为什么却没能再提升自己的泛化能力呢？\n\n\n# 材料瓶颈与模型瓶颈\n\n# 现象\n\n我们经常会发现，刚开始学习新事物时，会迅速提升，随后却进步缓慢，最终处在一个瓶颈，难以突破。像轮滑的学习、绘画的学习、设计的学习，对识别心电图的学习，甚至是对游戏的学习。\n\n# 材料的瓶颈\n\n由材料所引起的学习瓶颈。\n\n当我们对同一个任务的学习到达一定程度时，就会遇到很多重复材料，此时不论再怎么背诵或理解这些材料，都无法帮助我们进一步提升泛化能力了，也就是由材料所引起的瓶颈。\n\n打破材料瓶颈\n\n若想打破这种瓶颈，就不能单守着旧材料不断背诵，而是就要去搜寻新的学习材料。\n\n多教材学习：这也是为什么，有的同学用多本不同角度的教材去学习同一个知识时，理解会非常深刻。\n\n实例材料瓶颈\n\n在使用归纳学习材料来建构知识时，也需要用那些没有见过的新实例，来提升自己的泛化能力。\n\n * 这便是为什么，那些从事艺术创作的人，比如，ui设计，服装设计，需要看大量的新素材，来提升自己，这类知识是很难用指令学习来建构的。\n * 同时也解释了，为什么学校的老师会训诫学生，错题本一定要时时更新，把掌握了的旧题移除，但有的学生的错题本，从开始使用就在那里不断积累，从来没有移除过旧题，每次翻看时又都是从第一页开始看。\n\n# 模型的瓶颈\n\n由旧认识所引起的学习抵触。\n\n地穴寓言\n\n有一批囚徒自出生起就被锁链束缚在一个地穴中，不能回头，只能看着墙壁上的影子。久而久之，囚徒们建构了关于影子的各种知识，并认为这些影子就是世界的全部。某天，一个囚徒偶然打开了锁链，爬出了洞穴，看到了阳光下的真实世界，他这才意识到曾被自己称为“世界”的地方，只不过是个洞穴。随后，他回到了洞穴，想要告诉自己的同伴，外面的世界才是真实的，向他们解释什么是太阳，什么是树。但这一行为却激怒了同伴，认为他在胡言乱语，并计划将他杀死，以此来捍卫大家的“世界”。\n\n地穴寓言出自柏拉图的《理想国》，曾给人们很多启示，而我们也可以从中认识到在突破瓶颈时会遭遇的又一个问题。那就是：学习者的大脑中，已经存在一个既有“认识”了，虽然在理论上该认识不完美，但由于该认识能让该学习者预测他所处环境中的种种情况，大脑并不会觉得这个认识存在什么不足。那么此时，该学习者的大脑就会拒绝任何新材料。(拒绝接收新材料，新知识)\n\n那么该如何处理这个问题呢？\n\n其实答案同时也出现在了寓言中，因为地穴中已经有一个突破了旧认识的人，那就是爬出洞穴的人。这个人和其他人的区别是什么呢？爬出洞穴的人，最初所用的是【实例性材料】，而洞穴内的人所用的是【描述性材料】。通常来说，大脑对实例性材料是不抵触的。\n\n突破模型瓶颈\n\n在学习时，不能单单只喊“我们应该克服旧认识”的口号，还要依从大脑的特性来实现这一目标。\n\n那就是先不要用描述性材料对规律本身进行矫正，而是先至少用一个实例性材料，让大脑意识到自己的“认识”对于预测哪些新情况依旧是不足的 ，以打破对新材料的戒备和屏蔽。\n\n苏格拉底提问\n\n在辩论中，就经常使用这种技巧。即不跟对方争论，而是直接抛出一个新情况，让对方用现有的认识来预测结果再展示给对方他的预测结果不符合实际情况。\n\n# 总结\n\n 1. 一个是由材料所带来的瓶颈，解决这种瓶颈的办法就是去搜集新材料。一些应试生容易犯的误区是不断去背诵已掌握的旧材料。\n 2. 另一个是由脑中的旧认识对新材料的抗拒所带来的瓶颈，解决这种瓶颈的方法是，先至少用一个实例性材料来让大脑意识到自己已有的认识是不足的，然后再继续学习。比如，一个 ui 设计师，若在任何时候都抱着“自己的认识是高级的，欣赏不了的人就是不懂”的想法，那他的大脑自然是不会接受新材料的。\n\n\n# 存储\n\n\n# 存储目标与存储过程\n\n# 存储位置\n\n人脑知识存储在神经网络的结构中。\n\n规律的实现\n\n为了实现泛化，需要建构一个规律，一种映射，来生成从未见过的新情况。而这种规律，正是由大量神经细胞所形成的网络来实现的，网络中的神经细胞们会通过电信号的频率来交流，通过层层计算，最终告诉我们的身体该怎么做，而电信号的频率又受神经细胞之间的突触结构所控制，倘若结构不合适，就无法生成正确的电信号来控制身体。\n\n频率的调整\n\n在细胞层面来看，学习就变成了让神经细胞之间形成合适结构的过程。\n\n# 存储过程\n\n人脑知识在睡眠中自动构建。\n\n调整的手段\n\n我们只需要通过有效的训练，让大脑接收到合适的材料，大脑便可以把这些材料作为依据，调整出合适的结构。\n\n调整的时间\n\n大脑大规模调整结构的时间段，正是在睡眠期间。倘若一个人学习了一整天后却不睡觉，那他的大脑就没有获得足够的调整时间，自然就无法形成长期的记忆和知识。\n\n策略\n\n需要掌握好学习和睡眠这两个因素的平衡。\n\n * 光学习，不睡眠，那么大脑就没时间调整结构，无法存储知识；\n * 若光睡觉，不学习，那大脑也没有依据来调整结构。\n\n调整的试错\n\n大脑也并不能确保每次的调整都是正确的，对于复杂的知识，大脑经常会调整出以偏概全的规律，也就需要慢慢调整回更加普遍的规律。\n\n换句话说，神经细胞们也是需要试错的，这意味着很多任务的学习无法一蹴而就，而是一个多次迭代的过程。需要反复用不同的学习材料来训练大脑。\n\n多科目学习\n\n大脑的学习需要时间和调整过程，同样意味着，在校学生其实没必要一天只啃一个学科，每个科目都学习两三个知识点，同时学习多个科目，可能会产生事半功倍的效果。\n\n# 总结\n\n只要通过有效的训练给大脑提供合适的材料，并保障足够的睡眠，大脑便可以自己形成规律。\n\n\n# 有效训练与精细加工\n\n> 上期我们说过，在细胞层面上来看，学习就相当于让特定的神经细胞群形成适合所学任务的正确结构。\n> \n> 那么在学习时，我们自然是想让与所学任务相关的所有神经细胞都先受到刺激，做好更新的准备，随后再让大脑去更新这些神经细胞的结构。\n\n可要如何实现这个目标呢？我们仍然只能通过间接的手段来达成该目标。\n\n# 实际执行\n\n研究表明，想象和观察也能刺激到部分相关神经细胞。但要想全面高效地刺激相关神经细胞的最好办法，其实就是：自己实际去执行一遍这个任务，并得到一个自己的答案。（也就是实践见真知）\n\n# 答案反馈\n\n学习的材料必须要有反馈，才能提供改进方向。\n\n反馈答案\n\n实际执行一遍只是让相关神经细胞做好更新的准备，关键还是最后的更新，而让大脑知道该如何更新的前提条件，就是要有对应的答案，或对应的评分，反馈给大脑。\n\n有效训练\n\n所以，想要让大脑高效地学习，最好的方式就是经历“实际执行与反馈答案”两个过程。倘若我们用有效的学习材料，经历了这两个过程，就可以称其为一次有效训练，而大量的有效训练才是我们进步的关键。\n\n# 精细加工\n\n建立新学的知识与旧知识之间关联。\n\n对于实例性材料，我们很容易做到“实际执行与反馈答案”这两步，那么对于指令性材料，我们该怎么做呢？\n\n答案是相同的，仍然是“实际执行与反馈答案”两个过程。\n\n在第一期就讲过，指令性材料是对规律的直接描述，是用来“打底稿”的，防止大脑自动归纳出了以偏概全的规律，其最终目的仍是要预测新情况，实现泛化。\n\n尽管是对规律的直接描述，但指令性材料对大脑神经结构的直接调整能力远不如实例性材料，很容易就会被大脑所遗忘，尤其是在学习者不能理解指令材料的意义时，遗忘速度会非常迅速。\n\n所以，即便使用的是指令性材料，也需要自己扩充实例性材料，自己举例，并试图回答。最好能用该知识去解释自己周围的现象。\n\n强化指令学习\n\n为了抑制人脑对指令性材料的快速遗忘，我们还有一个办法，那就是：建立新学的知识与旧知识之间关联。当两个知识产生他洽与印证时，大脑会留下深刻印象。\n\n数学家华罗庚所分享的学习方法 -- 先把书读厚，再把书读薄\n\n读薄 并不是一种行为，而是一种状态，意思是说，当自己利用其他材料充分地理解了知识点后，大脑就可以推测出其他材料了，此时，书就相当于变薄了，并不是让大家通过删除内容把书变薄。\n\n# 总结\n\n这一期讲了只有经历了实际执行和反馈答案两个过程才算是一个有效的训练，并讲了如何通过精细加工让指令性材料也能达到有效训练的效果。\n\n\n# 验证\n\n学习的最后一步，验证。\n\n验证巩固作用\n\n验证的是前人脑中所建构的知识，而我们的目标是在自己的脑中建构出相同的知识，并且是通过有效训练间接地让大脑自动调整神经结构，来实现这一目标，问题在于大脑并不知道所调整的结构是否已经可以泛化，不知道什么时候该停止调整，更不知道是否应该将已调整的结构视为以偏概全的、过拟合的规律而直接遗忘掉（长期记忆的遗忘）。\n\n所以需要我们提供给大脑一个反馈信号，告诉它，现在建构出的规律是可以泛化的，不需要再调整了，也千万别遗忘了。而这个反馈信号，就是通过验证来间接提供给大脑的。\n\n验证校验作用\n\n验证最重要的功能，还是确保我们所建构的知识是正确的，我们不希望自己建构了错误的知识后，还永远不忘。\n\n\n# 新例预测与表述转换\n\n要如何验证呢？\n\n# 预测新例\n\n用所建构的知识去解决新问题。倘若无法解决新问题，就说明所建构知识的泛化能力还不足够。这是泛化能力原本的定义。（验证的是实例材料）\n\n# 转换表述\n\n通过能否用自己的话来表述相同的意思，来排除自己并不是只记住了表述而未理解。\n\n表述转换\n\n倘若某人真的用指令性材料建构了知识，而不是单单机械记住了这个材料本身，那他一定也可以用另一种描述表达出于与该指令性材料类似的意思。也就是老师常说的“学习要用自己的话来表述”。\n\n# 总结\n\n有两种最基本的验证方式：\n\n 1. 运用自己构建的知识来预测新情况的结果，并与实际情况相对照。 -- 看是否能解决新问题\n 2. 转换表述 -- 要学会用自己的话来描述指令性材料。\n\n# 以教促学\n\n预测新例和转换表述的结合应用。\n\n教人之所以可以巩固自己学习，其关键就在于，教学过程既可以检验学习者所建构知识的正确性，又给大脑提供了一个反馈信号，让大脑知道所建构的知识已经可以泛化，不必遗忘，从而巩固了知识的存储。\n\n复习方式\n\n复习和巩固知识的一种方法。不是单单拿自己勾画的那些重点句反复看，反复背诵，而是做几道新题，问自己几个新情况，或者用另一句话来表达相同的意思，正确解答之后，就可以巩固所建构的知识不被大脑所轻易遗忘。 -- 做题保持手感\n\n\n# 汇总\n\n学习的五个层面：目标、成果、材料、存储、验证。\n\n这五个层面囊括了学习的基本流程，当自己的学习出现任何问题时，都可以从这五个层面进行排查。\n\n 1. 目标层面决定了我们努力的方向和可以获得的成果；\n 2. 材料层面则是我们达成目标的代价和条件；\n 3. 存储层面又决定了我们以什么样的方式利用材料在脑中建构知识；\n 4. 成果层面或者说对象层面则让我们知晓要建构的知识有什么特点，建构时会遇到什么障碍，以及使用时又有哪些局限。\n 5. 验证层面则用来确保所获得的成果和我们的目标成果是相同的，并对大脑的存储做进一步的巩固。\n\n1.1 明确目标\n\n当有了一个需要掌握的内容时，先看这是一个需要重现的内容，还是一个需要泛化的内容，以此来决定是要采用学习方法，还是记忆方法。\n\n1.2 误区排查\n\n在 方式、材料、瓶颈突破、存储、训练、成果、应用、验证 等 8 个方面上排查是否有问题。\n\n课程名中的“断墨”正取自“断墨残楮”的前两个字，意为“残缺不全的典籍”，而断墨寻径这四个字正是在概括，学习中，我们究竟在做什么，即，在残缺不全，充满未知的条件下，寻找出通用的模式。\n\n\n# 参考\n\n断墨寻径：https://www.modevol.com/episode/ckx8eb99w000501l2ewyt2kto",charsets:{cjk:!0}}],themeConfig:{updateBar:{showToArticle:!1},logo:"https://cdn.jsdelivr.net/gh/cmty256/imgs-blog@main/logo/白云.38zbldnhh180.jpg",sidebarDepth:2,lastUpdated:"上次更新",nav:[{text:"首页",link:"/"},{text:"CPP语言",items:[{text:"Cpp之旅",link:"/pages/c5bdd8/"},{text:"Cpp专栏",link:"/pages/279e62/"},{text:"Effective_CPP",link:"/pages/801755/"},{text:"muduo网络库",link:"/pages/6b2468/"},{text:"Unix环境高级编程",link:"/pages/5f8c9f/"},{text:"Cpp提高编程",link:"/pages/3f1d21/"}]},{text:"计算机基础",items:[{text:"计算机网络",link:"/pages/7b1cb2/"},{text:"操作系统",link:"/pages/6048a8/"},{text:"数据结构",link:"/pages/3b34ba/"},{text:"Linux",link:"/pages/412fe7/"},{text:"算法",link:"/pages/2dcfa1/"}]},{text:"数据库",items:[{text:"基础篇",link:"/pages/efa3f2/"},{text:"MySql",link:"/pages/ccc445/"},{text:"Redis",link:"/pages/54616e/"}]},{text:"系统设计",items:[{text:"权限校验",link:"/pages/793d0a/"},{text:"设计模式",link:"/pages/73ddd7/"}]},{text:"开发日常",items:[{text:"Git知识总结",link:"/pages/71f6ae/"},{text:"nvm使用小结",link:"/pages/777b8a/"},{text:"虚拟机固定 IP 地址",link:"/pages/ee770e/"},{text:"随笔（持续更新）",link:"/pages/e472d1/"},{text:"VScode 插件 CodeGeeX 使用教程",link:"/pages/411aa4/"},{text:"KylinV10 将项目上传至 Github教程",link:"/pages/0d525d/"},{text:"KylinV10 安装 MySQL 教程（可防踩雷）",link:"/pages/ef40f0/"},{text:"个人博客代码推送教程",link:"/pages/f8640c/"}]},{text:"前端学习",items:[{text:"HTML与CSS",link:"/pages/99897f/"},{text:"JS学习",link:"/pages/51542d/"},{text:"Vue3入门",link:"/pages/803f9d/"},{text:"Vue3进阶",link:"/pages/ca4cfb/"},{text:"黑马Vue3",link:"/pages/50e8d3/"}]},{text:"项目笔记",items:[{text:"ip_file_hook",link:"/pages/08dfe9/"}]},{text:"面经",items:[{text:"虎牙C++技术面经",link:"/pages/d69946/"},{text:"金山一面复习",link:"/pages/29251d/"}]},{text:"其它",items:[{text:"博客搭建",link:"/pages/fa256e/"},{text:"网站收藏箱",link:"/pages/335531/"}]}],sidebar:{"/00.知识整理/":[["00.网站内容.md","网站内容","/pages/7e99d5/"]],catalogue:{},"/01.CPP语言/":[{title:"Cpp之旅",collapsable:!0,children:[["01.Cpp之旅/01.第1章 基础.md","第1章 基础","/pages/c5bdd8/"],["01.Cpp之旅/02.第2章 用户自定义类型.md","第2章 用户自定义类型","/pages/88a7db/"],["01.Cpp之旅/03.第3章 模块化.md","第3章 模块化","/pages/61ffe6/"],["01.Cpp之旅/04.第4章 错误处理.md","第4章 错误处理","/pages/2dfe3d/"],["01.Cpp之旅/05.第5章 类.md","第5章 类","/pages/1cb324/"],["01.Cpp之旅/07.第6章 基本操作.md","第6章 基本操作","/pages/fae683/"],["01.Cpp之旅/08.第7章 模板.md","第7章 模板","/pages/2cdace/"],["01.Cpp之旅/09.第8章 概念和泛型编程.md","第8章 概念和泛型编程","/pages/619376/"],["01.Cpp之旅/10.第9章 标准库.md","第9章 标准库","/pages/48ac45/"]]},{title:"Cpp专栏",collapsable:!0,children:[["20.Cpp专栏/01.第2章 变量和基本类型.md","第2章 变量和基本类型","/pages/279e62/"],["20.Cpp专栏/02.Cpp11新标准.md","Cpp11新标准","/pages/518856/"],["20.Cpp专栏/03.探索C++14新特性：更强大、更高效的编程.md","探索C++14新特性：更强大、更高效的编程","/pages/2f7f31/"]]},{title:"Effetcive_CPP",collapsable:!0,children:[["30.Effetcive_CPP/01.条款1-4 让自己习惯C++.md","条款1-4 让自己习惯Cpp","/pages/801755/"],["30.Effetcive_CPP/02.条款5- 12 构造析构赋值运算.md","条款5-12 构造析构赋值运算","/pages/4fc2cb/"],["30.Effetcive_CPP/03.条款26-31 实现.md","条款26-31 实现","/pages/ec62b4/"],["30.Effetcive_CPP/04.条款32-40 继承与面向对象设计.md","条款32-40 继承与面向对象设计","/pages/b4a7fb/"],["30.Effetcive_CPP/05.条款41-48 模板和泛型编程.md","条款41-48 模板和泛型编程","/pages/799b40/"]]},{title:"muduo网络库",collapsable:!0,children:[["40.muduo网络库/01.第4章 C++多线程系统编程精要.md","第4章 Cpp多线程系统编程精要","/pages/6b2468/"]]},{title:"Unix环境高级编程",collapsable:!0,children:[["50.Unix环境高级编程/11.第11章 线程同步.md","第11章 线程同步","/pages/5f8c9f/"]]},{title:"Cpp提高编程",collapsable:!0,children:[["60.Cpp提高编程/01.函数模板.md","函数模板","/pages/3f1d21/"],["60.Cpp提高编程/02.类模板.md","类模板","/pages/db4e3c/"],["60.Cpp提高编程/03.初识STL.md","初识STL","/pages/a7c324/"],["60.Cpp提高编程/04.string 容器.md","string 容器","/pages/4906d0/"],["60.Cpp提高编程/05.vector 容器.md","vector 容器","/pages/13697a/"],["60.Cpp提高编程/06.deque 容器.md","deque 容器","/pages/2a1016/"],["60.Cpp提高编程/07.stack 容器.md","stack 容器","/pages/29568d/"],["60.Cpp提高编程/08.queue 容器.md","queue 容器","/pages/95225a/"]]}],"/02.计算机基础/":[{title:"网络",collapsable:!0,children:[["01.网络/01.网络核心知识总结.md","网络核心知识总结","/pages/7b1cb2/"],["01.网络/02.TCP 三次握手和四次挥手.md","TCP 三次握手和四次挥手","/pages/0728af/"],["01.网络/03.TCP 传输可靠性问题.md","TCP 传输可靠性问题","/pages/8d5654/"],["01.网络/04.常见状态码总结.md","常见状态码总结","/pages/11e44b/"],["01.网络/10.《计算机网络》谢希仁.md","《计算机网络》谢希仁","/pages/92d82c/"]]},{title:"操作系统",collapsable:!0,children:[["02.操作系统/01.硬件结构.md","硬件结构","/pages/6048a8/"]]},{title:"数据结构",collapsable:!0,children:[["03.数据结构/01.数据结构基础小结.md","数据结构基础小结","/pages/3b34ba/"]]},{title:"算法",collapsable:!0,children:[["04.算法/1. 两数之和.md","两数之和","/pages/2dcfa1/"],["04.算法/14. 最长公共前缀.md","最长公共前缀","/pages/d52abe/"],["04.算法/26. 删除有序数组中的重复项.md","删除有序数组中的重复项","/pages/4c0819/"],["04.算法/53. 最大子数组和.md","最大子数组和","/pages/edd6da/"],["04.算法/69. x 的平方根.md","x 的平方根","/pages/480e04/"],["04.算法/70. 爬楼梯.md","爬楼梯","/pages/6b01fc/"],["04.算法/101. 对称二叉树.md","对称二叉树","/pages/3ec756/"],["04.算法/104. 二叉树的最大深度.md","二叉树的最大深度","/pages/cfaacb/"],["04.算法/120. LCR寻找文件副本.md","LCR寻找文件副本","/pages/5b2b9b/"],["04.算法/121. 买卖股票的最佳时机.md","买卖股票的最佳时机","/pages/4e735a/"],["04.算法/125. LCR图书整理 II.md","LCR图书整理 II","/pages/61a107/"],["04.算法/136. 只出现一次的数字.md","只出现一次的数字","/pages/d2368e/"],["04.算法/140. LCR 训练计划 II.md","LCR 训练计划 II","/pages/4806d9/"],["04.算法/141. 环形链表.md","环形链表","/pages/6ac024/"],["04.算法/206. 反转链表.md","反转链表","/pages/7c062a/"],["04.算法/226. 翻转二叉树.md","翻转二叉树","/pages/28ad9f/"],["04.算法/234. 回文链表.md","回文链表","/pages/29ee33/"],["04.算法/283. 移动零.md","移动零","/pages/e85eda/"],["04.算法/409. 最长回文串.md","最长回文串","/pages/5d801b/"],["04.算法/461. 汉明距离.md","汉明距离","/pages/55ec77/"],["04.算法/538. 把二叉搜索树转换为累加树.md","把二叉搜索树转换为累加树","/pages/299c79/"],["04.算法/581. 最短无序连续子数组.md","最短无序连续子数组","/pages/6354db/"],["04.算法/617. 合并二叉树.md","合并二叉树","/pages/2998a0/"],["04.算法/704. 二分查找.md","二分查找","/pages/173765/"],["04.算法/876. 链表的中间结点.md","链表的中间结点","/pages/d178f3/"],["04.算法/977. 有序数组的平方.md","有序数组的平方","/pages/67ccea/"],["04.算法/997. 找到小镇的法官.md","找到小镇的法官","/pages/33a1c0/"]]},{title:"Linux",collapsable:!0,children:[["05.Linux/01.Linux基础小结.md","Linux基础小结","/pages/412fe7/"]]}],"/03.数据库/":[{title:"基础",collapsable:!0,children:[["01.基础/01.数据库基础知识小结.md","数据库基础知识小结","/pages/efa3f2/"],["01.基础/02.NoSQL基础知识小结.md","NoSQL基础知识小结","/pages/54fc03/"],["01.基础/03.字符集详解.md","字符集详解","/pages/126a5a/"],{title:"SQL",collapsable:!0,children:[["01.基础/04.SQL/01.SQL语法基础小结.md","SQL语法基础小结","/pages/ed0fa0/"],["01.基础/04.SQL/02.SQL必知必会题解.md","SQL必知必会题解","/pages/def622/"]]}]},{title:"Mysql",collapsable:!0,children:[["02.Mysql/01.MySQL基础小结.md","MySQL基础小结","/pages/ccc445/"],["02.Mysql/02.索引篇.md","索引篇","/pages/0b5aee/"],["02.Mysql/10.思维导图.md","思维导图","/pages/db8ded/"]]},{title:"Redis",collapsable:!0,children:[["03.Redis/01.Redis总结.md","Redis总结","/pages/54616e/"],["03.Redis/02.Redis小记.md","Redis小记","/pages/163cf9/"]]}],"/05.系统设计/":[{title:"权限校验",collapsable:!0,children:[["03.权限校验/01.JWT基础小结.md","JWT","/pages/793d0a/"]]},{title:"设计模式",collapsable:!0,children:[["04.设计模式/01.常见设计模式总结.md","常见设计模式总结","/pages/73ddd7/"],["04.设计模式/02.设计模式 13 问.md","设计模式 13 问","/pages/0863fc/"]]}],"/07.开发日常/":[["02.Git知识总结.md","Git知识总结","/pages/71f6ae/"],["03.nvm使用小结.md","nvm使用小结","/pages/777b8a/"],["04.随笔（持续更新）.md","随笔（持续更新）","/pages/e472d1/"],["05.虚拟机固定ip地址.md","虚拟机固定ip地址","/pages/ee770e/"],["06.VScode 插件 CodeGeex 使用教程.md","VScode 插件 CodeGeex 使用教程","/pages/411aa4/"],["07.KylinV10 将项目上传至 Github.md","KylinV10 将项目上传至 Github","/pages/0d525d/"],["08.KylinV10 安装 MySQL 教程（可防踩雷）.md","KylinV10 安装 MySQL 教程（可防踩雷）","/pages/ef40f0/"],["09.个人博客代码推送教程.md","个人博客代码推送教程","/pages/f8640c/"]],"/08.项目笔记/":[{title:"存储介质消除工具",collapsable:!0,children:[["10.存储介质消除工具/01.项目笔记.md","项目笔记","/pages/67c5c8/"]]},{title:"ip_file_hook",collapsable:!0,children:[["30.ip_file_hook/01.项目解读.md","项目解读","/pages/08dfe9/"],["30.ip_file_hook/02.项目bug汇总.md","项目bug汇总","/pages/00e0b6/"]]}],"/09.前端学习/":[["01.HTML与CSS.md","HTML与CSS","/pages/99897f/"],["03.js学习.md","js学习","/pages/51542d/"],["06.Vue3入门.md","Vue3入门","/pages/803f9d/"],["08.Vue3进阶.md","Vue3 进阶","/pages/ca4cfb/"],["10.黑马Vue3.md","黑马Vue3","/pages/50e8d3/"]],"/15.面经/":[["01.虎牙C++技术面经.md","虎牙C++技术面经","/pages/d69946/"],["02.金山一面复习.md","金山一面复习","/pages/29251d/"]],"/20.碎片文章/":[["01.博客搭建.md","博客搭建","/pages/fa256e/"],["02.网站收藏箱.md","网站收藏箱","/pages/335531/"],["03.断墨寻径摘录.md","断墨寻径摘录","/pages/94109b/"]]},pageStyle:"line",category:!1,tag:!1,archive:!1,author:{name:"霜晨月"},footer:{createYear:2023,copyrightInfo:"霜晨月"}},locales:{"/":{lang:"zh-CN",path:"/"}}};var Fs=t(94),Hs=t(95),$s=t(11);var Gs={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object($s.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object($s.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object($s.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,i=n.length;r<i;r++){const{frontmatter:{categories:i,tags:a}}=n[r];"array"===Object($s.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object($s.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Gt.component(Fs.default),Gt.component(Hs.default);function Ws(n){return n.toString().padStart(2,"0")}t(244);Gt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,428))),Gt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95))),Gt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94)));t(245);var Qs=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Js=(n,e,t)=>(Qs(n,e,"read from private field"),t?t.call(n):e.get(n)),Ys=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},Ks=(n,e,t,r)=>(Qs(n,e,"write to private field"),r?r.call(n,t):e.set(n,t),t);var Xs,Zs;const nl=class{constructor(n,e,t,r=!0){Ys(this,Xs,void 0),Ys(this,Zs,void 0),Ks(this,Xs,{width:0,height:0});const{el:i,ctx:a}=nl.initCanvas(n);this.el=i,this.ctx=a,Ks(this,Zs,r),this.size={width:e||window.innerWidth,height:t||window.innerHeight}}get size(){return{...Js(this,Xs)}}set size({width:n,height:e}){var t;if(Js(this,Xs).width===n&&Js(this,Xs).height===e)return;Js(this,Xs).width=n,Js(this,Xs).height=e;const r=null!=(t=Js(this,Zs)?window.devicePixelRatio:1)?t:1;this.el.width=Math.round(Js(this,Xs).width*r),this.el.height=Math.round(Js(this,Xs).height*r),this.el.style.width=Js(this,Xs).width+"px",this.el.style.height=Js(this,Xs).height+"px",Js(this,Zs)&&this.ctx.scale(r,r)}clear(){nl.clearCanvas(this.ctx,{...Js(this,Xs)})}to(n){n.ctx.drawImage(this.el,0,0,Js(this,Xs).width,Js(this,Xs).height)}handleResize(n){this.size={width:window.innerWidth,height:window.innerHeight}}static setCanvasStyle(n,e,t){const r=n.style,{zIndex:i=0,opacity:a=1}=e;r.position="fixed",r.top="0",r.left="0",r.zIndex=i.toString(),r.width=(t?t.width:n.width).toString()+"px",r.height=(t?t.height:n.height).toString()+"px",1!==a&&(r.opacity=a.toString()),r.pointerEvents="none"}static initCanvas(n){n||(n=document.createElement("canvas"));const e=n.getContext("2d");return{el:n,ctx:e}}static createOffscreenCanvas(){return new nl}static clearCanvas(n,e){const{width:t,height:r}=e;n.clearRect(0,0,t,r)}};let el=nl;var tl,rl;Xs=new WeakMap,Zs=new WeakMap;class il{constructor(n,e,t,r=!0,i=!0,a={zIndex:0,opacity:1}){Ys(this,tl,void 0),Ys(this,rl,void 0),Ks(this,tl,new el(n,e,t,r)),el.setCanvasStyle(Js(this,tl).el,a,{width:e,height:t}),Ks(this,rl,i?new el(void 0,e,t,r):null)}get size(){return Js(this,tl).size}draw(n){var e;const t=null!=(e=Js(this,rl))?e:Js(this,tl);t.clear(),n(t.ctx,{...t.size})}render(){!Js(this,rl)||(Js(this,tl).clear(),Js(this,rl).to(Js(this,tl)))}handleResize(n){Js(this,tl).handleResize(n),Js(this,rl)&&Js(this,rl).handleResize(n)}clear(){Js(this,tl).clear(),Js(this,rl)&&Js(this,rl).clear()}}tl=new WeakMap,rl=new WeakMap;var al=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},ol=(n,e,t)=>(al(n,e,"read from private field"),t?t.call(n):e.get(n));var sl;class ll{constructor(){((n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)})(this,sl,void 0),((n,e,t,r)=>{al(n,e,"write to private field"),r?r.call(n,t):e.set(n,t)})(this,sl,new Map)}add(n,e,t=window){ol(this,sl).has(t)||ol(this,sl).set(t,new Map);const r=ol(this,sl).get(t);r.has(n)||r.set(n,new Set),r.get(n).add(e)}startAll(){for(const[n,e]of ol(this,sl))for(const[t,r]of e)for(const e of r)n.addEventListener(t,e)}stopAll(){for(const[n,e]of ol(this,sl))for(const[t,r]of e)for(const e of r)n.removeEventListener(t,e)}clear(){ol(this,sl).clear()}}function cl(n){return!!n.touches}sl=new WeakMap;class dl{static randomFloat(n,e){return Math.random()*(e-n)+n}static randomInt(n,e){return Math.floor(dl.randomFloat(n,e))}static choice(n){const e=n.length;return n[Math.floor(e*Math.random())]}static color(n="0123456789ABCDEF"){return"#"+dl.choice(n)+dl.choice(n)+dl.choice(n)+dl.choice(n)+dl.choice(n)+dl.choice(n)}}var ul,pl,ml,hl,vl,gl=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},fl=(n,e,t)=>(gl(n,e,"read from private field"),t?t.call(n):e.get(n)),bl=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},_l=(n,e,t,r)=>(gl(n,e,"write to private field"),r?r.call(n,t):e.set(n,t),t),yl=(n,e,t)=>(gl(n,e,"access private method"),t);class xl{constructor(n,e,t,r,i){bl(this,ul,void 0),bl(this,pl,void 0),bl(this,ml,void 0),this.size=t,this.color=r,_l(this,ml,0),_l(this,ul,i),_l(this,pl,e),this.position={...n}}move(){this.position.x=Math.sin(fl(this,ul))*fl(this,pl)+this.position.x,this.position.y=Math.cos(fl(this,ul))*fl(this,pl)+this.position.y+.3*fl(this,ml),((n,e,t,r)=>({set _(r){_l(n,e,r,t)},get _(){return fl(n,e,r)}}))(this,ml)._++}shouleRemove(n){return this.position.x<0||this.position.x>n.width||this.position.y>n.height}}ul=new WeakMap,pl=new WeakMap,ml=new WeakMap;hl=new WeakMap;class Tl{static create(n,e,t,r,i,a){return new(this.shapeMap.get(n))(e,t,r,i,a)}}Tl.shapeMap=new Map([["star",class extends xl{constructor(n,e,t,r,i){super(n,e,t,r,i),bl(this,hl,0)}draw(n,e){n.fillStyle=this.color,n.beginPath();const t=2*this.size,r=this.size;for(let e=0;e<5;e++)n.lineTo(Math.cos((18+72*e-fl(this,hl))/180*Math.PI)*t+this.position.x,-Math.sin((18+72*e-fl(this,hl))/180*Math.PI)*t+this.position.y),n.lineTo(Math.cos((54+72*e-fl(this,hl))/180*Math.PI)*r+this.position.x,-Math.sin((54+72*e-fl(this,hl))/180*Math.PI)*r+this.position.y);n.fill(),_l(this,hl,fl(this,hl)+5)}}],["circle",class extends xl{draw(n,e){n.fillStyle=this.color,n.beginPath(),n.arc(this.position.x,this.position.y,this.size,0,2*Math.PI),n.fill()}}]]);class kl{constructor(n,e,t,r){bl(this,vl,void 0),this.stopped=!1,_l(this,vl,new Set);for(let i=0;i<r;i++){const r=Tl.create(n,e,dl.randomFloat(1,6),t,dl.color("89ABCDEF"),dl.randomFloat(Math.PI-1,Math.PI+1));fl(this,vl).add(r)}}move(n){for(const e of fl(this,vl))e.shouleRemove(n)?fl(this,vl).delete(e):e.move();0===fl(this,vl).size&&(this.stopped=!0)}draw(n,e){for(const t of fl(this,vl))t.draw(n,e)}}vl=new WeakMap;var wl,El,Il,Cl,Al,zl,Sl,Pl,Rl,jl,ql,Ll,Ol,Nl,Dl,Bl,Ml,Ul,Vl,Fl;class Hl{constructor({shape:n="star",size:e=2,numParticles:t=10}={},r={}){bl(this,Rl),bl(this,ql),bl(this,Ol),bl(this,Dl),bl(this,Ml),bl(this,Vl),bl(this,wl,void 0),bl(this,El,void 0),bl(this,Il,void 0),bl(this,Cl,null),bl(this,Al,new Set),bl(this,zl,!1),bl(this,Sl,void 0),bl(this,Pl,new ll),_l(this,wl,n),_l(this,El,e),_l(this,Il,t),_l(this,Sl,r),this.animate=this.animate.bind(this)}mount(n){_l(this,Cl,new il(n,window.innerWidth,window.innerHeight,!0,!0,fl(this,Sl))),yl(this,Rl,jl).call(this),function(n,{leftColor:e="#fff",rightColor:t="#444",leftBgColor:r="#35495e",rightBgColor:i="#00ffc0"}={}){console.log(`%c ${n} %c v0.5.2 112fa81 %c`,`background: ${r}; padding: 2px; color: ${e}; font-weight: bold; text-transform: uppercase;`,`background: ${i}; padding: 2px; color: ${t}; font-weight: bold; text-transform: uppercase;`,"background: transparent")}("Theme Popper 🎉",{leftBgColor:"#ffb366"})}unmount(){yl(this,ql,Ll).call(this),_l(this,zl,!1)}animate(){if(_l(this,zl,!0),0===fl(this,Al).size)return _l(this,zl,!1),void fl(this,Cl).clear();requestAnimationFrame(this.animate);for(const n of fl(this,Al)){if(n.stopped)return void fl(this,Al).delete(n);n.move(fl(this,Cl).size)}fl(this,Cl).draw((n,e)=>{for(const t of fl(this,Al))t.draw(n,e)}),fl(this,Cl).render()}}wl=new WeakMap,El=new WeakMap,Il=new WeakMap,Cl=new WeakMap,Al=new WeakMap,zl=new WeakMap,Sl=new WeakMap,Pl=new WeakMap,Rl=new WeakSet,jl=function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)?fl(this,Pl).add("touchstart",yl(this,Ol,Nl).bind(this)):fl(this,Pl).add("mousedown",yl(this,Ol,Nl).bind(this)),fl(this,Pl).add("visibilitychange",yl(this,Ml,Ul).bind(this)),fl(this,Pl).add("resize",function(n,e,t){var r,i,a;void 0===e&&(e=50),void 0===t&&(t={});var o=null!=(r=t.isImmediate)&&r,s=null!=(i=t.callback)&&i,l=t.maxWait,c=Date.now(),d=[];function u(){if(void 0!==l){var n=Date.now()-c;if(n+e>=l)return l-n}return e}var p=function(){var e=[].slice.call(arguments),t=this;return new Promise((function(r,i){var l=o&&void 0===a;if(void 0!==a&&clearTimeout(a),a=setTimeout((function(){if(a=void 0,c=Date.now(),!o){var r=n.apply(t,e);s&&s(r),d.forEach((function(n){return(0,n.resolve)(r)})),d=[]}}),u()),l){var p=n.apply(t,e);return s&&s(p),r(p)}d.push({resolve:r,reject:i})}))};return p.cancel=function(n){void 0!==a&&clearTimeout(a),d.forEach((function(e){return(0,e.reject)(n)})),d=[]},p}(yl(this,Dl,Bl).bind(this),500)),fl(this,Pl).startAll()},ql=new WeakSet,Ll=function(){fl(this,Pl).stopAll(),fl(this,Pl).clear()},Ol=new WeakSet,Nl=function(n){const e={x:cl(n)?n.touches[0].clientX:n.clientX,y:cl(n)?n.touches[0].clientY:n.clientY},t=new kl(fl(this,wl),{...e},fl(this,El),fl(this,Il));fl(this,Al).add(t),fl(this,zl)||yl(this,Vl,Fl).call(this)},Dl=new WeakSet,Bl=function(n){fl(this,Cl).handleResize(n)},Ml=new WeakSet,Ul=function(n){fl(this,Al).clear(),_l(this,zl,!1)},Vl=new WeakSet,Fl=function(){requestAnimationFrame(this.animate)};var $l={name:"CursorEffects",data:()=>({popper:new Hl({shape:"star",size:2},{opacity:1,zIndex:999999999})}),mounted(){this.popper.mount(this.$el)},beforeDestroy(){this.popper.unmount()}},Gl=Object(Bs.a)($l,(function(){return(0,this._self._c)("canvas",{attrs:{id:"vuepress-canvas-cursor"}})}),[],!1,null,null,null).exports,Wl=[({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Ws(n.getUTCMonth()+1)}-${Ws(n.getUTCDate())} ${Ws(n.getUTCHours())}:${Ws(n.getUTCMinutes())}:${Ws(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(Gs)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({Vue:n})=>{n.component("CursorEffects",Gl)}],Ql=["CursorEffects"];class Jl extends class{constructor(){this.store=new Gt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Gt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Jl.prototype,{getPageAsyncComponent:os,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Yl={install(n){const e=new Jl;n.$vuepress=e,n.prototype.$vuepress=e}};function Kl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Xl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Gt.component(e)||Gt.component(e,os(e)),Gt.component(e)?n(e):n("")}},Zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},nc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},ec=(t(246),t(247),Object(Bs.a)(nc,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),tc={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Gt.config.productionTip=!1,Gt.use(Ho),Gt.use(Yl),Gt.mixin(function(n,e,t=Gt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Vs)),Gt.component("Content",Xl),Gt.component("ContentSlotsDistributor",Zl),Gt.component("OutboundLink",ec),Gt.component("ClientOnly",tc),Gt.component("Layout",ss("Layout")),Gt.component("NotFound",ss("NotFound")),Gt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.9",hash:"011a33c"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Vs.routerBase||Vs.base,t=new Ho({base:e,mode:"history",fallback:!1,routes:Us,scrollBehavior:(n,e,t)=>t||(n.hash?!Gt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Kl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Kl(n,t)?r(t):r()}else r();else{const t=e.path+"/",i=e.path+".html";Kl(n,i)?r(i):Kl(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Wl.filter(n=>"function"==typeof n).map(e=>e({Vue:Gt,options:r,router:t,siteData:Vs,isServer:n})))}catch(n){console.error(n)}return{app:new Gt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ql.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);